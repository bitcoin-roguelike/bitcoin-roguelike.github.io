<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self' https://noexxibndcooqjquhqzk.supabase.co/functions/v1/leaderboard https://mempool.space; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 10px; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: pan-x pan-y; /* Prevents pinch-to-zoom */
            -webkit-user-select: none; /* Prevents selection */
            -webkit-touch-callout: none; /* Disables iOS callouts */
        }
        /* Existing styles remain unchanged */
        #console { 
            background: #111;
            border: 4px solid #ff8c00;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            max-width: 800px;
            width: 100%;
            box-sizing: border-box;
        }
#whale-log { 
            width: 618px; 
            height: 24px; 
            overflow-y: auto;
            scroll-behavior: smooth; 
            background: #111; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator {color: var(--text-color, #ff8c00) !important;
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
#battle-log {
    width: 620px;
    margin-left: 20px; 
    background: transparent; 
    color: var(--text-color, #ff8c00) !important; 
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
    padding: 16px; 
    border: none; 
    font-size: 16px;
    z-index: 10;
    margin-top: -240px;
}

/* Soul Terminal Overlay */
#soul-terminal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 1000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'VT323', monospace;
    color: #ff8c00;
}

#soul-terminal {
    width: 90%;
    max-width: 800px;
    height: 80%;
    background: rgba(17, 17, 17, 0.95);
    border: 4px solid #ff8c00;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#soul-terminal-header {
    color: #ff8c00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 24px;
    margin-bottom: 15px;
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 2px solid #ff8c00;
}

#soul-terminal-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    background: #111;
    border: 2px solid #ff8c00;
    margin-bottom: 15px;
    font-size: 16px;
    line-height: 1.4;
}

#soul-terminal-input-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

#soul-terminal-prompt {
    color: #ff8c00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 16px;
    white-space: nowrap;
}

#soul-terminal-input {
    flex-grow: 1;
    background: #ff8c00;
    color: #000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    font-weight: 900;
    outline: none;
    padding: 5px;
}

#soul-terminal-input:focus {
    outline: 1px solid #ff8c00;
    background: #ff8c00;
    color: #000;
}
/ Add this for the blur behavior /
#soul-terminal-input:not(:focus) {
    background: #ff8c00;
    color: #000;
}
#battle-log textarea {
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    resize: none;
    width: 100%;
    height: 200px;
    padding: 0;
    overflow-y: auto;
    scroll-behavior: smooth;
    z-index: 10;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.2s ease;
    transform: translateX(-100%);
    opacity: 0;
    /* Hide scrollbar */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}
#inventory { 
    position: absolute;
    top: 10px;
    right: -12px;
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    padding: 8px;
    z-index: 10;
    font-family: 'VT323', monospace;
    font-size: 20px;
    line-height: 1.5;
    width: 160px;
}
#inventory sup {
    vertical-align: super;
    font-size: 0.6em; /* Matches ™ size */
    text-shadow: none; /* Remove shadow for clarity */
}
/* Tighten line-height for Safari */
@media not all and (min-resolution: 0.001dpcm) { /* Targets Safari */
    #inventory {
        line-height: 1.0; /* Reduce line-height by ~50% */
    }
}
	#floor-indicator { 
    	    position: absolute; 
    	    top: 11px; 
	    left: 10px; 
	    background: transparent; 
	    color: var(--text-color, #ff8c00) !important; 
	    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
	    padding: 8px; 
	    z-index: 10; 
	    font-family: 'VT323', monospace;
	    font-size: clamp(21px, 5.33vw, 32px);
	    line-height: 1.2; / Prevents squishing /
	}
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
            grid-area: t;
            z-index: 40;
            border-radius: 5%;
        }
        #left { 
            grid-area: l;
            z-index: 40;
            border-radius: 5%;
        }
        #right { 
            grid-area: r;
            z-index: 40; 
            border-radius: 5%;
        }
        #down { 
            grid-area: b;
            z-index: 40;
            border-radius: 5%;
        }
        #actions { 
            display: flex; 
            gap: 5px; 
            align-items: center; 
        }
button {
    background-color: transparent;
    border: 1px solid #ff8c00;
    color: #ff8c00;
    padding: 8px;
    border: 0px solid #000;
    cursor: pointer;
    font-size: 14px;
    width: 40px;
    height: 40px;
    box-sizing: border-box;
    transition: none; /* Prevent any transitions */
}
button:hover {
    background: rgba(224, 123, 0, 0.5);
    transition: background 0.1s ease; /* Smooth hover effect */
}
        #mute {
            padding: 0px;
            border-radius: 25%;
            height: 20px;
            width: 30px;
            background: #fff;
            color: #000;
            margin-right: 50px;
            z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #attack, #potion {
            margin-right: 20px;
            background: #ff8c00;
            color: #fff;
            height: 50px;
            width: 50px; 
            border-radius: 50%;
        }
        #attack:hover, #potion:hover {
            background: #e07b00;
        }
        #start-button {
            position: absolute;
            top: 75%;
            left: 50%;
            width: 120px;
            height: 50px;
            transform: translate(-50%, -50%);
            background: #00e8d8;
            color: #fff;
            border: none;
            padding: 0px 20px;
            font-family: 'VT323', monospace;
            font-size: 42px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 40;
        }
        #start-button:hover {
            background: #00b7ef;
        }
#dpad button {
    -webkit-tap-highlight-color: transparent; /* Remove browser default highlight */
    touch-action: none; /* Prevent browser touch interference */
    user-select: none; /* Prevent text selection */
    background: transparent; /* Default background */
    transition: background 0.1s ease-out; /* Brief flash for press */
}

#dpad button:active {
    background: rgba(224, 123, 0, 0.7); /* Orange flash on press */
}
#dpad button.pressed {
    background: rgba(224, 123, 0, 0.2); /* Subtle feedback for held state */
}

#submit-score, #view-leaderboard, #restart-game {
    background: #ff8c00;
    color: #fff;
    border: none;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 18px;
    cursor: pointer;
    border-radius: 5px;
    width: 120px; /* Keep for view-leaderboard and restart-game */
    height: 40px;
    z-index: 40;
}
#submit-score {
    width: 220px; /* Almost doubled from 120px */
}

#submit-score:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
}

#leaderboard-output {
    position: absolute;
    top: 0px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #ff8c00;
    border: 2px solid #ff8c00;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    width: 640px;
    max-width: 100%;
    text-align: left;
    white-space: pre;
    line-height: 1.2;
    box-sizing: border-box;
    word-break: break-word; /* Handle long text */
}

#sats-calc {
    display: block;          /* line‑break */
    color: var(--text-color);   /* inherits the theme colour */
}

    /* Windows 95 Screensaver Styles */
#screensaver-overlay { position: fixed; inset: 0; z-index: 99999; background: black; display: none; }   
#screensaver-canvas { position: absolute; top:0; left:0; width:100%; height:100%; display:block; }
    
.star {
    position: absolute;
    background-color: #ff8c00; /* Windows 95 orange */
    border-radius: 50%;
    box-shadow: 0 0 10px #ff8c00, 0 0 20px #ff8c00;
    /* Add these new properties for better visual effect */
    filter: blur(0.5px);
    animation: pulse 2s infinite alternate;
}

@keyframes pulse {
    0% { opacity: 0.7; }
    100% { opacity: 1; }
}
    
/* Phones (320px–767px) */
@media only screen and (min-width: 320px) and (max-width: 767px) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 9px;
    }
    #whale-hash-ids {
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 9px;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: 8px;
        height: 110px;
        font-size: 10px; /* Match font-size for consistency */
    }
    #inventory {
        width: 100px;
        font-size: 12px;
        line-height: 1.5;
        margin-right: 2px;
    }
    #floor-indicator {
        font-size: clamp(16px, 4.67vw, 24px);
    }
    button {
        width: 55px;
        height: 55px;
        font-size: 12px;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 40px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: -10px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 0px;
        margin-left: -15px;
        margin-top: 60px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 0px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 0px;
                margin-left: 20px;
        background: #ff8c00;
        height: 35px;
        width: 35px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }
    
    #submit-score, #view-leaderboard, #restart-game {
        width: 80px; /* Keep for view-leaderboard and restart-game */
        height: 30px;
        font-size: 16px;
    }
    #submit-score {
        width: 160px; /* Doubled from 80px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 14px;
}
    #leaderboard-output {
        top: -12px;
        width: 100%;
        max-width: 640px;
        font-size: 12px;
        max-height: 160px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}

/* Tablets (768px–1024px, high pixel ratio) */
@media only screen and (min-width: 768px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
        max-width: 640px;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 1.2rem;
    }
    #whale-hash-ids {
        font-size: 1.2rem;
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 1.2rem;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: -60px;
        height: 156px;
        font-size: 1.2rem;
    }
    #inventory {
        width: 170px;
        font-size: 1.4rem;
        line-height: 1.5;
        margin-right: 20px;
    }
    #floor-indicator {
        font-size: clamp(24px, 4.67vw, 37px);
    }
    button {
        width: 65px;
        height: 65px;
        font-size: 1.2rem;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 120px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: 20px;
        margin-top: -50px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 24px;
        width: 24px;
        background: #fff;
        color: #000;
        margin-right: 80px;
        margin-left: -15px;
        margin-top: 45px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 5px;
        background: #ff8c00;
        height: 65px;
        width: 65px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 5px;
        margin-left: 20px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }

    #submit-score, #view-leaderboard, #restart-game {
        width: 100px; /* Keep for view-leaderboard and restart-game */
        height: 48px;
        font-size: 18px;
    }
    #submit-score {
        width: 200px; /* Doubled from 100px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 16px;
}
    #leaderboard-output {
        top: 0px;
        width: 100%;
        max-width: 640px;
        font-size: 14px;
        max-height: 200px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}
</style>
</head>
<body>
    <div id="console">
        <div id="whale-log">
            <div id="whale-hash-ids">Whale Transactions:</div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
    		<canvas id="splash-canvas" width="320" height="320"></canvas>
    	    <button id="start-button">START</button>
    	    <div id="info-icon" onclick="showInfo()" style="position: absolute; top: 50px; right: 20px; width: 30px; height: 30px; background: #00e8d8; color: #fff; border: 3px solid #ff8c00; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-family: 'VT323', monospace; font-size: 24px; cursor: pointer; z-index: 50;">i</div>
    	    <!-- Add info message display -->
<div id="info-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 20px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; display: none; z-index: 60; max-width: 80vw; border-radius: 5px;">
    Hey listen! ;)<br><br>
    If you are using a Gamepad, connect it after you have pressed the START button on the screen.
</div>
	    </div>
<div id="game-over">
    <pre id="leaderboard-output"></pre>
    <canvas id="game-over-canvas" width="320" height="320"></canvas>
    <div style="position: absolute; top: 60%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px;"> <!-- Increased gap from 10px to 15px -->
        <input id="username-input" type="text" placeholder="Enter Username" maxlength="20" list="name-list" style="background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 8px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; width: 200px;">
<datalist id="name-list"></datalist>
        <button id="submit-score" onclick="submitScore()">Submit Score</button>
        <button id="view-leaderboard" onclick="fetchLeaderboard()">Leaderboard</button>
        <button id="restart-game" onclick="restart()">Restart</button>
    </div>
</div>
            <div id="floor-indicator">Floor 1</div>
<div id="inventory" style="-webkit-nbsp-mode: normal;">
    <span id="wave" style="display: none;">1</span>
    Health: <span id="health">24</span><br>
    Armor: <span id="armorStatus">Leather</span><br>
    Potions: <span id="potions">0</span><br>
    <span id="pickaxes" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    Floor x Bag: <span id="sats" style="display: none;">0</span>
    <span id="sats-calc" class="calc"></span>
    <span id="diamonds" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    <span id="perfectlyCutDiamonds" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    <span id="runes" style="display: none;">None</span><br> <!-- moved to soul terminal -->
</div>
        </div>
<div id="battle-log">
    <textarea id="battle-events" readonly>Battle Log:</textarea>
</div>

<!-- Soul Terminal Overlay -->
<div id="soul-terminal-overlay">
    <div id="soul-terminal">
        <div id="soul-terminal-header">BTC-DUNGEON</div>
        <div id="soul-terminal-content"></div>
        <div id="soul-terminal-input-container">
            <span id="soul-terminal-prompt">soul@terminal:~$ </span>
            <input type="text" id="soul-terminal-input" autocomplete="off" spellcheck="false">
        </div>
    </div>
</div>
<div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">↑</button>
                <button id="left" onclick="move('left')">←</button>
                <button id="right" onclick="move('right')">→</button>
                <button id="down" onclick="move('down')">↓</button>
            </div>
<div id="actions">
                <button id="mute" onclick="toggleMute()">♪</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.10.0/dist/axios.min.js"></script>
    <script>

const names = [
    "Alan-Soul",
    "Alex-Cipher",
    "Amanda-Quest",
    "Amy-Crypt",
    "Andrea-Haze",
    "Andrew-Fury",
    "Angela-Shade",
    "Ann-Shadow",
    "Anthony-Smog",
    "Arthur-Sky",
    "Ashley-Guild",
    "Azeroth-Blade",
    "Barbara-Storm",
    "Benjamin-Bolt",
    "Blaise-Crypt",
    "Brian-Block",
    "Brother-Void",
    "Bruce-Ice",
    "Carl-Fissure",
    "Catherine-Dark",
    "Charles-Claw",
    "Cheryl-Vine",
    "Christina-Spark",
    "Christopher-Blade",
    "Cindy-Breath",
    "Craig-Mark",
    "Crystal-Gale",
    "Cynthia-Frost",
    "Daniel-Hex",
    "David-Rune",
    "Deborah-Spear",
    "Dennis-Pulse",
    "Diane-Blood",
    "Donald-Ward",
    "Donna-Slash",
    "Edward-Blaze",
    "Elizabeth-Fog",
    "Emily-Dusk",
    "Eric-Iron",
    "Eugene-Dream",
    "Father-Rune",
    "Frank-Tide",
    "Gary-Grip",
    "George-Drift",
    "Gerden-Skull",
    "Gregory-Doom",
    "Heather-Knight",
    "Helen-Fire",
    "Howard-Wild",
    "James-Miner",
    "Jane-Trace",
    "Janet-Spine",
    "Jason-Void",
    "Jeffrey-Glare",
    "Jennifer-Vault",
    "Jeremy-Rage",
    "Jessica-Hash",
    "Joan-Tempest",
    "John-Flame",
    "Jonathan-Mist",
    "Joseph-Nexus",
    "Joshua-Coin",
    "Judith-Shock",
    "Julie-Fade",
    "Karen-Fell",
    "Kathleen-Howl",
    "Kelly-Wind",
    "Kenneth-Glow",
    "Kevin-Wisp",
    "Kimberly-Grim",
    "Kristin-Curse",
    "Larry-Vortex",
    "Laura-Veil",
    "Lauren-Bane",
    "Linda-Dawn",
    "Lisa-Torch",
    "Lori-Swarm",
    "Maria-Crag",
    "Mark-Wraith",
    "Mary-Raven",
    "Matt-Dread",
    "Matthew-Shard",
    "Megan-Sword",
    "Melissa-Cipher",
    "Michael-Chain",
    "Michelle-Viper",
    "Mother-Wraith",
    "Nancy-Byte",
    "Nathan-Bind",
    "Nicole-Rift",
    "Pamela-Node",
    "Patrich-Hex",
    "Patrick-Maze",
    "Paul-Hawk",
    "Philip-Wave",
    "Ponyo-Shard",
    "Rachel-Fang",
    "Randy-Clash",
    "Rebecca-Dust",
    "Richard-Lore",
    "Robert-Skull",
    "Roger-Light",
    "Ronald-Guard",
    "Ruth-Vow",
    "Ryan-Crow",
    "Sarah-Ledger",
    "Satoshi-Chain",
    "Scott-Ghost",
    "Sharon-Chill",
    "Shawn-Trail",
    "Sister-Gloom",
    "Solan-Fury",
    "Stephanie-Talon",
    "Steve-Burst",
    "Steven-Pool",
    "Susan-Thorn",
    "Terry-Edge",
    "Theresa-Stone",
    "Thomas-Gloom",
    "Tiffany-Flux",
    "Timothy-Night",
    "Tina-Fall",
    "Todd-Rush",
    "Tony-Realm",
    "Tracy-Wolf",
    "Victoria-Seer",
    "Walter-Hunt",
    "William-Dagger"
];

const uniqueMonsterNames = {
    'Shrimp': ['Fire-Shrimp', 'Gray-Shrimp', 'Gut-Shrimp', 'Sharp-Shrimp', 'Sin-Shrimp', 'Blaze-Shrimp', 'Spirit-Shrimp', 'Steel-Shrimp', 'Storm-Shrimp', 'Viper-Shrimp'],
    'Crab': ['Blade-Crab', 'Death-Crab', 'Gloom-Crab', 'Mind-Crab', 'Ooze-Crab', 'Pit-Crab', 'Rust-Crab', 'Vile-Crab', 'Wind-Crab', 'Thunder-Crab'],
    'Squid': ['Chaos-Squid', 'Cold-Squid', 'Dire-Squid', 'Dragon-Squid', 'Gore-Squid', 'Mold-Squid', 'Puke-Squid', 'Soul-Squid', 'Warp-Squid', 'Frost-Squid'],
    'Dolphin': ['Black-Dolphin', 'Blight-Dolphin', 'Demon-Dolphin', 'Dread-Dolphin', 'Flesh-Dolphin', 'Night-Dolphin', 'Seethe-Dolphin', 'Snot-Dolphin', 'Wrath-Dolphin', 'Venom-Dolphin'],
    'Shark': ['Bile-Shark', 'Bone-Shark', 'Doom-Shark', 'Grief-Shark', 'Moon-Shark', 'Plague-Shark', 'Pox-Shark', 'Shadow-Shark', 'Sharp-Shark', 'Bolt-Shark'],
    'Whale': ['Ash-Whale', 'Bane-Whale', 'Blood-Whale', 'Fester-Whale', 'Foul-Whale', 'Haze-Whale', 'Rot-Whale', 'Spine-Whale', 'Star-Whale', 'Inferno-Whale']
};

// Show info message
function showInfo() {
    const infoMessage = document.getElementById('info-message');
    infoMessage.style.display = 'block';
    
    // Switch to info.png
    currentSplashImage = 'info.png';
    splashCanvas.clearRect(0, 0, 320, 320);
    splashImg.src = currentSplashImage;
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    
    setTimeout(() => {
        infoMessage.style.display = 'none';
    }, 5000); // Auto-hide after 5 seconds
}

function populateNameList() {
    const datalist = document.getElementById('name-list');
    datalist.innerHTML = ''; // Clear existing options
    names.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        datalist.appendChild(option);
    });
}

function levenshtein(a, b) {
    const matrix = Array(b.length + 1).fill().map(() => Array(a.length + 1).fill(0));
    for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
    for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
            matrix[j][i] = Math.min(
                matrix[j-1][i] + 1,
                matrix[j][i-1] + 1,
                matrix[j-1][i-1] + (a[i-1].toLowerCase() === b[j-1].toLowerCase() ? 0 : 1)
            );
        }
    }
    return matrix[b.length][a.length];
}

// Enhanced name matching function
function findClosestName(input, nameList) {
    const inputLower = input.toLowerCase();
    
    // First, try exact prefix match (case-insensitive)
    const exactPrefixMatch = nameList.find(name => 
        name.toLowerCase().startsWith(inputLower)
    );
    if (exactPrefixMatch) return exactPrefixMatch;
    
    // Then, try partial match (substring anywhere in the name)
    const partialMatch = nameList.find(name => 
        name.toLowerCase().includes(inputLower)
    );
    if (partialMatch) return partialMatch;
    
    // If no prefix or partial match, use Levenshtein distance
    let minDistance = Infinity;
    let closestName = input; // Default to input if no close match
    
    for (const name of nameList) {
        const distance = levenshtein(inputLower, name.toLowerCase());
        if (distance < minDistance) {
            minDistance = distance;
            closestName = name;
        }
    }
    
    // Only use Levenshtein match if distance is reasonably small
    // Adjust threshold as needed - 3 seems good for most cases
    if (minDistance <= 3) {
        return closestName;
    }
    
    return input; // Return original if no good match found
}

/**
 * Calculates the score that will be sent to the leaderboard.
 *  • `floor` is the current floor number.
 *  • The multiplier is `floor / 100`.
 *  • The extra amount is `floor / 100` of the raw satoshis.
 *
 * Example: floor = 45, raw = 14000 BTC
 *   multiplier = 45 / 100 = 0.45
 *   extra      = 14000 * 0.45 = 6300
 *   finalScore = 14000 + 6300 = 20300
 */
function getScoreWithMultiplier(rawScore, currentFloor) {
    const multiplier = currentFloor / 100;          // 0.45 for floor 45
    const added = Math.floor(rawScore * multiplier);
    return rawScore + added;                       // 20300 in the example
}

// Modified submitScore function with nearest name matching and random fallback
async function submitScore() {
    if (!gameOver) return;
    if (scoreSubmitted) {
        document.getElementById('leaderboard-output').textContent = 'Score already submitted for this game!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: already submitted');
        return;
    }
    if (floor < 3) {
        document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: floor=', floor, '< 3');
        return;
    }
    let username = document.getElementById('username-input').value.trim();
    if (!username) {
        // Select random name if input is empty
        username = names[Math.floor(Math.random() * names.length)];
        console.log(`Empty username, selected random name: '${username}'`);
    } else if (!names.includes(username)) {
        // Find the closest matching name using enhanced algorithm
        const closestName = findClosestName(username, names);
        
        // Check if we found a match and it's different from input
        if (closestName !== username && closestName.toLowerCase() !== username.toLowerCase()) {
            console.log(`Username '${username}' matched to '${closestName}'`);
            username = closestName;
        } else {
            // Select random name if no good match found
            username = names[Math.floor(Math.random() * names.length)];
            console.log(`Username '${username}' not matched, selected random name: '${username}'`);
        }
    }
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    // NEW: calculate the leaderboard score with the floor multiplier
    const leaderboardScore = getScoreWithMultiplier(totalSats, floor);
    try {
    const response = await fetch(`${API_URL}?action=submit`, {
        method: 'POST',
        headers,
        // send the multiplied score
        body: JSON.stringify({ username, score: leaderboardScore, floor })
    });
      if (response.status === 429) {
        console.error('Rate limit exceeded for submitting scores');
        return;
      }
      if (!response.ok) {
        console.error(`POST Status: ${response.status}, Response: ${await response.text()}`);
        return;
      }
        const text = await response.text();
        console.log(`POST Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : {};
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok) {
            scoreSubmitted = true;
            document.getElementById('submit-score').disabled = true;
            document.getElementById('submit-score').style.background = '#666';
            document.getElementById('leaderboard-output').textContent = `Score submitted: ${username}, ${leaderboardScore} sats (Floor ${floor})`;
            document.getElementById('leaderboard-output').style.display = 'block';
            
            await fetchLeaderboard(username, leaderboardScore, floor);
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
            if (response.status === 400 && text.includes('new row violates row-level security policy')) {
                document.getElementById('leaderboard-output').textContent = 'Submission blocked: Must reach at least Floor 3!';
            }
            document.getElementById('leaderboard-output').style.display = 'block';
        }
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

// Generate or retrieve session ID
  function generateSessionId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  const sessionId = localStorage.getItem('sessionId') || generateSessionId();
  localStorage.setItem('sessionId', sessionId);

const API_URL = 'https://noexxibndcooqjquhqzk.supabase.co/functions/v1/leaderboard';
  const headers = {
    'Content-Type': 'application/json',
    'X-Session-ID': sessionId
  };


async function fetchLeaderboard(submittedUsername = null, submittedScore = null, submittedFloor = null) {
    try {
      const leaderboardResponse = await fetch(`${API_URL}?action=fetch&limit=10`, {
        method: 'GET',
        headers
      });
      if (leaderboardResponse.status === 429) {
        console.error('Rate limit exceeded for fetching leaderboard');
        document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching leaderboard';
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
      }
      if (!leaderboardResponse.ok) {
        const errorText = await leaderboardResponse.text();
        console.error(`GET Status: ${leaderboardResponse.status}, Response: ${errorText}`);
        document.getElementById('leaderboard-output').textContent = `Error: ${leaderboardResponse.status} ${errorText}`;
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
      }
      const text = await leaderboardResponse.text();
      console.log(`GET Status: ${leaderboardResponse.status}, Response: ${text}`);
      let data;
      try {
        data = text ? JSON.parse(text) : [];
      } catch (e) {
        data = { raw: text };
      }
      if (leaderboardResponse.ok && Array.isArray(data)) {
    // Cache the raw data
    localStorage.setItem('leaderboardData', JSON.stringify(data));
    cachedLeaderboard = data;
        let playerInTop10 = submittedUsername ? data.some(entry => entry.username === submittedUsername && entry.score === submittedScore && entry.floor === submittedFloor) : false;
        let playerEntry = null;
        let playerRank = null;

        // Fetch player's score and rank if not in top 10 and floor >= 3
        if (submittedUsername && !playerInTop10 && submittedFloor >= 3) {
          try {
            const playerResponse = await fetch(
              `${API_URL}?action=fetchPlayer&username=${encodeURIComponent(submittedUsername)}&score=${submittedScore}&floor=${submittedFloor}`,
              { method: 'GET', headers }
            );
            if (playerResponse.status === 429) {
              console.error('Rate limit exceeded for fetching player');
              document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching player';
              document.getElementById('leaderboard-output').style.display = 'block';
              return;
            }
            if (!playerResponse.ok) {
              console.error(`GET Status: ${playerResponse.status}, Response: ${await playerResponse.text()}`);
              return;
            }
            const playerData = await playerResponse.json();
            if (playerResponse.ok && playerData.length > 0) {
              playerEntry = playerData[0];
              const rankResponse = await fetch(`${API_URL}?action=fetchRank&score=${submittedScore}`, {
                method: 'GET',
                headers
              });
              if (rankResponse.status === 429) {
                console.error('Rate limit exceeded for fetching rank');
                document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching rank';
                document.getElementById('leaderboard-output').style.display = 'block';
                return;
              }
              if (!rankResponse.ok) {
                console.error(`GET Status: ${rankResponse.status}, Response: ${await rankResponse.text()}`);
                return;
              }
              const rankData = await rankResponse.json();
              if (rankResponse.ok) {
                playerRank = rankData.length + 1;
              }
            }
          } catch (e) {
            console.error('Error fetching player score or rank:', e);
          }
        }

        // Format leaderboard
        const maxUsernameLength = 20;
        const scoreWidth = 14;
        const numberWidth = 10;
        const floorWidth = 6;
        const header = `Rank  Username               Score         Floor`;
        let rows = data.map((entry, index) => {
          const rank = (index + 1).toString().padStart(2, '0');
          const username = entry.username.length > maxUsernameLength
            ? entry.username.substring(0, maxUsernameLength - 2) + '..'
            : entry.username.padEnd(maxUsernameLength);
          const scoreValue = entry.score;
          let numberPart, unitPart;
          if (scoreValue >= 1e8) {
            numberPart = (scoreValue / 1e8).toFixed(1);
            unitPart = 'BTC';
          } else {
            numberPart = scoreValue.toString();
            unitPart = 'sats';
          }
          const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
          const score = scoreDisplay.padEnd(scoreWidth);
          const floor = entry.floor.toString().padStart(floorWidth);
          return `${rank}    ${username}${score}${floor}`;
        });

        // Replace or append player's entry with actual rank if not in top 10
        if (playerEntry && !playerInTop10 && playerRank) {
          const username = playerEntry.username.length > maxUsernameLength
            ? playerEntry.username.substring(0, maxUsernameLength - 2) + '..'
            : playerEntry.username.padEnd(maxUsernameLength);
          const scoreValue = playerEntry.score;
          let numberPart, unitPart;
          if (scoreValue >= 1e8) {
            numberPart = (scoreValue / 1e8).toFixed(1);
            unitPart = 'BTC';
          } else {
            numberPart = scoreValue.toString();
            unitPart = 'sats';
          }
          const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
          const score = scoreDisplay.padEnd(scoreWidth);
          const floor = playerEntry.floor.toString().padStart(floorWidth);
          const playerRow = `${playerRank.toString().padStart(2, '0')}    ${username}${score}${floor}`;
          if (rows.length >= 10) {
            rows[9] = playerRow; // Replace 10th entry
          } else {
            rows.push(playerRow); // Append if fewer than 10 entries
          }
        }

        const leaderboardText = `${header}\n${rows.join('\n') || 'No entries yet!'}`;
        document.getElementById('leaderboard-output').textContent = leaderboardText;
      } else {
        document.getElementById('leaderboard-output').textContent = `Error: ${leaderboardResponse.status} ${JSON.stringify(data, null, 2)}`;
      }
      document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
      document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
      console.error('Fetch leaderboard error:', error);
      document.getElementById('leaderboard-output').style.display = 'block';
    }
  }

// Get player's estimated rank/score for cached leaderboard
function getPlayerEstimatedRank(cachedData, playerSats, playerFloor) {
    const playerScore = getScoreWithMultiplier(playerSats, playerFloor);
    let rank = 1;
    for (const entry of cachedData) {
        const entryScore = getScoreWithMultiplier(entry.score, entry.floor); // Recompute for fairness
        if (playerScore > entryScore) break;
        rank++;
    }
    return { score: playerScore, rank, floor: playerFloor };
}

document.getElementById('username-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameOver) {
        e.preventDefault(); // Prevent any default behavior
        e.stopPropagation(); // Stop event propagation to prevent restart
        submitScore(); // Trigger score submission
    }
});

// Also add blur handler to prevent touch keyboard from triggering restart
document.getElementById('username-input').addEventListener('blur', function() {
    // Allow a short delay before re-enabling game controls
    setTimeout(() => {
        // Re-enable game controls if needed
    }, 100);
});

// Prevent pinch-to-zoom and double-tap zoom
document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gestureend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });

const canvas = document.getElementById('game');
let touchMoveInterval = null; // Global variable for continuous touch movement
let touchTimeout = null; // Global variable for touch timeout
let dpadButtons = document.querySelectorAll('#dpad button');
let actionsButtons = document.querySelectorAll('#actions button');

// Touch handlers for #actions buttons
document.querySelectorAll('#actions button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.add('pressed');
        if (button.id === 'mute') toggleMute();
        else if (button.id === 'attack') attack();
        else if (button.id === 'potion') usePotion();
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed');
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault();
    }, { passive: false });
});

const c = canvas.getContext('2d');
const W = 20, H = 20, S = 16;
let currentTheme = 'dungeon'; // Default theme
const themes = ['dungeon', 'desert', 'paradise', 'hell', 'ruins'];
let initialWaveSpawned = false; // Track if initial wave has spawned

function selectNewTheme(current) {
    const available = themes.filter(t => t !== current);
    return available[Math.floor(Math.random() * available.length)];
}

let isFetchingTxs = false; // Track if fetchTxs is currently running
let savedPauseState = null; // remembers pause button state before screensaver
let currentRuneTile = null; // Track current rune tile position
let highlightTiles = [];
let activatedRunewords = [];
let lastDrawTime = null;
let frameCount = 0;  // Add this line
let borderLastUpdate = null;
let activeUniqueMonsterName = null;
let shrinePositions = [];
let map = [],
    p = {
x: 2,
    y: 2,
    currentX: 32,  // S * x
    currentY: 32,  // S * y
    moving: false,
    stepsLeft: 0,
    deltaX: 0,
    deltaY: 0,
    targetTileX: 0,
    targetTileY: 0,
    hp: 36,
        potions: 0,
        atk: 2,
        pickaxes: 0,
        hasArmor: true,
        hasDiamondArmor: false, // Track diamond armor
    	perfectlyCutDiamonds: 0, // Track perfectly cut diamonds
        runes: [], // Array to store collected rune letters (e.g., ['a','b','c'])
        runewords: [], // Array to store activated runewords (e.g., ['btc', 'hodl'])
        immortal: false, // Flag for HODL runeword immortality
        ripBlast: false, // Flag for RIP runeword blast
        isFalling: false, // Flag to track if the player is currently animating
        anim: {
            frames: {
                front: [new Image(), new Image()],
                back: [new Image(), new Image()],
                right: [new Image(), new Image()],
                armor_front: [new Image(), new Image()],
                armor_back: [new Image(), new Image()],
                armor_right: [new Image(), new Image()],
                diamond_armor_front: [new Image(), new Image()],
                diamond_armor_back: [new Image(), new Image()],
                diamond_armor_right: [new Image(), new Image()],
                fall: [new Image(), new Image(), new Image()],
            },
            direction: 'front',
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 400  // Doubled for half speed
        },
	// Add shrine charge tracking
	shrineCharges: 0,
	maxShrineCharges: 24,
	shrineUsedThisFloor: false, // Track if shrine was used on this floor
	
        // Add soul system properties
        soulStones: 0,
        soulShards: 0,
        soulOrbs: 0,
        soulStormCharges: 0, // Track how many charges we have (max 256)
        inSoulTerminal: false, // Track if player is in soul terminal
        soulTerminalCommand: '', // Current command input
        soulTerminalCursorPos: 0, // Cursor position in command
        soulTerminalActive: false, // Whether soul terminal is currently open
        // Add diamond hand properties
        hasDiamondHand: false, // Track if player has diamond hand
        moveCounter: 0,
        // Add elemental immunity
        elementImmunity: null, // Store the player's elemental immunity
        armorImmunity: null, // Store armor's elemental immunity
    }, 
    enemies = [], 
    rooms = [];
    dangerousAreas = []; // Track dangerous spell areas
    diamonds = 0;          // total diamonds collected in the current run
    let themeTimeoutId = null;   // <‑‑ new
    
// Load animation frames
p.anim.frames.front[0].src = 'player-front1.png';
p.anim.frames.front[1].src = 'player-front2.png';
p.anim.frames.back[0].src = 'player-back1.png';
p.anim.frames.back[1].src = 'player-back2.png';
p.anim.frames.right[0].src = 'player-right1.png';
p.anim.frames.right[1].src = 'player-right2.png';
p.anim.frames.armor_front[0].src = 'player_armor-front1.png';
p.anim.frames.armor_front[1].src = 'player_armor-front2.png';
p.anim.frames.armor_back[0].src = 'player_armor-back1.png';
p.anim.frames.armor_back[1].src = 'player_armor-back2.png';
p.anim.frames.armor_right[0].src = 'player_armor-right1.png';
p.anim.frames.armor_right[1].src = 'player_armor-right2.png';

// player is affected during theme "Ruins"
p.anim.frames.fall[0].src = 'player_fall1.png';
p.anim.frames.fall[1].src = 'player_fall2.png';
p.anim.frames.fall[2].src = 'player_fall3.png';
p.anim.frames.fall.forEach((frame, i) => {
    frame.onerror = () => console.error(`Failed to load fall frame ${i}: ${frame.src}`);
});

let floor = 1, wave = 1, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
let previousFloorState = null; // Store state before entering hideout
let inHideout = false; // Track if player is in hideout
let jewellerPos = null; // Track jeweller position
let blacksmithPos = null; // Track blacksmith position
let waypointPos = null; // Track waypoint position
let scoreSubmitted = false; // Tracks if score has been submitted
let cachedLeaderboard = null; // Store fetched leaderboard
let whaleHashIds = ['Whale Transactions:'], battleLog = [], killsLog = [];
let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let satoshiDrops = [];
let runeDrops = []; // Array to store rune drops with positions and letters
let scrollDrops = []; // Array to store scroll drops with positions
let portals = []; // Array to store active portal positions and animation state
let splashActive = true;
let waveActive = false;
let musicMuted = localStorage.getItem('musicMuted') === 'true';        
let swordDir = 'right', swordActive = false, swordStart = 0;
let gameOverSoundPlayed = false;
let fogMap = [];
let battleLogTimeout = null;
let projectiles = [];
let autoSubmitTriggered = false;
let inputBlocked = false;
let soulStashPos = null; // Position of soul stash on current floor
let soulTerminalActive = false; // Whether soul terminal is currently open
let soulTerminalCommand = ''; // Current command input
let soulTerminalCursorPos = 0; // Cursor position in command

const specialSoundsPlayedThisFloor = {
    lava: false,
    quicksand: false,
    pond: false,
    rune: false,
    hole: false
};

class EnemyType {
    constructor(name, min, max, hp, atk, move, reward = 0) {
        this.name = name;
        this.min = min;
        this.max = max;
        this.hp = hp;
        this.atk = atk;
        this.move = move;
        this.reward = reward;
        this.anim = {
            frames: [new Image(), new Image(), new Image()],
            hellFrames: [new Image(), new Image(), new Image()],
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 400  // Doubled for half speed
        };
    }
}

// Spell types for unique monsters
const SPELL_TYPES = {
    FIRE_WALL: 'Fire Wall',
    LIGHTNING_STORM: 'Lightning Storm',
    FROST_NOVA: 'Frost Nova',
    POISON_CLOUD: 'Poison Cloud'
};

const types = [
    new EnemyType('Shrimp', 0, 0.01, 2, 1, 1),
    new EnemyType('Crab', 0.01, 0.1, 3, 2, 1),
    new EnemyType('Squid', 0.1, 1, 4, 2, 2),
    new EnemyType('Dolphin', 1, 10, 4, 3, 2),
    new EnemyType('Shark', 10, 100, 5, 5, 2),
    new EnemyType('Whale', 100, Infinity, 6, 4, 2)
];

const assets = {
    themes: {
        dungeon: { floor: new Image(), wall: new Image() },
        desert: { floor: new Image(), wall: new Image(), special: new Image() },
        paradise: { floor: new Image(), wall: new Image(), special: new Image() },
        hell: { floor: new Image(), wall: new Image(), special: new Image() },
        ruins: { floor: new Image(), wall: new Image(), special: new Image() },
        hideout: { floor: new Image(), wall: new Image(), diamond_wall: new Image() }
    },
    potion: new Image(),
    player: new Image(),
    stairs: new Image(),
    bitcoin: new Image(),
    gameOver: new Image(),
    sword: new Image(),
    pickaxe: new Image(),
    armor: new Image(),
    player_armor: new Image(),
    player_diamond_armor: new Image(),
    pickaxe_sword: new Image(),
    shoot_sword: new Image(),
    gnome: new Image(),
    jeweller: new Image(),
    blacksmith: new Image(),
    waypoint: new Image(),
    rune_whisperer: new Image(),
    runes: {
        on_floor: new Image(),
        a: new Image(), b: new Image(), c: new Image(), d: new Image(), e: new Image(),
        f: new Image(), g: new Image(), h: new Image(), i: new Image(), k: new Image(),
        l: new Image(), m: new Image(), n: new Image(), o: new Image(), p: new Image(),
        q: new Image(), r: new Image(), s: new Image(), t: new Image(), u: new Image(),
        v: new Image(), y: new Image(), z: new Image(), æ: new Image(), ø: new Image()
    },
    diamond: new Image(),
    scroll: new Image(),
    town_portal: [new Image(), new Image(), new Image()],
    soul_stash: new Image(),
    soul_stone: new Image(),
    hooded_heirloom: new Image(),
    soul_orb_statue: new Image(),
    shrine: new Image()
};

// Initialize sprite frames for all enemy types
for (let i = 0; i < types.length; i++) {
    const type = types[i];
    if (type.name === 'Shrimp') {
        // Hell Shrimp has special frames that need to be loaded
        assets.themes.hell.special.onerror = () => console.error(`Failed to load hell special asset: ${assets.themes.hell.special.src}`);
    }
}

// Load sprite frames for each enemy type
types.forEach((type, index) => {
    // Set up default animation frames
    type.anim.frames[0].src = `${type.name.toLowerCase()}_1.png`;
    type.anim.frames[1].src = `${type.name.toLowerCase()}_2.png`;
    type.anim.frames[2].src = `${type.name.toLowerCase()}_3.png`;
    
    // Special handling for Hell Shrimp
    if (type.name === 'Shrimp') {
        type.anim.hellFrames[0].src = 'hell_shrimp_1.png';
        type.anim.hellFrames[1].src = 'hell_shrimp_2.png';
        type.anim.hellFrames[2].src = 'hell_shrimp_3.png';
        type.anim.hellFrames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load Hell Shrimp frame ${i}: ${frame.src}`);
        });
    }
});

Object.values(assets).forEach(asset => {
        if (asset instanceof Image) {
            asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
        } else if (typeof asset === 'object') {
            Object.values(asset).forEach(subAsset => {
                subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
            });
        }
    });
    
// Handle error for enemy sprite frames
types.forEach(t => {
    t.anim.frames.forEach((frame, i) => {
        frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
    });
    // Also handle Hell Shrimp frames if they exist
    if (t.anim.hellFrames) {
        t.anim.hellFrames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load Hell sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});
        assets.themes.dungeon.floor.src = 'floor.png';
        assets.themes.dungeon.wall.src = 'wall.png';
        assets.themes.desert.floor.src = 'sand_floor.png';
        assets.themes.desert.wall.src = 'sand_wall.png';
        assets.themes.desert.special.src = 'quicksand.png';
        assets.themes.paradise.floor.src = 'paradise_floor.png';
        assets.themes.paradise.wall.src = 'paradise_wall.png';
        assets.themes.paradise.special.src = 'pond.png';
        assets.themes.hell.floor.src = 'hell_floor.png';
        assets.themes.hell.wall.src = 'hell_wall.png';
        assets.themes.hell.special.src = 'lava.png';
        assets.themes.ruins.floor.src = 'ring_floor.png';
        assets.themes.ruins.wall.src = 'ring_wall.png';
        assets.themes.ruins.special.src = 'ring_hole.png';
        assets.potion.src = 'potion.png';
        assets.gnome.src = 'gnome.png';
	assets.player.src = 'player.png';
	assets.pickaxe.src = 'pickaxe.png';
	assets.armor.src = 'armor.png';
	assets.player_armor.src = 'player_armor.png';
        assets.stairs.src = 'stairs.png'; 
        assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png';
        assets.sword.src = 'sword.png';
        assets.diamond_hand = new Image(); // Add diamond hand asset
        assets.diamond_hand.src = 'diamond_hand.png';
        assets.pickaxe_sword.src = 'pickaxe-sword.png';
        assets.shoot_sword.src = 'shoot_sword.png';
        assets.soul_sword = new Image();
        assets.soul_sword.src = 'soul_sword.png';      
        assets.runes.on_floor.src = 'rune_on_floor.png';
	assets.runes.a.src = 'rune-a.png';
	assets.runes.b.src = 'rune-b.png';
	assets.runes.c.src = 'rune-c.png';
	assets.runes.d.src = 'rune-d.png';
	assets.runes.e.src = 'rune-e.png';
	assets.runes.f.src = 'rune-f.png';
	assets.runes.g.src = 'rune-g.png';
	assets.runes.h.src = 'rune-h.png';
	assets.runes.i.src = 'rune-i.png';
	assets.runes.k.src = 'rune-k.png';
	assets.runes.l.src = 'rune-l.png';
	assets.runes.m.src = 'rune-m.png';
	assets.runes.n.src = 'rune-n.png';
	assets.runes.o.src = 'rune-o.png';
	assets.runes.p.src = 'rune-p.png';
	assets.runes.q.src = 'rune-q.png';
	assets.runes.r.src = 'rune-r.png';
	assets.runes.s.src = 'rune-s.png';
	assets.runes.t.src = 'rune-t.png';
	assets.runes.u.src = 'rune-u.png';
	assets.runes.v.src = 'rune-v.png';
	assets.runes.y.src = 'rune-y.png';
	assets.runes.z.src = 'rune-z.png';
	assets.runes.æ.src = 'rune-æ.png';
	assets.runes.ø.src = 'rune-ø.png';
	
	assets.diamond.src = 'diamond.png';
	assets.scroll.src = 'scroll.png';
	assets.town_portal[0].src = 'town_portal_1.png';
	assets.town_portal[1].src = 'town_portal_2.png';
	assets.town_portal[2].src = 'town_portal_3.png';
	assets.themes.hideout.floor.src = 'town_floor.png';
	assets.themes.hideout.wall.src = 'town_wall.png';
	assets.themes.hideout.diamond_wall.src = 'diamond_wall.png';
	assets.soul_orb_statue.src = 'soul_orb_statue.png';
	assets.shrine.src = 'shrine.png';
	assets.jeweller.src = 'jeweller.png';
	assets.blacksmith.src = 'blacksmith.png';
	assets.waypoint.src = 'waypoint.png';
	assets.rune_whisperer.src = 'rune_whisperer.png';
	assets.player_diamond_armor.src = 'player_diamond_armor.png';
	assets.soul_stash.src = 'soul_stash.png';
	assets.soul_stone.src = 'soul_stone.png';
	assets.hooded_heirloom.src = 'hooded_heirloom.png';
	p.anim.frames.diamond_armor_front = [new Image(), new Image()];
	p.anim.frames.diamond_armor_front[0].src = 'player_diamond_armor-front1.png';
	p.anim.frames.diamond_armor_front[1].src = 'player_diamond_armor-front2.png';
	p.anim.frames.diamond_armor_back = [new Image(), new Image()];
	p.anim.frames.diamond_armor_back[0].src = 'player_diamond_armor-back1.png';
	p.anim.frames.diamond_armor_back[1].src = 'player_diamond_armor-back2.png';
	p.anim.frames.diamond_armor_right = [new Image(), new Image()];
	p.anim.frames.diamond_armor_right[0].src = 'player_diamond_armor-right1.png';
	p.anim.frames.diamond_armor_right[1].src = 'player_diamond_armor-right2.png';
	
Object.values(assets.runes).forEach(rune => {
    rune.onerror = () => console.error(`Failed to load rune asset: ${rune.src}`);
});
Object.values(assets).forEach(asset => {
    if (asset instanceof Image) {
        asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
    } else if (typeof asset === 'object') {
        Object.values(asset).forEach(subAsset => {
            subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
        });
    }
});
types.forEach(t => {
    if (t.img) {
        t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`);
    } else if (t.anim) {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});

function placeStairs() {
    if (inHideout) {
        console.warn('Attempted to place stairs in hideout – forbidden');
        return false;
    }
    if (exit) {
        logBattleEvent(`Floor ${floor} - Stairs placement skipped: exit already exists at (${exit.x}, ${exit.y})`);
        return true;
    }
    let x, y, placed = false;
    // Try room-based placement first
    if (rooms && rooms.length > 0) {
        let r = rooms[Math.floor(Math.random() * rooms.length)];
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = r.x + Math.floor(Math.random() * r.w);
            y = r.y + Math.floor(Math.random() * r.h);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    // Fallback to any valid floor tile
    if (!placed) {
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = Math.floor(Math.random() * W);
            y = Math.floor(Math.random() * H);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    if (placed) {
        exit = {x, y};
        updateSatsDisplay();
        logBattleEvent(`Floor ${floor} - Stairs appeared!`);
        needsRedraw = true;
        return true;
    } else {
        logBattleEvent(`Floor ${floor} - Failed to place stairs: no valid position found!`);
        console.warn(`Stairs placement failed: rooms=${rooms.length}, map valid=${map.every(row => row.length === W)}`);
        needsRedraw = true;
        return false;
    }
}

const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioContext = null;
function getAudioContext() {
    if (!audioContext) {
        audioContext = new AudioContext();
    }
    return audioContext;
}
audioContext = getAudioContext();

const sounds = {
    attack: new Audio('attack.wav'),
    potion: new Audio('potion.wav'),
    hit: { buffer: null, url: 'hit.wav', isPlaying: false, duration: 720 },
    pickup: { buffer: null, url: 'pickup.wav', isPlaying: false, duration: 950 },
    dungeon: new Audio('dungeon.mp3'),
desert: new Audio('desert.mp3'),
hell: new Audio('hell.mp3'),
paradise: new Audio('paradise.mp3'),
ruins: new Audio('ruins.mp3'),
hideout: new Audio('hideout.mp3'),
    gameover: new Audio('gameover.wav'),
    stairs: new Audio('stairs.wav'),
    secret: new Audio('secret.wav'),
    shoot_sword: new Audio('shoot_sword.wav'),
    heads: { buffer: null, url: 'heads.wav', isPlaying: false, duration: 650 },
    tails: { buffer: null, url: 'tails.wav', isPlaying: false, duration: 950 },
    lava: { buffer: null, url: 'lava.wav', isPlaying: false, duration: 900 },
    quicksand: { buffer: null, url: 'quicksand.wav', isPlaying: false, duration: 250 },
    pond: { buffer: null, url: 'pond.wav', isPlaying: false, duration: 500 },
    rune: { buffer: null, url: 'rune.wav', isPlaying: false, duration: 2000 },
    rune_drop: { buffer: null, url: 'rune_drop.wav', isPlaying: false, duration: 1000 },
    hole: { buffer: null, url: 'hole.wav', isPlaying: false, duration: 745 },
    town_portal: { buffer: null, url: 'town_portal.wav', isPlaying: false, duration: 535 },
    buzz: { buffer: null, url: 'buzz.wav', isPlaying: false, duration: 1000 },
    unique_monster: { buffer: null, url: 'unique_monster.wav', isPlaying: false, duration: 1400 }
};

// Volume control
let soundVolume = localStorage.getItem('soundVolume') || 1.0;
let musicVolume = localStorage.getItem('musicVolume') || 1.0;

function setSoundVolume(volume) {
    soundVolume = Math.max(0, Math.min(1, volume));
    localStorage.setItem('soundVolume', soundVolume);
    
    // Update all sound volumes
    Object.entries(sounds).forEach(([key, sound]) => {
        // Skip music tracks which are handled by musicManager
        if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout') {
            return; // Skip music tracks
        }
        if (sound.buffer) {
            // Web Audio sounds need to be handled via gain nodes - we'll handle this in playWebAudioSound
            return;
        }
        if (sound instanceof Audio) {
            sound.volume = soundVolume;
        }
    });
}

function setMusicVolume(volume) {
    musicVolume = Math.max(0, Math.min(1, volume));
    localStorage.setItem('musicVolume', musicVolume);
    
    // Update music manager volume
    if (musicManager) {
        musicManager.volume = musicVolume;
        if (musicManager.current && musicManager.audios[musicManager.current]) {
            const currentAudio = musicManager.audios[musicManager.current];
            currentAudio.volume = musicManager.muted ? 0 : musicVolume;
        }
    }
}

// Load Web Audio buffers
function loadSoundBuffer(url, key) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(data => audioContext.decodeAudioData(data))
        .then(buffer => {
            sounds[key].buffer = buffer;
                    })
        .catch(e => console.error(`Failed to load Web Audio buffer for ${key}: ${url}`, e));
}
loadSoundBuffer('hit.wav', 'hit');
loadSoundBuffer('pickup.wav', 'pickup');
loadSoundBuffer('heads.wav', 'heads');
loadSoundBuffer('tails.wav', 'tails');
loadSoundBuffer('lava.wav', 'lava');
loadSoundBuffer('quicksand.wav', 'quicksand');
loadSoundBuffer('pond.wav', 'pond');
loadSoundBuffer('rune.wav', 'rune');
loadSoundBuffer('rune_drop.wav', 'rune_drop');
loadSoundBuffer('hole.wav', 'hole');
loadSoundBuffer('town_portal.wav', 'town_portal');
loadSoundBuffer('buzz.wav', 'buzz');
loadSoundBuffer('unique_monster.wav', 'unique_monster');

class MusicManager {
  constructor() {
    this.audios = {
      dungeon: sounds.dungeon,
      desert: sounds.desert,
      hell: sounds.hell,
      paradise: sounds.paradise,
      ruins: sounds.ruins,
      hideout: sounds.hideout
    };
    this.current = null;
    this.muted = false;
    this.volume = 1.0;
    Object.values(this.audios).forEach(audio => {
      audio.loop = true;
      audio.onerror = () => console.error(`Failed to load music: ${audio.src}`);
      audio.volume = musicVolume; // Set initial volume from global
    });
  }
  play(theme) {
    if (!this.audios[theme]) return;
    const audio = this.audios[theme];
    if (this.current === theme) {
      if (!this.muted) {
        audio.play().catch(e => console.error('Music play failed:', e));
      }
      return;
    }
    if (this.current) {
      this.fadeOut(this.audios[this.current]);
    }
audio.volume = this.muted ? 0 : musicVolume; // Set initial volume based on muted state
audio.muted = this.muted;
audio.play().catch(e => console.error('Music play failed:', e));
if (!this.muted) {
  this.fadeIn(audio); // Ensure fadeIn is called only if not muted
}
    this.current = theme;
  }
  fadeOut(audio) {
    let vol = audio.volume;
    const interval = setInterval(() => {
      vol = Math.max(0, vol - 0.1);
      audio.volume = vol;
      if (vol <= 0) {
        clearInterval(interval);
        audio.pause();
        audio.currentTime = 0;
      }
    }, 100);
  }
  fadeIn(audio) {
    let vol = 0;
    const interval = setInterval(() => {
      vol = Math.min(this.volume, vol + 0.1);
      audio.volume = vol;
      if (vol >= this.volume) {
        clearInterval(interval);
      }
    }, 100);
  }
  mute(muted) {
    this.muted = muted;
    if (this.current) {
      this.audios[this.current].muted = muted;
      this.audios[this.current].volume = muted ? 0 : musicVolume;
    }
  }
}
const musicManager = new MusicManager();

Object.values(sounds).forEach(s => {
    if (s instanceof Audio) {
        s.volume = 1.0;
        s.onerror = () => console.error(`Failed to load sound: ${s.src}`);
    }
});

function isIOSorSafari() {
    const ua = navigator.userAgent;
    return /iPad|iPhone|iPod/.test(ua) || /Safari/.test(ua);
}

function preloadSounds() {
    // Save current volume before setting to 0
    const savedSoundVolume = soundVolume;
    
    if (isIOSorSafari()) {
        // iOS/Safari: Preload by setting src without playing
        Object.entries(sounds).forEach(([key, sound]) => {
            if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop' || key === 'hole' || key === 'town_portal' || key === 'buzz' || key === 'unique_monster') return; // Skip music and Web Audio sounds
            if (Array.isArray(sound)) {
                sound.forEach((instance, idx) => {
                    // Create a new Audio object to trigger caching
                    const tempAudio = new Audio(instance.src);
                    tempAudio.volume = 0; // Set volume to 0 during preload
                });
            } else if (sound instanceof Audio && sound.src) {
                // Create a new Audio object to trigger caching
                const tempAudio = new Audio(sound.src);
                tempAudio.volume = 0;
            }
        });
} else {
    // Non-iOS: Existing preload logic
    Object.entries(sounds).forEach(([key, sound]) => {
        if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop' || key === 'hole' || key === 'town_portal' || key === 'buzz' || key === 'unique_monster') return; // Skip music and Web Audio sounds
        if (Array.isArray(sound)) {
            sound.forEach((instance, idx) => {
                if (instance instanceof Audio && instance.src) {
                    instance.volume = 0; // Set volume to 0 during preload
                    instance.play().then(() => {
                        instance.pause();
                        instance.currentTime = 0;
                        instance.volume = 0; // Keep at 0 during preload
                    }).catch(e => console.error(`Preload sound error for ${instance.src}:`, e));
                }
            });
        } else if (sound instanceof Audio && sound.src) {
            sound.volume = 0; // Set volume to 0 during preload
            sound.play().then(() => {
                sound.pause();
                sound.currentTime = 0;
                sound.volume = 0; // Keep at 0 during preload
            }).catch(e => console.error(`Preload sound error for ${sound.src}:`, e));
        }
    });
}
    
    // Restore original volume after preloading is complete
    setTimeout(() => {
        setSoundVolume(savedSoundVolume);
    }, 100);
}

function playWebAudioSound(soundObj) {
    if (!soundObj.buffer) {
        console.warn(`Buffer not loaded for ${soundObj.url}`);
        return;
    }
    if (soundObj.isPlaying) {
                return;
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
                    }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    soundObj.isPlaying = true; // Set flag
    const source = audioContext.createBufferSource();
    source.buffer = soundObj.buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = soundVolume; // Use global sound volume setting
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
        source.onended = () => {
        soundObj.isPlaying = false; // Clear flag
            };
    // Fallback timeout to clear flag if onended fails
    setTimeout(() => {
        if (soundObj.isPlaying) {
            soundObj.isPlaying = false;
                    }
    }, soundObj.duration);
}

const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
let currentSplashImage = 'splash.png';
const splashImg = new Image();
splashImg.src = currentSplashImage;
splashImg.onload = () => {
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
};

function fadeSplash() {
    setTimeout(() => {
        const imgData = splashCanvas.getImageData(0, 0, 320, 320);
        const pixels = imgData.data;
        const totalPixels = 320 * 320;
        const fadePerFrame = totalPixels / 20;
        let fadedPixels = 0;
        const fadeInterval = setInterval(() => {
            for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                const px = Math.floor(Math.random() * totalPixels) * 4;
                pixels[px + 3] = 0;
                fadedPixels++;
            }
            splashCanvas.putImageData(imgData, 0, 0);
            if (fadedPixels >= totalPixels) {
                clearInterval(fadeInterval);
                splashActive = false;
                document.getElementById('splash-screen').style.display = 'none'; // Hide instead of remove
                            }
        }, 75);
    }, 25);
}

function resetSplashScreen() {
    splashActive = true;
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block'; // Show splash screen
    // Redraw splash image
    splashCanvas.clearRect(0, 0, 320, 320);
    splashImg.src = currentSplashImage;
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
}

document.getElementById('start-button').addEventListener('click', () => {
    currentTheme = 'dungeon'; // Force default theme on game start
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }

    // Assign random elemental immunity
    const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
    p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];

wakeLock = null;

// Function to request wake lock
async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake lock activated');
      wakeLock.addEventListener('release', () => {
        console.log('Wake lock released');
      });
    } else {
      console.warn('Wake Lock API not supported in this browser. Adjust OS power settings manually.');
      alert('Wake Lock not supported. To prevent sleep, disable screen timeout in your OS settings or play a silent audio loop.');
    }
  } catch (err) {
    console.error('Wake lock error:', err);
  }
}

// Re-request wake lock if visibility changes (e.g., tab switch)
document.addEventListener('visibilitychange', async () => {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    await requestWakeLock();
  }
});

if (splashActive) {
        preloadSounds();
        // Ensure AudioContext is resumed for iOS
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                // Reset music manager state and play music after AudioContext is resumed
                musicManager.current = null;
                if (!musicMuted) {
                    musicManager.play(currentTheme); // Play music after AudioContext is resumed
                }
            }).catch(e => console.error('Failed to resume AudioContext:', e));
        } else {
            // Reset music manager state on restart
            musicManager.current = null;
            if (!musicMuted) {
                musicManager.play(currentTheme); // Play music if AudioContext is already running
            }
        }
            // Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

        musicManager.mute(musicMuted); // Ensure proper mute state
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }
    
// Set music volume to 0 when restarting
setSoundVolume(0);
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);
fadeSplash();
setTimeout(() => {
    if (!gameOver && !splashActive) {
        requestWakeLock();  // ← Add this to request wake lock on game start
        fetchTxs();
        lastUpdate = Date.now();
        console.log('Initial fetchTxs triggered after splash, wave=', wave);
        
        // First-time leaderboard cache (only once per browser session)
        if (!localStorage.getItem('leaderboardCached')) {
            fetchLeaderboard().then(() => {
                localStorage.setItem('leaderboardCached', 'true');
                cachedLeaderboard = JSON.parse(localStorage.getItem('leaderboardData') || '[]');
                console.log('Leaderboard cached on first start');
            }).catch(err => console.error('Cache fetch failed:', err));
        } else {
            cachedLeaderboard = JSON.parse(localStorage.getItem('leaderboardData') || '[]');
        }
    }
}, 2000);
    }
    
    // Set music volume to max when starting
if (musicManager.current) {
    const currentAudio = musicManager.audios[musicManager.current];
    if (currentAudio) {
        currentAudio.currentTime = 0;
        currentAudio.volume = 1;
    }
}
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);
});

function toggleMute() {
    const muteButton = document.getElementById('mute');
    const currentState = muteButton.textContent;
    
    // Cycle through the three states: ♪ → X → ☀ → ♪
    if (currentState === '♪') {
        // First state: Music on → Mute music
        musicMuted = true;
        musicManager.mute(true);
        muteButton.textContent = 'X';
        localStorage.setItem('musicMuted', 'true');
} else if (currentState === 'X') {
        // Second state: Music muted → Activate screensaver
        musicMuted = true;
        musicManager.mute(true);
        muteButton.textContent = '☀';
        if (!splashActive) {
            musicManager.current = null; // Reset MusicManager state
            musicManager.play(currentTheme);
        }
        // Activate screensaver when moving to ☀ state
        activateScreensaver();
    } else if (currentState === '☀') {
        // Third state: Screensaver active → Return to music
        // Reset screensaver and return to normal state
        exitScreensaver();
        musicMuted = false;
        musicManager.mute(false);
        muteButton.textContent = '♪';
        if (!splashActive) {
            musicManager.current = null; // Reset MusicManager state
            musicManager.play(currentTheme);
        }
        localStorage.setItem('musicMuted', 'false');
    }
}

function logWhaleHashId(txid) {
    const newEntry = `Floor ${floor} - <a href="https://mempool.space/tx/${txid}" target="_blank">${txid}</a>`;
    whaleHashIds.push(newEntry);
    if (whaleHashIds.length > 50) {
        whaleHashIds = ['Whale Transactions:', ...whaleHashIds.slice(-49)];
        const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
        while (whaleHashIdsDiv.children.length > 49) {
            whaleHashIdsDiv.removeChild(whaleHashIdsDiv.firstChild);
        }
    }
    const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
    const newDiv = document.createElement('div');
    newDiv.innerHTML = newEntry;
    whaleHashIdsDiv.appendChild(newDiv);
    const whaleLog = document.getElementById('whale-log');
    whaleLog.scrollTop = whaleLog.scrollHeight;
    console.log('Whale Hash ID:', txid);
}

function logBattleEvent(event) {
    if (gameOver) return;
    const battleEvents = document.getElementById('battle-events');
    if (event.startsWith('Kills:') || event.match(/^(Shrimp|Crab|Squid|Dolphin|Shark|Whale):/) || event === '') {
        if (event === 'Kills:') {
            killsLog = [event];
        } else {
            killsLog.push(event);
            if (killsLog.length > 10) {
                killsLog = killsLog.slice(-10); // Cap at 10 entries
            }
        }
        if (exit && enemies.length === 0) {
            // Show exactly 8 kills lines
            battleEvents.value = killsLog.join('\n');
            battleEvents.scrollTop = battleEvents.scrollHeight;
            // Keep visible without fade-out
            battleEvents.style.transform = 'translateX(0)';
            battleEvents.style.opacity = '1';
            if (battleLogTimeout) {
                clearTimeout(battleLogTimeout);
                battleLogTimeout = null;
            }
                        return;
        }
    }
    // Keep last 3 messages for regular events (reverse waterfall)
    battleLog.push(event);
    battleLog = battleLog.slice(-3); // Keep last 3 events
    battleEvents.value = battleLog.join('\n');
    battleEvents.scrollTop = battleEvents.scrollHeight;
    // Clear any existing timeout
    if (battleLogTimeout) {
        clearTimeout(battleLogTimeout);
    }
    // Slide in and fade in
    battleEvents.style.transform = 'translateX(0)';
    battleEvents.style.opacity = '1';
    // Schedule slide out after 3 seconds for non-kills events
    battleLogTimeout = setTimeout(() => {
        battleEvents.style.transform = 'translateX(-100%)';
        battleEvents.style.opacity = '0';
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(battleEvents);
            if (computedStyle.opacity === '0') {
                battleLog = [];
                battleEvents.value = '';
                                // Restore kills display if still valid
                if (exit && enemies.length === 0) {
                    killsLog = [
                        'Kills:',
                        `Shrimp: ${kills.Shrimp}`,
                        `Crab: ${kills.Crab}`,
                        `Squid: ${kills.Squid}`,
                        `Dolphin: ${kills.Dolphin}`,
                        `Shark: ${kills.Shark}`,
                        `Whale: ${kills.Whale}`,
                        '' // Empty line for 8 lines total
                    ];
                    battleEvents.value = killsLog.join('\n');
                    battleEvents.style.transform = 'translateX(0)';
                    battleEvents.style.opacity = '1';
                    battleEvents.scrollTop = battleEvents.scrollHeight;
                                    }
            }
        }, 300); // Wait for transition (0.3s)
        battleLogTimeout = null;
    }, 3000);
}

function updateSatsDisplay() {
    const raw = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
    const mult = getScoreWithMultiplier(raw , floor);

    // Main value (sats or BTC)
    const satsElem   = document.getElementById('sats');
    satsElem.textContent =
        raw < 1e8 ? `${raw} sats` : `${(raw / 1e8).toFixed(1)} BTC`;

    // The calculation – shown on its own line
    const calcElem = document.getElementById('sats-calc');
    calcElem.textContent = `${floor / 100}: ${mult < 1e8 ? `${mult} sats` : `${(mult / 1e8).toFixed(1)} BTC`}`;

    // Trigger kills display only when exit exists and no enemies remain
    if (exit && enemies.length === 0) {
        logBattleEvent(`Kills:`);
        for (const type of types) {
            if (kills[type.name] > 0) {
                logBattleEvent(`${type.name}: ${kills[type.name]}`);
            }
        }
    }
}

function spawnItemWithChance(item, chance, maxItems, proximityRange, avoidPlayer) {
    let positions = [];
    let attempts = 0;
    const maxAttempts = 100;

    while (positions.length < maxItems && attempts < maxAttempts) {
        if (Math.random() < chance) {
            let x = Math.floor(Math.random() * W);
            let y = Math.floor(Math.random() * H);
            let valid = map[y][x] === 0;

            if (avoidPlayer) {
                valid = valid && Math.abs(x - p.x) >= 3 && Math.abs(y - p.y) >= 3; // Ensure 5x5 clear area
            }

            if (valid) {
                let isNearOtherItem = false;
                for (let pos of positions) {
                    if (Math.abs(x - pos[0]) <= 2 && Math.abs(y - pos[1]) <= 2) {
                        isNearOtherItem = true;
                        break;
                    }
                }
                if (!isNearOtherItem) {
                    positions.push([x, y]);
                    if (item !== -1) {
                        map[y][x] = item;
                    }
                }
            }
        }
        attempts++;
    }

    return positions;
}

function playUniqueMonsterSound(uniqueName) {
    // Check if we have a unique monster sound file
    if (isIOSorSafari()) {
        // iOS/Safari version - use existing audio handling
        const audio = sounds.unique_monster;
        if (audio && audio.src) {
            audio.currentTime = 0;
            audio.play().catch(e => console.error('Unique monster sound error:', e));
        }
    } else {
        // Non-iOS version - use Web Audio
        playWebAudioSound(sounds.unique_monster);
    }
}

function initMap() {
    try {
        if (inHideout) {
            currentTheme = 'hideout';
            document.documentElement.style.setProperty('--text-color', '#ff8c00');
            document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                el.style.color = '#ff8c00';
            });
            enemies = [];
            enemiesSpawnedThisFloor = 0;
            whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
            initialSpawnDoneThisFloor = false;
            initialWaveSpawned = false;
            map = Array(H).fill().map(() => Array(W).fill(1));
            fogMap = Array(H).fill().map(() => Array(W).fill(0));
            rooms = [];
            satoshiDrops = [];
            runeDrops = runeDrops.filter(r => !r.specific);
            scrollDrops = [];
            portals = [];
            dangerousAreas = []; // Clear dangerous areas
            currentRuneTile = null;
            jewellerPos = null;
            blacksmithPos = null;
            waypointPos = null;
            exit = null; // Prevent stairs and related enemy spawning

            dpadButtons = document.querySelectorAll('#dpad button');
            actionsButtons = document.querySelectorAll('#actions button');

            rooms = [];
            const roomSize = 7;
            const gap = 2;

            const mainRoomX = Math.floor((W - roomSize) / 2);
            const mainRoomY = Math.floor((H - roomSize) / 2);
            rooms.push({ x: mainRoomX, y: mainRoomY, w: roomSize, h: roomSize });
            for (let y = mainRoomY; y < mainRoomY + roomSize; y++) {
                for (let x = mainRoomX; x < mainRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            const leftRoomX = mainRoomX - roomSize - gap;
            const leftRoomY = mainRoomY;
            rooms.push({ x: leftRoomX, y: leftRoomY, w: roomSize, h: roomSize });
            for (let y = leftRoomY; y < leftRoomY + roomSize; y++) {
                for (let x = leftRoomX; x < leftRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            const rightRoomX = mainRoomX + roomSize + gap;
            const rightRoomY = mainRoomY;
            rooms.push({ x: rightRoomX, y: rightRoomY, w: roomSize, h: roomSize });
            for (let y = rightRoomY; y < rightRoomY + roomSize; y++) {
                for (let x = rightRoomX; x < rightRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            for (let x = leftRoomX + roomSize; x < mainRoomX; x++) {
                map[mainRoomY + 3][x] = 0;
            }
            for (let x = mainRoomX + roomSize; x < rightRoomX; x++) {
                map[mainRoomY + 3][x] = 0;
            }

            jewellerPos = { x: mainRoomX + 3, y: mainRoomY + 3 };
            const diamondWallTiles = [
                {x: mainRoomX + 2, y: mainRoomY + 2}, {x: mainRoomX + 3, y: mainRoomY + 2}, {x: mainRoomX + 4, y: mainRoomY + 2},
                {x: mainRoomX + 2, y: mainRoomY + 3}, {x: mainRoomX + 4, y: mainRoomY + 3},
                {x: mainRoomX + 2, y: mainRoomY + 4}, {x: mainRoomX + 4, y: mainRoomY + 4}
            ];
            diamondWallTiles.forEach(pos => {
                if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H) {
                    map[pos.y][pos.x] = 13;
                }
            });
            map[jewellerPos.y][jewellerPos.x] = 14;

            // Place blacksmith at a fixed position in the left room
            const blacksmithX = leftRoomX + 4;
            const blacksmithY = leftRoomY + 3;
            if (map[blacksmithY][blacksmithX] === 0) {
                map[blacksmithY][blacksmithX] = 15; // Blacksmith
                blacksmithPos = { x: blacksmithX, y: blacksmithY };
            } else {
                console.warn('Failed to place blacksmith: tile occupied at', blacksmithX, blacksmithY);
            }

            // Place waypoint at a fixed position in the right room
            const waypointX = rightRoomX + 3;
            const waypointY = rightRoomY + 3;
            if (map[waypointY][waypointX] === 0) {
                map[waypointY][waypointX] = 16; // Waypoint
                waypointPos = { x: waypointX, y: waypointY };
            } else {
                console.warn('Failed to place waypoint: tile occupied at', waypointX, waypointY);
            }
            
            // Place rune whisperer at a fixed position in the right room
            const runeWhispererX = rightRoomX + 1;
            const runeWhispererY = rightRoomY + 5;
            if (map[runeWhispererY][runeWhispererX] === 0) {
                map[runeWhispererY][runeWhispererX] = 17; // Rune Whisperer
                runeWhispererPos = { x: runeWhispererX, y: runeWhispererY };
            } else {
                console.warn('Failed to place rune whisperer: tile occupied at', runeWhispererX, runeWhispererY);
            }

            // Place hooded heirloom (4 tiles north of rune whisperer)
            const heirloomX = runeWhispererX;
            const heirloomY = runeWhispererY - 4;
            if (map[heirloomY][heirloomX] === 0) {
                map[heirloomY][heirloomX] = 18; // Hooded Heirloom
            } else {
                console.warn('Failed to place hooded heirloom: tile occupied at', heirloomX, heirloomY);
            }

p.x = mainRoomX + 3;
p.y = mainRoomY + 6;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
updateFogMap(p.x, p.y);
            needsRedraw = true;
            logBattleEvent(`Hideout - Entered the secret hideout!`);
            document.getElementById('floor-indicator').textContent = `Hideout`;
            return;
        }

        // Change theme every fourth floor
        if (floor % 3 === 0 && floor > 1) {
            currentTheme = selectNewTheme(currentTheme);
        }
        // Update text color based on theme
        let textColor;
        switch (currentTheme) {
            case 'hell':
                textColor = '#00ff00'; // Matrix green for hell
                break;
            case 'desert':
            case 'paradise':
            case 'ruins':
                textColor = '#ff8c00'; // Orange for desert, paradise, and ruins
                break;
            default:
                textColor = '#ff8c00'; // Orange for dungeon
        }
        document.documentElement.style.setProperty('--text-color', textColor);
        // Force re-render of text color
        document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
            el.style.color = textColor;
        });
        // Reset enemy spawning variables
        enemies = [];
        enemiesSpawnedThisFloor = 0;
        whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
        initialSpawnDoneThisFloor = false;
        initialWaveSpawned = false;
        map = Array(H).fill().map(() => Array(W).fill(1));
        fogMap = Array(H).fill().map(() => Array(W).fill(0));
        rooms = [];
        satoshiDrops = [];
        runeDrops = []; // Clear rune drops on map, but keep p.runes, p.runewords, p.immortal
        scrollDrops = []; // Clear scroll drops
        portals = []; // Clear portals
        // Reset rune tracking
        currentRuneTile = null;

        function checkCurrentRuneTile() {
            if (map[p.y][p.x] === 9) {
                const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
                if (rune) {
                    const floorIndicator = document.getElementById('floor-indicator');
                    floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
                    currentRuneTile = { x: p.x, y: p.y };
                    return true;
                }
            }
            return false;
        }

        // Generate rooms
        let maxAttempts = 100;
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        maxAttempts = 50;
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap();
        }

        // Connect rooms with corridors
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r1.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }

        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;

// Place player
p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
   for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) {
       p.x = x; p.y = y;
       p.currentX = p.x * S; p.currentY = p.y * S;
       p.targetTileX = p.x; p.targetTileY = p.y;
       break;
    }
}
// Mark initial player area as explored
updateFogMap(p.x, p.y);

        // Place special tiles based on theme (pond, quicksand, lava)
        let specialPositions = [];
        if (currentTheme !== 'dungeon') {
            specialPositions = spawnItemWithChance(6, 0.5, 2, 5, true); // 50% chance, max 2 tiles
        }

        // Place Gnome with X% chance, only if no conflict with special tiles
        let gnomePositions = [];
        if (
            currentTheme === 'dungeon' || 
            currentTheme === 'desert' || 
            currentTheme === 'hell' || 
            currentTheme === 'paradise' || 
            specialPositions.length < 2
        ) {
            if (Math.random() < 0.1) { // 10% chance to spawn a gnome
                gnomePositions = spawnItemWithChance(7, 1.0, 1, 5, true);
                if (gnomePositions.length > 0) {
                } else {
                }
            } else {
            }
        } else {
        }

        /* -------------------------------------------------
           Place potions – 2 total, never in the same room
           ------------------------------------------------- */

        let potionPositions = [];                         // all potion coordinates
        let selectedRooms = rooms
            .sort(() => 0.5 - Math.random())              // random order
            .slice(0, Math.min(3, rooms.length));        // look at up to 3 rooms

        let proximityRange = 5;
        let potionsNeeded = 2;                             // how many potions are still missing

        for (let r of selectedRooms) {
            if (potionsNeeded <= 0) break;                // we already have 2

            let x, y, attempts = 100;

            // try to place **one** potion in this room
            while (attempts > 0 && potionsNeeded > 0) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);

                // empty tile, not the player, not too close to another potion
                if (
                    map[y][x] === 0 &&
                    (x !== p.x || y !== p.y) &&
                    !potionPositions.some(
                        p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange
                    )
                ) {
                    map[y][x] = 2;                        // place the potion
                    potionPositions.push({ x, y });
                    potionsNeeded--;                      // one potion placed
                    break;                                // stop – only one per room
                }

                attempts--;
            }

            // If we ran out of attempts in this room, warn and try again with a tighter range
            if (attempts === 0 && potionsNeeded > 0) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;                           // restart attempts for the same room
            }
        }

        // Place pickaxe (chance to drop a pickaxe)
        let pickaxePositions = [];
        if (Math.random() < 0.25) { // 25% chance to spawn a pickaxe
            pickaxePositions = spawnItemWithChance(4, 1.0, 1, 5, true);
            if (pickaxePositions.length > 0) {
            } else {
            }
        }    

// Place soul stash in the same room as player spawn (only on normal floors)
if (!inHideout) {
    const room = rooms[0]; // Player spawns in first room
    let stashX, stashY;
    let attempts = 100;
    
    // First priority: Spawn near player (2 tiles away)
    let foundNearPlayer = false;
    if (p.x >= 0 && p.y >= 0) {
        const possiblePositions = [];
        for (let dx = -2; dx <= 2; dx++) {
            for (let dy = -2; dy <= 2; dy++) {
                if (Math.abs(dx) + Math.abs(dy) === 2) { // Exactly 2 tiles away
                    const x = p.x + dx;
                    const y = p.y + dy;
                    if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] === 0) {
                        possiblePositions.push({x, y});
                    }
                }
            }
        }
        
        if (possiblePositions.length > 0) {
            const randomPos = possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
            stashX = randomPos.x;
            stashY = randomPos.y;
            foundNearPlayer = true;
        }
    }
    
    // If no near player position found, use original logic
    if (!foundNearPlayer) {
        do {
            stashX = room.x + Math.floor(Math.random() * room.w);
            stashY = room.y + Math.floor(Math.random() * room.h);
            attempts--;
        } while ((map[stashY][stashX] !== 0 || 
                 (stashX === p.x && stashY === p.y)) && attempts > 0);
    }
    
    if (attempts > 0 || foundNearPlayer) {
        map[stashY][stashX] = 19; // Soul stash tile
        soulStashPos = {x: stashX, y: stashY};
    } else {
        // Fallback to player position if no room space found
        if (map[p.y][p.x] === 0) {
            map[p.y][p.x] = 19; // Soul stash tile
            soulStashPos = {x: p.x, y: p.y};
        }
    }
}

// After placing soul stash, spawn soul orb statues
if (!inHideout && floor > 1) { // Don't spawn on floor 1 to avoid conflicts
	// Add soul orb statue spawning logic here
	function spawnSoulOrbStatue() {
		if (inHideout) return; // Don't spawn in hideout
		
		// 5% chance to spawn a soul orb statue
		if (Math.random() < 0.05) {
			let attempts = 0;
			const maxAttempts = 50;
			
			do {
				let x = Math.floor(Math.random() * W);
				let y = Math.floor(Math.random() * H);
				
				// Ensure it's a floor tile, not a wall, not occupied by player or items
				if (map[y][x] === 0 && 
					!(x === p.x && y === p.y) &&
					!enemies.some(e => e.x === x && e.y === y) &&
					!satoshiDrops.some(d => d.x === x && d.y === y) &&
					!runeDrops.some(r => r.x === x && r.y === y) &&
					!scrollDrops.some(s => s.x === x && s.y === y) &&
					!portals.some(p => p.x === x && p.y === y) &&
					Math.abs(x - p.x) > 2 && Math.abs(y - p.y) > 2) {
					
					map[y][x] = 21; // Soul orb statue tile
					return {x, y};
				}
				attempts++;
			} while (attempts < maxAttempts);
		}
	}
	spawnSoulOrbStatue();
}

// In the initMap function where items are placed, add shrine placement:
// Place shrine (20% chance, except in hideout)
if (!inHideout && Math.random() < 0.20) {
    let attempts = 0;
    const maxAttempts = 50;
    
    do {
        let x = Math.floor(Math.random() * W);
        let y = Math.floor(Math.random() * H);
        
        // Ensure it's a floor tile, not a wall, not occupied by player or items
        if (map[y][x] === 0 && 
            !(x === p.x && y === p.y) &&
            !enemies.some(e => e.x === x && e.y === y) &&
            !satoshiDrops.some(d => d.x === x && d.y === y) &&
            !runeDrops.some(r => r.x === x && r.y === y) &&
            !scrollDrops.some(s => s.x === x && s.y === y) &&
            !portals.some(p => p.x === x && p.y === p.y) &&
            Math.abs(x - p.x) > 2 && Math.abs(y - p.y) > 2) {
            
            map[y][x] = 22; // Shrine tile
            shrinePositions.push({x, y});
            break;
        }
        attempts++;
    } while (attempts < maxAttempts);
}

// Initialize dangerous areas array for spells
dangerousAreas = [];

        exit = null;
        initialWaveSpawned = false;
        needsRedraw = true;

        // Reset shrine usage tracking for new floor
        p.shrineUsedThisFloor = false;

        // Check runewords at floor start
        checkRunewordsAtFloorStart();
        // Update rune display
        //checkRunewords();
        if (!musicMuted) {
            musicManager.play(currentTheme);
        }
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

function createSecretRoom(wx, wy, px, py, dir) {
    // Create a 3x3 room based on player's facing direction
    const roomSize = 3;
    let rx, ry;
    // Position room based on direction
    switch (dir) {
        case 'up':
            rx = wx;
            ry = wy - roomSize;
            break;
        case 'down':
            rx = wx;
            ry = wy + 1;
            break;
        case 'left':
            rx = wx - roomSize;
            ry = wy;
            break;
        case 'right':
            rx = wx + 1;
            ry = wy;
            break;
        default:
            console.error(`Invalid direction: ${dir}`);
            p.pickaxes++;
            logBattleEvent(`Floor ${floor} - Secret Room Failed: Invalid direction`);
            return;
    }
    // Check if room fits within map bounds
    if (rx < 1 || rx + roomSize > W - 1 || ry < 1 || ry + roomSize > H - 1) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): out of bounds`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Check if the 3x3 area is all walls
    let allWalls = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (map[y][x] !== 1) {
                allWalls = false;
                break;
            }
        }
        if (!allWalls) break;
    }
    if (!allWalls) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): not a 3x3 wall block`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No 3x3 wall block for secret room! Pickaxe refunded`);
        return;
    }
    // Validate room placement - allow overlap with existing rooms
    let valid = true;
    let overlappingRooms = 0;

    // Count how many existing rooms this new room overlaps with
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            // Check if any existing room overlaps with this tile
            rooms.forEach(r => {
                if (x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h) {
                    overlappingRooms++;
                }
            });
            
            // Check for conflicts (items, player, enemies)
            if (
                [2, 3, 4, 5].includes(map[y][x]) || // Items
                (x === px && y === py) || // Player
                enemies.some(e => e.x === x && e.y === y) // Enemies
            ) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
    }

    // If we have conflicts, but it's a valid 3x3 wall area, proceed anyway
    // (This allows for rooms that slightly overlap corridors)
    if (!valid && overlappingRooms > 0) {
        // Check specifically if the room can be placed in this location
        let canPlace = true;
        for (let y = ry; y < ry + roomSize; y++) {
            for (let x = rx; x < rx + roomSize; x++) {
                // Allow overlap with items, player, or enemies if they're not in the main area
                if (map[y][x] !== 0 && map[y][x] !== 1) { // Not a floor or wall
                    canPlace = false;
                    break;
                }
            }
            if (!canPlace) break;
        }
        valid = canPlace;
    }

    if (!valid) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): invalid placement (items, player, or overlap)`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Carve out the room
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            map[y][x] = 0;
        }
    }
    // Clear the broken wall
    map[wy][wx] = 0;
// Punch a non-directional hole (clear one adjacent tile)
const adjacent = [
    { x: wx - 1, y: wy }, // Left
    { x: wx + 1, y: wy }, // Right
    { x: wx, y: wy - 1 }, // Up
    { x: wx, y: wy + 1 }  // Down
].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] !== 0);

if (adjacent.length > 0) {
    const hole = adjacent[Math.floor(Math.random() * adjacent.length)];
    map[hole.y][hole.x] = 0;
}

// Carve a corridor to a nearby floor tile
let floorTiles = [];
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        if (map[y][x] === 0 && !(x === px && y === py) && !(x === wx && y === wy)) {
            floorTiles.push({ x, y });
        }
    }
}

if (floorTiles.length > 0) {
    floorTiles.sort((a, b) => {
        const distA = Math.abs(a.x - wx) + Math.abs(a.y - wy);
        const distB = Math.abs(b.x - wx) + Math.abs(b.y - wy);
        return distA - distB;
    });
    const target = floorTiles[0];
    let x = wx, y = wy;
    while (x !== target.x || y !== target.y) {
        if (Math.abs(target.x - x) > Math.abs(target.y - y)) {
            x += target.x > x ? 1 : -1;
        } else {
            y += target.y > y ? 1 : -1;
        }
        if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 0) {
            map[y][x] = 0;
        }
    }
} else {
    console.warn(`No floor tile found to connect secret room at (${wx}, ${wy})`);
}
    // Place armor in the center
    const armorX = rx + 1;
    const armorY = ry + 1;
    map[armorY][armorX] = 5;

    // place a diamond with 50 % chance
    const dirs = [
        {dx: -1, dy: 0},
        {dx:  1, dy: 0},
        {dx:  0, dy: -1},
        {dx:  0, dy:  1}
    ];
    dirs.sort(() => Math.random() - 0.5);
    for (const d of dirs) {
        const nx = armorX + d.dx;
        const ny = armorY + d.dy;
        if (
            nx >= 0 && nx < W &&
            ny >= 0 && ny < H &&
            map[ny][nx] === 0          // only on an empty floor tile
        ) {
            if (Math.random() < 0.25) {   // ← 25 % chance
                map[ny][nx] = 10;          // diamond tile
            }
            break;
        }
    }

// Show "Found Secret!" in Whale alert area and log success
const floorIndicator = document.getElementById('floor-indicator');
floorIndicator.textContent = `Found Secret!`;
logBattleEvent(`Floor ${floor} - Secret Room Created!`);
setTimeout(() => {
    floorIndicator.textContent = `Floor ${floor}`;
}, 5000);
updateFogMap(px, py);
needsRedraw = true;
}

// Modified updatePlayerState to ensure immortality works correctly
function updatePlayerState() {
    if (p.hp <= 24 && p.hasDiamondArmor) {
        p.hasDiamondArmor = false;
        p.hasArmor = false;
        p.armorImmunity = null; // Reset armor immunity
        logBattleEvent(`Floor ${floor} - Diamond Armor lost! Reverted to normal clothing.`);
        document.getElementById('armorStatus').textContent = 'Cloth';
    } else if (p.hp <= 24 && p.hasArmor) {
        p.hasArmor = false;
        p.armorImmunity = null; // Reset armor immunity
        logBattleEvent(`Floor ${floor} - Armor boost lost!`);
        document.getElementById('armorStatus').textContent = 'Cloth';
    } else if (p.hasDiamondArmor) {
        document.getElementById('armorStatus').textContent = 'Diamond';
    } else if (p.hasArmor) {
        document.getElementById('armorStatus').textContent = 'Leather';
    } else {
        document.getElementById('armorStatus').textContent = 'Cloth';
    }

    // HODL immortality protection
    if (p.immortal && p.hp <= 0) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
    }

// Check if player is on blacksmith tile and can get diamond armor or diamond hand
if (map[p.y][p.x] === 15 && p.perfectlyCutDiamonds > 0) {
    if (!p.hasDiamondArmor) {
        p.hasDiamondArmor = true;
        p.perfectlyCutDiamonds--;
        logBattleEvent(`Floor ${floor} - Diamond Armor acquired from Blacksmith!`);
        document.getElementById('armorStatus').textContent = 'Diamond';
    } else if (!p.hasDiamondHand) {
        p.hasDiamondHand = true;
        p.perfectlyCutDiamonds--;
        p.atk = 3; // Increase attack power for diamond hand
        logBattleEvent(`Floor ${floor} - Diamond Hand acquired from Blacksmith!`);
    }
}

// Check if player lost diamond armor and should lose diamond hand
if (!p.hasDiamondArmor && p.hasDiamondHand) {
    p.hasDiamondHand = false;
    logBattleEvent(`Floor ${floor} - Diamond Hand lost! Back to normal sword.`);
    p.atk = 2; // Reset attack power
}

    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('diamonds').textContent = diamonds;
    document.getElementById('perfectlyCutDiamonds').textContent = p.perfectlyCutDiamonds;
    
    // Add soul items to display
    if (p.inSoulTerminal) {
        // In terminal, update both regular and soul inventory
        document.getElementById('runes').textContent = p.runes.join(' ');
    }
    
    needsRedraw = true;
}

function updateFogMap(px, py) {
    const radius = 3; // Visibility radius
    
    // Quick optimization: Only process tiles within radius and visible from player
    const start_x = Math.max(0, px - radius);
    const end_x = Math.min(W, px + radius + 1);
    const start_y = Math.max(0, py - radius);
    const end_y = Math.min(H, py + radius + 1);
    
    // Track newly visible Shrimps
    const newlyVisibleShrimps = [];
    for (let y = start_y; y < end_y; y++) {
        for (let x = start_x; x < end_x; x++) {
            const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (dist <= radius) {
                // Simple line-of-sight check for performance
                const hasLOS = true; // Simplified for performance
                if (hasLOS && fogMap[y][x] !== 1) { // Tile was not previously explored
                    fogMap[y][x] = 1; // Mark as explored
                    // Check for Shrimp at this position
                    const shrimp = enemies.find(e => e.x === x && e.y === y && e.type.name === 'Shrimp' && currentTheme === 'hell');
                    if (shrimp) {
                        newlyVisibleShrimps.push(shrimp);
                    }
                }
            }
        }
    }
    // Log evolution for newly visible Shrimps
    if (newlyVisibleShrimps.length > 0) {
        logBattleEvent(`Floor ${floor} - Shrimp evolves to Hell Shrimp!`);
    }
}

let lastKeyMoveTime = 0; // Track last keyboard move time
let pendingKeyDir = null; // Track latest keyboard direction
let isKeyHeld = false; // Track if a key is held
let enemiesSpawnedThisFloor = 0;
let uniqueMonstersSpawnedThisFloor = 0; // Track unique monsters spawned this floor
let scrollDroppedThisFloor = false; // Track if a scroll has dropped on this floor
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 30000; // 30 seconds

function shouldSpawn() {
  // If we are in hideout, or we have just stepped into it, abort.
  return !inHideout;
}

async function fetchTxs() {
    if (gameOver || splashActive || floor === 0 || inHideout || screensaverActive) {
        console.log(`Skipping fetchTxs: gameOver=${gameOver}, splashActive=${splashActive}, floor=${floor}, inHideout=${inHideout}, screensaverActive=${screensaverActive}`);
        return;
    }
    
    // Prevent duplicate calls
    if (isFetchingTxs) {
        console.log('fetchTxs: Already running, skipping');
        return;
    }
    
    isFetchingTxs = true; // Set flag
    
    const now = Date.now();
    // Prevent duplicate calls within API_INTERVAL
    if (nextApiCallTime && now < nextApiCallTime) {
        console.log(`fetchTxs: Already scheduled, skipping`);
        isFetchingTxs = false;
        return;
    }
    
    // Prevent concurrent calls to the same function
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }
    
    try {
        console.log(`fetchTxs: floor=${floor}, wave=${wave}, enemiesSpawnedThisFloor=${enemiesSpawnedThisFloor}, initialSpawnDoneThisFloor=${initialSpawnDoneThisFloor}, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}, enemies=${enemies.length}`);
        await new Promise(resolve => setTimeout(resolve, 25));
        
        // Check if we're still in the right state before making API call
        if (gameOver || splashActive || floor === 0 || inHideout) {
            console.log(`fetchTxs: State changed during API call, aborting`);
            return;
        }
        
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }
        
        // *** NEW *** Abort early if we have stepped into hideout while the request was still processing.
        if (!shouldSpawn()) {
          console.log('Player entered hideout while fetchTxs was in progress. Aborting enemy spawn.');
          return;
        }
        
        let enemyCount = 0;
        const processedTxids = new Set();
        console.warn(`[WHALE ATTEMPT] Checking ${res.data.length} transactions for Whale spawns (> 100 BTC)`);
        
        for (const tx of res.data.slice(0, 10)) {
          // *** NEW *** Stop the loop if hideout has been entered during this loop.
          if (!shouldSpawn()) {
            console.log('Player entered hideout. Stopping spawn loop.');
            break;
          }
          
          if (processedTxids.has(tx.txid)) continue;
          processedTxids.add(tx.txid);
          
          let value = 0;
          let address = 'Invalid address';
          try {
              await new Promise(resolve => setTimeout(resolve, 25));
              const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
              if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                  value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                  address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
              } else {
                  continue;
              }
          } catch (e) {
              continue;
          }
          
          if (value <= 0) {
              continue;
          }
          
          const btc = value / 1e8;
          const type = types.find(t => btc > t.min && btc <= t.max);
          if (!type) {
              continue;
          }

          // Handle initial spawn (up to 10 enemies, including Whales)
          if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10 && enemies.length < 10) {
              if (type.name !== 'Whale' && exit) {
                  continue;
              }
              //console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`);
              console.log('Initial Spawn Tx: Checking 10 transactions for Enemies spawns'); // less bloat means win in the long run
              const r = rooms[Math.floor(Math.random() * rooms.length)];
              let x, y, attempts = 50;
              const auraRadius = 2; // 5x5 grid
              let validPosition = false;
              do {
                  x = r.x + Math.floor(Math.random() * r.w);
                  y = r.y + Math.floor(Math.random() * r.h);
                  validPosition = (
                      map[y][x] === 0 &&
                      !(x === p.x && y === p.y) &&
                      !enemies.some(e => e.x === x && e.y === y) &&
                      Math.abs(x - p.x) > auraRadius &&
                      Math.abs(y - p.y) > auraRadius
                  );
                  attempts--;
              } while (attempts > 0 && !validPosition);
              
const newEnemy = { 
                 x,
                 y,
                  currentX: x * S,
                  currentY: y * S,
                  moving: false,
                  stepsLeft: 0,
                  deltaX: 0,
                  deltaY: 0,
                  targetTileX: 0,
                  targetTileY: 0,
                 type,
                 hp: type.name === 'Shrimp' && currentTheme === 'hell' ? 3 : type.hp,
                 address,
                 sats: Math.round(btc * 1e8),
                 anim: {
                     frameIndex: Math.floor(Math.random() * type.anim.frames.length),
                     lastFrameTime: performance.now()
                 }
              };
    
// I am starting to think 10% chance to spawn an unique monster actually means per regular enemy spawned (10%,10%,10%,10%,10%,10%,10%,10%,10%,10% instead of just 10%)
if (floor > 1 && Math.random() < 0.10) {
    const randomUniqueName = uniqueMonsterNames[type.name][Math.floor(Math.random() * uniqueMonsterNames[type.name].length)];
    // Check if we've already spawned a unique monster of this type on this floor
    const hasUniqueSpawned = enemies.some(e => e.uniqueName && 
        e.uniqueName.includes(type.name) && 
        !e.uniqueName.includes('Shrimp') || // Allow multiple Shrimp types
        (type.name === 'Shrimp' && e.type.name === 'Shrimp'));
    
    if (!hasUniqueSpawned && uniqueMonstersSpawnedThisFloor < 1) {
        newEnemy.uniqueName = randomUniqueName;
        // Make unique monster stronger
        newEnemy.atk = type.atk * 2;
        newEnemy.hp = type.hp * 2;
        
        // Assign a spell to this unique monster
        const spell = assignUniqueMonsterSpell(newEnemy);
        
        // Play unique monster sound on first spawn of this type
        playUniqueMonsterSound(randomUniqueName);        
        
        logBattleEvent(`Floor ${floor} - Unique ${type.name} Spawn: ${btc.toFixed(2)} BTC`);
        uniqueMonstersSpawnedThisFloor++;
    } else {
        const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
        logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
    }
} else {
    const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
    logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
}
          
              if (!validPosition) {
                  // Fallback: try any floor tile in any room
                  for (let r of rooms) {
                      for (let y = r.y; y < r.y + r.h; y++) {
                          for (let x = r.x; x < r.x + r.w; x++) {
                              if (
                                  map[y][x] === 0 &&
                                  !(x === p.x && y === p.y) &&
                                  Math.abs(x - p.x) > auraRadius &&
                                  Math.abs(y - p.y) > auraRadius &&
                                  !enemies.some(e => e.x === x && e.y === y)
                              ) {
                                  newEnemy.x = x;
                                  newEnemy.y = y;
                                  newEnemy.currentX = newEnemy.x * S;
                                  newEnemy.currentY = newEnemy.y * S;
                                  newEnemy.targetTileX = newEnemy.x;
                                  newEnemy.targetTileY = newEnemy.y;
                                  
                                  validPosition = true;
                                  break;
                              }
                          }
                          if (validPosition) break;
                      }
                      if (validPosition) break;
                  }
              }
              
              if (!validPosition) {
                  console.log(`No valid spawn position found for tx ${tx.txid}, skipping`);
                  continue;
              }
              
              // *** NEW *** Check again before pushing the new enemy.
              if (!shouldSpawn()) {
                console.log('Player entered hideout. Skipping enemy spawn.');
                continue;
              }
              
              enemies.push(newEnemy);
              const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
              logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
              enemiesSpawnedThisFloor++;
              enemyCount++;
              
              if (type.name === 'Whale') {
                  console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                  logWhaleHashId(tx.txid);
                  document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                  setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
              }
              
              if (enemiesSpawnedThisFloor >= 10) {
                  initialSpawnDoneThisFloor = true;
              }
          } else if (type.name === 'Whale') {
              console.log(`[WHALE SPAWN ATTEMPT] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}`);
              const r = rooms[Math.floor(Math.random() * rooms.length)];
              let x, y, attempts = 50;
              const auraRadius = 2; // 5x5 grid
              let validPosition = false;
              do {
                  x = r.x + Math.floor(Math.random() * r.w);
                  y = r.y + Math.floor(Math.random() * r.h);
                  validPosition = (
                      map[y][x] === 0 &&
                      !(x === p.x && y === p.y) &&
                      !enemies.some(e => e.x === x && e.y === y) &&
                      Math.abs(x - p.x) > auraRadius &&
                      Math.abs(y - p.y) > auraRadius
                  );
                  attempts--;
              } while (attempts > 0 && !validPosition);
              
              if (!validPosition) {
                  // Fallback: try any floor tile in any room
                  for (let r of rooms) {
                      for (let y = r.y; y < r.y + r.h; y++) {
                          for (let x = r.x; x < r.x + r.w; x++) {
                              if (
                                  map[y][x] === 0 &&
                                  !(x === p.x && y === p.y) &&
                                  Math.abs(x - p.x) > auraRadius &&
                                  Math.abs(y - p.y) > auraRadius &&
                                  !enemies.some(e => e.x === x && e.y === y)
                              ) {
                                  x = x;
                                  y = y;
                                  validPosition = true;
                                  break;
                              }
                          }
                          if (validPosition) break;
                      }
                      if (validPosition) break;
                  }
              }
              
              if (!validPosition) {
                  console.log(`No valid spawn position found for Whale tx ${tx.txid}, skipping`);
                  continue;
              }
              
              if (type.name === 'Whale' && whalesSpawnedThisFloor >= 10) {
                  console.log(`Whale spawn skipped: reached cap of 10 Whales on floor ${floor}`);
                  continue;
              }
              
              const newEnemy = { x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8),
                   anim: {
                       frameIndex: Math.floor(Math.random() * type.anim.frames.length),
                       lastFrameTime: performance.now()
                   }
                 };
              enemies.push(newEnemy);
              
              if (type.name === 'Whale') {
                  whalesSpawnedThisFloor++; // Increment Whale counter
              }
              
              const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
              logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
              console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
              logWhaleHashId(tx.txid);
              document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
              setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
              enemyCount++;
          }
        }
        
        // Apply RIP blast to all on-screen enemies if active
        if (p.ripBlast && enemies.length > 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast annihilates all enemies!`);
            playWebAudioSound(sounds.hit);
            ripBlastActive = true; // Set flag for firestorm effect
            ripBlastStartTime = Date.now();
            enemies.forEach(enemy => {
                enemy.hp = 0; // Instant kill
                handleUniqueMonsterReward(enemy);
                kills[enemy.type.name]++;
                logBattleEvent(`Floor ${floor} - ${enemy.type.name} destroyed!`);
                let dropPlaced = false;
                
                if (map[enemy.y][enemy.x] === 0) {
                    map[enemy.y][enemy.x] = 3;
                    satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: enemy.x, y: enemy.y - 1},
                        {x: enemy.x, y: enemy.y + 1},
                        {x: enemy.x - 1, y: enemy.y},
                        {x: enemy.x + 1, y: enemy.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }

                // Scroll drop logic (1 in 25 chance, only if no scroll has dropped this floor)
                if (!scrollDroppedThisFloor && Math.random() < 1/25) {
                    let scrollPlaced = false;
                    scrollDroppedThisFloor = true; // Mark scroll as dropped for this floor
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 11; // Scroll tile
                        scrollDrops.push({ x: enemy.x, y: enemy.y });
                        scrollPlaced = true;
                    } else {
                        const adjacent = [
                            { x: enemy.x, y: enemy.y - 1 },
                            { x: enemy.x, y: enemy.y + 1 },
                            { x: enemy.x - 1, y: enemy.y },
                            { x: enemy.x + 1, y: enemy.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny) &&
                                !scrollDrops.some(s => s.x === nx && s.y === ny)
                            ) {
                                map[ny][nx] = 11; // Scroll tile
                                scrollDrops.push({ x: nx, y: ny });
                                scrollPlaced = true;
                                break;
                            }
                        }
                    }
                    if (scrollPlaced) {
                        logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a scroll!`);
                        playWebAudioSound(sounds.pickup);
                    }
                }
                
                // Rune drop logic (20% for Hell Shrimp, 10% for others)
                if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                        const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 8;
                        runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: enemy.x, y: enemy.y - 1 },
                            { x: enemy.x, y: enemy.y + 1 },
                            { x: enemy.x - 1, y: enemy.y },
                            { x: enemy.x + 1, y: enemy.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8;
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
            });
            
            enemies = enemies.filter(e => e.hp > 0); // Remove dead enemies
            // Delay stairs placement until fire wave animation completes
            if (enemies.length === 0 && !exit && waveActive) {
                // Stairs will be placed in draw() after animation completes
            }
            p.ripBlast = false; // Disable blast after use
            needsRedraw = true;
        } else if (p.ripBlast && enemies.length === 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast activated but no enemies to destroy!`);
            // Delay stairs placement until fire wave animation completes
            p.ripBlast = false; // Consume RIP even if no enemies
            needsRedraw = true;
        }
        
        if (enemyCount > 0 && enemies.length > 0 && !exit) {
            if (!waveActive) {
                initialWaveSpawned = true;
                waveActive = true;
                document.getElementById('wave').textContent = wave;
                logBattleEvent(`Floor ${floor} - Wave ${wave} Started!`);
                console.log(`New wave started: wave=${wave}, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
            } else {
                console.log(`Additional enemies added to wave ${wave}, enemies=${enemies.length}, waveActive=${waveActive}`);
            }
            needsRedraw = true;
        } else {
            console.log(`No enemies spawned, wave=${wave}, scheduling retry in ${API_INTERVAL / 1000}s`);
        }
        
} catch (e) {
    console.error('fetchTxs Error:', e, e.stack);
} finally {
    // Set next API call time after successful execution
    nextApiCallTime = now + API_INTERVAL;
    apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    isFetchingTxs = false; // Clear flag when done
}
}

function isSolid(x, y) {
    return map[y][x] === 1 || map[y][x] === 13; // Standard walls and diamond walls
}

function move(dir) {
    if (gameOver || splashActive || inputBlocked) return;
    
    // Check if player is in hideout and trying to pause from waypoint tile
    if (inHideout && map[p.y][p.x] === 16) {
        // Allow pausing when on waypoint in hideout
        // This is handled by the existing logic but we want to ensure it works properly
    }

    swordDir = dir;
    let nx = p.x, ny = p.y;
    let newDirection = p.anim.direction;

    if (dir === 'up') { ny--; newDirection = 'back'; }
    if (dir === 'down') { ny++; newDirection = 'front'; }
    if (dir === 'left') { nx--; newDirection = 'left'; }
    if (dir === 'right') { nx++; newDirection = 'right'; }

// In the move function, after updating position:
p.moveCounter++;
if (p.moveCounter >= 2) {
    if (p.shrineCharges > 0) {
        p.hp++;
        p.shrineCharges--;
        // Log only every 8 charges spent to reduce spam
        if ((p.maxShrineCharges - p.shrineCharges) % 8 === 0) {
            logBattleEvent(`Floor ${floor} - Shrine refills health! (${p.shrineCharges}/${p.maxShrineCharges})`);
        }
        updatePlayerState();
    }
    p.moveCounter = 0;
}

    // Validate move before starting animation
    if (nx < 0 || nx >= W || ny < 0 || ny >= H || isSolid(nx, ny)) {
        p.anim.direction = newDirection; // Update direction for rendering
        needsRedraw = true;
        return; // Don't start animation
    }

    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return; // Don't start animation
    }

    if (enemies.some(e => e.x === nx && e.y === ny)) {
        p.anim.direction = newDirection; // Update direction for rendering
        needsRedraw = true;
        return; // Don't start animation
    }

    // Update direction and position (will be interpolated during draw)
    p.anim.direction = newDirection;
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        // Set target position for animation but don't update immediately
        // Actual position will be updated during interpolation in draw()
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
// Cap animation updates to 10 FPS (100ms - doubled interval)
if (now - p.anim.lastFrameTime >= 50) { // 10 FPS capped
    p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
    p.anim.lastFrameTime = now;
}
} else {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = performance.now();
    }
    }
    
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    
    // Always update direction for rendering, even if blocked by enemy
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        needsRedraw = true; // Ensure redraw to reflect new direction
        return;
    }
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        // Actual position update will happen during interpolation in draw()
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
    // Cap animation updates to 20 FPS (50ms)
    if (now - p.anim.lastFrameTime >= 50) { // 20 FPS capped
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
} else {
            p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
            p.anim.lastFrameTime = performance.now();
        }
    }
    
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    
    // Always update direction for rendering, even if blocked by enemy
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        needsRedraw = true; // Ensure redraw to reflect new direction
        return;
    }
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
    
const oldX = p.x;
const oldY = p.y;
p.x = nx;
p.y = ny;
p.targetTileX = nx;
p.targetTileY = ny;
p.deltaX = (nx - oldX) * 2;
p.deltaY = (ny - oldY) * 2;
p.stepsLeft = 8;
p.moving = true;
p.anim.direction = newDirection;
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
    // Half speed animation during movement (10 FPS)
    if (now - p.anim.lastFrameTime >= 50) {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
}

        // Apply spell damage when moving onto dangerous areas
        applySpellDamage(p.x, p.y);
        
        if (map[ny][nx] === 2) { 
            p.potions++; 
            map[ny][nx] = 0; 
            playWebAudioSound(sounds.pickup);
        }
        
if (map[ny][nx] === 6 && !inHideout) {
    if (currentTheme === 'paradise') {
        // Only restore HP if we're below the threshold
        if (p.hp < 24) {  // Or use p.hp < 36 if that's your desired cutoff
            const oldHP = p.hp;
            p.hp = 24 + (p.hasArmor ? 12 : 0); // Full health (24 or 36 with armor)
            logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
            playWebAudioSound(sounds.pickup);
        }
        // Additional condition for armor users with less than 36 HP
        else if (p.hasArmor && p.hp < 36) {
            const oldHP = p.hp;
            p.hp = 36; // Fill up to 36 HP for armor-wearing players
            logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
            playWebAudioSound(sounds.pickup);
        }
    }       
            // If p.hp > 36, do nothing and continue
            
            // Desert – Sludge pit
            if (currentTheme === 'desert') {
                // Check for poison immunity
                if (p.elementImmunity === 'Poison' || p.armorImmunity === 'Poison') {
                    logBattleEvent(`Floor ${floor} - Sludge Pit: Immune to Poison damage!`);
                } else {
                    p.hp = Math.max(0, p.hp - 2);
                    logBattleEvent(`Floor ${floor} - Sludge Pit: -2 HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hit);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;                // ← reset diamonds
                        updatePlayerState();          // ← update display
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                        gameOver = true;
                    }
                }
            }

            // Hell – Lava
            if (currentTheme === 'hell') {
                // Check for fire immunity
                if (p.elementImmunity === 'Fire' || p.armorImmunity === 'Fire') {
                    logBattleEvent(`Floor ${floor} - Lava: Immune to Fire damage!`);
                } else {
                    p.hp = Math.max(0, p.hp - 8);
                    logBattleEvent(`Floor ${floor} - Lava: -8 HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hit);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;
                        updatePlayerState();
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                        gameOver = true;
                    }
                }
            }

            // Ruins – Falling into a hole
            if (currentTheme === 'ruins') {
                if (p.hp === 1) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Fell into Hole: Hero Fell! Reached Floor ${floor}`);
                    playWebAudioSound(sounds.hole);
                    gameOver = true;
                } else {
                    const oldHP = p.hp;
                    p.hp = Math.ceil(p.hp / 2);
                    logBattleEvent(`Floor ${floor} - Fell into Hole: -${oldHP - p.hp} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hole);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;
                        updatePlayerState();
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                        gameOver = true;
                    }
                }
            }

            updatePlayerState();
        }
        
        if (map[ny][nx] === 7) {
            const coinToss = Math.random() < 0.5; // 50/50 chance
            if (coinToss) {
                // Grant max health (original behavior)
                const healthGain = p.potions * 12;
                p.maxHP += healthGain;
                p.hp += healthGain;
                logBattleEvent(`Floor ${floor} - Gnome flips a coin... Heads! Traded ${p.potions} potions for +${healthGain} max HP (new max HP: ${p.hp})`);
                playWebAudioSound(sounds.heads); // Play heads.wav
            } else {
                // Remove excess health and adjust armor
                let currentMaxHP = 24; // Base HP
                let newArmorStatus = 'Cloth';
                if (p.hp > 1000) {
                    currentMaxHP = 1000; // Diamond armor max
                    newArmorStatus = 'Diamond';
                } else if (p.hp > 36) {
                    currentMaxHP = 36; // Leather armor max
                    newArmorStatus = 'Leather';
                } else if (p.hp > 24) {
                    currentMaxHP = 24; // Cloth max
                    newArmorStatus = 'Cloth';
                }
                if (p.hp > currentMaxHP) {
                    const healthLost = p.hp - currentMaxHP;
                    p.hp = currentMaxHP;
                    p.hasDiamondArmor = currentMaxHP >= 1000;
                    p.hasArmor = currentMaxHP === 36;
                    document.getElementById('armorStatus').textContent = newArmorStatus;
                    logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! A mischievous cackle echoes as ${healthLost} excess HP is whisked away! Armor set to ${newArmorStatus} (HP now: ${p.hp})`);
                } else {
                    logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! The gnome giggles but finds no excess HP to take! (HP: ${p.hp})`);
                }
                playWebAudioSound(sounds.tails); // Play tails.wav
            }
            p.potions = 0;
            map[ny][nx] = 0;
            updatePlayerState();
        }
        
        if (map[ny][nx] === 3) {
            const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
            if (drop) {
                satsEarned[drop.type] += drop.sats;
                map[ny][nx] = 0;
                satoshiDrops = satoshiDrops.filter(d => d !== drop);
                playWebAudioSound(sounds.pickup);
                updateSatsDisplay();
            }
        }
        
        if (map[ny][nx] === 4) {
            p.pickaxes++;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Pickaxe Found!`);
        }
        
        if (map[ny][nx] === 5) {
            if (p.hp >= 24) {
                p.hp += 12;
            } else {
                p.hp = 24 + 12;
            }
            p.hasArmor = true;
            const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
            let available = elements.filter(el => el !== p.elementImmunity);
            if (available.length > 0) {
                p.armorImmunity = available[Math.floor(Math.random() * available.length)];
                logBattleEvent(`Floor ${floor} - Leather Armor grants 100% ${p.armorImmunity} resistance!`);
            }
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Armor Found: HP set to ${p.hp}`);
            updatePlayerState();
        }
        
        if (map[ny][nx] === 10) {            // diamond tile
            diamonds++;                      // collect it
            map[ny][nx] = 0;                 // remove from map
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Diamond collected!`);
            updatePlayerState();              // updates inventory display
        }
        
        if (map[ny][nx] === 11) { // Scroll tile
            const scroll = scrollDrops.find(s => s.x === nx && s.y === ny);
            if (scroll) {
                map[ny][nx] = 0; // Consume scroll
                scrollDrops = scrollDrops.filter(s => s !== scroll);
                playWebAudioSound(sounds.pickup);
                logBattleEvent(`Floor ${floor} - Scroll consumed! Town portal opened nearby!`);
                // Find an adjacent tile for the portal
                const adjacent = [
                    { x: nx, y: ny - 1 },
                    { x: nx, y: ny + 1 },
                    { x: nx - 1, y: ny },
                    { x: nx + 1, y: ny }
                ].filter(pos => 
                    pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H &&
                    map[pos.y][pos.x] === 0 &&
                    !enemies.some(e => e.x === pos.x && e.y === pos.y) &&
                    !portals.some(p => p.x === pos.x && p.y === pos.y)
                );
                if (adjacent.length > 0) {
                    const portalPos = adjacent[Math.floor(Math.random() * adjacent.length)];
                    map[portalPos.y][portalPos.x] = 12; // Portal tile
                    portals.push({
                        x: portalPos.x,
                        y: portalPos.y,
                        frameIndex: 0,
                        lastFrameTime: performance.now(),
                        frameDuration: 400  // Doubled for half speed
                    });
                } else {
                    logBattleEvent(`Floor ${floor} - No space for town portal!`);
                }
            }
        }

        // Check for adjacent special tiles (type 6) and play ambient sound once per floor
        if (currentTheme !== 'dungeon') {
            const adjacent = [
                {x: p.x, y: p.y - 1}, // Up
                {x: p.x, y: p.y + 1}, // Down
                {x: p.x - 1, y: p.y}, // Left
                {x: p.x + 1, y: p.y}  // Right
            ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 6);
            if (adjacent.length > 0) {
                let soundKey;
                switch (currentTheme) {
                    case 'hell':
                        soundKey = 'lava';
                        break;
                    case 'desert':
                        soundKey = 'quicksand';
                        break;
                    case 'paradise':
                        soundKey = 'pond';
                        break;
                }
                if (soundKey && !specialSoundsPlayedThisFloor[soundKey]) {
                    playWebAudioSound(sounds[soundKey]);
                    specialSoundsPlayedThisFloor[soundKey] = true;
                    logBattleEvent(`Floor ${floor} - Heard ${soundKey === 'quicksand' ? 'sludge pit' : soundKey} nearby!`);
                }
            }
        }

        // Check for falling animation (only on Ruins theme)
        if (
            currentTheme === 'ruins' &&
            map[ny][nx] === 6 && // Ring hole tile
            !p.isFalling // Not already falling
        ) {
            inputBlocked = true;
            p.isFalling = true;
            const direction = p.anim.direction; // Save current direction for push
            const oldX = p.x;
            const oldY = p.y;

            // Start fall animation - ensure it starts from frame 0
            let frameIndex = 0;
            const fallDuration = 200; // ms per frame
            const totalFrames = 4; // it is really just 3 frames but the last seems to be clipped off due to this "totalFrames - 1"
            const startTime = Date.now();

            function animateFall() {
                const elapsed = Date.now() - startTime;
                frameIndex = Math.min(Math.floor(elapsed / fallDuration), totalFrames - 1);

                // Update animation - this ensures all frames play, including the last one!
                p.anim.frameIndex = frameIndex;
                needsRedraw = true;

                if (frameIndex < totalFrames - 1) {
                    requestAnimationFrame(animateFall);
                } else {
                    // Animation complete, now push player one tile away
                    let pushX = oldX;
                    let pushY = oldY;

                    switch (direction) {
                        case 'up': pushY--; break;
                        case 'down': pushY++; break;
                        case 'left': pushX--; break;
                        case 'right': pushX++; break;
                    }

                    // Ensure player lands on a valid floor tile (not wall or hole), preferring same direction
                    pushX = oldX; // Reuse existing pushX
                    pushY = oldY; // Reuse existing pushY
                    let validPosition = false;

                    // Log original position for debugging
                    //console.log(`Original position: (${oldX}, ${oldY}), tile=${oldX >= 0 && oldX < W && oldY >= 0 && oldY < H ? map[oldY][oldX] : 'out of bounds'}`);

                    // Try pushing one tile in the original direction
                    //console.log(`Direction before initial push: ${direction}`);
                    switch (direction) {
                        case 'back': pushY--; break; // Up
                        case 'front': pushY++; break; // Down
                        case 'left': pushX--; break;
                        case 'right': pushX++; break;
                    }

                    //console.log(`Initial push: direction=${direction}, position=(${pushX}, ${pushY}), tile=${pushX >= 0 && pushX < W && pushY >= 0 && pushY < H ? map[pushY][pushX] : 'out of bounds'}`);

                    // Check if initial push position is the hole; if so, player is already on it
                    if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] === 6 // Initial push is the hole
                    ) {
                        // Try one tile before the hole (opposite direction, same side)
                        let backX = oldX;
                        let backY = oldY;
                        switch (direction) {
                            case 'front': backY--; break; // Up (opposite of front)
                            case 'back': backY++; break; // Down (opposite of back)
                            case 'left': backX++; break; // Right (opposite of left)
                            case 'right': backX--; break; // Left (opposite of right)
                        }
                        //console.log(`Back push (opposite direction): position=(${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                        if (
                            backX >= 0 && backX < W &&
                            backY >= 0 && backY < H &&
                            map[backY][backX] !== 1 && // Not a wall
                            map[backY][backX] !== 6 // Not a hole
                        ) {
                            pushX = backX;
                            pushY = backY;
                            validPosition = true;
                            //console.log(`Valid back push position found at (${pushX}, ${pushY})`);
                        } else {
                            //console.log(`Back push invalid at (${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                            // Try adjacent tiles on same side (left/right for front/back, up/down for left/right)
                            const adjacent = [
                                direction === 'front' || direction === 'back' ? { x: oldX - 1, y: oldY } : { x: oldX, y: oldY - 1 }, // Left or up
                                direction === 'front' || direction === 'back' ? { x: oldX + 1, y: oldY } : { x: oldX, y: oldY + 1 }  // Right or down
                            ];
                            for (let i = 0; i < adjacent.length; i++) {
                                const adjX = adjacent[i].x;
                                const adjY = adjacent[i].y;
                                //console.log(`Adjacent push ${i+1}: position=(${adjX}, ${adjY}), tile=${adjX >= 0 && adjX < W && adjY >= 0 && adjY < H ? map[adjY][adjX] : 'out of bounds'}`);
                                if (
                                    adjX >= 0 && adjX < W &&
                                    adjY >= 0 && adjY < H &&
                                    map[adjY][adjX] !== 1 && // Not a wall
                                    map[adjY][adjX] !== 6 // Not a hole
                                ) {
                                    pushX = adjX;
                                    pushY = adjY;
                                    validPosition = true;
                                    //console.log(`Valid adjacent push position found at (${pushX}, ${pushY})`);
                                    break;
                                }
                            }
                        }
                    } else if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] !== 1 && // Not a wall
                        map[pushY][pushX] !== 6 // Not a hole
                    ) {
                        validPosition = true;
                        //console.log(`Valid initial position found at (${pushX}, ${pushY})`);
                    } else if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] === 1 // Wall detected
                    ) {
                        // Try one tile before the hole (opposite direction, same side)
                        let backX = oldX;
                        let backY = oldY;
                        switch (direction) {
                            case 'front': backY--; break; // Up
                            case 'back': backY++; break; // Down
                            case 'left': backX++; break; // Right
                            case 'right': backX--; break; // Left
                        }
                        //console.log(`Back push (opposite direction): position=(${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                        if (
                            backX >= 0 && backX < W &&
                            backY >= 0 && backY < H &&
                            map[backY][backX] !== 1 && // Not a wall
                            map[backY][backX] !== 6 // Not a hole
                        ) {
                            pushX = backX;
                            pushY = backY;
                            validPosition = true;
                            //console.log(`Valid back push position found at (${pushX}, ${pushY})`);
                        } else {
                            //console.log(`Back push invalid at (${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                            // Try adjacent tiles on same side
                            const adjacent = [
                                direction === 'front' || direction === 'back' ? { x: oldX - 1, y: oldY } : { x: oldX, y: oldY - 1 }, // Left or up
                                direction === 'front' || direction === 'back' ? { x: oldX + 1, y: oldY } : { x: oldX, y: oldY + 1 }  // Right or down
                            ];
                            for (let i = 0; i < adjacent.length; i++) {
                                const adjX = adjacent[i].x;
                                const adjY = adjacent[i].y;
                                //console.log(`Adjacent push ${i+1}: position=(${adjX}, ${adjY}), tile=${adjX >= 0 && adjX < W && adjY >= 0 && adjY < H ? map[adjY][adjX] : 'out of bounds'}`);
                                if (
                                    adjX >= 0 && adjX < W &&
                                    adjY >= 0 && adjY < H &&
                                    map[adjY][adjX] !== 1 && // Not a wall
                                    map[adjY][adjX] !== 6 // Not a hole
                                ) {
                                    pushX = adjX;
                                    pushY = adjY;
                                    validPosition = true;
                                    //console.log(`Valid adjacent push position found at (${pushX}, ${pushY})`);
                                    break;
                                }
                            }
                        }
                    }

                    // Final check to ensure player doesn't land on hole
                    if (validPosition && pushX >= 0 && pushX < W && pushY >= 0 && pushY < H && map[pushY][pushX] === 6) {
                        //console.log(`Error: Final position is a hole at (${pushX}, ${pushY}); resetting to invalid`);
                        validPosition = false;
                    }

                    if (!validPosition) {
                        console.log(`No valid position found; player may be stuck at (${pushX}, ${pushY}), tile=${pushX >= 0 && pushX < W && pushY >= 0 && pushY < H ? map[pushY][pushX] : 'out of bounds'}`);
                    }

                    // Update player position if valid
                    if (validPosition) {
p.x = pushX;
p.y = pushY;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
                    } else {
                        // Fallback: keep player at original position if no valid move
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
return;
                    }

                    // Reset falling flag and animation state
                    p.isFalling = false;
                    p.anim.frameIndex = 0; // Reset to first frame
                    p.anim.direction = direction; // Restore original direction
                    // ⬅️ UNBLOCK INPUT HERE
                    setTimeout(() => {
                        inputBlocked = false;
                    }, 200); // Small delay to ensure smooth transition
                    needsRedraw = true;
                }
            }
            // Ensure we reset to first frame before starting animation
            p.anim.frameIndex = 0;
            animateFall();
            return; // Exit move early to prevent further movement
        }

// Add this after the stairs logic in move function:
if (exit && p.x === exit.x && p.y === exit.y && !inHideout) {

    // clear console log for each stage to keep it from blowing up
    console.clear()

    // NEW: make sure the scroll flag is reset for the next floor
    scrollDroppedThisFloor = false;

    sounds.stairs.play().catch(e => console.error('Stairs sound error:', e));
    if (p.immortal) {
        p.immortal = false;
        logBattleEvent(`Floor ${floor} - HODL immortality has worn off!`);
    }
    
    enemiesSpawnedThisFloor = 0;
    uniqueMonstersSpawnedThisFloor = 0; // Reset unique monster spawn counter
    initialSpawnDoneThisFloor = false;
    enemies = [];
    floor++;
    initialWaveSpawned = false;
    waveActive = false;
    exit = null;
    killsLog = [];
    battleLog = []; // Clear battleLog to prevent memory buildup
    // Reset special sound tracking for the new floor
    specialSoundsPlayedThisFloor.lava = false;
    specialSoundsPlayedThisFloor.quicksand = false;
    specialSoundsPlayedThisFloor.pond = false;
    specialSoundsPlayedThisFloor.rune = false;
    specialSoundsPlayedThisFloor.hole = false;
    // Reset runewords to allow reactivation on new floor
    p.runewords = [];
    // Clear runeDrops specific runes to prevent stale entries
    runeDrops = runeDrops.filter(r => !r.specific);
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    // Reset attack to base value before new floor (accounts for diamond hand)
    p.atk = p.hasDiamondHand ? 3 : 2;
    initMap();
    nextApiCallTime = null;

    // Show runeword message if active, otherwise show theme name for 3 s then revert to floor number
    const floorIndicator = document.getElementById('floor-indicator');
    if (themeTimeoutId) clearTimeout(themeTimeoutId);   // cancel any old timer

    // Check if any runewords are active
    const hasActiveRunewords = p.runewords.length > 0;
    
    if (hasActiveRunewords) {
// Show runeword message with the whole rune part in uppercase
const uppercasedRunewords = p.runewords.map(r => r.toUpperCase());

//floorIndicator.textContent = `Runeword${uppercasedRunewords.length > 1 ? 's' : ''} ${uppercasedRunewords.join(', ')} found!`;
//        if (themeTimeoutId) clearTimeout(themeTimeoutId);   // cancel any old timer
    } else {
        // Show theme name for 3 s, then revert to floor number
        const themeName = currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1);
        floorIndicator.textContent = themeName;               // 1️⃣ show theme

        themeTimeoutId = setTimeout(() => {                   // 3️⃣ after 3 s …
            floorIndicator.textContent = `Floor ${floor}`;     // 2️⃣ revert
            themeTimeoutId = null;
        }, 3000);
    }
    
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value = '';
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
    
    // Immediately trigger fetchTxs after floor transition
    if (!gameOver && !splashActive && floor > 0) {
        fetchTxs();
        console.log(`Triggered fetchTxs for wave ${wave} on floor ${floor}`);
    }
    
    // Add proper exit handling to prevent teleportation issues
    return; // ✅ This is CRUCIAL - stops further execution after exit
}

        // In move function - before calling fetchTxs
        if (map[ny][nx] === 12 && !inHideout) { // Portal tile in normal floor
            playWebAudioSound(sounds.town_portal);
            inHideout = true;
            initMap();
            return;
        }

        if (map[ny][nx] === 16 && inHideout) {
            playWebAudioSound(sounds.town_portal);
            if (previousFloorState) {
                // Restore previous floor state
                map = previousFloorState.map.map(row => [...row]);
                enemies = previousFloorState.enemies.map(e => ({ ...e, type: { ...e.type } }));
                rooms = previousFloorState.rooms.map(r => ({ ...r }));
                exit = previousFloorState.exit ? { ...previousFloorState.exit } : null;
                satoshiDrops = [...previousFloorState.satoshiDrops];
                runeDrops = [...previousFloorState.runeDrops];
                scrollDrops = [...previousFloorState.scrollDrops];
                portals = previousFloorState.portals.map(p => ({ ...p }));
                floor = previousFloorState.floor;
                wave = previousFloorState.wave;
                enemiesSpawnedThisFloor = previousFloorState.enemiesSpawnedThisFloor;
                whalesSpawnedThisFloor = previousFloorState.whalesSpawnedThisFloor;
                initialSpawnDoneThisFloor = previousFloorState.initialSpawnDoneThisFloor;
                initialWaveSpawned = previousFloorState.initialWaveSpawned;
                waveActive = previousFloorState.waveActive;
currentTheme = previousFloorState.currentTheme;
fogMap = previousFloorState.fogMap.map(row => [...row]);  // ← Add this line
const portal = previousFloorState.portals.find(p => p.x !== undefined && p.y !== undefined);
p.x = portal ? portal.x : 2;
p.y = portal ? portal.y : 2;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
inHideout = false;
document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
updateFogMap(p.x, p.y);
needsRedraw = true;
logBattleEvent(`Floor ${floor} - Returned from hideout via waypoint!`);
                document.documentElement.style.setProperty('--text-color', currentTheme === 'hell' ? '#00ff00' : '#ff8c00');
                document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                    el.style.color = currentTheme === 'hell' ? '#00ff00' : '#ff8c00';
                });
                return;
            } else {
                inHideout = false;
                initMap();
                portals = [{ x: p.x, y: p.y, frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 }];
                map[p.y][p.x] = 12;
                logBattleEvent(`Floor ${floor} - Returned to a new floor via waypoint!`);
                document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
                needsRedraw = true;
                document.documentElement.style.setProperty('--text-color', currentTheme === 'hell' ? '#00ff00' : '#ff8c00');
                document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                    el.style.color = currentTheme === 'hell' ? '#00ff00' : '#ff8c00';
                });
                return;
            }
        }

        if (!musicMuted) {
            musicManager.play(currentTheme);
        }

// Handle soul stash interaction
if (map[ny][nx] === 19 && !inHideout) { // Soul stash tile
    // Lock player movement while in terminal
    inputBlocked = true;
    // Store the exact position of the soul stash for proper positioning
    const stashX = nx;
    const stashY = ny;
    openSoulTerminal();
    return;
}

// In the move function, add shrine pickup logic:
if (map[ny][nx] === 22 && !inHideout) { // Shrine tile
    if (!p.shrineUsedThisFloor) {
        p.shrineCharges = 24; // Give 24 charges immediately
        p.shrineUsedThisFloor = true; // Mark that shrine was used on this floor
        logBattleEvent(`Floor ${floor} - Shrine charges activated! (24/24 charges)`);
        playWebAudioSound(sounds.pond);
    } else {
        logBattleEvent(`Floor ${floor} - Shrine already used this floor!`);
    }
}

// Add soul orb statue interaction
if (map[ny][nx] === 21 && !inHideout) { // Soul orb statue tile
	// Check if player already collected from this statue on current floor
	const currentFloorStatueKey = `statue_${floor}_${nx}_${ny}`;
	if (!p.collectedFromStatue || !p.collectedFromStatue[currentFloorStatueKey]) {
		p.soulOrbs++;
		logBattleEvent(`Block 74638: You received 1 Soul Orb!`);
		if (!p.collectedFromStatue) {
			p.collectedFromStatue = {};
		}
		p.collectedFromStatue[currentFloorStatueKey] = true;
		//map[ny][nx] = 0; // Remove statue after collection
		playWebAudioSound(sounds.buzz);
		updatePlayerState();
	} else {
		logBattleEvent(`Block 74638: Seek the masked relics’ refuge, where souls gather.`);
		needsRedraw = true;
	}
	return;
}
        
if (map[ny][nx] === 20) { // Soul stone tile
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Floor ${floor} - Soul Stone collected!`);
    updatePlayerState();
}

        if (map[ny][nx] === 14 && inHideout) { // Jeweller
            if (diamonds >= 3) {
                diamonds -= 3;
                p.perfectlyCutDiamonds++;
                logBattleEvent(`Jeweller refined 3 diamonds into a Perfectly Cut Diamond!`);
                playWebAudioSound(sounds.pickup);
                updatePlayerState();
            } else {
                logBattleEvent(`Jeweller requires 3 diamonds to refine!`);
            }
        }
        
        if (map[ny][nx] === 15 && inHideout) { // Blacksmith
            if (p.perfectlyCutDiamonds >= 1 && !p.hasDiamondArmor) {
                p.perfectlyCutDiamonds--;
                p.hasDiamondArmor = true;
                p.hasArmor = false; // Remove regular armor
                p.armorImmunity = null; // Reset previous armor immunity
                const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
                let available = elements.filter(el => el !== p.elementImmunity);
                if (available.length > 0) {
                    p.armorImmunity = available[Math.floor(Math.random() * available.length)];
                    logBattleEvent(`Floor ${floor} - Diamond Armor grants 100% ${p.armorImmunity} resistance!`);
                }
                p.hp += 1000;
                logBattleEvent(`Blacksmith forged Diamond Armor! HP increased to ${p.hp}`);
                playWebAudioSound(sounds.pickup);
                updatePlayerState();
            } else if (p.hasDiamondArmor) {
                logBattleEvent(`Blacksmith: You already have Diamond Armor!`);
            } else {
                logBattleEvent(`Blacksmith requires a Perfectly Cut Diamond!`);
            }
        }

        if (map[ny][nx] === 17 && inHideout) { // Rune Whisperer
            if (p.runes.length > 0) {
                const runeCount = p.runes.length;
                const healthGain = runeCount * 2;
                p.hp += healthGain;
                p.runes = [];
                runeDrops = runeDrops.filter(r => !r.specific);
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        if (map[y][x] === 9) {
                            map[y][x] = 0; // Clear specific rune tiles
                        }
                    }
                }
                logBattleEvent(`Rune Whisperer traded ${runeCount} runes for +${healthGain} HP! (HP now: ${p.hp})`);
                playWebAudioSound(sounds.pickup);
                checkRunewords();
                updatePlayerState();
            } else {
                logBattleEvent(`Rune Whisperer: No runes to trade!`);
            }
        }

if (map[ny][nx] === 18 && inHideout) { // Hooded Heirloom
    // Player can turn in soul orbs here for 256 charges each
    if (p.soulOrbs > 0) {
        if (p.soulStormCharges >= 256) {
            logBattleEvent(`Hooded Heirloom: You already have the maximum 256 Soul Storm Charges!`);
        } else {
            p.soulOrbs--;
            const chargesToAdd = Math.min(256 - p.soulStormCharges, 256);
            p.soulStormCharges += chargesToAdd;
            logBattleEvent(`Hooded Heirloom: Received ${chargesToAdd} Soul Storm Charges!`);
            playWebAudioSound(sounds.pickup);
        }
    } else {
        logBattleEvent(`Hooded Heirloom: No Soul Orbs to trade!`);
    }
}

        if (map[ny][nx] === 8) {
            const rune = runeDrops.find(r => r.x === nx && r.y === ny);
            if (rune) {
                p.runes.push(rune.letter);
                map[ny][nx] = 9; // Specific rune image
                runeDrops = runeDrops.filter(r => r !== rune);
                runeDrops.push({ x: nx, y: ny, letter: rune.letter, specific: true }); // Mark as specific rune for drawing
                playWebAudioSound(sounds.pickup);
                logBattleEvent(`Floor ${floor} - Picked up Rune ${rune.letter.toUpperCase()}!`);
                
                // Show rune name in floor indicator when picking up rune
                const floorIndicator = document.getElementById('floor-indicator');
                floorIndicator.textContent = `Rune Found: ${rune.letter.toUpperCase()}`;
                setTimeout(() => {
                    if (!currentRuneTile || !(p.x === currentRuneTile.x && p.y === currentRuneTile.y)) {
                        floorIndicator.textContent = `Floor ${floor}`;
                    }
                }, 3000); // Reset after 3 seconds

                //checkRunewords();
                // Track that player is currently on a rune tile
                currentRuneTile = { x: nx, y: ny };
            }
        }

// Check for unique monster in fog of war
function checkUniqueMonsterInFog() {
    if (activeUniqueMonsterName) return;
    
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0 && !activeUniqueMonsterName) {
        const firstVisible = visibleUniqueMonsters[0];
        activeUniqueMonsterName = firstVisible.uniqueName;
        
        // Show unique monster name in floor indicator
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName === firstVisible.uniqueName) {
                activeUniqueMonsterName = null;
                const currentText = floorIndicator.textContent;
                if (currentText === activeUniqueMonsterName || 
                    currentText.includes(firstVisible.uniqueName)) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }
        }, 5000);
    }
}

// Check for unique monster in fog of war when moving
// Only check when we DON'T have an active unique monster name
if (!activeUniqueMonsterName) {
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0) {
        const firstVisible = visibleUniqueMonsters[0];
        activeUniqueMonsterName = firstVisible.uniqueName;
        
        // Show unique monster name in floor indicator
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName === firstVisible.uniqueName) {
                activeUniqueMonsterName = null;
                const currentText = floorIndicator.textContent;
                if (currentText === activeUniqueMonsterName || 
                    currentText.includes(firstVisible.uniqueName)) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }
        }, 5000);
    }
}

// Check for unique monster in fog of war
const uniqueMonstersInFog = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 0);
if (uniqueMonstersInFog.length > 0 && !activeUniqueMonsterName) {
    const firstInFog = uniqueMonstersInFog[0];
    // Show the harbinger message
    const floorIndicator = document.getElementById('floor-indicator');
    if (!floorIndicator.textContent.includes("A harbinger of doom is near.")) {
        floorIndicator.textContent = "A harbinger of doom is near.";
        // Don't auto-clear - keep static until enemy is found or dead
        // Clear only when enemy is killed or when leaving the area
    }
}

// Check if player moved from a rune tile
if (currentRuneTile && !(p.x === currentRuneTile.x && p.y === currentRuneTile.y)) {
    const floorIndicator = document.getElementById('floor-indicator');
    if (floorIndicator.textContent.startsWith("Rune Found:") || 
        floorIndicator.textContent.startsWith("Rune:")) {
        // Reset to normal floor text if leaving rune tile
        setTimeout(() => {
            // Double-check that player is still not on a rune tile before resetting
            const stillOnRuneTile = map[p.y][p.x] === 9 && 
                runeDrops.some(r => r.x === p.x && r.y === p.y && r.specific);
            
            if (!stillOnRuneTile) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 100); // Small delay to prevent flicker
    }
}

        updateFogMap(p.x, p.y);
    }
    
    moveEnemies();
    updatePlayerState();
    
    // Check if player is standing on a rune tile (specifically placed rune)
    if (map[p.y][p.x] === 9) {
        const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
        if (rune) {
            const floorIndicator = document.getElementById('floor-indicator');
            // Show rune name when stepping on rune tile
            if (!floorIndicator.textContent.startsWith("Rune:")) {
                floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
            } else {
                // Update rune letter if it's different from what's currently displayed
                const currentRuneText = floorIndicator.textContent;
                const expectedRune = `Rune: ${rune.letter.toUpperCase()}`;
                if (currentRuneText !== expectedRune) {
                    floorIndicator.textContent = expectedRune;
                }
            }
            currentRuneTile = { x: p.x, y: p.y };
        }
    } else if (currentRuneTile && map[p.y][p.x] !== 9) {
        // Player moved away from rune tile
        const floorIndicator = document.getElementById('floor-indicator');
        if (floorIndicator.textContent.startsWith("Rune:")) {
            // Reset to floor text after a delay, but only if not currently on another rune tile
            setTimeout(() => {
                // Check again if player is now on a different rune tile
                const stillOnRuneTile = map[p.y][p.x] === 9 && 
                    runeDrops.some(r => r.x === p.x && r.y === p.y && r.specific);
                
                if (!stillOnRuneTile) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }, 100);
        }
    }
    
    needsRedraw = true;

}

function moveEnemies() {
    if (gameOver || splashActive) return;
    enemies.forEach(e => {
        let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
        if (dist <= 5) {
            let moves = e.type.move, steps = 0;
let startX = e.x, startY = e.y;
let finalX = e.x, finalY = e.y;
let numTileSteps = 0;
let tempDx = dx, tempDy = dy;
while (steps < moves) {
    let nx = finalX, ny = finalY;
    if (e.type.name === 'Crab') {
        nx += tempDx > 0 ? 1 : -1;
    } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
        if (Math.abs(tempDx) > Math.abs(tempDy)) nx += tempDx > 0 ? 1 : -1;
        else ny += tempDy > 0 ? 1 : -1;
    } else {
        if (Math.abs(tempDx) > Math.abs(tempDy)) nx += tempDx > 0 ? 1 : -1;
        else ny += tempDy > 0 ? 1 : -1;
    }
    if (
       nx >= 0 && nx < W && ny >= 0 && ny < H &&
       map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) &&
        !enemies.some(en => en.x === nx && en.y === ny && en !== e)
    ) {
        finalX = nx;
        finalY = ny;
        numTileSteps++;
    } else break;
    steps++;
    tempDx = p.x - finalX; tempDy = p.y - finalY;
}
if (numTileSteps > 0) {
    const totalDeltaX = (finalX - startX) * S;
    const totalDeltaY = (finalY - startY) * S;
    const totalDistance = Math.abs(totalDeltaX) + Math.abs(totalDeltaY);
    const numSubSteps = totalDistance / 2;
    e.deltaX = totalDeltaX > 0 ? 2 : (totalDeltaX < 0 ? -2 : 0);
    e.deltaY = totalDeltaY > 0 ? 2 : (totalDeltaY < 0 ? -2 : 0);
    e.stepsLeft = numSubSteps;
    e.moving = true;
    e.x = finalX;
    e.y = finalY;
    e.targetTileX = finalX;
    e.targetTileY = finalY;
    e.currentX = startX * S;
    e.currentY = startY * S;
}
dx = p.x - e.x; dy = p.y - e.y;  // Update for attack
            }
            if (
                (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark') ?
                (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
            ) {
const damage = e.type.name === 'Whale' ? Math.ceil(p.hp / 10) + 3 : e.type.atk;	// Added + 3 dmg to make the whale still pretty dangerous at early stages
p.hp -= damage;
logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${damage} DMG`);
playWebAudioSound(sounds.hit);
if (p.hp <= 0 && p.immortal) {
    p.hp = 1;
    logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
} else if (p.hp <= 0) {
    p.hp = 0;
    diamonds = 0;                // reset diamonds
    updatePlayerState();          // update inventory
    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
    gameOver = true;
}

updatePlayerState(); // Check HP and armor state after damage
            }
    });
if (enemies.length === 0 && !exit && waveActive && !p.ripBlast && !ripBlastActive && !inHideout) {
    if (placeStairs()) {
        wave++;
        waveActive = false;
        document.getElementById('wave').textContent = wave;
        logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);
    } else {
        logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
    }
}

}

// Function to apply spell damage to player
function applySpellDamage(x, y) {
    // Check if player is standing on a dangerous area
    const dangerousArea = dangerousAreas.find(area => area.x === x && area.y === y);
    
    if (dangerousArea) {
        let damage = 0;
        let damageType = "";
        
        switch (dangerousArea.spellType) {
            case SPELL_TYPES.FIRE_WALL:
                damage = 2;
                damageType = "Fire";
                break;
            case SPELL_TYPES.LIGHTNING_STORM:
                damage = 1;
                damageType = "Lightning";
                break;
            case SPELL_TYPES.FROST_NOVA:
                damage = 2;
                damageType = "Frost";
                break;
            case SPELL_TYPES.POISON_CLOUD:
                damage = 1;
                damageType = "Poison";
                break;
        }
        
        // Check if player has immunity to this spell type
        if (p.elementImmunity === damageType || p.armorImmunity === damageType) {
            logBattleEvent(`Floor ${floor} - Immune to ${damageType} spell! No damage taken.`);
            return; // Skip damage application
        }
        
        p.hp -= damage;
        logBattleEvent(`Floor ${floor} - ${damageType} spell damage! ${damage} DMG`);
        playWebAudioSound(sounds.hit);
        
        if (p.hp <= 0 && p.immortal) {
            p.hp = 1;
            logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
        } else if (p.hp <= 0) {
            p.hp = 0;
            diamonds = 0;                // reset diamonds
            updatePlayerState();          // update inventory
            logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
            gameOver = true;
        }
        
        updatePlayerState();
    }
}

// Modified updateProjectiles function with Hell Shrimp rune drop rate changed to 20%
function updateProjectiles() {
    if (gameOver || splashActive) return;
    projectiles = projectiles.filter(proj => {
        // Only move every 50ms
        if (Date.now() - proj.lastMoveTime < 50) return true;
        
        // Calculate next position
        let nx = proj.x, ny = proj.y;
        if (proj.dir === 'up') ny--;
        if (proj.dir === 'down') ny++;
        if (proj.dir === 'left') nx--;
        if (proj.dir === 'right') nx++;
        
        // Check bounds
        if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
            needsRedraw = true;
            return false;
        }
        
        // Check for wall hit before moving
        if (map[ny][nx] === 1) {
            needsRedraw = true;
            return false;
        }
        
// Check for first enemy hit and deal damage
let hit = enemies.find(e => e.x === nx && e.y === ny);
if (hit) {
    const damage = Math.floor(p.atk * 0.5); // Half the damage output for shooting sword
    hit.hp -= damage;
    logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (HP: ${hit.hp})`);
    playWebAudioSound(sounds.hit);
    if (hit.hp <= 0) {
        kills[hit.type.name]++;
        let dropPlaced = false;
        
// Handle unique monster rewards using new function
handleUniqueMonsterReward(hit);
        
        // Remove enemy immediately to prevent further hits
        enemies = enemies.filter(e => e !== hit);
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 3;
                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }
                if (!dropPlaced) {
                    // No space for satoshi drop
                }

// Scroll drop logic (1 in 25 chance, only if no scroll has dropped this floor)
if (!scrollDroppedThisFloor && Math.random() < 1/25) {
    let scrollPlaced = false;
    scrollDroppedThisFloor = true; // Mark scroll as dropped for this floor
    if (map[hit.y][hit.x] === 0) {
        map[hit.y][hit.x] = 11; // Scroll tile
        scrollDrops.push({ x: hit.x, y: hit.y });
        scrollPlaced = true;
    } else {
        const adjacent = [
            { x: hit.x, y: hit.y - 1 },
            { x: hit.x, y: hit.y + 1 },
            { x: hit.x - 1, y: hit.y },
            { x: hit.x + 1, y: hit.y }
        ];
        for (const pos of adjacent) {
            const nx = pos.x, ny = pos.y;
            if (
                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                map[ny][nx] === 0 &&
                !enemies.some(e => e.x === nx && e.y === ny) &&
                !scrollDrops.some(s => s.x === nx && s.y === ny)
            ) {
                map[ny][nx] = 11; // Scroll tile
                scrollDrops.push({ x: nx, y: ny });
                scrollPlaced = true;
                break;
            }
        }
    }
    if (scrollPlaced) {
        logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a scroll!`);
        playWebAudioSound(sounds.pickup);
    }
}
                
                // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
                if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                        // Hell Shrimp: Use specific rune letters
                        const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        // Regular rune drop
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[hit.y][hit.x] === 0) {
                        map[hit.y][hit.x] = 8; // Generic rune on floor
                        runeDrops.push({ x: hit.x, y: hit.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: hit.x, y: hit.y - 1 },
                            { x: hit.x, y: hit.y + 1 },
                            { x: hit.x - 1, y: hit.y },
                            { x: hit.x + 1, y: hit.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8; // Generic rune on floor
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
                
                enemies = enemies.filter(e => e !== hit);
            }
            needsRedraw = true;
            return false; // Destroy projectile on enemy hit
        }
        
        // Update projectile position and move time
        proj.x = nx;
        proj.y = ny;
        proj.lastMoveTime = Date.now();
        needsRedraw = true;
        return true;
    });
}

let usePickaxeSword = false; // Global flag for draw
let ripBlastActive = false; // Flag for RIP blast gradient overlay effect
let ripBlastStartTime = 0; // Timestamp for RIP blast start
let columnProgress = 0; // Progress of gradient columns (0 to 1)

// Initialize gradient column overlay for RIP blast effect
function initGradientOverlay() {
    columnProgress = 0; // Start at beginning of animation
}

// Modified checkRunewords function to display 5x5 rune grid with counts
function checkRunewords() {
    // Define all possible runes
    const allRunes = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
    
    // Count occurrences of each rune, capped at 9
    const runeCounts = {};
    allRunes.forEach(rune => runeCounts[rune] = 0);
    p.runes.forEach(rune => {
        if (runeCounts[rune] < 9) {
            runeCounts[rune]++;
        }
    });
    
// Build 5x5 grid display
let displayText = '<br>'; // Start with a <br> for the first row
for (let i = 0; i < 5; i++) {
    const row = allRunes.slice(i * 5, (i + 1) * 5).map(rune => {
        const count = runeCounts[rune];
        const letter = rune.toUpperCase();
        const display = `${letter}<sup style="font-size: 0.6em;">${count}</sup>`;
        if (count > 0) {
            return display;
        }
        return `<span style="opacity: 0;">${display}</span>`;
    }).join('  '); // Two spaces for separation
    //displayText += row + (i < 4 ? '<br>' : ''); // Newline except for last row
    displayText += row + (i < 4 ? ' ' : ''); // Newline except for last row
}
    
    // Wrap displayText in a span with Safari-compatible nbsp styling
    const wrappedDisplayText = `<span style="-webkit-nbsp-mode: normal;">${displayText}</span>`;
    
    // Update inventory display
    document.getElementById('runes').innerHTML = wrappedDisplayText; // Apply wrapped text to runes element
}

// Modified checkRunewordsAtFloorStart function to check for BTC, HODL, RIP and SAT runes in any order
function checkRunewordsAtFloorStart() {
    // Only check for runewords at start of floor (no continuous checking)
    const runewords = [
        { name: 'btc', runes: ['b', 't', 'c'], effect: () => {
            p.hp += 444;
            p.maxHP = Math.max(p.maxHP, p.hp);
            p.runewords.push('btc');
            logBattleEvent(`Floor ${floor} - Runeword BTC activated! +444 HP (now ${p.hp})`);
            updatePlayerState();
            needsRedraw = true;
        }},
        { name: 'hodl', runes: ['h', 'o', 'd', 'l'], effect: () => {
            p.immortal = true;
            p.runewords.push('hodl');
            logBattleEvent(`Floor ${floor} - Runeword HODL activated! You are immortal!`);
            updatePlayerState();
            needsRedraw = true;
        }},
	{ name: 'rip', runes: ['r', 'i', 'p'], effect: () => {
	    p.ripBlast = true;
	    p.runewords.push('rip');
	    logBattleEvent(`Floor ${floor} - Runeword RIP activated! Incoming blast...`);
	    needsRedraw = true;
	}},
	{ name: 'sat', runes: ['s', 'a', 't'], effect: () => {
	    p.atk *= 2;
	    p.runewords.push('sat');
	    logBattleEvent(`Floor ${floor} - Runeword SAT activated! Attack doubled to ${p.atk}! (Satoshi's blessing)`);
	    updatePlayerState();
	    needsRedraw = true;
	}}
    ];

    // Compute rune counts and indices in a single pass
    const runeData = { counts: {}, indices: {} };
    p.runes.forEach((rune, i) => {
        if (!runeData.counts[rune]) {
            runeData.counts[rune] = 0;
            runeData.indices[rune] = [];
        }
        runeData.counts[rune]++;
        runeData.indices[rune].push(i);
    });

    let usedIndices = [];
    let activatedRunewords = [];

    // Check each runeword
    for (const runeword of runewords) {
        if (p.runewords.includes(runeword.name)) continue; // Skip already activated runewords

        // Check if all required runes are available
        const hasAllRunes = runeword.runes.every(rune => (runeData.counts[rune] || 0) > 0);
        if (hasAllRunes) {
            // Collect indices for the required runes
            const indices = [];
            for (const rune of runeword.runes) {
                if (runeData.indices[rune].length > 0) {
                    indices.push(runeData.indices[rune].shift()); // Take first available index
                    runeData.counts[rune]--;
                } else {
                    break; // Missing a rune, stop checking this runeword
                }
            }
            if (indices.length === runeword.runes.length) { // All runes found
                runeword.effect();
                usedIndices.push(...indices);
                activatedRunewords.push(runeword.name.toUpperCase());
            }
        }
    }

    // Display runeword message if any were activated
    if (activatedRunewords.length > 0) {
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Runeword${activatedRunewords.length > 1 ? 's' : ''} ${activatedRunewords.join(', ')} found!`;
        if (!specialSoundsPlayedThisFloor.rune) {
            playWebAudioSound(sounds.rune);
            specialSoundsPlayedThisFloor.rune = true;
        }
        setTimeout(() => {
            const currentText = floorIndicator.textContent;
            if (currentText.startsWith("Runeword")) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 5000);
    }

    // Remove used runes
    if (usedIndices.length > 0) {
        usedIndices.sort((a, b) => b - a); // Sort descending to avoid index issues
        for (const index of usedIndices) {
            p.runes.splice(index, 1);
        }
    }

    // Clear specific rune drops
    runeDrops = runeDrops.filter(r => !r.specific);
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 9) {
                map[y][x] = 0; // Clear specific rune tiles
            }
        }
    }

    checkRunewords(); // Update inventory display
    needsRedraw = true;
}

// Modified handleUniqueMonsterReward function with fadeout before removing dangerous areas
function handleUniqueMonsterReward(hit) {
    if (!hit.uniqueName) return false;
    
    // Reward for unique monster: at least 2X (up to 4X) the normal sats/btc
    const baseReward = hit.sats;
    const floorMultiplier = floor / 100; // Calculate floor multiplier
    const added = Math.floor(baseReward * floorMultiplier); // Apply floor multiplier
    const baseWithMultiplier = baseReward + added; // Base reward with floor multiplier
    
// Apply additional random multiplier for unique monsters (2x to 4x)
    const randomMultiplier = 2 + Math.random() * 2; // Random multiplier from 2x to 4x
    const reward = Math.round(baseWithMultiplier * randomMultiplier);
    
    // Add bitcoin drops around the monster position
    let dropPlaced = false;
    if (map[hit.y][hit.x] === 0) {
        map[hit.y][hit.x] = 3;
        satoshiDrops.push({x: hit.x, y: hit.y, sats: reward, type: hit.type.name});
        dropPlaced = true;
    } else {
        const adjacent = [
            {x: hit.x, y: hit.y - 1},
            {x: hit.x, y: hit.y + 1},
            {x: hit.x - 1, y: hit.y},
            {x: hit.x + 1, y: hit.y}
        ];
        for (const pos of adjacent) {
            const nx = pos.x, ny = pos.y;
            if (
                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                map[ny][nx] === 0 &&
                !enemies.some(e => e.x === nx && e.y === ny)
            ) {
                map[ny][nx] = 3;
                satoshiDrops.push({x: nx, y: ny, sats: reward, type: hit.type.name});
                dropPlaced = true;
                break;
            }
        }
    }
    
    if (dropPlaced) {
        const rewardBtc = reward / 1e8;
        const [displayAmount, displayUnit] = rewardBtc < 1 ? [Math.round(reward), 'sats'] : [rewardBtc.toFixed(2), 'BTC'];
        logBattleEvent(`Floor ${floor} - Unique monster ${hit.uniqueName} defeated! Reward: ${displayAmount} ${displayUnit}`);

	// Clear harbinger message if it was active for this monster
	const floorIndicator = document.getElementById('floor-indicator');
	if (floorIndicator.textContent === "A harbinger of doom is near.") {
	    floorIndicator.textContent = `Floor ${floor}`;
	}
	activeUniqueMonsterName = null; // Also clear any lingering visible name
        // Also add to satsEarned for proper display
        satsEarned[hit.type.name] += reward;
        updateSatsDisplay();
    } else {
        logBattleEvent(`Floor ${floor} - Unique monster ${hit.uniqueName} defeated!`);
    }
    
// Tag all areas with this monster's death timestamp for global fadeout/removal
if (hit.uniqueName && hit.spell) {
    const deathTime = Date.now();
    dangerousAreas.forEach(area => {
        if (area.spellType === hit.spell) {
            area.deathTime = deathTime; // Tag for fadeout
        }
    });
    

}
    
    return true;
}

// Function to assign a spell to a unique monster when it spawns
function assignUniqueMonsterSpell(enemy) {
    // Only assign spells to unique monsters
    if (!enemy.uniqueName || !uniqueMonsterNames[enemy.type.name]) {
        return null;
    }

    // Elemental keyword correlations (case-insensitive)
    const correlations = {
        fire: SPELL_TYPES.FIRE_WALL, blaze: SPELL_TYPES.FIRE_WALL, inferno: SPELL_TYPES.FIRE_WALL,
        storm: SPELL_TYPES.LIGHTNING_STORM, lightning: SPELL_TYPES.LIGHTNING_STORM, bolt: SPELL_TYPES.LIGHTNING_STORM, thunder: SPELL_TYPES.LIGHTNING_STORM,
        cold: SPELL_TYPES.FROST_NOVA, frost: SPELL_TYPES.FROST_NOVA, ice: SPELL_TYPES.FROST_NOVA, chill: SPELL_TYPES.FROST_NOVA,
        poison: SPELL_TYPES.POISON_CLOUD, viper: SPELL_TYPES.POISON_CLOUD, snot: SPELL_TYPES.POISON_CLOUD, plague: SPELL_TYPES.POISON_CLOUD,
        bile: SPELL_TYPES.POISON_CLOUD, pox: SPELL_TYPES.POISON_CLOUD, ooze: SPELL_TYPES.POISON_CLOUD, venom: SPELL_TYPES.POISON_CLOUD
    };

    // Check for matching keyword in name
    const nameLower = enemy.uniqueName.toLowerCase();
    let matchedSpell = null;
    for (const [keyword, spell] of Object.entries(correlations)) {
        if (nameLower.includes(keyword)) {
            matchedSpell = spell;
            break;
        }
    }

    // Assign matched spell or fallback to random
    const spell = matchedSpell || Object.values(SPELL_TYPES)[Math.floor(Math.random() * Object.keys(SPELL_TYPES).length)];
    enemy.spell = spell;
    return spell;
}

// Function to remove dangerous areas when a unique monster dies
function removeDangerousAreas(monster) {
    if (!monster.uniqueName || !monster.spell) return;
    
    // Remove all dangerous areas that match this spell type
    dangerousAreas = dangerousAreas.filter(area => area.spellType !== monster.spell);
    
    // Redraw to reflect changes
    needsRedraw = true;
}

// Enhanced draw for fading dangerous areas based on deathTime
function drawFadingDangerousAreas() {
    dangerousAreas.forEach(area => {
        const dist = Math.sqrt((area.x - p.x) ** 2 + (area.y - p.y) ** 2);
        const isVisible = fogMap[area.y][area.x] === 1 || dist <= 4;
        if (!isVisible) return; // Skip fog-hidden areas
        
        let spellAlpha = 0.5;
        let spellColor = 'rgba(255, 255, 255, 0.5)';
        
        // Fade if tagged with deathTime
        if (area.deathTime) {
            const elapsed = Date.now() - area.deathTime;
            const fadeDuration = 5000;
            const progress = Math.min(elapsed / fadeDuration, 1);
            spellAlpha *= (1 - progress);
            
            // Set color based on spell
            switch (area.spellType) {
                case SPELL_TYPES.FIRE_WALL: spellColor = `rgba(255, 0, 0, ${spellAlpha})`; break;
                case SPELL_TYPES.LIGHTNING_STORM: spellColor = `rgba(255, 255, 0, ${spellAlpha})`; break;
                case SPELL_TYPES.FROST_NOVA: spellColor = `rgba(0, 255, 255, ${spellAlpha})`; break;
                case SPELL_TYPES.POISON_CLOUD: spellColor = `rgba(0, 255, 0, ${spellAlpha})`; break;
            }
        } else {
            // Non-fading areas
            switch (area.spellType) {
                case SPELL_TYPES.FIRE_WALL: spellColor = 'rgba(255, 0, 0, 0.5)'; break;
                case SPELL_TYPES.LIGHTNING_STORM: spellColor = 'rgba(255, 255, 0, 0.5)'; break;
                case SPELL_TYPES.FROST_NOVA: spellColor = 'rgba(0, 255, 255, 0.5)'; break;
                case SPELL_TYPES.POISON_CLOUD: spellColor = 'rgba(0, 255, 0, 0.5)'; break;
            }
        }
        
        c.save();
        c.fillStyle = spellColor;
        c.fillRect(area.x * S, area.y * S, S, S);
        c.restore();
    });

    // Continuous cleanup: remove fully faded areas
    const now = Date.now();
    dangerousAreas = dangerousAreas.filter(area => {
        if (area.deathTime) {
            const elapsed = now - area.deathTime;
            return elapsed < 5000;  // Remove after 5s
        }
        return true;
    });

    if (needsRedraw) needsRedraw = true;  // Ensure redraw if cleaned
}

// Modified attack function with Hell Shrimp rune drop rate changed to 20%
function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    
    // Update player direction
    let newDirection = p.anim.direction;
    if (swordDir === 'up') newDirection = 'back';
    if (swordDir === 'down') newDirection = 'front';
    if (swordDir === 'left') newDirection = 'left';
    if (swordDir === 'right') newDirection = 'right';
    p.anim.direction = newDirection;
    
    const initialPickaxes = p.pickaxes;
    
    // Check for enemy or wall one tile away in swordDir
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    
    const isEnemyNearby = enemies.some(e => e.x === sx && e.y === sy);
    const isWallNearby = sx >= 0 && sx < W && sy >= 0 && sy < H && map[sy][sx] === 1;
    
    if (initialPickaxes > 0 || isEnemyNearby || isWallNearby) {
        usePickaxeSword = initialPickaxes > 0;
        let hit = enemies.find(e => e.x === sx && e.y === sy);
        
if (hit) {
    // Check if the enemy is a unique monster that can cast spells
    if (hit.uniqueName && hit.spell) {
        // Unique monster uses its spell
        const spellEffect = hit.spell;
        logBattleEvent(`Floor ${floor} - ${hit.uniqueName} casts ${spellEffect}!`);
        
        // Create the spell effect area around the enemy position
        switch (spellEffect) {
            case SPELL_TYPES.FIRE_WALL:
                // Create fire wall in a 3x3 area centered on the enemy
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
            case SPELL_TYPES.LIGHTNING_STORM:
                // Create lightning storm in a 5x5 area centered on the enemy
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
            case SPELL_TYPES.FROST_NOVA:
                // Create frost nova in a 3x3 area centered on the enemy
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
            case SPELL_TYPES.POISON_CLOUD:
                // Create poison cloud in a 5x5 area centered on the enemy
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
        }
    }
    if (p.hasDiamondHand && !(p.pickaxes > 0 && usePickaxeSword)) {
        // Diamond hand AOE damage - updated to match the specified pattern
        const damageArea = [];
        
        // Determine damage tiles based on direction
        if (swordDir === 'up') {
            const close_y = p.y - 1;
            const far_y = p.y - 2;
            for (let dx = -1; dx <= 1; dx++) {
                damageArea.push({x: p.x + dx, y: close_y});
            }
            for (let dx = -2; dx <= 2; dx++) {
                damageArea.push({x: p.x + dx, y: far_y});
            }
        } else if (swordDir === 'down') {
            const close_y = p.y + 1;
            const far_y = p.y + 2;
            for (let dx = -1; dx <= 1; dx++) {
                damageArea.push({x: p.x + dx, y: close_y});
            }
            for (let dx = -2; dx <= 2; dx++) {
                damageArea.push({x: p.x + dx, y: far_y});
            }
        } else if (swordDir === 'left') {
            const close_x = p.x - 1;
            const far_x = p.x - 2;
            for (let dy = -1; dy <= 1; dy++) {
                damageArea.push({x: close_x, y: p.y + dy});
            }
            for (let dy = -2; dy <= 2; dy++) {
                damageArea.push({x: far_x, y: p.y + dy});
            }
        } else if (swordDir === 'right') {
            const close_x = p.x + 1;
            const far_x = p.x + 2;
            for (let dy = -1; dy <= 1; dy++) {
                damageArea.push({x: close_x, y: p.y + dy});
            }
            for (let dy = -2; dy <= 2; dy++) {
                damageArea.push({x: far_x, y: p.y + dy});
            }
        }
        
        // Apply damage to all valid tiles in the area
        const damage = 3; // Diamond hand AOE damage
        let enemiesHit = 0;
        let totalDamage = 0;
        
        highlightTiles = []; // Clear previous highlights
        for (const tile of damageArea) {
            const {x, y} = tile;
            
            // Check if tile is within bounds and not a wall
            if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 1) {
                highlightTiles.push({x, y, highlightStart: Date.now()}); // Add tile to highlight
                // Check if there's an enemy at this tile
                const enemy = enemies.find(e => e.x === x && e.y === y);
                
                if (enemy) {
                    // Apply damage to enemy
                    enemy.hp -= damage;
                    logBattleEvent(`Floor ${floor} - Diamond Hand hits ${enemy.type.name} for ${damage} DMG (HP: ${enemy.hp})`);
                    playWebAudioSound(sounds.hit);
                    
                    if (enemy.hp <= 0) {
                        kills[enemy.type.name]++;
                        let dropPlaced = false;

// Handle unique monster rewards using new function
handleUniqueMonsterReward(hit);
                        
                        // Drop satoshi
                        if (map[enemy.y][enemy.x] === 0) {
                            map[enemy.y][enemy.x] = 3;
                            satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                            dropPlaced = true;
                        } else {
                            const adjacent = [
                                {x: enemy.x, y: enemy.y - 1},
                                {x: enemy.x, y: enemy.y + 1},
                                {x: enemy.x - 1, y: enemy.y},
                                {x: enemy.x + 1, y: enemy.y}
                            ];
                            for (const pos of adjacent) {
                                const nx = pos.x, ny = pos.y;
                                if (
                                    nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                    map[ny][nx] === 0 &&
                                    !enemies.some(e => e.x === nx && e.y === ny)
                                ) {
                                    map[ny][nx] = 3;
                                    satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                                    dropPlaced = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!dropPlaced) {
                            // No space for satoshi drop
                        }

                        // Soul stone drop logic (5% chance)
                        if (Math.random() < 0.05) {
                            let stonePlaced = false;
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 20; // Soul stone tile
                                stonePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: enemy.x, y: enemy.y - 1},
                                    {x: enemy.x, y: enemy.y + 1},
                                    {x: enemy.x - 1, y: enemy.y},
                                    {x: enemy.x + 1, y: enemy.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 20; // Soul stone tile
                                        stonePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (stonePlaced) {
                                p.soulStones++;
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a Soul Stone!`);
                                playWebAudioSound(sounds.buzz);
                            }
                        }

                        // Scroll drop logic (1 in 25 chance, only if no scroll has dropped this floor)
                        if (!scrollDroppedThisFloor && Math.random() < 1/25) {
                            let scrollPlaced = false;
                            scrollDroppedThisFloor = true; // Mark scroll as dropped for this floor
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 11; // Scroll tile
                                scrollDrops.push({ x: enemy.x, y: enemy.y });
                                scrollPlaced = true;
                            } else {
                                const adjacent = [
                                    { x: enemy.x, y: enemy.y - 1 },
                                    { x: enemy.x, y: enemy.y + 1 },
                                    { x: enemy.x - 1, y: enemy.y },
                                    { x: enemy.x + 1, y: enemy.y }
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny) &&
                                        !scrollDrops.some(s => s.x === nx && s.y === ny)
                                    ) {
                                        map[ny][nx] = 11; // Scroll tile
                                        scrollDrops.push({ x: nx, y: ny });
                                        scrollPlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (scrollPlaced) {
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a scroll!`);
                                playWebAudioSound(sounds.pickup);
                            }
                        }

                        // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
                        if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                            let runeLetter;
                            if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                                // Hell Shrimp: Use specific rune letters
                                const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                                runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                            } else {
                                // Regular rune drop
                                const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                                runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                            }
                            let runePlaced = false;
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 8; // Generic rune on floor
                                runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                                runePlaced = true;
                            } else {
                                const adjacent = [
                                    { x: enemy.x, y: enemy.y - 1 },
                                    { x: enemy.x, y: enemy.y + 1 },
                                    { x: enemy.x - 1, y: enemy.y },
                                    { x: enemy.x + 1, y: enemy.y }
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 8; // Generic rune on floor
                                        runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                        runePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (runePlaced) {
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                                playWebAudioSound(sounds.rune_drop);
                            }
                        }

                        enemies = enemies.filter(en => en !== enemy);
                        enemiesHit++;
                    }
                    totalDamage += damage;
                }
            }
        }
    } else {
        // Regular sword attack
        const damage = p.atk; // Remove armor bonus
        hit.hp -= damage;
        logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG (HP: ${hit.hp})`);
        playWebAudioSound(sounds.hit);
if (hit.hp <= 0) {
    kills[hit.type.name]++;
    let dropPlaced = false;
    
// Handle unique monster rewards using new function
handleUniqueMonsterReward(hit);

        // Normal enemy reward
        if (map[hit.y][hit.x] === 0) {
            map[hit.y][hit.x] = 3;
            satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
            dropPlaced = true;
        } else {
            const adjacent = [
                {x: hit.x, y: hit.y - 1},
                {x: hit.x, y: hit.y + 1},
                {x: hit.x - 1, y: hit.y},
                {x: hit.x + 1, y: hit.y}
            ];
            for (const pos of adjacent) {
                const nx = pos.x, ny = pos.y;
                if (
                    nx >= 0 && nx < W && ny >= 0 && ny < H &&
                    map[ny][nx] === 0 &&
                    !enemies.some(e => e.x === nx && e.y === ny)
                ) {
                    map[ny][nx] = 3;
                    satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                    dropPlaced = true;
                    break;
                }
            }
        }
        if (!dropPlaced) {
            // No space for satoshi drop
        }

            // Soul stone drop logic (5% chance)
            if (Math.random() < 0.05) {
                let stonePlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 20; // Soul stone tile
                    stonePlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 20; // Soul stone tile
                            stonePlaced = true;
                            break;
                        }
                    }
                }
                if (stonePlaced) {
                    p.soulStones++;
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a Soul Stone!`);
                    playWebAudioSound(sounds.buzz);
                }
            }

            // Scroll drop logic (1 in 25 chance, only if no scroll has dropped this floor)
            if (!scrollDroppedThisFloor && Math.random() < 1/25) {
                let scrollPlaced = false;
                scrollDroppedThisFloor = true; // Mark scroll as dropped for this floor
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 11; // Scroll tile
                    scrollDrops.push({ x: hit.x, y: hit.y });
                    scrollPlaced = true;
                } else {
                    const adjacent = [
                        { x: hit.x, y: hit.y - 1 },
                        { x: hit.x, y: hit.y + 1 },
                        { x: hit.x - 1, y: hit.y },
                        { x: hit.x + 1, y: hit.y }
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny) &&
                            !scrollDrops.some(s => s.x === nx && s.y === ny)
                        ) {
                            map[ny][nx] = 11; // Scroll tile
                            scrollDrops.push({ x: nx, y: ny });
                            scrollPlaced = true;
                            break;
                        }
                    }
                }
                if (scrollPlaced) {
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a scroll!`);
                    playWebAudioSound(sounds.pickup);
                }
            }

            // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
            if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                let runeLetter;
                if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                    // Hell Shrimp: Use specific rune letters
                    const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                    runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                } else {
                    // Regular rune drop
                    const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                    runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                }
                let runePlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 8; // Generic rune on floor
                    runeDrops.push({ x: hit.x, y: hit.y, letter: runeLetter });
                    runePlaced = true;
                } else {
                    const adjacent = [
                        { x: hit.x, y: hit.y - 1 },
                        { x: hit.x, y: hit.y + 1 },
                        { x: hit.x - 1, y: hit.y },
                        { x: hit.x + 1, y: hit.y }
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 8; // Generic rune on floor
                            runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                            runePlaced = true;
                            break;
                        }
                    }
                }
                if (runePlaced) {
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                    playWebAudioSound(sounds.rune_drop);
                }
            }

            enemies = enemies.filter(en => en !== hit);
        }
    }
} else if (initialPickaxes > 0 && isWallNearby) {
    p.pickaxes--;
    sounds.secret.play().catch(e => console.error('Secret sound error:', e));
    logBattleEvent(`Floor ${floor} - Wall Broken!`);
    createSecretRoom(sx, sy, p.x, p.y, swordDir);
}

    }
    
// Add soul storm charge consumption for each attack
if (p.soulStormCharges >= 4 && !p.hasDiamondHand && projectiles.length === 0 && !usePickaxeSword) {
    // Consume 4 charges for this attack
    p.soulStormCharges -= 4;
    activateSoulStorm();
    
    // Continue with regular projectile logic only for normal sword attacks (not diamond hand or pickaxe sword)
    // Check if player is standing adjacent to an enemy - prevent projectiles when adjacent
    let isAdjacentToEnemy = false;
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    
    // Check if there's an enemy one tile away in the sword direction
    if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
        isAdjacentToEnemy = enemies.some(e => e.x === sx && e.y === sy);
    }
    
    // Also check if player is standing directly adjacent to ANY enemy
    let isNearEnemy = false;
    const adjacentPositions = [
        {x: p.x, y: p.y - 1}, // Up
        {x: p.x, y: p.y + 1}, // Down
        {x: p.x - 1, y: p.y}, // Left
        {x: p.x + 1, y: p.y}  // Right
    ];
    
    for (const pos of adjacentPositions) {
        if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H) {
            if (enemies.some(e => e.x === pos.x && e.y === pos.y)) {
                isNearEnemy = true;
                break;
            }
        }
    }
    
    // Only shoot projectiles if not standing adjacent to an enemy
    // This prevents projectile shooting when player is within 1 tile of enemy (snugging)
    if (!isAdjacentToEnemy && !isNearEnemy) {
        let startSx = p.x, startSy = p.y; // Start at player's position
        if (startSx >= 0 && startSx < W && startSy >= 0 && startSy < H) {
            projectiles.push({ x: startSx, y: startSy, dir: swordDir, startTime: Date.now(), lastMoveTime: Date.now() });
            sounds.shoot_sword.pause();
            sounds.shoot_sword.currentTime = 0;
            sounds.shoot_sword.play().catch(e => console.error('Shoot sword sound error:', e));
        }
    }
} else if (!p.hasDiamondHand && p.hp >= 24 && projectiles.length === 0 && !usePickaxeSword) {
    // Check if player is standing adjacent to an enemy - prevent projectiles when adjacent
    let isAdjacentToEnemy = false;
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    
    // Check if there's an enemy one tile away in the sword direction
    if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
        isAdjacentToEnemy = enemies.some(e => e.x === sx && e.y === sy);
    }
    
    // Also check if player is standing directly adjacent to ANY enemy
    let isNearEnemy = false;
    const adjacentPositions = [
        {x: p.x, y: p.y - 1}, // Up
        {x: p.x, y: p.y + 1}, // Down
        {x: p.x - 1, y: p.y}, // Left
        {x: p.x + 1, y: p.y}  // Right
    ];
    
    for (const pos of adjacentPositions) {
        if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H) {
            if (enemies.some(e => e.x === pos.x && e.y === pos.y)) {
                isNearEnemy = true;
                break;
            }
        }
    }
    
    // Only shoot projectiles if not standing adjacent to an enemy
    // This prevents projectile shooting when player is within 1 tile of enemy (snugging)
    if (!isAdjacentToEnemy && !isNearEnemy) {
        let startSx = p.x, startSy = p.y; // Start at player's position
        if (startSx >= 0 && startSx < W && startSy >= 0 && startSy < H) {
            projectiles.push({ x: startSx, y: startSy, dir: swordDir, startTime: Date.now(), lastMoveTime: Date.now() });
            sounds.shoot_sword.pause();
            sounds.shoot_sword.currentTime = 0;
            sounds.shoot_sword.play().catch(e => console.error('Shoot sword sound error:', e));
        }
    }
}
    
    moveEnemies();
    needsRedraw = true;
    setTimeout(() => {
        swordActive = false;
        usePickaxeSword = false;
        highlightTiles = []; // Clear highlights after flash
        needsRedraw = true;
    }, 200);
}

function usePotion() {
    if (gameOver || splashActive || p.potions <= 0) return;
    if (p.hp >= 24) {
        logBattleEvent(`Floor ${floor} - Potion Returned: HP already at ${p.hp}!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Refund potion by not decrementing p.potions
    }
    p.potions--;
    const oldHP = p.hp;
    p.hp = Math.min(24, p.hp + 12);
    logBattleEvent(`Floor ${floor} - Potion Used: +${p.hp - oldHP} HP (now ${p.hp})`);
    sounds.potion.play().catch(e => console.error('Potion sound error:', e));
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

// Add these functions near the other utility functions
function openSoulTerminal() {
    if (p.inSoulTerminal) return; // Already in terminal
    
    p.inSoulTerminal = true;
    p.soulTerminalActive = true;
    p.soulTerminalCommand = '';
    p.soulTerminalCursorPos = 0;
    
    // Show soul terminal overlay
    const overlay = document.getElementById('soul-terminal-overlay');
    const content = document.getElementById('soul-terminal-content');
    const input = document.getElementById('soul-terminal-input');
    
    // Clear content and add welcome message
    content.innerHTML = '';
    addTerminalLineToContent('Welcome to Soul Terminal!');
    addTerminalLineToContent('Type "help" for available commands.');
    updateSoulTerminalInventory();
    
    // Show overlay and focus input
    overlay.style.display = 'flex';
    setTimeout(() => {
        input.focus();
    }, 100);
}

function closeSoulTerminal() {
    p.inSoulTerminal = false;
    p.soulTerminalActive = false;
    p.soulTerminalCommand = '';
    p.soulTerminalCursorPos = 0;
    
    // Hide soul terminal overlay
    const overlay = document.getElementById('soul-terminal-overlay');
    overlay.style.display = 'none';
    
    // Restore input control
    inputBlocked = false;
    
    // Ensure player is properly positioned after terminal exit
    // This prevents teleportation issues when exiting soul terminal
    updateFogMap(p.x, p.y);
    
    needsRedraw = true;
}

function addTerminalLine(line) {
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value += line + '\n';
    battleEvents.scrollTop = battleEvents.scrollHeight;
}

function addTerminalLineToContent(line) {
    const content = document.getElementById('soul-terminal-content');
    const lineElement = document.createElement('div');
    lineElement.textContent = line;
    content.appendChild(lineElement);
    content.scrollTop = content.scrollHeight;
}

function updateSoulTerminalInventory() {
checkRunewords();
//    addTerminalLineToContent('');
            const clearContent = document.getElementById('soul-terminal-content');
            clearContent.innerHTML = '';
            addTerminalLineToContent('Soul Terminal ver 1.0');
            addTerminalLineToContent('');  
    // Display soul-related items
    addTerminalLineToContent('--- Soul Inventory ---');
    addTerminalLineToContent(`Soul Stones: ${p.soulStones}`);
    addTerminalLineToContent(`Soul Shards: ${p.soulShards}`);
    addTerminalLineToContent(`Soul Orbs: ${p.soulOrbs}`);
    addTerminalLineToContent(`Soul Storm Charges: ${p.soulStormCharges}/256`);
    addTerminalLineToContent('');
    
// Display resistances (elemental and armor)
let resistanceText = '';
if (p.elementImmunity) {
    resistanceText += `${p.elementImmunity} 100%`;
}
if (p.armorImmunity) {
    if (resistanceText) resistanceText += ', ';
    resistanceText += `${p.armorImmunity} 100%`;
}
if (resistanceText) {
    addTerminalLineToContent(`Resistances: ${resistanceText}`);
    addTerminalLineToContent('');
}
    
    // Display regular inventory items
    addTerminalLineToContent('--- Regular Inventory ---');
    addTerminalLineToContent(`Health: ${p.hp}`);
    addTerminalLineToContent(`Potions: ${p.potions}`);
    addTerminalLineToContent(`Pickaxes: ${p.pickaxes}`);
    addTerminalLineToContent(`Diamonds: ${diamonds}`);
    addTerminalLineToContent(`Perfectly Cut Diamonds: ${document.getElementById('perfectlyCutDiamonds').textContent}`);
    //addTerminalLineToContent(`Runes: ${document.getElementById('runes').textContent}`); // all runes
    // Get runes text and filter out runes ending with 0 (like p0)
    let runesText = document.getElementById('runes').textContent;
    let displayRunes = 'None'; // Default to 'None' if no runes remain
    if (runesText) {
        // Split by spaces and filter out runes ending with 0
        const runeArray = runesText.split(/\s+/).filter(rune => rune && !rune.endsWith('0'));
        if (runeArray.length > 0) {
            displayRunes = runeArray.join(' ');
        }
    }
    addTerminalLineToContent(`Runes: ${displayRunes}`);
    addTerminalLineToContent('');
//    addTerminalLineToContent('--- Audio Settings ---');
//    addTerminalLineToContent(`Sound Volume: ${(soundVolume * 100).toFixed(0)}%`);
//    addTerminalLineToContent(`Music Volume: ${(musicVolume * 100).toFixed(0)}%`);
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
}

function processSoulCommand(command) {
    const trimmed = command.trim();
    
    if (trimmed === '') return;
    
    // Clear screen before executing any command (always)
    const content = document.getElementById('soul-terminal-content');
    content.innerHTML = '';
            addTerminalLineToContent('Soul Terminal ver 1.0');
            addTerminalLineToContent('');
    // Parse command and arguments
    const parts = trimmed.split(' ');
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1);
    
    switch (cmd) {
case 'ls':
            updateSoulTerminalInventory();
            break;
case 'clear':
            const clearContent = document.getElementById('soul-terminal-content');
            // Check if there are arguments after 'clear'
            if (args.length > 0) {
                // Join all arguments with spaces to create the ASCII art text
                const asciiText = args.join(' ');
                // Create a simple ASCII art effect by displaying each character
                clearContent.innerHTML = '';
                addTerminalLineToContent(asciiText.padEnd(54));
            } else {
                clearContent.innerHTML = '';
            }
            break;
        case 'exit':
            closeSoulTerminal();
            return;
case 'help':
    addTerminalLineToContent('Available commands:');
    addTerminalLineToContent('  ls ---------- View inventory');
    addTerminalLineToContent('  convert ----- Convert soul items');
    addTerminalLineToContent('  set --------- Settings');
    addTerminalLineToContent('  clear ------- Clear screen');
    addTerminalLineToContent('  leaderboard - View top 10 scores');
    addTerminalLineToContent('  exit -------- Exit terminal');
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
case 'convert':
            if (args.length === 0) {
                addTerminalLineToContent('Usage: convert stones');
                addTerminalLineToContent('Usage: convert shards');
                addTerminalLineToContent('_____________________');
                addTerminalLineToContent('Type "help" for help.');
            } else {
                const type = args[0].toLowerCase();
                let count = 1; // Default to 1 if no count specified
                
                // Check if a count was provided (second argument)
                if (args.length > 1 && !isNaN(args[1])) {
                    count = parseInt(args[1]);
                }
                
                switch (type) {
                    case 'stones':
                        const maxStonesToConvert = Math.floor(p.soulStones / 3) * 3; // Ensure we convert in multiples of 3
                        if (args.length > 1 && !isNaN(args[1])) {
                            count = Math.min(count, maxStonesToConvert);
                        } else {
                            count = maxStonesToConvert;
                        }
                        
                        if (count >= 3) {
                            const shardsToGain = Math.floor(count / 3);
                            p.soulStones -= count;
                            p.soulShards += shardsToGain;
                            addTerminalLineToContent(`Converted ${count} Soul Stones into ${shardsToGain} Soul Shards.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else if (p.soulStones >= 3) {
                            // If no count specified or count < 3, convert minimum
                            p.soulStones -= 3;
                            p.soulShards++;
                            addTerminalLineToContent('Converted 3 Soul Stones into 1 Soul Shard.');
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else {
                            addTerminalLineToContent(`Need at least 3 Soul Stones, you have ${p.soulStones}.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        }
                        break;
                    case 'shards':
                        const maxShardsToConvert = Math.floor(p.soulShards / 2) * 2; // Ensure we convert in multiples of 2
                        if (args.length > 1 && !isNaN(args[1])) {
                            count = Math.min(count, maxShardsToConvert);
                        } else {
                            count = maxShardsToConvert;
                        }
                        
                        if (count >= 2) {
                            const orbsToGain = Math.floor(count / 2);
                            p.soulShards -= count;
                            p.soulOrbs += orbsToGain;
                            addTerminalLineToContent(`Converted ${count} Soul Shards into ${orbsToGain} Soul Orbs.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else if (p.soulShards >= 2) {
                            // If no count specified or count < 2, convert minimum
                            p.soulShards -= 2;
                            p.soulOrbs++;
                            addTerminalLineToContent('Converted 2 Soul Shards into 1 Soul Orb.');
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else {
                            addTerminalLineToContent(`Need at least 2 Soul Shards, you have ${p.soulShards}.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        }
                        break;
                    default:
                        addTerminalLineToContent('ERROR!');
                        addTerminalLineToContent('Usage: convert stones');
                        addTerminalLineToContent('Usage: convert shards');
                        addTerminalLineToContent('_____________________');
    	                addTerminalLineToContent('Type "help" for help.');
                }
            }
            break;
case 'set':
    if (args.length === 0) {
        addTerminalLineToContent('Settings:');
        addTerminalLineToContent('  set sound ------ Control sound volume');
        addTerminalLineToContent('  set music ------ Control music volume');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
    } else {
        const subCmd = args[0].toLowerCase();
        switch (subCmd) {
            case 'sound':
                if (args.length < 2) {
                    addTerminalLineToContent('Usage: set sound [volume]');
                    addTerminalLineToContent('Example: set sound 50');
                } else {
                    const volume = parseFloat(args[1]);
                    if (isNaN(volume) || volume < 0 || volume > 100) {
                        addTerminalLineToContent('ERROR!');
                        addTerminalLineToContent('Usage: set sound [volume]');
                        addTerminalLineToContent('Example: set sound 50');
                        addTerminalLineToContent('_____________________');
                        addTerminalLineToContent('Type "help" for help.');
                    } else {
                        setSoundVolume(volume / 100);
                        addTerminalLineToContent(`Sound volume set to ${(soundVolume * 100).toFixed(0)}%`);
                        addTerminalLineToContent('_____________________');
                        addTerminalLineToContent('Type "help" for help.');
                    }
                }
                break;
            case 'music':
                if (args.length < 2) {
                    addTerminalLineToContent('Usage: set music [volume]');
                    addTerminalLineToContent('Example: set music 75');
                } else {
                    const volume = parseFloat(args[1]);
                    if (isNaN(volume) || volume < 0 || volume > 100) {
                        addTerminalLineToContent('ERROR!');
                        addTerminalLineToContent('Usage: set music [volume]');
                        addTerminalLineToContent('Example: set music 75');
                        addTerminalLineToContent('_____________________');
                        addTerminalLineToContent('Type "help" for help.');
                    } else {
                        setMusicVolume(volume / 100);
                        addTerminalLineToContent(`Music volume set to ${(musicVolume * 100).toFixed(0)}%`);
                        addTerminalLineToContent('_____________________');
                        addTerminalLineToContent('Type "help" for help.');
                    }
                }
                break;
            default:
                addTerminalLineToContent('ERROR!');
                addTerminalLineToContent('Available commands:');
                addTerminalLineToContent('  Usage: set sound       - Control sound volume');
                addTerminalLineToContent('  Usage: set music       - Control music volume');
                addTerminalLineToContent('_____________________');
                addTerminalLineToContent('Type "help" for help.');
        }
    }
        break;
case 'leaderboard':
    if (!cachedLeaderboard || cachedLeaderboard.length === 0) {
        addTerminalLineToContent('No cached leaderboard available. Play more to fetch!');
    } else {
        const leaderboardTotalSats = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
        const displayedMultText = document.getElementById('sats-calc').textContent.trim();
        const multMatch = displayedMultText.match(/:\s*([\d.]+)\s*(sats|BTC)/);
        const leaderboardPlayerScore = multMatch ? (multMatch[2] === 'BTC' ? parseFloat(multMatch[1]) * 1e8 : parseInt(multMatch[1])) : leaderboardTotalSats;
        const playerEst = getPlayerEstimatedRank(cachedLeaderboard, leaderboardTotalSats, floor);
        
        // Format cached list with player inserted
        const maxUsernameLength = 20;
        const numberWidth = 10;
        
        let rows = cachedLeaderboard.slice(0, 10).map((entry, index) => {
            const rank = (index + 1).toString().padStart(2, '0');
            const username = entry.username.length > maxUsernameLength
                ? entry.username.substring(0, maxUsernameLength - 2) + '..'
                : entry.username;
            const scoreValue = entry.score;
            let numberPart, unitPart;
            if (scoreValue >= 1e8) {
                numberPart = (scoreValue / 1e8).toFixed(1);
                unitPart = 'BTC';
            } else {
                numberPart = scoreValue.toString();
                unitPart = 'sats';
            }
            return `Rank: ${rank}, ${username}, ${numberPart} ${unitPart}`;
        });
        
        // Insert player at estimated rank if in top 10
        const playerUsername = 'You';
        let playerNumberPart, playerUnitPart;
        if (leaderboardPlayerScore >= 1e8) {
            playerNumberPart = (leaderboardPlayerScore / 1e8).toFixed(1);
            playerUnitPart = 'BTC';
        } else {
            playerNumberPart = leaderboardPlayerScore.toString();
            playerUnitPart = 'sats';
        }
        const playerRow = `Rank: ${playerEst.rank.toString().padStart(2, '0')}, ${playerUsername}, ${playerNumberPart} ${playerUnitPart}`;
        
        if (playerEst.rank <= 10) {
            rows.splice(playerEst.rank - 1, 0, playerRow); // Insert at rank (shifts others down)
            rows = rows.slice(0, 10); // Limit to top 10 including player
        }
        
        // Format for display (no header)
        let fullText = `Top 10 scores (leaderboard)`;
        rows.forEach(row => {
            fullText += `\n${row}`;
        });
        
        if (playerEst.rank > 10) {
            const estRow = `Rank: ??, ${playerUsername}, ${playerNumberPart} ${playerUnitPart}`;
            fullText += `\n${estRow}`;
        }
        
        const lines = fullText.split('\n');
        lines.forEach(line => addTerminalLineToContent(line));
    }
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
        default:
            addTerminalLineToContent(`Command not found: ${cmd}`);
            addTerminalLineToContent('_____________________');
            addTerminalLineToContent('Type "help" for help.');
    }
}

function activateSoulStorm() {
    // Create a horizontal wave of 3 tiles that lights up with soul light
    const damageArea = [];
    
    // Determine damage tiles based on direction
    if (swordDir === 'up') {
        const close_y = p.y - 1;
        const far_y = p.y - 2;
        for (let dx = -1; dx <= 1; dx++) {
            damageArea.push({x: p.x + dx, y: close_y});
        }
        for (let dx = -2; dx <= 2; dx++) {
            damageArea.push({x: p.x + dx, y: far_y});
        }
    } else if (swordDir === 'down') {
        const close_y = p.y + 1;
        const far_y = p.y + 2;
        for (let dx = -1; dx <= 1; dx++) {
            damageArea.push({x: p.x + dx, y: close_y});
        }
        for (let dx = -2; dx <= 2; dx++) {
            damageArea.push({x: p.x + dx, y: far_y});
        }
    } else if (swordDir === 'left') {
        const close_x = p.x - 1;
        const far_x = p.x - 2;
        for (let dy = -1; dy <= 1; dy++) {
            damageArea.push({x: close_x, y: p.y + dy});
        }
        for (let dy = -2; dy <= 2; dy++) {
            damageArea.push({x: far_x, y: p.y + dy});
        }
    } else if (swordDir === 'right') {
        const close_x = p.x + 1;
        const far_x = p.x + 2;
        for (let dy = -1; dy <= 1; dy++) {
            damageArea.push({x: close_x, y: p.y + dy});
        }
        for (let dy = -2; dy <= 2; dy++) {
            damageArea.push({x: far_x, y: p.y + dy});
        }
    }
    
    // Apply damage to all valid tiles in the area
    const damage = 1; // 1 damage per hit
    let enemiesHit = 0;
    let totalDamage = 0;
    
    highlightTiles = []; // Clear previous highlights
    for (const tile of damageArea) {
        const {x, y} = tile;
        
        // Check if tile is within bounds and not a wall
        if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 1) {
            highlightTiles.push({x, y, highlightStart: Date.now()}); // Add tile to highlight
            
            // Check if there's an enemy at this tile
            const enemy = enemies.find(e => e.x === x && e.y === y);
            
            if (enemy) {
                // Apply damage to enemy
                enemy.hp -= damage;
                logBattleEvent(`Soul Storm hits ${enemy.type.name} for ${damage} DMG`);
                
                if (enemy.hp <= 0) {
                    kills[enemy.type.name]++;
                    handleUniqueMonsterReward(enemy);
                    let dropPlaced = false;
                    
                    // Drop satoshi
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 3;
                        satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                        dropPlaced = true;
                    } else {
                        const adjacent = [
                            {x: enemy.x, y: enemy.y - 1},
                            {x: enemy.x, y: enemy.y + 1},
                            {x: enemy.x - 1, y: enemy.y},
                            {x: enemy.x + 1, y: enemy.y}
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 3;
                                satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                                dropPlaced = true;
                                break;
                            }
                        }
                    }
                    
                    enemies = enemies.filter(en => en !== enemy);
                    enemiesHit++;
                }
                totalDamage += damage;
            }
        }
    }
    
    if (enemiesHit > 0) {
        logBattleEvent(`Soul Storm hit ${enemiesHit} enemies for ${totalDamage} total damage!`);
    } else {
        logBattleEvent('Soul Storm hits empty space!');
    }
}

function handleTerminalInput(e) {
    const key = e.key;
    
    // If terminal is not focused, focus it and add the key
    if (!document.activeElement.matches('#soul-terminal-input')) {
        const input = document.getElementById('soul-terminal-input');
        input.focus();
        input.value = p.soulTerminalCommand; // Update value to reflect current command
        
        // Handle key press immediately
        if (key.length === 1 && key !== 'Enter') {
            const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
            const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
            p.soulTerminalCommand = before + key + after;
            p.soulTerminalCursorPos++;
            input.value = p.soulTerminalCommand.substring(1); // One-liner hack to remove first character
        }
        
        return;
    }
    
    if (key === 'Enter') {
        e.preventDefault();
        processSoulCommand(p.soulTerminalCommand);
        p.soulTerminalCommand = '';
        p.soulTerminalCursorPos = 0;
        // Blur the input field when Enter is pressed
        const input = document.getElementById('soul-terminal-input');
        if (input) {
            input.blur();
        }
        return;
    }
    
    if (key === 'Backspace') {
        if (p.soulTerminalCursorPos > 0) {
            p.soulTerminalCommand = 
                p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos - 1) + 
                p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
            p.soulTerminalCursorPos--;
        }
        return;
    }
    
    if (key === 'ArrowLeft' && p.soulTerminalCursorPos > 0) {
        p.soulTerminalCursorPos--;
        return;
    }
    
    if (key === 'ArrowRight' && p.soulTerminalCursorPos < p.soulTerminalCommand.length) {
        p.soulTerminalCursorPos++;
        return;
    }
    
    // Add regular character
    if (key.length === 1 && key !== 'Enter') {
        const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
        const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
        p.soulTerminalCommand = before + key + after;
        p.soulTerminalCursorPos++;
    }
}

// Add this function to handle terminal input when not focused
function handleBlurredTerminalInput(key) {
    const input = document.getElementById('soul-terminal-input');
    if (input && !input.matches(':focus')) {
        // Focus the input field
        input.focus();
        
        // Update command with new key
        const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
        const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
        p.soulTerminalCommand = before + key + after;
        p.soulTerminalCursorPos++;
        
        // Update display
        input.value = p.soulTerminalCommand.substring(1);
    }
}

// Function to create dangerous spell area (called when unique monster uses a spell)
function createDangerousArea(x, y, spellType) {
    // Add the dangerous area to the array
    dangerousAreas.push({
        x: x,
        y: y,
        spellType: spellType
    });
    
    // Draw immediate visual feedback
    needsRedraw = true;
}

// Function to remove dangerous areas when a unique monster dies
function removeDangerousAreas(monster) {
    if (!monster.uniqueName || !monster.spell) return;
    
    // Remove all dangerous areas that match this spell type
    dangerousAreas = dangerousAreas.filter(area => area.spellType !== monster.spell);
    
    // Redraw to reflect changes
    needsRedraw = true;
}

function cleanupEventListeners() {
    // Clear any existing intervals
    if (touchMoveInterval) {
        clearInterval(touchMoveInterval);
        touchMoveInterval = null;
    }
    if (touchTimeout) {
        clearTimeout(touchTimeout);
        touchTimeout = null;
    }
    
    // Clear existing touch listeners from dpad buttons
    dpadButtons.forEach(button => {
        button.classList.remove('pressed');
        // Remove all event listeners for each button
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
            button._touchstartHandler = null;
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
            button._touchendHandler = null;
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
            button._touchcancelHandler = null;
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
            button._clickHandler = null;
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
            button._contextmenuHandler = null;
        }
    });

    // Clear existing touch listeners from actions buttons
    actionsButtons.forEach(button => {
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
            button._touchstartHandler = null;
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
            button._touchendHandler = null;
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
            button._touchcancelHandler = null;
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
            button._clickHandler = null;
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
            button._contextmenuHandler = null;
        }
    });
    
    // Clear existing touch listeners from gamepad buttons
    if (gamepadIndex !== null && navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        if (gamepads[gamepadIndex]) {
            const gamepad = gamepads[gamepadIndex];
            if (gamepad.buttons && gamepad.buttons.length > 0) {
                // Remove event listeners from gamepad buttons
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    if (gamepad.buttons[i]._clickHandler) {
                        gamepad.buttons[i].removeEventListener('click', gamepad.buttons[i]._clickHandler);
                        gamepad.buttons[i]._clickHandler = null;
                    }
                }
            }
        }
    }
    
    // Clear existing event listeners from document
    if (document._keydownHandler) {
        document.removeEventListener('keydown', document._keydownHandler);
        document._keydownHandler = null;
    }
    if (document._keyupHandler) {
        document.removeEventListener('keyup', document._keyupHandler);
        document._keyupHandler = null;
    }

    // Clear keyboard movement interval
    if (keyboardMovementTimer) {
        clearInterval(keyboardMovementTimer);
        keyboardMovementTimer = null;
    }
    if (document._touchstartHandler) {
        document.removeEventListener('touchstart', document._touchstartHandler);
        document._touchstartHandler = null;
    }
    if (document._touchmoveHandler) {
        document.removeEventListener('touchmove', document._touchmoveHandler);
        document._touchmoveHandler = null;
    }
    if (document._touchendHandler) {
        document.removeEventListener('touchend', document._touchendHandler);
        document._touchendHandler = null;
    }
    if (document._gamepadConnectedHandler) {
        window.removeEventListener('gamepadconnected', document._gamepadConnectedHandler);
        document._gamepadConnectedHandler = null;
    }
    if (document._gamepadDisconnectedHandler) {
        window.removeEventListener('gamepaddisconnected', document._gamepadDisconnectedHandler);
        document._gamepadDisconnectedHandler = null;
    }
}

/* ------------------------------------------------------------------
   Enhanced touch controls with 200ms movement delay
   ------------------------------------------------------------------ */
function initTouchControls() {
    let activeTouchId = null;
    let currentTouchDir = null;
    let isMoving = false;
    let lastMoveTime = 0;

    // Use the global dpadButtons
    dpadButtons.forEach(button => {
        button._touchstartHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (inputBlocked || splashActive || gameOver) return;

            const touch = e.changedTouches[0];
            if (!activeTouchId) {
                activeTouchId = touch.identifier;
                button.classList.add('pressed');
                currentTouchDir = button.id;
                isMoving = true;

                // Start continuous movement with 200ms delay
                const moveLoop = () => {
                    if (isMoving && currentTouchDir && !inputBlocked && !gameOver) {
                        const now = Date.now();
                        if (now - lastMoveTime >= 200) { // Enforce 200ms delay
                            move(currentTouchDir);
                            lastMoveTime = now;
                        }
                        requestAnimationFrame(moveLoop);
                    }
                };
                requestAnimationFrame(moveLoop);
            }
        };

        button._touchmoveHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            // Keep touch active but don't trigger move
            const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
            if (touch && currentTouchDir && !inputBlocked && !gameOver) {
                // No move call here; let moveLoop handle movement
            }
        };

        button._touchendHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.changedTouches[0];
            if (touch.identifier === activeTouchId) {
                button.classList.remove('pressed');
                activeTouchId = null;
                currentTouchDir = null;
                isMoving = false;
            }
        };

        button._touchcancelHandler = button._touchendHandler;
        button._contextmenuHandler = function (e) { 
            e.preventDefault(); 
            e.stopPropagation();
        };
        button._clickHandler = function (e) { 
            e.preventDefault(); 
            e.stopPropagation();
        };

        // Remove existing listeners and add new ones
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
        }
        if (button._touchmoveHandler) {
            button.removeEventListener('touchmove', button._touchmoveHandler);
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
        }

        button.addEventListener('touchstart', button._touchstartHandler, { passive: false });
        button.addEventListener('touchmove', button._touchmoveHandler, { passive: false });
        button.addEventListener('touchend', button._touchendHandler, { passive: false });
        button.addEventListener('touchcancel', button._touchcancelHandler, { passive: false });
        button.addEventListener('contextmenu', button._contextmenuHandler, { passive: false });
        button.addEventListener('click', button._clickHandler, { passive: false });
    });

    /* Clean up on restart */
    document.addEventListener('restart', () => {
        dpadButtons.forEach(button => {
            button.classList.remove('pressed');
            if (button._touchstartHandler) button.removeEventListener('touchstart', button._touchstartHandler);
            if (button._touchmoveHandler) button.removeEventListener('touchmove', button._touchmoveHandler);
            if (button._touchendHandler) button.removeEventListener('touchend', button._touchendHandler);
            if (button._touchcancelHandler) button.removeEventListener('touchcancel', button._touchcancelHandler);
            if (button._clickHandler) button.removeEventListener('click', button._clickHandler);
            if (button._contextmenuHandler) button.removeEventListener('contextmenu', button._contextmenuHandler);
        });
        activeTouchId = null;
        currentTouchDir = null;
        isMoving = false;
        lastMoveTime = 0;
        initTouchControls(); // Re-attach listeners
    });
}

/* ------------------------------------------------------------------
   Restart the game – reset state & re‑initialise listeners
   ------------------------------------------------------------------ */
function restart() {

    /* ------------------------------------------------------------------
       1. Clean up old listeners/timers
       ------------------------------------------------------------------ */
    cleanupEventListeners();
    document.dispatchEvent(new Event('restart')); // Trigger custom restart event

    // Reset fetch flag
    isFetchingTxs = false;
    
    /* ------------------------------------------------------------------
       2. Reset all game state variables
       ------------------------------------------------------------------ */
    floor = 1;
    inHideout = false;
    previousFloorState = null;
    jewellerPos = null;
    blacksmithPos = null;
    waypointPos = null;
    p.hasDiamondArmor = false;
    p.hasDiamondHand = false;
    p.perfectlyCutDiamonds = 0;
    // Reset soul items
    p.soulStones = 0;
    p.soulShards = 0;
    p.soulOrbs = 0;
    p.soulStormCharges = 0;
    // Reset shrine tracking
    p.shrineCharges = 0;
    p.shrineUsedThisFloor = false;
    currentTheme = 'dungeon';            // default theme
    p.maxHP = 24;                       // default max HP
    document.documentElement.style.setProperty('--text-color', '#ff8c00'); // orange
    wave = 1;
    document.getElementById('wave').textContent = wave;
    p.hp = 36;
    p.potions = 0;
    p.pickaxes = 0;
    diamonds = 0;
    p.hasArmor = true;
    p.armorImmunity = null; // Reset armor immunity on restart
    
    p.runes = [];
    runeDrops = runeDrops.filter(r => !r.specific);			// maybe
    for (let y = 0; y < H; y++) {					// \
        for (let x = 0; x < W; x++) {					//  \
            if (map[y][x] === 9) {					//   \
                map[y][x] = 0; // Clear specific rune tiles		//    \
            }								//     \
        }								//      \
    }									//       overkill
    
    p.x = 2;
    p.y = 2;
    p.atk = 2;
    enemies = [];
    map = [];
    rooms = [];
    exit = null;
    gameOver = false;
    gameOverSoundPlayed = false;
    autoSubmitTriggered = false;
enemiesSpawnedThisFloor = 0;
uniqueMonstersSpawnedThisFloor = 0; // Reset unique monster spawn counter
whalesSpawnedThisFloor = 0;
scrollDroppedThisFloor = false;
initialSpawnDoneThisFloor = false;
initialWaveSpawned = false;
waveActive = false;
    nextApiCallTime = null;
    whaleHashIds = ['Whale Transactions:'];
    battleLog = [];
    killsLog = [];
    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    satoshiDrops = [];
    scrollDrops = [];
    portals = [];
    swordDir = 'right';
    swordActive = false;
    swordStart = 0;
    fogMap = [];
    scoreSubmitted = false;
    hasPlayedOnce = true;  // allow the "Enter" key to start the next game
    projectiles = []; // Add this line to reset projectiles array on restart
    populateNameList();
    
// Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

        musicManager.mute(musicMuted); // Ensure proper mute state from localStorage
        // Set initial volumes
        setSoundVolume(soundVolume);
        setMusicVolume(musicVolume);
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }
    
    // Set music volume to 0 when restarting
    if (musicManager.current) {
        const currentAudio = musicManager.audios[musicManager.current];
        if (currentAudio) {
            currentAudio.volume = 0;
        }
    }

    /* ------------------------------------------------------------------
       3. Reset UI elements
       ------------------------------------------------------------------ */
    const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
    whaleHashIdsDiv.innerHTML = ''; // clear
    const newDiv = document.createElement('div');
    newDiv.innerHTML = whaleHashIds.join('<br>');
    whaleHashIdsDiv.appendChild(newDiv);
    const whaleLog = document.getElementById('whale-log');
    whaleLog.scrollTop = whaleLog.scrollHeight;

    document.getElementById('battle-events').value = '';
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    document.getElementById('health').textContent = p.hp;
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('sats').textContent = '0';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('submit-score').style.display = 'none';
    document.getElementById('view-leaderboard').style.display = 'none';
    document.getElementById('restart-game').style.display = 'none';
    document.getElementById('username-input').value = '';
    document.getElementById('leaderboard-output').textContent = '';
    document.getElementById('leaderboard-output').style.display = 'none';
    document.getElementById('submit-score').disabled = false;
    document.getElementById('submit-score').style.background = '#ff8c00';
    document.getElementById('splash-screen').style.display = 'block';

    /* ------------------------------------------------------------------
       4. Re-initialize button variables and touch listeners
       ------------------------------------------------------------------ */
    // Re-initialize button variables properly
    dpadButtons = document.querySelectorAll('#dpad button');
    actionsButtons = document.querySelectorAll('#actions button');
    
    // Cleanup old listeners first
    cleanupEventListeners();
    
    // Re-initialize touch controls
    initTouchControls(); // Re-initialize touch controls
    
    /* ------------------------------------------------------------------
       5. Reset audio & gamepad polling
       ------------------------------------------------------------------ */
    if (apiTimeoutId) clearTimeout(apiTimeoutId);
    if (movementTimer) clearInterval(movementTimer);
    movementTimer = null;
    gamepadMoveDir = null;
    gamepadLastMoveTime = 0;
    lastButtonsState = [];
    if (gamepadIndex !== null) {
        // Check for gamepad at restart
        if (navigator.getGamepads) {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepadIndex = i;
                    console.log('Gamepad detected at restart:', gamepads[i].id);
                    break;
                }
            }
        }
        gamepadPollingActive = true;
        if (!movementTimer) {
            movementTimer = setInterval(() => {
                if (!splashActive && !gameOver && gamepadMoveDir) {
                    const now = Date.now();
                    if (now - gamepadLastMoveTime >= 200) {
                        move(gamepadMoveDir);
                        gamepadLastMoveTime = now;
                    }
                }
            }, 50);
        }
        requestAnimationFrame(updateGamepad);
    }

    /* ------------------------------------------------------------------
       6. Reset visual state
       ------------------------------------------------------------------ */
    resetSplashScreen();
    initMap();
    updatePlayerState();
    updateSatsDisplay();
    needsRedraw = true;
}

function draw() {
    // Add frame rate limiting - cap to maximum 50ms updates (20 FPS)
    const now = performance.now();
    if (now - lastDrawTime < 50) {
        needsRedraw = true;
        return;
    }
    lastDrawTime = now;
    
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
    // Cap animation updates to 20 FPS (50ms)
    if (now - p.anim.lastFrameTime >= 50) { // 20 FPS capped
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
}
    
    if (!map?.[0] || !p || !enemies || !rooms?.length || !fogMap?.[0]) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms, 'fogMap=', fogMap);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);
    if (gameOver) {
        const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
        gameOverCanvas.clearRect(0, 0, 320, 320);
        gameOverCanvas.fillStyle = '#000';
        gameOverCanvas.fillRect(0, 0, 320, 320);
        const scale = window.innerWidth <= 700 ? 1.5 : 2;
        const gw = 128 * scale, gh = 32 * scale;
        const offsetY = (Math.sin(Date.now() / 500) * 10);
        gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh) / 2 + offsetY, gw, gh);
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('submit-score').style.display = 'block';
        document.getElementById('view-leaderboard').style.display = 'block';
        document.getElementById('restart-game').style.display = 'block';
        return;
    }
    if (splashActive) { needsRedraw = false; return; }

    const radius = 4;
    // Draw walls first
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] === 1) c.drawImage(assets.themes[currentTheme].wall, x * S, y * S, S, S);
    }
// Save floor state before entering hideout (moved here to run once per draw)
if (!inHideout) {
previousFloorState = {
    map: map.map(row => [...row]),
    enemies: enemies.map(e => ({ ...e, type: { ...e.type } })),
    rooms: rooms.map(r => ({ ...r })),
    exit: exit ? { ...exit } : null,
    satoshiDrops: [...satoshiDrops],
    runeDrops: [...runeDrops],
    scrollDrops: [...scrollDrops],
    portals: portals.map(p => ({ ...p })),
    fogMap: fogMap.map(row => [...row]),  // ← Add this line
    floor: floor,
    wave: wave,
    enemiesSpawnedThisFloor: enemiesSpawnedThisFloor,
    whalesSpawnedThisFloor: whalesSpawnedThisFloor,
    initialSpawnDoneThisFloor: initialSpawnDoneThisFloor,
    initialWaveSpawned: initialWaveSpawned,
    waveActive: waveActive,
    currentTheme: currentTheme
};
}

// Draw floors, items, stairs, and runes
for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
    const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
    const isVisible = fogMap[y][x] === 1 || dist <= radius || map[y][x] === 1;
    if (isVisible && map[y][x] !== 1) {
        c.drawImage(assets.themes[currentTheme].floor, x * S, y * S, S, S);
        
        // Draw dangerous areas (spells) before other items
        dangerousAreas.forEach(area => {
            if (area.x === x && area.y === y) {
                let spellColor = 'rgba(255, 255, 255, 0.5)';
                switch (area.spellType) {
                    case SPELL_TYPES.FIRE_WALL:
                        spellColor = 'rgba(255, 0, 0, 0.5)'; // Red for fire
                        break;
                    case SPELL_TYPES.LIGHTNING_STORM:
                        spellColor = 'rgba(255, 255, 0, 0.5)'; // Yellow for lightning
                        break;
                    case SPELL_TYPES.FROST_NOVA:
                        spellColor = 'rgba(0, 255, 255, 0.5)'; // Cyan for frost
                        break;
                    case SPELL_TYPES.POISON_CLOUD:
                        spellColor = 'rgba(0, 255, 0, 0.5)'; // Green for poison
                        break;
                }
                c.fillStyle = spellColor;
                c.globalAlpha = 0.5;
                c.fillRect(x * S, y * S, S, S);
                c.globalAlpha = 1;
            }
        });
        
        if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
        if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
        if (map[y][x] === 4) c.drawImage(assets.pickaxe, x * S, y * S, S, S);
        if (map[y][x] === 5) c.drawImage(assets.armor, x * S, y * S, S, S);
        if (map[y][x] === 6 && currentTheme !== 'dungeon') c.drawImage(assets.themes[currentTheme].special, x * S, y * S, S, S);
        if (map[y][x] === 7) c.drawImage(assets.gnome, x * S, y * S, S, S);
        if (map[y][x] === 8) c.drawImage(assets.runes.on_floor, x * S, y * S, S, S);
        if (map[y][x] === 9) {
            const rune = runeDrops.find(r => r.x === x && r.y === y && r.specific);
            if (rune && assets.runes[rune.letter]) {
                c.globalAlpha = 0.9; // Apply 10% transparency
                c.drawImage(assets.runes[rune.letter], x * S, y * S, S, S);
                c.globalAlpha = 1; // Restore full opacity
            }
        }
        if (map[y][x] === 10) { // diamond tile
            c.drawImage(assets.diamond, x * S, y * S, S, S);
        }
        if (map[y][x] === 11) { // scroll tile
            c.drawImage(assets.scroll, x * S, y * S, S, S);
        }
        if (map[y][x] === 12) { // portal tile
            const portal = portals.find(p => p.x === x && p.y === y);
            if (portal) {
                const now = performance.now();
                if (now - portal.lastFrameTime >= portal.frameDuration) {
                    portal.frameIndex = (portal.frameIndex + 1) % assets.town_portal.length;
                    portal.lastFrameTime = now;
                    needsRedraw = true; // Ensure redraw for animation
                }
                c.drawImage(assets.town_portal[portal.frameIndex], x * S, y * S, S, S);
            }
        }
        if (map[y][x] === 13) { // Diamond wall
            c.drawImage(assets.themes.hideout.diamond_wall, x * S, y * S, S, S);
        }
        if (map[y][x] === 14) { // Jeweller
            c.drawImage(assets.jeweller, x * S, y * S, S, S);
        }
        if (map[y][x] === 15) { // Blacksmith
            c.drawImage(assets.blacksmith, x * S, y * S, S, S);
        }
        if (map[y][x] === 16) { // Waypoint
            c.drawImage(assets.waypoint, x * S, y * S, S, S);
        }
        if (map[y][x] === 17) { // Rune Whisperer
            c.drawImage(assets.rune_whisperer, x * S, y * S, S, S);
        }
        if (map[y][x] === 18) { // Hooded Heirloom
            c.drawImage(assets.hooded_heirloom, x * S, y * S, S, S);
        }
        if (map[y][x] === 19) { // Soul Stash
            c.drawImage(assets.soul_stash, x * S, y * S, S, S);
        }
        if (map[y][x] === 20) { // Soul Stone
            c.drawImage(assets.soul_stone, x * S, y * S, S, S);
        }
        if (map[y][x] === 21) { // Soul Orb Statue
            c.drawImage(assets.soul_orb_statue, x * S, y * S, S, S);
        }
        if (map[y][x] === 22) { // Shrine
            c.drawImage(assets.shrine, x * S, y * S, S, S);
        }
        // Draw stairs after portals to ensure proper visibility
        if (exit && exit.x === x && exit.y === y) {
            c.drawImage(assets.stairs, x * S, y * S, S, S);
        }
    }
}

///////////
// NOTICE: DRAW ORDER IS A THING! ;)
/////////

// Draw flash effect for diamond hand AOE damage
highlightTiles.forEach(tile => {
    if (Date.now() - tile.highlightStart < 200 && tile.x >= 0 && tile.x < W && tile.y >= 0 && tile.y < H && map[tile.y][tile.x] !== 1) {
        const dist = Math.sqrt((tile.x - p.x) ** 2 + (tile.y - p.y) ** 2);
        const isVisible = fogMap[tile.y][tile.x] === 1 || dist <= radius;
        if (isVisible) {
            c.save();
            c.fillStyle = 'rgba(247, 147, 26, 0.5)'; // Bitcoin orange flash
            c.fillRect(tile.x * S, tile.y * S, S, S);
            c.restore();
        }
    }
});

// In the draw function, after drawing items but before drawing player:
// Draw shrines with fog handling
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
        const isVisible = fogMap[y][x] === 1 || dist <= radius;
        
        if (map[y][x] === 22 && isVisible) { // Shrine tile
            c.drawImage(assets.shrine, x * S, y * S, S, S);
            needsRedraw = true; // Add this to ensure proper redraw after shrine drawing
        }
    }
}

// Draw projectiles, skipping player's position
    projectiles.forEach(proj => {
        if (proj.x >= 0 && proj.x < W && proj.y >= 0 && proj.y < H && 
            (proj.x !== p.x || proj.y !== p.y)) {
            c.save();
            c.translate(proj.x * S + S / 2, proj.y * S + S / 2);
            if (proj.dir === 'up') c.rotate(-Math.PI / 2);
            if (proj.dir === 'down') c.rotate(Math.PI / 2);
            if (proj.dir === 'left') c.rotate(Math.PI);
            c.drawImage(assets.shoot_sword, -S / 2, -S / 2, S, S);
            c.restore();
        }
    });
// Draw player
// Add this to the existing draw function for player rendering
    if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
const now = performance.now();
// Animation frame update logic here
if (p.moving) {
    // Half speed animation during movement (5 FPS - doubled interval)
    if (now - p.anim.lastFrameTime >= 50) {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
} else {
    p.anim.frameIndex = 0; // Fixed idle frame
}
        
let drawX = p.currentX;
let drawY = p.currentY;
        
        const direction = p.anim.direction;
        const baseDirection = direction === 'left' ? 'right' : direction;
let frameKey = p.hasDiamondArmor ? `diamond_armor_${baseDirection}` : (p.hasArmor ? `armor_${baseDirection}` : baseDirection);
if (p.isFalling) {
    frameKey = 'fall';
}
	const frame = p.anim.frames[frameKey][p.anim.frameIndex];
        c.save();
                
        if (direction === 'left') {
            c.translate(drawX + S, drawY);
            c.scale(-1, 1);
            c.drawImage(frame, 0, 0, S, S);
        } else {
            c.drawImage(frame, drawX, drawY, S, S);
        }
        c.restore();
    }
// Draw sword or pickaxe-sword or diamond hand
if (swordActive && Date.now() - swordStart < 200) {
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    if (sx >= 0 && sx < W && sy >= 0 && sy < H && Math.sqrt((sx - p.x) ** 2 + (sy - p.y) ** 2) <= radius) {
        c.save();
        c.translate(sx * S + S / 2, sy * S + S / 2);
        if (swordDir === 'up') c.rotate(-Math.PI / 2);
        if (swordDir === 'down') c.rotate(Math.PI / 2);
        if (swordDir === 'left') c.rotate(Math.PI);
        // Prioritize pickaxe sword if player has pickaxes and is using it, then diamond hand, then regular sword
        if (p.pickaxes > 0 && usePickaxeSword) {
            c.drawImage(assets.pickaxe_sword, -S / 2, -S / 2, S, S);
            p.atk = 2; // Reset attack power
        } else if (p.hasDiamondHand) {
            c.drawImage(assets.diamond_hand, -S / 2, -S / 2, S, S);
            p.atk = 3; // diamond hand attack power
        } else {
   if (p.soulStormCharges >= 8) {
       c.drawImage(assets.soul_sword, -S / 2, -S / 2, S, S);
   } else {
       c.drawImage(assets.sword, -S / 2, -S / 2, S, S);
   }
            p.atk = 2; // Reset attack power
        }
        c.restore();
    }
}
    
// Add rune tile indicator when player is on a rune tile
if (currentRuneTile && map[p.y][p.x] === 9) {
    const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
    if (rune) {
        const floorIndicator = document.getElementById('floor-indicator');
        if (!floorIndicator.textContent.startsWith("Rune:")) {
            floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
        }
    }
}
    
// Draw gradient column overlay for RIP blast
if (ripBlastActive && Date.now() - ripBlastStartTime < 3000) {
    if (columnProgress === 0) {
        initGradientOverlay(); // Initialize overlay on first draw
    }
    c.save();
    c.globalCompositeOperation = 'screen'; // Subtle glow for visibility
    const elapsed = Date.now() - ripBlastStartTime;
    columnProgress = elapsed / 2000; // 0 to 1 over 2 seconds
    const columnWidth = 20; // Width of each column in pixels
    const numColumns = Math.ceil(W * S / columnWidth) + 1; // Cover entire width
    for (let i = 0; i < numColumns; i++) {
        const x = i * columnWidth + columnProgress * W * S; // Sweep left to right
        if (x > W * S) continue; // Skip columns off-screen
        const gradient = c.createLinearGradient(x, 0, x + columnWidth, 0);
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0)'); // Transparent edge
        gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.4)'); // Smudged orange center
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)'); // Transparent edge
        c.fillStyle = gradient;
        c.fillRect(x, 0, columnWidth, H * S); // Draw full-height column
    }
    c.restore();
    needsRedraw = true; // Ensure continuous redraw during effect
} else if (ripBlastActive) {
    ripBlastActive = false; // End effect after 3 seconds
    columnProgress = 0;
    if (enemies.length === 0 && !exit) {
        if (placeStairs()) {
            wave++;
            waveActive = false;
            document.getElementById('wave').textContent = wave;
            logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);
        } else {
            logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
        }
    }
    needsRedraw = true;
}


    // Draw fog overlay
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] !== 1 && !fogMap[y][x]) {
            c.fillStyle = 'rgba(0, 0, 0, 0.7)';
            c.fillRect(x * S, y * S, S, S);
        }
    }
    
/**
 * Makes pure‑red pixels transparent (α = 0).  
 * Works for desert and ruins – the same color is used for the “eyes” in those PNGs.
 */
function punchHoleThroughRed(imageData) {
    const d = imageData.data;
    for (let i = 0; i < d.length; i += 4) {
        // Check for pure red or near-red with wider tolerance
        if (
            d[i] >= 200 && d[i] <= 255 && // Red component (wider range)
            d[i+1] <= 50 && // Green component (wider range)
            d[i+2] <= 50 // Blue component (wider range)
        ) {
            //console.log(`Found near-red pixel at index ${i}: R=${d[i]}, G=${d[i+1]}, B=${d[i+2]}, A=${d[i+3]}`);
            d[i+3] = 1; // Mark eye pixels with a unique alpha (1) to identify them later
        }
    }
}

// Pulsating animation timing
const pulsePeriod = 200; // 200 ms cycle
const pulseAlphaMin = 0.5;
const pulseAlphaMax = 1;
const pulseAlpha = pulseAlphaMin + (pulseAlphaMax - pulseAlphaMin) * (Math.sin(Date.now() / pulsePeriod * Math.PI) + 1) / 2;



// Draw enemies with theme-based color overlays, preserving transparent backgrounds
enemies.forEach(e => {
    if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
        const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
        const isVisible = fogMap[e.y][e.x] === 1 || dist <= radius;
        
        // Check if this enemy is a unique monster
        const isUniqueMonster = e.uniqueName !== undefined;
if (inHideout || screensaverActive) {  // Add this: skip effects in hideout/screensaver
    c.drawImage(img, e.currentX, e.currentY, S, S);
    c.restore();
    return;
}
        
	c.save();
	const doPixelEffect = (frameCount % 1 === 0); 
        // Create a temporary canvas for rendering
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = S;
        tempCanvas.height = S;
        const tempCtx = tempCanvas.getContext('2d');
        
// Handle animation for enemies with anim property (e.g., Shrimp) - throttled
let img;
if (e.type.anim && e.anim) {
    const now = performance.now();
    const numFrames = (e.type.name === 'Shrimp' && currentTheme === 'hell' && e.type.anim.hellFrames) ? e.type.anim.hellFrames.length : e.type.anim.frames.length;
    if (now - e.anim.lastFrameTime >= 200) {
        e.anim.frameIndex = (e.anim.frameIndex + 1) % numFrames;
        e.anim.lastFrameTime = now;
    }
    // Use Hell Shrimp frames if theme is hell, enemy is Shrimp, and visible
    if (e.type.name === 'Shrimp' && currentTheme === 'hell' && isVisible && e.type.anim.hellFrames) {
        img = e.type.anim.hellFrames[e.anim.frameIndex];
    } else {
        img = e.type.anim.frames[e.anim.frameIndex];
    }
} else {
    img = e.type.img;
}
        
        let spriteCanvas, spriteCtx;
        if (isVisible) {
if (doPixelEffect && isVisible) {
                spriteCanvas = document.createElement('canvas');
                spriteCanvas.width = S;
                spriteCanvas.height = S;
                spriteCtx = spriteCanvas.getContext('2d');
                spriteCtx.imageSmoothingEnabled = false;
                spriteCtx.drawImage(img, 0, 0, S, S);
                
                // Apply theme-based effects to the sprite canvas
                if (currentTheme === 'desert') {
                    const imageData = spriteCtx.getImageData(0, 0, S, S);
                    const data = imageData.data;
                    punchHoleThroughRed(imageData); // Mark eye pixels
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] === 1) { // Eye pixel
                            data[i] = 255;     // Red
                            data[i + 1] = 0;   // Green
                            data[i + 2] = 0;   // Blue
                            data[i + 3] = 255; // Full opacity
                        } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel
                            data[i] = 255;     // Red
                            data[i + 1] = 242; // Green
                            data[i + 2] = 230; // Blue
                            data[i + 3] = Math.round(0.95 * 255); // 95% opacity
                        }
                    }
                    spriteCtx.putImageData(imageData, 0, 0);
                } else if (currentTheme === 'ruins') {
                    const imageData = spriteCtx.getImageData(0, 0, S, S);
                    const data = imageData.data;
                    punchHoleThroughRed(imageData); // Mark eye pixels
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] === 1) { // Eye pixel
                            data[i] = 255;     // Red
                            data[i + 1] = 0;   // Green
                            data[i + 2] = 0;   // Blue
                            data[i + 3] = 255; // Full opacity
                        } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel
                            data[i] = 144;     // Red
                            data[i + 1] = 126; // Green
                            data[i + 2] = 105; // Blue
                            data[i + 3] = 255; // Full opacity (removed 95% opacity)
                        }
                    }
                    spriteCtx.putImageData(imageData, 0, 0);
                } else if (currentTheme === 'hell') {
                    // Apply red tint for hell theme
                    spriteCtx.globalCompositeOperation = 'source-atop';
                    spriteCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    spriteCtx.fillRect(0, 0, S, S);
                    spriteCtx.globalCompositeOperation = 'source-over'; // Reset
                } else if (currentTheme === 'paradise') {
                    // Apply purple tint for paradise theme
                    spriteCtx.globalCompositeOperation = 'source-atop';
                    spriteCtx.fillStyle = 'rgba(153, 102, 255, 0.4)';
                    spriteCtx.fillRect(0, 0, S, S);
                    spriteCtx.globalCompositeOperation = 'source-over'; // Reset
                }
                
                // Special handling for unique monsters (poison green with red eyes)
                if (isUniqueMonster) {
                    const imageData = spriteCtx.getImageData(0, 0, S, S);
                    const data = imageData.data;
                    punchHoleThroughRed(imageData); // Mark eye pixels
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] === 1) { // Eye pixel - make red
                            data[i] = 255;     // Red
                            data[i + 1] = 0;   // Green
                            data[i + 2] = 0;   // Blue
                            data[i + 3] = 255; // Full opacity
                        } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel - make poison green
                            data[i] = 0;       // Red
                            data[i + 1] = 255; // Green (poison green)
                            data[i + 2] = 0;   // Blue
                            data[i + 3] = Math.round(0.95 * 255); // 95% opacity
                        }
                    }
                    spriteCtx.putImageData(imageData, 0, 0);
                }
            }
            // Fallback draw if pixel effect skipped
            if (!doPixelEffect || !isVisible) {
                tempCtx.drawImage(img, 0, 0, S, S);
            }
            }
        
        // Draw the sprite on the temporary canvas
        if (isVisible) {
            tempCtx.globalAlpha = pulseAlpha;
            tempCtx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red
            const centerX = S / 2;
            const centerY = S / 2;
            const radius = S / 2;
            tempCtx.beginPath();
            tempCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            tempCtx.fill();
            tempCtx.globalAlpha = 1.0;
        }
        tempCtx.imageSmoothingEnabled = false;
        if (isVisible) {
                        // Draw to tempCtx: processed if effects ran, else raw img
            if (doPixelEffect && isVisible) {
                tempCtx.drawImage(spriteCanvas, 0, 0, S, S);
            } else {
                tempCtx.drawImage(img, 0, 0, S, S);
            }
        } else {
            // Outside fog of war, draw original sprite to show red eyes
            tempCtx.drawImage(img, 0, 0, S, S);
        }
        
        // Draw the processed sprite to the main canvas
        c.drawImage(tempCanvas, e.currentX, e.currentY, S, S);
        c.restore();
        
// Show unique monster name when enemy becomes visible (fog of war)
if (isUniqueMonster && isVisible && !activeUniqueMonsterName) {
    activeUniqueMonsterName = e.uniqueName;
    const floorIndicator = document.getElementById('floor-indicator');
    floorIndicator.textContent = activeUniqueMonsterName;
    
    // Auto-clear after 5 seconds like Harbringer message
    setTimeout(() => {
        if (activeUniqueMonsterName === e.uniqueName) {
            activeUniqueMonsterName = null;
            const currentText = floorIndicator.textContent;
            if (currentText === activeUniqueMonsterName || 
                currentText.includes(e.uniqueName)) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }
    }, 5000);
}
    }
});

// Draw fading dangerous spell areas after enemies
drawFadingDangerousAreas();

// Draw low-health warning border with smooth transition
if ((p.hp <= 4 || (p.hp > 4 && p.hp < 9)) && !gameOver && !splashActive) {
    // Use a smooth, consistent pulse instead of frame-rate dependent flashing
    const pulse = Math.sin(Date.now() / 100); // Slower, smoother pulse
    let alpha, color;
    
    if (p.hp <= 4) {
        alpha = 0.5 + 0.1 * pulse; // Smooth red transition (0.7 to 1.0)
        color = `rgba(255, 0, 0, ${alpha})`; // Red border for hp <= 4
    } else {
        alpha = 0.5 + 0.1 * pulse; // Smooth orange transition (0.5 to 0.8)
        color = `rgba(255, 165, 0, ${alpha})`; // Bitcoin orange border for 4 < hp < 9
    }
    
    c.strokeStyle = color;
    c.lineWidth = Math.max(5, window.innerWidth > 700 ? 10 : 5); // Responsive thickness
    c.beginPath();
    // Draw the border around the entire canvas
    c.moveTo(0, 0);
    c.lineTo(W * S, 0);
    c.lineTo(W * S, H * S);
    c.lineTo(0, H * S);
    c.closePath();
    c.stroke();
}
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = false;
frameCount++;  // Add this line
    
if (activeUniqueMonsterName) {
    // Display unique monster name in battle log if not already shown
    const floorIndicator = document.getElementById('floor-indicator');
    if (!floorIndicator.textContent.includes(activeUniqueMonsterName)) {
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName && 
                floorIndicator.textContent === activeUniqueMonsterName) {
                activeUniqueMonsterName = null;
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 5000);
    }
}
}

function gameLoop(timestamp) {
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state');
        initMap();
        needsRedraw = true;
    }
    
if (gameOver) {
    musicManager.mute(true);
    musicManager.play(currentTheme);
    if (!gameOverSoundPlayed) {
        sounds.gameover.play().catch(e => console.error('Gameover sound error:', e));
        gameOverSoundPlayed = true;
    }
    document.getElementById('health').textContent = 0;
    // Reset text color to Bitcoin orange for game-over screen
    document.documentElement.style.setProperty('--text-color', '#ff8c00');
    document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #leaderboard-output, #username-input, #sats-calc').forEach(el => {
        el.style.color = '#ff8c00';
    });
    
    // Add gamepad control blocking logic
    if (gamepadIndex !== null && !inputBlocked) {
        inputBlocked = true;
        // Block controls for 1 second (1000ms)
        setTimeout(() => {
            inputBlocked = false;
        }, 1000);
    }
    
// Auto-submit score with random name from names array only if gamepad is connected
   if (!scoreSubmitted && gamepadIndex !== null && !autoSubmitTriggered) {
       autoSubmitTriggered = true;
       // Do NOT auto-submit anymore - user must press B button to submit
   }
    needsRedraw = true;
}
    
updateProjectiles();
// Simple delta updates (run every frame for smooth movement)
if (p.moving) {
    p.currentX += p.deltaX;
    p.currentY += p.deltaY;
    p.stepsLeft--;
if (p.stepsLeft <= 0) {
    p.moving = false;
    p.anim.frameIndex = 0;  // Reset to idle frame on stop
    p.currentX = p.x * S;
    p.currentY = p.y * S;
}
    needsRedraw = true;
}
enemies.forEach(e => {
    if (e.moving) {
        e.currentX += e.deltaX;
        e.currentY += e.deltaY;
        e.stepsLeft--;
        if (e.stepsLeft <= 0) {
            e.moving = false;
            e.currentX = e.x * S;
            e.currentY = e.y * S;
        }
        needsRedraw = true;
    }
});
// Frame animation (only when moving) - throttled
const now = performance.now();
if (p.moving && now - p.anim.lastFrameTime >= 50) {
    p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
    p.anim.lastFrameTime = now;
}
    
    // Check for invisible health warning animation (activated at above 8 HP)
    const showInvisibleHealthWarning = p.hp > 8; // Trigger animation at higher threshold
    
    // Throttle draw to 20 FPS, but keep updates smooth
    if ((needsRedraw || p.hp <= 8 || showInvisibleHealthWarning) && !splashActive) {
        draw();
    }
    
// Final death check (after all updates)
if (p.hp <= 0 && !gameOver) {
    if (p.immortal) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
    } else {
        p.hp = 0;
        diamonds = 0;                // reset diamonds
        updatePlayerState();          // update inventory
        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
        gameOver = true;
    }
}

    // Revert to unthrottled RAF for smooth interpolation; draw throttling is internal
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
        // Check if Enter is coming from username input field
        if (document.activeElement && document.activeElement.id === 'username-input') {
            return; // Let the username input handler handle this
        }
        
        if (splashActive && !hasPlayedOnce) {
            return; // Block Enter on initial splash screen
        }
        if (splashActive && hasPlayedOnce) {
            const startButton = document.getElementById('start-button');
            startButton.style.background = '#00b7ef'; // Mimic :hover color
            setTimeout(() => {
                startButton.style.background = '#00e8d8'; // Revert to original color
            }, 200); // Short duration to simulate tap

currentTheme = 'dungeon'; // Force default theme on game start
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }
    
if (splashActive) {
        preloadSounds();
        // Ensure AudioContext is resumed for iOS
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                // Reset music manager state and play music after AudioContext is resumed
                musicManager.current = null;
                if (!musicMuted) {
                    musicManager.play(currentTheme); // Play music after AudioContext is resumed
                }
            }).catch(e => console.error('Failed to resume AudioContext:', e));
        } else {
            // Reset music manager state on restart
            musicManager.current = null;
            if (!musicMuted) {
                musicManager.play(currentTheme); // Play music if AudioContext is already running
            }
        }
            // Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

        musicManager.mute(musicMuted); // Ensure proper mute state
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }
    
// Set music volume to 0 when restarting
setSoundVolume(0);
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);
        fadeSplash();
        setTimeout(() => {
            if (!gameOver && !splashActive) {
                fetchTxs();
                lastUpdate = Date.now();
                console.log('Initial fetchTxs triggered after splash, wave=', wave);
            }
        }, 2000);
    }
    
    // Set music volume to max when starting
if (musicManager.current) {
    const currentAudio = musicManager.audios[musicManager.current];
    if (currentAudio) {
        currentAudio.currentTime = 0;
        currentAudio.volume = 1;
    }
}
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);

            fadeSplash();
            setTimeout(() => {
                if (!gameOver && !splashActive) {
                    fetchTxs();
                    lastUpdate = Date.now();
                    console.log('Initial fetchTxs triggered after splash via Enter, wave=', wave);
                }
            }, 2000); // Match delay in start-button and startGame
            return;
        }
        
if (gameOver && hasPlayedOnce) {
    restart();
    return;
}
    }
    if (gameOver || splashActive) return;

    // Handle terminal input when active
    if (p.inSoulTerminal && p.soulTerminalActive) {
        handleTerminalInput(e);
        return;
    }

    /*
    // DEBUG: Runeword testing with keys 1-9 - comment out when not needed
    if (['1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(e.key)) {
        debugRuneword(e.key);
        needsRedraw = true;
        return;
    }
    */

    // Update key states and handle actions
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keyStates[e.key] = true;
    } else if (e.key === 'a') {
        attack();
    } else if (e.key === 'd') {
        usePotion();
    }

    // Start keyboard movement polling if not already started
    if (!keyboardMovementTimer) {
        keyboardMovementTimer = setInterval(() => {
            if (!splashActive && !gameOver) {
                let newMoveDir = null;
                if (keyStates.ArrowUp) {
                    newMoveDir = 'up';
                } else if (keyStates.ArrowDown) {
                    newMoveDir = 'down';
                } else if (keyStates.ArrowLeft) {
                    newMoveDir = 'left';
                } else if (keyStates.ArrowRight) {
                    newMoveDir = 'right';
                }

                if (newMoveDir) {
                    const now = Date.now();
                    if (!currentMoveDir || newMoveDir !== currentMoveDir || now - lastMoveTime >= 200) {
                        move(newMoveDir);
                        lastMoveTime = now;
                        currentMoveDir = newMoveDir;
                    }
                } else if (currentMoveDir) {
                    currentMoveDir = null;
                    lastMoveTime = 0;
                }
            }
        }, 50); // Poll frequently, moves capped at 200ms
    }
});

// Add this after the main document.addEventListener('keydown', ... line
document.getElementById('soul-terminal-input').addEventListener('keydown', function(e) {
    if (p.inSoulTerminal && p.soulTerminalActive) {
        // Prevent default for Enter to avoid duplicate handling
        if (e.key === 'Enter') {
            e.preventDefault();
        }
        handleTerminalInput(e);
        
        // Handle Enter key for terminal input
        if (e.key === 'Enter') {
            const command = this.value;
            processSoulCommand(command);
            this.value = '';
            this.focus();
        }
    }
});

// Add this after the existing soul-terminal-input keydown listener
document.addEventListener('keydown', function(e) {
    if (p.inSoulTerminal && p.soulTerminalActive && !e.target.matches('#soul-terminal-input')) {
        // Handle keyboard input when terminal is active but not focused
        const key = e.key;
        if (key.length === 1 && key !== 'Enter') {
            handleBlurredTerminalInput(key);
        }
    }
});

// Add global event listeners with proper cleanup handling
document._keydownHandler = function(e) {
    // Existing keydown handler logic here
};
document.addEventListener('keydown', document._keydownHandler);

document._keyupHandler = function(e) {
    // Existing keyup handler logic here
};
document.addEventListener('keyup', document._keyupHandler);

// Add touch event listeners with proper cleanup
document._touchstartHandler = function(e) {
    // Existing touchstart handler logic here
};
document.addEventListener('touchstart', document._touchstartHandler);

document._touchmoveHandler = function(e) {
    // Existing touchmove handler logic here
};
document.addEventListener('touchmove', document._touchmoveHandler);

document._touchendHandler = function(e) {
    // Existing touchend handler logic here
};
document.addEventListener('touchend', document._touchendHandler);

// Add gamepad event listeners with proper cleanup
document._gamepadConnectedHandler = function(e) {
    // Existing gamepadconnected handler logic here
};
window.addEventListener('gamepadconnected', document._gamepadConnectedHandler);

document._gamepadDisconnectedHandler = function(e) {
    // Existing gamepaddisconnected handler logic here
};
window.addEventListener('gamepaddisconnected', document._gamepadDisconnectedHandler);

// Update key states on release
document.addEventListener('keyup', e => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        keyStates[e.key] = false;
    }
});

// Add a global animation update for continuous animation when player moves or health changes
function animateHealthWarning() {
    // This function will be called periodically to trigger invisible animations
    if (p.hp > 8 && !gameOver && !splashActive) {
        needsRedraw = true;
    }
}

// Set up interval for invisible health warning animation updates
setInterval(animateHealthWarning, 100); // Update every 100ms when health is above threshold

document.getElementById('game-over').addEventListener('click', (event) => {
    if (
        gameOver &&
        !document.getElementById('username-input').contains(event.target) &&
        !document.getElementById('submit-score').contains(event.target) &&
        !document.getElementById('view-leaderboard').contains(event.target) &&
        !document.getElementById('restart-game').contains(event.target) &&
        !document.getElementById('leaderboard-output').contains(event.target)
    ) {
    }
});

        initMap();
        updateSatsDisplay();
        populateNameList();
        requestAnimationFrame(gameLoop);
        
// Removed redundant D-pad touch event listeners; handled in initTouchControls

//////////////////////
// Gamepad support //
////////////////////
let gamepadIndex = null; // Track connected gamepad
let lastButtonsState = []; // Track previous button states
let lastAxesState = { axis0: 0, axis1: 0 }; // Track previous D-pad axis states
let lastStartPressTime = 0; // Debounce Start button
const DEBOUNCE_MS = 200; // Debounce interval
const GAMEPAD_POLL_INTERVAL = 50; // Poll rate in ms
let lastGamepadPollTime = 0; // Throttle polling
let movementTimer = null; // Timer for continuous movement
let currentMoveDir = null; // Track current movement direction
let lastMoveTime = 0; // Track last move to enforce 200ms interval
let gamepadMoveDir = null; // Track gamepad movement direction
let gamepadLastMoveTime = 0; // Track last gamepad move to enforce 200ms interval
let gamepadPollingActive = false; // Track if gamepad polling is enabled
let hasPlayedOnce = false; // Track if player has played at least one game


const keyStates = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false
};
let keyboardMovementTimer = null;

// Simplified gamepad axis handling class without excessive profiling
class GamepadAxes {
    constructor(gamepad) {
        this.gamepad = gamepad;
        this.axis0 = 0;
        this.axis1 = 0;
    }
    
    // Update axes with current state
    update() {
        if (this.gamepad.axes.length >= 2) {
            this.axis0 = this.gamepad.axes[0];
            this.axis1 = this.gamepad.axes[1];
        }
    }
    
    // Get direction based on buttons or axes
    getDirection() {
        let newMoveDir = null;
        const deadZone = 0.2;
        
        // First check if we have a valid gamepad
        if (!this.gamepad) return null;
        
        // Check button-based D-pad (indices 12-15 for standard mapping)
        if (this.gamepad.buttons.length >= 16) {
            const upBtn = this.gamepad.buttons[12];
            const downBtn = this.gamepad.buttons[13];
            const leftBtn = this.gamepad.buttons[14];
            const rightBtn = this.gamepad.buttons[15];
            
            // Check each button individually
            if (leftBtn.pressed) {
                newMoveDir = 'left';
            } else if (rightBtn.pressed) {
                newMoveDir = 'right';
            } else if (upBtn.pressed) {
                newMoveDir = 'up';
            } else if (downBtn.pressed) {
                newMoveDir = 'down';
            }
        }
        
        // If no button direction, check axes 0 and 1
        if (!newMoveDir) {
            if (Math.abs(this.axis0) > deadZone) {
                newMoveDir = this.axis0 > 0 ? 'right' : 'left';
            } else if (Math.abs(this.axis1) > deadZone) {
                newMoveDir = this.axis1 > 0 ? 'down' : 'up';
            }
        }
        
        return newMoveDir;
    }
    
    // Check if D-pad is active (button-based or axis-based)
    isDpadActive() {
        const deadZone = 0.2;
        
        // Check button-based D-pad
        if (this.gamepad.buttons.length >= 16) {
            const upBtn = this.gamepad.buttons[12];
            const downBtn = this.gamepad.buttons[13];
            const leftBtn = this.gamepad.buttons[14];
            const rightBtn = this.gamepad.buttons[15];
            
            if (upBtn.pressed || downBtn.pressed || leftBtn.pressed || rightBtn.pressed) {
                return true;
            }
        }
        
        // Check axis-based D-pad
        return Math.abs(this.axis0) > deadZone || Math.abs(this.axis1) > deadZone;
    }
}

// Global instance for current gamepad axes
let currentAxes = null;

// Start game function for splash screen
function startGame() {
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪'; // Update mute button UI based on saved state
    if (!splashActive) {
        return;
    }
    
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }
    
    const startButton = document.getElementById('start-button');
    startButton.style.background = '#00b7ef'; // Mimic hover
    setTimeout(() => {
        startButton.style.background = '#00e8d8'; // Revert
    }, 200);
    
    // Check for gamepad at game start
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                console.log('Gamepad detected at game start:', gamepads[i].id);
                break;
            }
        }
    }
    
    // Resume AudioContext
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
        }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    preloadSounds(); // Preload sounds after user interaction
    
    currentTheme = 'dungeon'; // Force default theme on game start
    // Set mute state based on saved preference
    musicManager.mute(musicMuted);
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪'; // Update mute button UI
    musicManager.current = null; // Reset MusicManager state
    musicManager.audios[currentTheme].pause(); // Ensure audio is stopped
    musicManager.audios[currentTheme].currentTime = 0; // Reset to start of track
    
    if (musicManager.audios[currentTheme].readyState >= 2) { // Check if audio is loaded
        console.log('Playing music from start:', currentTheme); // Debug log
        musicManager.play(currentTheme); // Play the music immediately
    } else {
        console.log('Audio not ready, waiting for', currentTheme); // Debug log
        musicManager.audios[currentTheme].load(); // Force reload
        musicManager.audios[currentTheme].oncanplaythrough = () => {
            console.log('Audio ready, playing from start:', currentTheme); // Debug log
            musicManager.audios[currentTheme].currentTime = 0; // Reset to start of track
            if (!musicMuted) {
                musicManager.play(currentTheme); // Play once ready only if we should unmute
            }
        };
    }
    
    fadeSplash();
    
    // Start gamepad polling if gamepad is connected
    if (gamepadIndex !== null) {
        gamepadPollingActive = true;
        updateGamepad();
    }
    
    hasPlayedOnce = true; // Mark that the player has started a game
    
    // Ensure fetchTxs is triggered after splash fade
    setTimeout(() => {
        if (!gameOver && !splashActive && floor > 0) {
            console.log('Post-splash fetchTxs triggered: floor=', floor, 'wave=', wave);
            fetchTxs();
        } else {
            console.log('Post-splash fetchTxs skipped: gameOver=', gameOver, 'splashActive=', splashActive, 'floor=', floor);
        }
    }, 2000); // Match original start-button delay
}
window.addEventListener("gamepadconnected", (e) => {
    // Only connect if no gamepad is currently connected or if it's a different gamepad
    if (gamepadIndex === null) {
        gamepadIndex = e.gamepad.index;
        lastButtonsState = new Array(e.gamepad.buttons.length).fill(false);
        lastGamepadPollTime = performance.now();
        console.log('Gamepad connected:', e.gamepad.id);
        
        if (!splashActive) {
            gamepadPollingActive = true;
            if (!movementTimer) {
                movementTimer = setInterval(() => {
                    if (!splashActive && !gameOver && gamepadMoveDir) {
                        const now = Date.now();
                        if (now - gamepadLastMoveTime >= 200) {
                            move(gamepadMoveDir);
                            gamepadLastMoveTime = now;
                        }
                    }
                }, 50);
            }
            updateGamepad();
        }
    } else {
        console.log('Gamepad connected but already tracking:', e.gamepad.id);
    }
});

window.addEventListener("gamepaddisconnected", (e) => {
    // Only handle disconnection if this is the same gamepad we were tracking
    if (gamepadIndex === e.gamepad.index) {
        gamepadIndex = null;
        lastButtonsState = [];
        gamepadPollingActive = false;
        
        // Clear movement timer if active
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
        }
        
        // Reset gamepad movement tracking
        gamepadMoveDir = null;
        gamepadLastMoveTime = 0;
        
        console.log('Gamepad disconnected:', e.gamepad.id);
    }
});

// Modify the updateGamepad function to handle start button press for pausing
function updateGamepad(timestamp) {
    if (gamepadIndex === null) {
        // Try to find a connected gamepad
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                gamepadPollingActive = true;
                break;
            }
        }
        if (gamepadIndex === null) {
            return; // No gamepad found, stop polling
        }
    }

    if (!gamepadPollingActive) {
        const gamepad = navigator.getGamepads()[gamepadIndex];
        if (gamepad && gamepad.buttons[3].pressed && !lastButtonsState[3] && splashActive) {
            const nowTime = Date.now();
            if (nowTime - lastStartPressTime > DEBOUNCE_MS) {
                startGame();
                lastStartPressTime = nowTime;
                gamepadPollingActive = true;
                if (!movementTimer) {
                    movementTimer = setInterval(() => {
                        if (!splashActive && !gameOver && gamepadMoveDir) {
                            const now = Date.now();
                            if (now - gamepadLastMoveTime >= 200) {
                                move(gamepadMoveDir);
                                gamepadLastMoveTime = now;
                            }
                        }
                    }, 50);
                }
            }
            lastButtonsState[3] = gamepad.buttons[3].pressed;
        }
        requestAnimationFrame(updateGamepad);
        return;
    }

    const now = performance.now();
    if (now - lastGamepadPollTime < GAMEPAD_POLL_INTERVAL) {
        requestAnimationFrame(updateGamepad);
        return;
    }
    lastGamepadPollTime = now;
    const gamepad = navigator.getGamepads()[gamepadIndex];
    if (!gamepad) {
        gamepadIndex = null;
        gamepadPollingActive = false;
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            currentMoveDir = null;
            lastMoveTime = 0;
        }
        return;
    }

    // Update axes with new state
    currentAxes = new GamepadAxes(gamepad);
    currentAxes.update();

    // Check for actual gamepad input (buttons or axes)
    const buttons = gamepad.buttons;
    const hasInput = buttons.some(b => b.pressed) || currentAxes.isDpadActive();
    
    if (!splashActive && !gameOver && inputBlocked) {
        // Just return, don't process movement
        requestAnimationFrame(updateGamepad);
        return;
    }

    // Handle buttons (A=0, B=1, Select=2, Start=3)
    const nowTime = Date.now();

    // A Button (0) - usePotion
    if (buttons[0].pressed && !lastButtonsState[0] && !splashActive && !gameOver) {
        usePotion();
        lastMoveTime = nowTime; // Update lastMoveTime to maintain consistency with other actions
    }

// B Button (1) - attack or submit score during game over
    if (buttons[1].pressed && !lastButtonsState[1]) {
        if (!splashActive && !gameOver) {
            // Normal gameplay B button action
            attack();
            lastMoveTime = nowTime; // Update lastMoveTime to maintain consistency with other actions
        } else if (gameOver && gamepadIndex !== null && !scoreSubmitted) {
            // During game over, B button submits score with random name
            submitScoreWithRandomName();
        }
    }

    // Select Button (2) - toggleMute
    if (buttons[2].pressed && !lastButtonsState[2] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        toggleMute();
        lastStartPressTime = nowTime; // Reuse lastStartPressTime for debouncing
    }

// Start Button (3) - startGame, restart
    if (buttons[3].pressed && !lastButtonsState[3] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        if (splashActive) {
            startGame();
        } else if (gameOver) {
            restart();
        } else 
        lastStartPressTime = nowTime;
    }

    // Update button states
    lastButtonsState = buttons.map(b => b.pressed);

    // Update movement direction using the new axes class
    if (!splashActive && !gameOver) {
        let newMoveDir = currentAxes.getDirection();
        gamepadMoveDir = newMoveDir; // Always update gamepadMoveDir
        
        // Rely on movementTimer for continuous movement
        if (newMoveDir && !movementTimer) {
            movementTimer = setInterval(() => {
                if (!splashActive && !gameOver && gamepadMoveDir) {
                    const now = Date.now();
                    if (now - gamepadLastMoveTime >= 200) {
                        move(gamepadMoveDir);
                        gamepadLastMoveTime = now;
                    }
                }
            }, 50);
        } else if (!newMoveDir && movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            gamepadLastMoveTime = 0;
        }
    }

    // Continue polling
    requestAnimationFrame(updateGamepad);
}

// Initialize touch controls after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the global button variables
    dpadButtons = document.querySelectorAll('#dpad button');
    actionsButtons = document.querySelectorAll('#actions button');
    
    setTimeout(() => {
        initTouchControls();
    }, 100);
    
    // Add event listener for soul terminal input
    const soulTerminalInput = document.getElementById('soul-terminal-input');
    if (soulTerminalInput) {
        soulTerminalInput.addEventListener('keydown', function(e) {
            if (p.inSoulTerminal && p.soulTerminalActive) {
                handleTerminalInput(e);
                
                // Handle Enter key for terminal input
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const command = this.value;
                    processSoulCommand(command);
                    this.value = '';
                    this.focus();
                }
            }
        });
    }
});

// Add this to prevent context menu issues
document.addEventListener('contextmenu', function(e) {
    // Only prevent context menu for elements that might cause issues
    if (e.target.closest('#game-container, #dpad, #actions') || 
        e.target.id === 'game' || 
        e.target.id === 'battle-events') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, { passive: false });

// Function to submit score with random name
function submitScoreWithRandomName() {
    if (gameOver && !scoreSubmitted && gamepadIndex !== null) {
        // Select a random name from the names array
        const randomName = names[Math.floor(Math.random() * names.length)];
        document.getElementById('username-input').value = randomName;
        
        // Submit the score
        submitScore();
    }
}

function displayUniqueMonsterName() {
    if (!activeUniqueMonsterName) return;
    
    // Check if any visible unique monsters are present
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0) {
        // Clear previous display
        activeUniqueMonsterName = null;
        return;
    }
    
    // Check if unique monster is in fog of war but still has a name to show
    const uniqueMonsterInFog = enemies.find(e => e.uniqueName && fogMap[e.y][e.x] === 0);
    
    if (uniqueMonsterInFog && !activeUniqueMonsterName) {
        activeUniqueMonsterName = uniqueMonsterInFog.uniqueName;
        logBattleEvent(`A harbinger of doom is near.`);
        
// Clear only when enemy is killed or when leaving the area
// No auto-clear timeout needed anymore
    }
}

// Screensaver: black background, slow drifting orange ball (#f7931a) with white "₿" and soft glows.
// Smooth fade-out/fade-in, minimal breathing and drift.

let screensaverActive = false;
let screensaverCanvas = null;
let screensaverCtx = null;
let screensaverInitialized = false;
let screensaverLoopId = null;

(function ensureScreensaverOverlay() {
  if (!document.getElementById('screensaver-overlay')) {
    const newOverlay = document.createElement('div');
    newOverlay.id = 'screensaver-overlay';
    newOverlay.style.display = 'none';
    newOverlay.style.position = 'fixed';
    newOverlay.style.left = '0';
    newOverlay.style.top = '0';
    newOverlay.style.width = '100%';
    newOverlay.style.height = '100%';
    newOverlay.style.zIndex = '9999';
    newOverlay.innerHTML = '<canvas id="screensaver-canvas"></canvas>';
    document.body.appendChild(newOverlay);
  }
})();

function initScreensaver() {
  if (screensaverInitialized) return true;
  screensaverCanvas = document.getElementById('screensaver-canvas');
  if (!screensaverCanvas) return false;
  screensaverCanvas.style.display = 'block';
  screensaverCanvas.style.width = '100%';
  screensaverCanvas.style.height = '100%';
  screensaverCtx = screensaverCanvas.getContext('2d');
  if (!screensaverCtx) return false;

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    if (screensaverCanvas.width !== w || screensaverCanvas.height !== h) {
      screensaverCanvas.width = w;
      screensaverCanvas.height = h;
    }
  }
  resize();
  window.addEventListener('resize', resize);

  screensaverInitialized = true;
  return true;
}

function activateScreensaver() {
  if (!initScreensaver()) return;
  const overlay = document.getElementById('screensaver-overlay');
  if (!overlay) return;
  overlay.style.display = 'block';
  screensaverActive = true;
  if (!screensaverLoopId) screensaverLoopId = requestAnimationFrame(drawScreensaver);
}

function exitScreensaver() {
  const overlay = document.getElementById('screensaver-overlay');
  if (overlay) overlay.style.display = 'none';
  screensaverActive = false;
  if (screensaverLoopId) {
    cancelAnimationFrame(screensaverLoopId);
    screensaverLoopId = null;
  }
  startTime = 0;
}

// Visual settings
const ORANGE_HEX = '#f7931a';
const ORANGE_RGB = { r: 247, g: 147, b: 26 }; // for rgba usage
const BASE_RADIUS_RATIO = 0.10;
const SLOW_BREATHE_AMPL = 0.02;
const BREATHE_PERIOD = 10.0;
const DRIFT_PERIOD_Y = 20.0;
const DRIFT_AMPL_Y = 0.05;
const DRIFT_PERIOD_X = 26.0;
const DRIFT_AMPL_X = 0.07;

const VISIBLE_INTERVAL = 9.0;
const HIDE_DURATION = 3.5;
const FADE_DURATION = 1.0;

let startTime = 0;

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function alphaForTime(tSec) {
  const cycleLen = VISIBLE_INTERVAL + FADE_DURATION + HIDE_DURATION + FADE_DURATION;
  const p = tSec % cycleLen;
  if (p < VISIBLE_INTERVAL) return 1;
  let q = p - VISIBLE_INTERVAL;
  if (q < FADE_DURATION) return 1 - easeInOutCubic(q / FADE_DURATION);
  q -= FADE_DURATION;
  if (q < HIDE_DURATION) return 0;
  q -= HIDE_DURATION;
  if (q < FADE_DURATION) return easeInOutCubic(q / FADE_DURATION);
  return 1;
}

function drawScreensaver(timestamp) {
  if (!screensaverActive || !screensaverCtx) {
    screensaverLoopId = null;
    return;
  }
  if (!startTime) startTime = timestamp || performance.now();
  const now = timestamp || performance.now();
  const tSec = (now - startTime) / 1000;

  // Clear
  screensaverCtx.fillStyle = 'black';
  screensaverCtx.fillRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);

  const alpha = alphaForTime(tSec);
  if (alpha <= 0) {
    screensaverLoopId = requestAnimationFrame(drawScreensaver);
    return;
  }

  const w = screensaverCanvas.width;
  const h = screensaverCanvas.height;
  const minWH = Math.min(w, h);

  const baseRadius = minWH * BASE_RADIUS_RATIO;
  const breathe = 1 + SLOW_BREATHE_AMPL * Math.sin((2 * Math.PI * tSec) / BREATHE_PERIOD);
  const radius = baseRadius * breathe;

  const offsetY = DRIFT_AMPL_Y * h * Math.sin((2 * Math.PI * tSec) / DRIFT_PERIOD_Y);
  const offsetX = DRIFT_AMPL_X * w * Math.sin((2 * Math.PI * tSec) / DRIFT_PERIOD_X + 0.9);

  const cx = w / 2 + offsetX;
  const cy = h / 2 + offsetY;

  // Orange glow (soft, larger than before)
  const glowRadius = radius * 2.8;
  const glowAlpha = 0.22 * alpha;
  const grad = screensaverCtx.createRadialGradient(cx, cy, radius * 0.25, cx, cy, glowRadius);
  grad.addColorStop(0, `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${(glowAlpha).toFixed(3)})`);
  grad.addColorStop(0.45, `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${(glowAlpha * 0.55).toFixed(3)})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  screensaverCtx.fillStyle = grad;
  screensaverCtx.beginPath();
  screensaverCtx.arc(cx, cy, glowRadius, 0, Math.PI * 2);
  screensaverCtx.fill();

  // Main steady circle
  const mainAlpha = 0.75 * alpha;
  screensaverCtx.fillStyle = `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${mainAlpha.toFixed(3)})`;
  screensaverCtx.beginPath();
  screensaverCtx.arc(cx, cy, radius, 0, Math.PI * 2);
  screensaverCtx.fill();

  // White ₿ with soft white halo
  const fontSize = Math.max(12, Math.round(radius * 1.05));
  screensaverCtx.save();
  // white halo using shadow
  screensaverCtx.globalAlpha = alpha;
  screensaverCtx.shadowColor = 'rgba(255,255,255,0.75)';
  screensaverCtx.shadowBlur = Math.max(6, radius * 0.22);
  screensaverCtx.fillStyle = '#ffffff';
  screensaverCtx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`;
  screensaverCtx.textAlign = 'center';
  screensaverCtx.textBaseline = 'middle';
  screensaverCtx.fillText('₿', cx, cy + (fontSize * 0.02));
  screensaverCtx.restore();

  screensaverLoopId = requestAnimationFrame(drawScreensaver);
}

/* Input handlers to exit screensaver (kept minimal) */
let screensaverMovementTimeout = null;
let lastMovementTime = 0;
const DEBOUNCE_DELAY = 50;

function handleMovement() {
  const now = Date.now();
  if (!screensaverActive) return;
  if (now - lastMovementTime > DEBOUNCE_DELAY) {
    lastMovementTime = now;
    if (screensaverMovementTimeout) {
      clearTimeout(screensaverMovementTimeout);
      screensaverMovementTimeout = null;
    }
    screensaverMovementTimeout = setTimeout(() => {
      // Make screensaver exit behave like gamepad select button
      const muteButton = document.getElementById('mute');
      if (muteButton.textContent === '☀') { // Screensaver active state
        exitScreensaver();
        musicMuted = false;
        musicManager.mute(false);
        muteButton.textContent = '♪';
        if (!splashActive) {
          musicManager.current = null; // Reset MusicManager state
          musicManager.play(currentTheme);
        }
        localStorage.setItem('musicMuted', 'false');
      } else {
        exitScreensaver();
      }
    }, DEBOUNCE_DELAY * 2);
  }
}

document.addEventListener('pointerdown', function (e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  handleMovement();
}, { passive: true });

document.addEventListener('touchstart', function (e) {
  if (e.touches && e.touches.length > 1) return;
  handleMovement();
}, { passive: true });

document.addEventListener('mousedown', function (e) {
  if (e.button !== 0) return;
  handleMovement();
}, { passive: true });

document.addEventListener('keydown', function (e) {
  if (['a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Enter'].includes(e.key)) {
    handleMovement();
  }
});
    </script>
</body>
</html>
