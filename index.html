<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self' https://noexxibndcooqjquhqzk.supabase.co/functions/v1/leaderboard https://mempool.space; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 10px; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: pan-x pan-y; /* Prevents pinch-to-zoom */
            -webkit-user-select: none; /* Prevents selection */
            -webkit-touch-callout: none; /* Disables iOS callouts */
        }
        /* Existing styles remain unchanged */
        #console { 
            background: #111;
            border: 4px solid #ff8c00;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            max-width: 800px;
            width: 100%;
            box-sizing: border-box;
        }
#whale-log { 
            width: 618px; 
            height: 18px; 
            overflow-y: auto;
            scroll-behavior: smooth; 
            background: #111; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator {color: var(--text-color, #ff8c00) !important;
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
#battle-log {
    width: 620px;
    margin-left: 20px; 
    background: transparent; 
    color: var(--text-color, #ff8c00) !important; 
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
    padding: 16px; 
    border: none; 
    font-size: 16px;
    z-index: 10;
    margin-top: -240px;
}

/* Soul Terminal Overlay */
#soul-terminal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 1000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'VT323', monospace;
    color: #ff8c00;
}

#soul-terminal {
    width: 90%;
    max-width: 800px;
    height: 80%;
    background: rgba(17, 17, 17, 0.95);
    border: 4px solid #ff8c00;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#soul-terminal-header {
    color: #ff8c00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 24px;
    margin-bottom: 15px;
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 2px solid #ff8c00;
}

#soul-terminal-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    background: #111;
    border: 2px solid #ff8c00;
    margin-bottom: 15px;
    font-size: 16px;
    line-height: 1.4;
}

#soul-terminal-input-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

#soul-terminal-prompt {
    color: #ff8c00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 16px;
    white-space: nowrap;
}

#soul-terminal-input {
    flex-grow: 1;
    background: #ff8c00;
    color: #000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    font-weight: 900;
    outline: none;
    padding: 5px;
}

#soul-terminal-input:focus {
    outline: 1px solid #ff8c00;
    background: #ff8c00;
    color: #000;
}
/ Add this for the blur behavior /
#soul-terminal-input:not(:focus) {
    background: #ff8c00;
    color: #000;
}

/* Passive Terminal Overlay */
#passive-terminal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 1000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'VT323', monospace;
    color: #00ff00;
}

#passive-terminal {
    width: 90%;
    max-width: 800px;
    height: 80%;
    background: rgba(17, 17, 17, 0.95);
    border: 4px solid #00ff00;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#passive-terminal-header {
    color: #00ff00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 24px;
    margin-bottom: 15px;
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 2px solid #00ff00;
}

#passive-terminal-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    background: #111;
    border: 2px solid #00ff00;
    margin-bottom: 15px;
    font-size: 16px;
    line-height: 1.4;
}

#passive-terminal-input-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

#passive-terminal-prompt {
    color: #00ff00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 16px;
    white-space: nowrap;
}

#passive-terminal-input {
    flex-grow: 1;
    background: #00ff00;
    color: #000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    font-weight: 900;
    outline: none;
    padding: 5px;
}

#passive-terminal-input:focus {
    outline: 1px solid #00ff00;
    background: #00ff00;
    color: #000;
}
/ Add this for the blur behavior /
#passive-terminal-input:not(:focus) {
    background: #00ff00;
    color: #000;
}

#battle-log textarea {
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    resize: none;
    width: 100%;
    height: 200px;
    padding: 0;
    overflow-y: auto;
    scroll-behavior: smooth;
    z-index: 10;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.2s ease;
    transform: translateX(-100%);
    opacity: 0;
    /* Hide scrollbar */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}
#battle-log textarea:focus {
    outline: none !important;
}
#inventory { 
    position: absolute;
    top: 10px;
    right: -18px;
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    padding: 8px;
    z-index: 10;
    font-family: 'VT323', monospace;
    font-size: 20px;
    line-height: 1.5;
    width: 160px;
}
#inventory sup {
    vertical-align: super;
    font-size: 0.6em; /* Matches ™ size */
    text-shadow: none; /* Remove shadow for clarity */
}
/* Tighten line-height for Safari */
@media not all and (min-resolution: 0.001dpcm) { /* Targets Safari */
    #inventory {
        line-height: 1.0; /* Reduce line-height by ~50% */
    }
}
	#floor-indicator { 
    	    position: absolute; 
    	    top: 11px; 
	    left: 10px; 
	    background: transparent; 
	    color: var(--text-color, #ff8c00) !important; 
	    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
	    padding: 8px; 
	    z-index: 10; 
	    font-family: 'VT323', monospace;
	    font-size: clamp(21px, 5.33vw, 32px);
	    line-height: 1.2; / Prevents squishing /
	}
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
            grid-area: t;
            z-index: 40;
            border-radius: 5%;
        }
        #left { 
            grid-area: l;
            z-index: 40;
            border-radius: 5%;
        }
        #right { 
            grid-area: r;
            z-index: 40; 
            border-radius: 5%;
        }
        #down { 
            grid-area: b;
            z-index: 40;
            border-radius: 5%;
        }
        #actions { 
            display: flex; 
            gap: 5px; 
            align-items: center; 
        }
button {
    background-color: transparent;
    border: 1px solid #ff8c00;
    color: #ff8c00;
    padding: 8px;
    border: 0px solid #000;
    cursor: pointer;
    font-size: 14px;
    width: 40px;
    height: 40px;
    box-sizing: border-box;
    transition: none; /* Prevent any transitions */
}
button:hover {
    background: rgba(224, 123, 0, 0.5);
    transition: background 0.1s ease; /* Smooth hover effect */
}
        #mute {
            padding: 0px;
            border-radius: 25%;
            height: 20px;
            width: 30px;
            background: #fff;
            color: #000;
            margin-right: 50px;
            z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #attack, #potion {
            margin-right: 20px;
            background: #ff8c00;
            color: #fff;
            height: 50px;
            width: 50px; 
            border-radius: 50%;
        }
        #attack:hover, #potion:hover {
            background: #e07b00;
        }
        #start-button {
            position: absolute;
            top: 75%;
            left: 50%;
            width: 120px;
            height: 50px;
            transform: translate(-50%, -50%);
            background: #00e8d8;
            color: #fff;
            border: none;
            padding: 0px 20px;
            font-family: 'VT323', monospace;
            font-size: 42px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 40;
        }
        #start-button:hover {
            background: #00b7ef;
        }
#dpad button {
    -webkit-tap-highlight-color: transparent; /* Remove browser default highlight */
    touch-action: none; /* Prevent browser touch interference */
    user-select: none; /* Prevent text selection */
    background: transparent; /* Default background */
    transition: background 0.1s ease-out; /* Brief flash for press */
}

#dpad button:active {
    background: rgba(224, 123, 0, 0.7); /* Orange flash on press */
}
#dpad button.pressed {
    background: rgba(224, 123, 0, 0.2); /* Subtle feedback for held state */
}

#submit-score, #view-leaderboard, #restart-game {
    background: #ff8c00;
    color: #fff;
    border: none;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 18px;
    cursor: pointer;
    border-radius: 5px;
    width: 120px; /* Keep for view-leaderboard and restart-game */
    height: 40px;
    z-index: 40;
}
#submit-score {
    width: 220px; /* Almost doubled from 120px */
}

#submit-score:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
}

#leaderboard-output {
    position: absolute;
    top: 0px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #ff8c00;
    border: 2px solid #ff8c00;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    width: 640px;
    max-width: 100%;
    text-align: left;
    white-space: pre;
    line-height: 1.2;
    box-sizing: border-box;
    word-break: break-word; /* Handle long text */
}

#sats-calc {
    display: block;          /* line‑break */
    color: var(--text-color);   /* inherits the theme colour */
}

    /* Windows 95 Screensaver Styles */
#screensaver-overlay { position: fixed; inset: 0; z-index: 99999; background: black; display: none; }   
#screensaver-canvas { position: absolute; top:0; left:0; width:100%; height:100%; display:block; }

#skill-tree-overlay {
    opacity: 0;
    transform: scale(0.9);
    transition: opacity 0.4s ease, transform 0.4s ease;
}
#skill-tree-overlay.visible {
    opacity: 1;
    transform: scale(1);
}
    
.star {
    position: absolute;
    background-color: #ff8c00; /* Windows 95 orange */
    border-radius: 50%;
    box-shadow: 0 0 10px #ff8c00, 0 0 20px #ff8c00;
    /* Add these new properties for better visual effect */
    filter: blur(0.5px);
    animation: pulse 2s infinite alternate;
}

.class-option {
    display: inline-block;
    margin: 20px;
    padding: 20px;
    width: 220px;
    cursor: pointer;
    border: 3px solid #666;
    background: rgba(0,0,0,0.3);
    transition: all 0.2s ease;
}
.class-option.selected {
    border: 6px solid #00e8d8 !important;
    background: rgba(0,123,126,1) !important;
    box-shadow: 0 0 20px #00ff00;
}

.class-option.disabled {
    opacity: 0.4;
    pointer-events: none;
    border-color: #666 !important;
    background: rgba(0,0,0,0.1) !important;
}

@keyframes pulse {
    0% { opacity: 0.7; }
    100% { opacity: 1; }
}
    
/* Phones (320px–767px) */
@media only screen and (min-width: 320px) and (max-width: 767px) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 18px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 9px;
    }
    #whale-hash-ids {
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 9px;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: 8px;
        height: 110px;
        font-size: 10px; /* Match font-size for consistency */
    }
    #inventory {
        width: 100px;
        font-size: 16px;
        line-height: 1.5;
        margin-right: 2px;
    }
    #floor-indicator {
        font-size: clamp(16px, 4.67vw, 24px);
    }
    button {
        width: 55px;
        height: 55px;
        font-size: 12px;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 40px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: -10px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 0px;
        margin-left: -15px;
        margin-top: 60px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 0px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 0px;
                margin-left: 20px;
        background: #ff8c00;
        height: 35px;
        width: 35px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }
    
    #submit-score, #view-leaderboard, #restart-game {
        width: 80px; /* Keep for view-leaderboard and restart-game */
        height: 30px;
        font-size: 16px;
    }
    #submit-score {
        width: 160px; /* Doubled from 80px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 14px;
}
    #leaderboard-output {
        top: -12px;
        width: 100%;
        max-width: 640px;
        font-size: 12px;
        max-height: 160px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}

/* Tablets (768px–1024px, high pixel ratio) */
@media only screen and (min-width: 768px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
        max-width: 640px;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 18px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 1.2rem;
    }
    #whale-hash-ids {
        font-size: 1.2rem;
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 1.2rem;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: -60px;
        height: 156px;
        font-size: 1.2rem;
    }
    #inventory {
        width: 170px;
        font-size: 1.5rem;
        line-height: 1.5;
        margin-right: 0px;
    }
    #floor-indicator {
        font-size: clamp(24px, 4.67vw, 37px);
    }
    button {
        width: 65px;
        height: 65px;
        font-size: 1.2rem;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 120px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: 20px;
        margin-top: -50px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 24px;
        width: 24px;
        background: #fff;
        color: #000;
        margin-right: 80px;
        margin-left: -15px;
        margin-top: 45px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 5px;
        background: #ff8c00;
        height: 65px;
        width: 65px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 5px;
        margin-left: 20px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }

    #submit-score, #view-leaderboard, #restart-game {
        width: 100px; /* Keep for view-leaderboard and restart-game */
        height: 48px;
        font-size: 18px;
    }
    #submit-score {
        width: 200px; /* Doubled from 100px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 16px;
}
    #leaderboard-output {
        top: 0px;
        width: 100%;
        max-width: 640px;
        font-size: 14px;
        max-height: 200px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}
</style>
</head>
<body>
    <div id="console">
        <div id="whale-log" style="position:relative;height:18px;overflow:hidden;">
            <!-- Scrollable whale transactions (full 18px) -->
            <div id="whale-hash-ids" style="height:18px;overflow-y:auto;padding:0 8px;font-size:14px;line-height:18px;box-sizing:border-box;color:#ff8c00;text-shadow:-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000;white-space:nowrap;">
                Whale Transactions:
            </div>
            <!-- XP bar overlaid on top half - transparent -->
            <div id="xp-bar-container" tabindex="-1" style="position:absolute;top:0;left:0;width:100%;height:12px;background:transparent;pointer-events:none;z-index:10;">
                <div id="xp-bar-fill" style="height:100%;width:0%;background:#007b7e;transition:width 0.3s ease;opacity:0.8;"></div>
                <div id="xp-text" style="position:absolute;top:0;left:0;width:100%;text-align:center;color:#ff8c00;font-size:12px;line-height:12px;text-shadow:1px 1px 1px #000;font-weight:bold;">LVL 1 • 0 / 10 XP</div>
            </div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
    		<canvas id="splash-canvas" width="320" height="320"></canvas>

<!-- Passive Terminal Overlay -->
<div id="passive-terminal-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.80); z-index:1000; font-family:'VT323', monospace; color:#00ff00;">
    <div id="passive-terminal" style="width:90%; max-width:800px; height:80%; background:rgba(17,17,17,0.1); border:4px solid #00ff00; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; overflow:hidden;">
        <div id="passive-terminal-header" style="color:#00ff00; text-shadow:-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000; font-size:24px; margin-bottom:15px; text-align:center; padding-bottom:10px; border-bottom:2px solid #00ff00;">
            Passive Tree
        </div>
        <div id="passive-terminal-content" style="flex-grow:1; overflow-y:auto; padding:10px; background:rgba(17,17,17,0.1); border:2px solid #00ff00; margin-bottom:15px; font-size:16px; line-height:1.4;"></div>
        <div id="passive-terminal-input-container" style="display:flex; align-items:center; gap:10px;">
            <span id="passive-terminal-prompt" style="color:#00ff00; text-shadow:-1px -1px 0 #000,1px -1px 0 #000,-1px 1px 0 #000,1px 1px 0 #000; font-size:16px; white-space:nowrap;">
                tree@terminal:~$
            </span>
            <input type="text" id="passive-input" autocomplete="off" spellcheck="false" style="flex-grow:1; background:#00ff00; color:#000; border:none; font-family:'VT323', monospace; font-size:16px; font-weight:900; outline:none; padding:5px;">
        </div>
    </div>
</div>

<!-- NEW: Loading message (shown until splash is ready) -->
    <div id="loading-text" style="position: absolute; top: 70%; left: 50%; transform: translate(-50%, -50%); color: #ff8c00; font-family: 'VT323', monospace; font-size: 24px; text-align: center; pointer-events: none; z-index: 50;">
        Loading...
    </div>
    
    <!-- START button now hidden by default -->
    <button id="start-button" style="display: none;">START</button>
    	    <div id="info-icon" onclick="showInfo()" style="position: absolute; top: 50px; right: 20px; width: 30px; height: 30px; background: #00e8d8; color: #fff; border: 3px solid #ff8c00; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-family: 'VT323', monospace; font-size: 24px; cursor: pointer; z-index: 50;">i</div>
    	    <!-- Add info message display -->
<div id="info-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 20px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; display: none; z-index: 60; max-width: 80vw; border-radius: 5px;">
    Hey listen! ;)<br><br>
    If you are using a Gamepad, connect it after you have pressed the START button on the screen.
</div>
	    </div>
<div id="game-over">
    <pre id="leaderboard-output"></pre>
    <canvas id="game-over-canvas" width="320" height="320"></canvas>
    <div style="position: absolute; top: 60%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px;"> <!-- Increased gap from 10px to 15px -->
        <input id="username-input" type="text" placeholder="Enter Username" maxlength="20" list="name-list" style="background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 8px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; width: 200px;">
<datalist id="name-list"></datalist>
        <button id="submit-score" onclick="submitScore()">Submit Score</button>
        <button id="view-leaderboard" onclick="fetchLeaderboard()">Leaderboard</button>
        <button id="restart-game" onclick="restart()">Restart</button>
    </div>
</div>
<div id="top-right-ui" style="position:absolute;top:6px;right:8px;display:flex;align-items:center;gap:8px;z-index:20;pointer-events:none;">
    <div id="armor-icon-container" style="width:48px;height:0px;display:flex;align-items:center;justify-content:center;image-rendering:pixelated;"></div>
</div>
<div id="floor-indicator">Floor 1</div>

<div id="inventory" style="-webkit-nbsp-mode: normal;">
    <span id="wave" style="display: none;">1</span>			<!-- deactivated -->
    ><span id="sats" style="display: none;">0</span>			<!-- ACTIVE newline -->
    <span id="sats-calc" class="calc"></span>				<!-- ACTIVE -->
    Potions: <span id="potions">0</span><br>				<!-- ACTIVE -->
    <span id="armorStatus" style="display: none;">Leather</span><br>	<!-- deactivated -->
    <span id="pickaxes" style="display: none;">0</span><br>		<!-- moved to soul terminal -->
    <span id="health" style="display: none;">24</span><br>		<!-- deactivated -->
    <span id="diamonds" style="display: none;">0</span><br>		<!-- moved to soul terminal -->
    <span id="perfectlyCutDiamonds" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    <span id="runes" style="display: none;">None</span><br>		<!-- moved to soul terminal -->
    <span id="resonance" style="display: none;">0%</span><br>		<!-- moved to soul terminal -->
</div>
        </div>
<div id="battle-log">
    <textarea id="battle-events" readonly tabindex="-1">Battle Log:</textarea>
</div>

<!-- Soul Terminal Overlay -->
<div id="soul-terminal-overlay">
    <div id="soul-terminal">
        <div id="soul-terminal-header">BTC-DUNGEON</div>
        <div id="soul-terminal-content"></div>
        <div id="soul-terminal-input-container">
            <span id="soul-terminal-prompt">soul@terminal:~$ </span>
            <input type="text" id="soul-terminal-input" autocomplete="off" spellcheck="false">
        </div>
    </div>
</div>

<div id="skill-tree-overlay" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:1000;display:none;flex-direction:column;align-items:center;justify-content:center;color:#ff8c00;font-size:24px;text-align:center;">
    <div style="border:4px solid #ff8c00;padding:20px;background:#111;max-width:90%;">
        <h1>Skill Tree</h1>
        <div id="skill-tree-content"></div>
        <div id="skill-tree-instructions" style="margin-top:20px;font-size:18px;display:${pendingSkillTreeLevel === 3 ? 'block' : 'none'};">Use ← → or gamepad to choose • B / Tap to confirm</div>
    </div>
</div>

<div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">↑</button>
                <button id="left" onclick="move('left')">←</button>
                <button id="right" onclick="move('right')">→</button>
                <button id="down" onclick="move('down')">↓</button>
            </div>
<div id="actions">
                <button id="mute" onclick="toggleMute()">♪</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.10.0/dist/axios.min.js"></script>
    <script src="talk.js"></script>
    <script>

// Auto-scroll whale log to bottom when new transaction added
const whaleObserver = new MutationObserver(() => {
    const whaleIds = document.getElementById('whale-hash-ids');
    if (whaleIds) {
        whaleIds.scrollTop = whaleIds.scrollHeight;
    }
});
whaleObserver.observe(document.getElementById('whale-hash-ids'), { childList: true, subtree: true });

const names = [
    "Alan-Soul",
    "Alex-Cipher",
    "Amanda-Quest",
    "Amy-Crypt",
    "Andrea-Haze",
    "Andrew-Fury",
    "Angela-Shade",
    "Ann-Shadow",
    "Anthony-Smog",
    "Arthur-Sky",
    "Ashley-Guild",
    "Azeroth-Blade",
    "Barbara-Storm",
    "Benjamin-Bolt",
    "Blaise-Crypt",
    "Brian-Block",
    "Brother-Void",
    "Bruce-Ice",
    "Carl-Fissure",
    "Catherine-Dark",
    "Charles-Claw",
    "Cheryl-Vine",
    "Christina-Spark",
    "Christopher-Blade",
    "Cindy-Breath",
    "Craig-Mark",
    "Crystal-Gale",
    "Cynthia-Frost",
    "Daniel-Hex",
    "David-Rune",
    "Deborah-Spear",
    "Dennis-Pulse",
    "Diane-Blood",
    "Donald-Ward",
    "Donna-Slash",
    "Edward-Blaze",
    "Elizabeth-Fog",
    "Emily-Dusk",
    "Eric-Iron",
    "Eugene-Dream",
    "Father-Rune",
    "Frank-Tide",
    "Gary-Grip",
    "George-Drift",
    "Gerden-Skull",
    "Gregory-Doom",
    "Heather-Knight",
    "Helen-Fire",
    "Howard-Wild",
    "James-Miner",
    "Jane-Trace",
    "Janet-Spine",
    "Jason-Void",
    "Jeffrey-Glare",
    "Jennifer-Vault",
    "Jeremy-Rage",
    "Jessica-Hash",
    "Joan-Tempest",
    "John-Flame",
    "Jonathan-Mist",
    "Joseph-Nexus",
    "Joshua-Coin",
    "Judith-Shock",
    "Julie-Fade",
    "Karen-Fell",
    "Kathleen-Howl",
    "Kelly-Wind",
    "Kenneth-Glow",
    "Kevin-Wisp",
    "Kimberly-Grim",
    "Kristin-Curse",
    "Larry-Vortex",
    "Laura-Veil",
    "Lauren-Bane",
    "Linda-Dawn",
    "Lisa-Torch",
    "Lori-Swarm",
    "Maria-Crag",
    "Mark-Wraith",
    "Mary-Raven",
    "Matt-Dread",
    "Matthew-Shard",
    "Megan-Sword",
    "Melissa-Cipher",
    "Michael-Chain",
    "Michelle-Viper",
    "Mother-Wraith",
    "Nancy-Byte",
    "Nathan-Bind",
    "Nicole-Rift",
    "Pamela-Node",
    "Patrich-Hex",
    "Patrick-Maze",
    "Paul-Hawk",
    "Philip-Wave",
    "Ponyo-Shard",
    "Rachel-Fang",
    "Randy-Clash",
    "Rebecca-Dust",
    "Richard-Lore",
    "Robert-Skull",
    "Roger-Light",
    "Ronald-Guard",
    "Ruth-Vow",
    "Ryan-Crow",
    "Sarah-Ledger",
    "Satoshi-Chain",
    "Scott-Ghost",
    "Sharon-Chill",
    "Shawn-Trail",
    "Sister-Gloom",
    "Solan-Fury",
    "Stephanie-Talon",
    "Steve-Burst",
    "Steven-Pool",
    "Susan-Thorn",
    "Terry-Edge",
    "Theresa-Stone",
    "Thomas-Gloom",
    "Tiffany-Flux",
    "Timothy-Night",
    "Tina-Fall",
    "Todd-Rush",
    "Tony-Realm",
    "Tracy-Wolf",
    "Victoria-Seer",
    "Walter-Hunt",
    "William-Dagger"
];

const uniqueMonsterNames = {
    'Shrimp': ['Fire-Shrimp', 'Gray-Shrimp', 'Gut-Shrimp', 'Sharp-Shrimp', 'Sin-Shrimp', 'Blaze-Shrimp', 'Spirit-Shrimp', 'Steel-Shrimp', 'Storm-Shrimp', 'Viper-Shrimp'],
    'Crab': ['Blade-Crab', 'Death-Crab', 'Gloom-Crab', 'Mind-Crab', 'Ooze-Crab', 'Pit-Crab', 'Rust-Crab', 'Vile-Crab', 'Wind-Crab', 'Thunder-Crab'],
    'Squid': ['Chaos-Squid', 'Cold-Squid', 'Dire-Squid', 'Dragon-Squid', 'Gore-Squid', 'Mold-Squid', 'Puke-Squid', 'Soul-Squid', 'Warp-Squid', 'Frost-Squid'],
    'Dolphin': ['Black-Dolphin', 'Blight-Dolphin', 'Demon-Dolphin', 'Dread-Dolphin', 'Flesh-Dolphin', 'Night-Dolphin', 'Seethe-Dolphin', 'Snot-Dolphin', 'Wrath-Dolphin', 'Venom-Dolphin'],
    'Shark': ['Bile-Shark', 'Bone-Shark', 'Doom-Shark', 'Grief-Shark', 'Moon-Shark', 'Plague-Shark', 'Pox-Shark', 'Shadow-Shark', 'Sharp-Shark', 'Bolt-Shark'],
    'Whale': ['Ash-Whale', 'Bane-Whale', 'Blood-Whale', 'Fester-Whale', 'Foul-Whale', 'Haze-Whale', 'Rot-Whale', 'Spine-Whale', 'Star-Whale', 'Inferno-Whale']
};

// Show info message
function showInfo() {
    const infoMessage = document.getElementById('info-message');
    infoMessage.style.display = 'block';
    
    // Switch to info.png
    currentSplashImage = 'info.png';
    splashCanvas.clearRect(0, 0, 320, 320);
    splashImg.src = currentSplashImage;
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    
    setTimeout(() => {
        infoMessage.style.display = 'none';
    }, 5000); // Auto-hide after 5 seconds
}

function populateNameList() {
    const datalist = document.getElementById('name-list');
    datalist.innerHTML = ''; // Clear existing options
    names.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        datalist.appendChild(option);
    });
}

function levenshtein(a, b) {
    const matrix = Array(b.length + 1).fill().map(() => Array(a.length + 1).fill(0));
    for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
    for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
            matrix[j][i] = Math.min(
                matrix[j-1][i] + 1,
                matrix[j][i-1] + 1,
                matrix[j-1][i-1] + (a[i-1].toLowerCase() === b[j-1].toLowerCase() ? 0 : 1)
            );
        }
    }
    return matrix[b.length][a.length];
}

// Enhanced name matching function
function findClosestName(input, nameList) {
    const inputLower = input.toLowerCase();
    
    // First, try exact prefix match (case-insensitive)
    const exactPrefixMatch = nameList.find(name => 
        name.toLowerCase().startsWith(inputLower)
    );
    if (exactPrefixMatch) return exactPrefixMatch;
    
    // Then, try partial match (substring anywhere in the name)
    const partialMatch = nameList.find(name => 
        name.toLowerCase().includes(inputLower)
    );
    if (partialMatch) return partialMatch;
    
    // If no prefix or partial match, use Levenshtein distance
    let minDistance = Infinity;
    let closestName = input; // Default to input if no close match
    
    for (const name of nameList) {
        const distance = levenshtein(inputLower, name.toLowerCase());
        if (distance < minDistance) {
            minDistance = distance;
            closestName = name;
        }
    }
    
    // Only use Levenshtein match if distance is reasonably small
    // Adjust threshold as needed - 3 seems good for most cases
    if (minDistance <= 3) {
        return closestName;
    }
    
    return input; // Return original if no good match found
}

/**
 * Calculates the score that will be sent to the leaderboard.
 *  • `floor` is the current floor number.
 *  • The multiplier is `floor / 100`.
 *  • The extra amount is `floor / 100` of the raw satoshis.
 *
 * Example: floor = 45, raw = 14000 BTC
 *   multiplier = 45 / 100 = 0.45
 *   extra      = 14000 * 0.45 = 6300
 *   finalScore = 14000 + 6300 = 20300
 */
function getScoreWithMultiplier(rawScore, currentFloor) {
    const multiplier = currentFloor / 100;
    const added = Math.floor(rawScore * multiplier);
    let finalScore = rawScore + added;

    // Cap at 21 million BTC (2.1 quadrillion sats)
    const MAX_SATS = 2100000000000000;
    if (finalScore > MAX_SATS) {
        finalScore = MAX_SATS;
    }

    return finalScore;
}

// Modified submitScore function with nearest name matching and random fallback
async function submitScore() {
    if (!gameOver) return;

    // Prevent double submission
    if (scoreSubmitted) {
        document.getElementById('leaderboard-output').textContent = 'Score already submitted for this game!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: already submitted');
        return;
    }

    if (floor < 3) {
        document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: floor=', floor, '< 3');
        return;
    }

    // Disable the button immediately to prevent accidental double-clicks
    const submitButton = document.getElementById('submit-score');
    submitButton.disabled = true;
    submitButton.style.background = '#666';
    submitButton.textContent = 'Submitted';

    let username = document.getElementById('username-input').value.trim();
    if (!username) {
        // Select random name if input is empty
        username = names[Math.floor(Math.random() * names.length)];
        console.log(`Empty username, selected random name: '${username}'`);
    } else if (!names.includes(username)) {
        // Find the closest matching name using enhanced algorithm
        const closestName = findClosestName(username, names);
       
        // Check if we found a match and it's different from input
        if (closestName !== username && closestName.toLowerCase() !== username.toLowerCase()) {
            console.log(`Username '${username}' matched to '${closestName}'`);
            username = closestName;
        } else {
            // Select random name if no good match found
            username = names[Math.floor(Math.random() * names.length)];
            console.log(`Username '${username}' not matched, selected random name: '${username}'`);
        }
    }

    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    const leaderboardScore = getScoreWithMultiplier(totalSats, floor);

    try {
        const response = await fetch(`${API_URL}?action=submit`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ username, score: leaderboardScore, floor })
        });

        if (response.status === 429) {
            console.error('Rate limit exceeded for submitting scores');
            throw new Error('Rate limited');
        }

        if (!response.ok) {
            const text = await response.text();
            console.error(`POST Status: ${response.status}, Response: ${text}`);
            throw new Error(`Server error ${response.status}`);
        }

        const text = await response.text();
        console.log(`POST Status: ${response.status}, Response: ${text}`);

        let data;
        try {
            data = text ? JSON.parse(text) : {};
        } catch (e) {
            data = { raw: text };
        }

        scoreSubmitted = true;
        document.getElementById('leaderboard-output').textContent = `Score submitted: ${username}, ${leaderboardScore} sats (Floor ${floor})`;
        document.getElementById('leaderboard-output').style.display = 'block';

        await fetchLeaderboard(username, leaderboardScore, floor);

    } catch (error) {
        // Re-enable button on any error so player can try again
        submitButton.disabled = false;
        submitButton.style.background = '#ff8c00';
        submitButton.textContent = 'Submit Score';

        document.getElementById('leaderboard-output').textContent = `Error: ${error.message}`;
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

// Generate or retrieve session ID
  function generateSessionId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  const sessionId = localStorage.getItem('sessionId') || generateSessionId();
  localStorage.setItem('sessionId', sessionId);

const API_URL = 'https://noexxibndcooqjquhqzk.supabase.co/functions/v1/leaderboard';
  const headers = {
    'Content-Type': 'application/json',
    'X-Session-ID': sessionId
  };


async function fetchLeaderboard(submittedUsername = null, submittedScore = null, submittedFloor = null) {
    try {
      const leaderboardResponse = await fetch(`${API_URL}?action=fetch&limit=10`, {
        method: 'GET',
        headers
      });
      if (leaderboardResponse.status === 429) {
        console.error('Rate limit exceeded for fetching leaderboard');
        document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching leaderboard';
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
      }
      if (!leaderboardResponse.ok) {
        const errorText = await leaderboardResponse.text();
        console.error(`GET Status: ${leaderboardResponse.status}, Response: ${errorText}`);
        document.getElementById('leaderboard-output').textContent = `Error: ${leaderboardResponse.status} ${errorText}`;
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
      }
      const text = await leaderboardResponse.text();
      console.log(`GET Status: ${leaderboardResponse.status}, Response: ${text}`);
      let data;
      try {
        data = text ? JSON.parse(text) : [];
      } catch (e) {
        data = { raw: text };
      }
      if (leaderboardResponse.ok && Array.isArray(data)) {
    // Cache the raw data
    localStorage.setItem('leaderboardData', JSON.stringify(data));
    cachedLeaderboard = data;
        let playerInTop10 = submittedUsername ? data.some(entry => entry.username === submittedUsername && entry.score === submittedScore && entry.floor === submittedFloor) : false;
        let playerEntry = null;
        let playerRank = null;

        // Fetch player's score and rank if not in top 10 and floor >= 3
        if (submittedUsername && !playerInTop10 && submittedFloor >= 3) {
          try {
            const playerResponse = await fetch(
              `${API_URL}?action=fetchPlayer&username=${encodeURIComponent(submittedUsername)}&score=${submittedScore}&floor=${submittedFloor}`,
              { method: 'GET', headers }
            );
            if (playerResponse.status === 429) {
              console.error('Rate limit exceeded for fetching player');
              document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching player';
              document.getElementById('leaderboard-output').style.display = 'block';
              return;
            }
            if (!playerResponse.ok) {
              console.error(`GET Status: ${playerResponse.status}, Response: ${await playerResponse.text()}`);
              return;
            }
            const playerData = await playerResponse.json();
            if (playerResponse.ok && playerData.length > 0) {
              playerEntry = playerData[0];
              const rankResponse = await fetch(`${API_URL}?action=fetchRank&score=${submittedScore}`, {
                method: 'GET',
                headers
              });
              if (rankResponse.status === 429) {
                console.error('Rate limit exceeded for fetching rank');
                document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching rank';
                document.getElementById('leaderboard-output').style.display = 'block';
                return;
              }
              if (!rankResponse.ok) {
                console.error(`GET Status: ${rankResponse.status}, Response: ${await rankResponse.text()}`);
                return;
              }
              const rankData = await rankResponse.json();
              if (rankResponse.ok) {
                playerRank = rankData.length + 1;
              }
            }
          } catch (e) {
            console.error('Error fetching player score or rank:', e);
          }
        }

        // Format leaderboard
        const maxUsernameLength = 20;
        const scoreWidth = 14;
        const numberWidth = 10;
        const floorWidth = 6;
        const header = `Rank  Username             Score           Floor`;
        let rows = data.map((entry, index) => {
          const rank = (index + 1).toString().padStart(2, '0');
          const username = entry.username.length > maxUsernameLength
            ? entry.username.substring(0, maxUsernameLength - 2) + '..'
            : entry.username.padEnd(maxUsernameLength);
          const scoreValue = entry.score;
          let numberPart, unitPart;
          if (scoreValue >= 1e8) {
            numberPart = (scoreValue / 1e8).toFixed(1);
            unitPart = 'BTC';
          } else {
            numberPart = scoreValue.toString();
            unitPart = 'sats';
          }
          const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
          const score = scoreDisplay.padEnd(scoreWidth);
          const floor = entry.floor.toString().padStart(floorWidth);
          return `${rank}    ${username}${score}${floor}`;
        });

        // Replace or append player's entry with actual rank if not in top 10
        if (playerEntry && !playerInTop10 && playerRank) {
          const username = playerEntry.username.length > maxUsernameLength
            ? playerEntry.username.substring(0, maxUsernameLength - 2) + '..'
            : playerEntry.username.padEnd(maxUsernameLength);
          const scoreValue = playerEntry.score;
          let numberPart, unitPart;
          if (scoreValue >= 1e8) {
            numberPart = (scoreValue / 1e8).toFixed(1);
            unitPart = 'BTC';
          } else {
            numberPart = scoreValue.toString();
            unitPart = 'sats';
          }
          const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
          const score = scoreDisplay.padEnd(scoreWidth);
          const floor = playerEntry.floor.toString().padStart(floorWidth);
          const playerRow = `${playerRank.toString().padStart(2, '0')}    ${username}${score}${floor}`;
          if (rows.length >= 10) {
            rows[9] = playerRow; // Replace 10th entry
          } else {
            rows.push(playerRow); // Append if fewer than 10 entries
          }
        }

        const leaderboardText = `${header}\n${rows.join('\n') || 'No entries yet!'}`;
        document.getElementById('leaderboard-output').textContent = leaderboardText;
      } else {
        document.getElementById('leaderboard-output').textContent = `Error: ${leaderboardResponse.status} ${JSON.stringify(data, null, 2)}`;
      }
      document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
      document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
      console.error('Fetch leaderboard error:', error);
      document.getElementById('leaderboard-output').style.display = 'block';
    }
  }

// Get player's estimated rank/score for cached leaderboard
function getPlayerEstimatedRank(cachedData, playerSats, playerFloor) {
    const playerScore = getScoreWithMultiplier(playerSats, playerFloor);
    let rank = 1;
    for (const entry of cachedData) {
        const entryScore = getScoreWithMultiplier(entry.score, entry.floor); // Recompute for fairness
        if (playerScore > entryScore) break;
        rank++;
    }
    return { score: playerScore, rank, floor: playerFloor };
}

document.getElementById('username-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameOver) {
        e.preventDefault(); // Prevent any default behavior
        e.stopPropagation(); // Stop event propagation to prevent restart
        submitScore(); // Trigger score submission
    }
});

// Also add blur handler to prevent touch keyboard from triggering restart
document.getElementById('username-input').addEventListener('blur', function() {
    // Allow a short delay before re-enabling game controls
    setTimeout(() => {
        // Re-enable game controls if needed
    }, 100);
});

// Prevent pinch-to-zoom and double-tap zoom
document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gestureend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });

const canvas = document.getElementById('game');
let touchMoveInterval = null; // Global variable for continuous touch movement
let touchTimeout = null; // Global variable for touch timeout
let dpadButtons = document.querySelectorAll('#dpad button');
let actionsButtons = document.querySelectorAll('#actions button');

// Touch handlers for #actions buttons
document.querySelectorAll('#actions button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.add('pressed');
        if (button.id === 'mute') toggleMute();
        else if (button.id === 'attack') attack();
        else if (button.id === 'potion') usePotion();
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed');
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault();
    }, { passive: false });
});

const c = canvas.getContext('2d');
const W = 20, H = 20, S = 16;
let currentTheme = 'dungeon'; // Default theme
const themes = ['dungeon', 'desert', 'paradise', 'hell', 'ruins'];
let initialWaveSpawned = false; // Track if initial wave has spawned

function selectNewTheme(current) {
    const available = themes.filter(t => t !== current);
    return available[Math.floor(Math.random() * available.length)];
}

function patchStaticCanvas(x, y) {
    if (!puzzleStaticCtx) return;
    puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, x * S, y * S, S, S);
}

let isFetchingTxs = false; // Track if fetchTxs is currently running
let savedPauseState = null; // remembers pause button state before screensaver
let currentRuneTile = null; // Track current rune tile position
let highlightTiles = [];
let shrimpBloodDrips = []; // {x, y, startTime}

let activatedRunewords = [];
let lastDrawTime = null;
let frameCount = 0;  // Add this line
let borderLastUpdate = null;
let activeUniqueMonsterName = null;

let lastMessageTime = 0;

let redMazeActive = false;          // Is the boss currently on the floor?
let redMazeSavedMuteState = null; // null = no boss active, object = saved state
let redMaze = null;                 // Boss object {x, y, hp, teleportTime}
let redMazeLastFloor = 0;           // Last floor the boss appeared on (for 50-floor cooldown)
let redMazeLazerTime = 0;           // Timestamp for next lazer volley
let activeLazers = [];  // Array of active lazer beams for drawing {wallX, wallY, px, py, startTime}
let redMazeAuraGiven = false;       // Has the player received the red aura reward this run?

let sandworm = null; // {x, y, currentX, currentY, hp: 50, nextBurrowTime}
let sandwormBurrowPaused = false; // pause burrow timer in special areas
let desertStreakHasSandworm = false; // one sandworm per desert streak

let enemyBgFrameTimes = new Map(); // Track per-enemy bg animation start time
let shrinePositions = [];
let auraHitStartTime = 0; // New: Track aura hit flash start
let auraFlashDuration = 300; // New: Flash duration in ms

let puzzlePreviousTheme = null;  // remembers theme before entering puzzle portal
let currentThemeBlock = null;  // 'hell_normal' or 'hell_snowy' for the current 3-floor block
let puzzleCurrentLayout = null;  // ← ADD THIS

// ─────── ZOOM SYSTEM ───────
let zoomEnabled = false; // Default: no zoom
let minimapVisible = false;

// Respect saved user preference first
if (localStorage.getItem('zoomEnabled') === 'true') {
    zoomEnabled = true;
} else if (localStorage.getItem('zoomEnabled') === 'false') {
    zoomEnabled = false;
}
// Auto-enable zoom ONLY on phones (small screens + touch), if no preference saved
else if (window.innerWidth <= 767 && (navigator.maxTouchPoints > 0 || 'ontouchstart' in window)) {
    zoomEnabled = true;
}

// Final sync
minimapVisible = zoomEnabled;

let camera = { x: 0, y: 0 };
let stairsArrow = null;           // {dx,dy} when stairs are off-screen

camera.velocityX = 0;
camera.velocityY = 0;
camera.lastDeltaX = 0;
camera.lastDeltaY = 0;

let puzzleStaticCanvas = null;
let puzzleStaticCtx = null;

let ensnareActive = false;
window.spokenUniques = new Set(); // Track spoken unique names this run
window.breakReminderSpoken = false; // Track if reminder fired this 25-floor block

window.currentBounty = null;
window.seenBountyTypes = []; // optional – for "cousin" tracking

window.currentSideQuest = null;
window.lastSideQuestType = null;

let tileVariantMap = []; // H x W variant indices (-1 = default single tile)

let infoSignActive = false;
let bountyBoardActive = false;
let infoGracePeriod = false;

let passiveTreeActive = false;
let passiveGracePeriod = false; // like infoGracePeriod

const GEM_TILES = {
    ruby:     37,
    sapphire: 38,
    emerald:  39,
    citrine:  40
};

let map = [],
p = {
x: 2,
y: 2,
currentX: 32,  // S * x
currentY: 32,  // S * y
moving: false,
stepsLeft: 0,
deltaX: 0,
deltaY: 0,
targetTileX: 0,
targetTileY: 0,
hp: 36,
maxHP: 36,  // Initialize maxHP to match starting hp
potions: 0,
atk: 2,
pickaxes: 0,
hasArmor: true,
hasDiamondArmor: false, // Track diamond armor
perfectlyCutDiamonds: 0, // Track perfectly cut diamonds
runes: [], // Array to store collected rune letters (e.g., ['a','b','c'])
runewords: [], // Array to store activated runewords (e.g., ['btc', 'hodl'])
immortal: false, // Flag for HODL runeword immortality
ripBlast: false, // Flag for RIP runeword blast
isFalling: false, // Flag to track if the player is currently animating
gems: { ruby: 0, sapphire: 0, emerald: 0, citrine: 0 },
gemAtk: { fire: 0, cold: 0, earth: 0, lightning: 0 },
gemDef: { shrimpCrab: 0, dolphin: 0, shark: 0, squid: 0 },
inPassiveTerminal: false, // Track if player is in passive terminal
passiveTerminalActive: false, // Whether passive terminal is currently open
passiveTerminalCommand: '', // Current command input
passiveTerminalCursorPos: 0, // Cursor position in command
anim: {
    frames: {
        front: [new Image(), new Image()],
        back: [new Image(), new Image()],
        right: [new Image(), new Image()],
        armor_front: [new Image(), new Image()],
        armor_back: [new Image(), new Image()],
        armor_right: [new Image(), new Image()],
        diamond_armor_front: [new Image(), new Image()],
        diamond_armor_back: [new Image(), new Image()],
        diamond_armor_right: [new Image(), new Image()],
        fall: [new Image(), new Image(), new Image(), new Image(), new Image(), new Image()],
    },
    direction: 'front',
    frameIndex: 0,
    lastFrameTime: 0,
    frameDuration: 400  // Doubled for half speed
},
// Add shrine charge tracking
shrineCharges: 0,
maxShrineCharges: 24,
shrineUsedThisFloor: false, // Track if shrine was used on this floor

// Add soul system properties
soulStones: 0,
soulOrbs: 0,
soulStormCharges: 256, // Track how many charges we have (max 256)
soulStormCharges: 256,
currentWeapon: 'sword', // 'sword | soul_sword | satoshi_scourge | etc ..
coolROI: 0,              // total Cool ROI collected
farmROI: 0,              // Cool ROI currently placed in the active farm spot (0–∞)

echoWardenBlessingGiven: false,

farmLocked: false,
farmLockedFloor: 0,
farmLockedSats: 0,

inSoulTerminal: false, // Track if player is in soul terminal
soulTerminalCommand: '', // Current command input
soulTerminalCursorPos: 0, // Cursor position in command
soulTerminalActive: false, // Whether soul terminal is currently open
// Add diamond hand properties
hasDiamondHand: false, // Track if player has diamond hand
moveCounter: 0,
auraMoveCounter: 0,
lastAuraRefillMove: 0,  // New: Track last refill to throttle
// Add elemental immunity
elementImmunity: null, // Store the player's elemental immunity
armorImmunity: null, // Store armor's elemental immunity
},
    enemies = [], 
    rooms = [];
    dangerousAreas = []; // Track dangerous spell areas
    diamonds = 0;          // total diamonds collected in the current run
    let themeTimeoutId = null;   // <‑‑ new
    
// Load animation frames
p.anim.frames.front[0].src = 'player-front1.png';
p.anim.frames.front[1].src = 'player-front2.png';
p.anim.frames.back[0].src = 'player-back1.png';
p.anim.frames.back[1].src = 'player-back2.png';
p.anim.frames.right[0].src = 'player-right1.png';
p.anim.frames.right[1].src = 'player-right2.png';
p.anim.frames.armor_front[0].src = 'player_armor-front1.png';
p.anim.frames.armor_front[1].src = 'player_armor-front2.png';
p.anim.frames.armor_back[0].src = 'player_armor-back1.png';
p.anim.frames.armor_back[1].src = 'player_armor-back2.png';
p.anim.frames.armor_right[0].src = 'player_armor-right1.png';
p.anim.frames.armor_right[1].src = 'player_armor-right2.png';

// player is affected during theme "Ruins"
p.anim.frames.fall[0].src = 'player_fall1.png';
p.anim.frames.fall[1].src = 'player_fall2.png';
p.anim.frames.fall[2].src = 'player_fall3.png';
p.anim.frames.fall[0].src = 'player_fall4.png';
p.anim.frames.fall[1].src = 'player_fall5.png';
p.anim.frames.fall[2].src = 'player_fall6.png';
p.anim.frames.fall.forEach((frame, i) => {
    frame.onerror = () => console.error(`Failed to load fall frame ${i}: ${frame.src}`);
});

let floor = 1, wave = 1, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
let previousFloorState = null; // Store state before entering hideout
let inHideout = false; // Track if player is in hideout
let jewellerPos = null; // Track jeweller position
let blacksmithPos = null; // Track blacksmith position
let waypointPos = null; // Track waypoint position
let scoreSubmitted = false; // Tracks if score has been submitted
let gameOverBPressed = false;
let cachedLeaderboard = null; // Store fetched leaderboard
let whaleHashIds = ['Whale Transactions:'], battleLog = [], killsLog = [];
let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let soulResonance = 0; // 0-100%
let resonanceTriggeredThisRun = false; 
let wardenUses = 0;  // tracks echo warden revives (reset on restart)
let wardenRollPending = false;  // true when we need to roll for revive
let wardenFlashStart = 0; // Timestamp for 500ms invert flash
let wisps = []; // Array for active wisps (max 1)
let wispPromptTimeout = null; // Timer for floor text prompt
let deadWispCorpse = null; // {x, y, frameIndex, fadeStart: timestamp}
let staticWispDangerSpoken = false;
let wispIsSpeaking = false;
let spellPulseTimer = 0;        // ← add this line
let spellHarassTimer = 0;   // ← add this line
let spellPulseInterval = 0;     // ← and this one
let echoWardenPos = null; // Track warden position for draw
let satoshiDrops = [];
let runeDrops = []; // Array to store rune drops with positions and letters
let scrollDrops = []; // Array to store scroll drops with positions
let portals = []; // Array to store active portal positions and animation state
let splashActive = true;
let waveActive = false;
let musicMuted = localStorage.getItem('musicMuted') === 'true';
      
let swordDir = 'right', swordActive = false, swordStart = 0;
let gameOverSoundPlayed = false;
let fogMap = [];
let battleLogTimeout = null;
let projectiles = [];
let frostNovaProjectiles = []; // {x, y, currentX, currentY, targetX, targetY, frameIndex, startTime}
let wispFireBoltProjectiles = [];
let wispLightningProjectiles = [];
let wispEarthquakeProjectiles = [];
let entangleAnimations = []; // {x, y, frameIndex, startTime, enemyRef}
let snowflakes = [];
let ruinsRainActive = false;
let rainAmbienceTimer = null; // restart loop timer
let rainNoiseSource = null; // source node for looping rain (use global context)
let rainAmbiencePlayed = false; // track if we've started rain sound this run
let fireplaceNoiseSource = null;
let fireplaceAmbienceTimer = null;
let lfo = null;               // ember‑flicker LFO
let popTimeout = null;        // handle for the next pop burst
let raindrops = [];
let floorSplashes = [];
let ruinsRainAngle = 0;  // diagonal direction for rain streaks (set once per block)
let snowyHellActive = false;        // master switch
let snowyHellToggleFloor = 0;       // for slow random toggles
let autoSubmitTriggered = false;
let inputBlocked = false;
let soulStashPos = null; // Position of soul stash on current floor

let catPos = null; // {x, y}
let catVisible = false; // Fade in/out
let catAnimStart = 0; // Timestamp for fade cycle

// Skill tree system
let playerXP = 0;
let playerLevel = 1;
let playerClass = null; // null | 'druid' | 'degen'

let pendingSkillTreeLevel = null; // show tree at (null = none)
let skillTreeActive = false;
let skillTreeSelectedOption = 0; // 0 = Druid, 1 = Degen (only at lvl 3)

const LEVEL_XP = [
    0,  // lvl 1
    10, // 2
    25, // 3 → tree
    45,
    70,
    100,
    135,
    175,
    220,
    270, // 10 → tree
    325,
    385,
    450,
    520,
    595,
    675,
    760,
    850,
    945,
    1045, // 20 → tree
    1150,
    1260,
    1375,
    1495,
    1620,
    1750,
    1885,
    2025,
    2170,
    2320, // 30 → tree
    2475,
    2635,
    2800,
    2970,
    3145,
    3325,
    3510,
    3700,
    3895,
    4095, // 40 → tree
    4300,
    4510,
    4725,
    4945,
    5170,
    5400,
    5635,
    5875,
    6120,
    6370 // 50 → tree
];
function getXPForLevel(lvl) { 
    if (lvl < 1) return 0;
    if (lvl > 50) return LEVEL_XP[49] + 65535; // Cap at lvl 50
    return LEVEL_XP[lvl-1] || 0; 
}
function checkLevelUp() {
    while (playerXP >= getXPForLevel(playerLevel + 1)) {
        playerLevel++;
        logBattleEvent(`Level up! Now level ${playerLevel}`);
        if ([3,10,20,30,40,50].includes(playerLevel)) {
            pendingSkillTreeLevel = playerLevel;
            // Show immediately — no need to wait for move()
            if (!skillTreeActive) {
                showSkillTree();
            }
        }
    }
    // Only update XP bar after kills (not every frame)
}

let soulTerminalActive = false; // Whether soul terminal is currently open
let soulTerminalCommand = ''; // Current command input
let soulTerminalCursorPos = 0; // Cursor position in command

// Puzzle Room System (v2 — proper L2 style)
let inPuzzleRoom = false;
let puzzleHazards = [];      // {x,y,type} — lava, water, quicksand
let puzzleArrows = [];       // {x,y,dir} — 'up','down','left','right'
let puzzleBoulders = [];     // {x,y}
let puzzleHeartFramers = []; // array of {x,y} — collect ALL to open chest
let puzzleChest = null;      // {x,y}

let puzzleTotalHearts = 0;   // Initial number of hearts (set once)
let puzzleCollectedHearts = 0; // How many picked up so far

let farmSpot = null;

let puzzleReturnPos = null;
let puzzleTheme = 'hell';    // hell, desert, paradise

const specialSoundsPlayedThisFloor = {
    lava: false,
    quicksand: false,
    pond: false,
    rune: false,
    hole: false
};

class EnemyType {
    constructor(name, min, max, hp, atk, move, reward = 0) {
        this.name = name;
        this.min = min;
        this.max = max;
        this.hp = hp;
        this.atk = atk;
        this.move = move;
        this.reward = reward;
        this.anim = {
            frames: [new Image(), new Image(), new Image()],
            hellFrames: [new Image(), new Image(), new Image()],
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 400  // Doubled for half speed
        };
    }
}

// Spell types for unique monsters
const SPELL_TYPES = {
    FIRE_WALL: 'Fire Wall',
    LIGHTNING_STORM: 'Lightning Storm',
    FROST_NOVA: 'Frost Nova',
    POISON_CLOUD: 'Poison Cloud'
};

const types = [
    new EnemyType('Shrimp', 0, 0.01, 2, 1, 1),
    new EnemyType('Crab', 0.01, 0.1, 3, 2, 1),
    new EnemyType('Squid', 0.1, 1, 4, 2, 2),
    new EnemyType('Dolphin', 1, 10, 4, 3, 2),
    new EnemyType('Shark', 10, 100, 5, 5, 2),
    new EnemyType('Whale', 100, Infinity, 6, 4, 2),
    new EnemyType('Jester', 0, 0, 10, 2, 1) // no sats, 10 HP, 2 ATK, 1 move
];

// Wisp types (companion spells)
const WISP_TYPES = [
    { name: 'cold', damage: 0, range: 3, aoe: 'medium', effect: 'freeze' }, // Freeze AOE, no dmg
    { name: 'fire', damage: 3, range: 2, aoe: 'single', effect: 'damage' }, // Strong single
    { name: 'chain', damage: 1, range: 3, aoe: 'large', effect: 'chain' }, // Weak large AOE
    { name: 'earth', damage: 2, range: 4, aoe: 'huge', effect: 'quake' } // Strong huge AOE (restrictive)
];
    // Add Cursed Trader as special enemy (not in types for tx spawning)
    const cursedTraderType = new EnemyType('Cursed Trader', 0, 0, 12, 2, 1); // Custom: 12 HP, 2 DMG, 1 move
    cursedTraderType.anim.frames[0].src = 'cursedtrader_1.png';
    cursedTraderType.anim.frames[1].src = 'cursedtrader_2.png';
    cursedTraderType.anim.frames[2].src = 'cursedtrader_3.png';
    cursedTraderType.anim.frameDuration = 400;
    cursedTraderType.reward = 0; // No sats reward

const assets = {
    themes: {
        dungeon: { floor: new Image(), wall: new Image() },
        desert: { floor: new Image(), wall: new Image(), special: new Image() },
        paradise: { floor: new Image(), wall: new Image(), special: new Image() },
        hell: { floor: new Image(), wall: new Image(), special: new Image() },
        ruins: { floor: new Image(), wall: new Image(), special: new Image() },
        hideout: { floor: new Image(), wall: new Image(), diamond_wall: new Image() }
    },
    potion: new Image(),
    player: new Image(),
    stairs: new Image(),
    bitcoin: new Image(),
    gameOver: new Image(),
    sword: new Image(),
    pickaxe: new Image(),
    armor: new Image(),
    player_armor: new Image(),
    player_diamond_armor: new Image(),
    pickaxe_sword: new Image(),
    shoot_sword: new Image(),
    gnome: new Image(),
    jeweller: new Image(),
    blacksmith: new Image(),
    waypoint: new Image(),
    rune_whisperer: new Image(),
    runes: {
        on_floor: new Image(),
        a: new Image(), b: new Image(), c: new Image(), d: new Image(), e: new Image(),
        f: new Image(), g: new Image(), h: new Image(), i: new Image(), k: new Image(),
        l: new Image(), m: new Image(), n: new Image(), o: new Image(), p: new Image(),
        q: new Image(), r: new Image(), s: new Image(), t: new Image(), u: new Image(),
        v: new Image(), y: new Image(), z: new Image(), æ: new Image(), ø: new Image()
    },
    diamond: new Image(),
    scroll: new Image(),
    town_portal: [new Image(), new Image(), new Image()],
    soul_stash: new Image(),
    soul_stone: new Image(),
    hooded_heirloom: new Image(),
    soul_orb_statue: new Image(),
    shrine: new Image()
};

// Load sprite frames for each enemy type
types.forEach((type, index) => {
    // Set up default animation frames
    type.anim.frames[0].src = `${type.name.toLowerCase()}_1.png`;
    type.anim.frames[1].src = `${type.name.toLowerCase()}_2.png`;
    type.anim.frames[2].src = `${type.name.toLowerCase()}_3.png`;
    
    // Theme-specific frames — skip Jester (uses custom jester_frames)
    if (type.name !== 'Jester') {
        type.anim.paradiseFrames = [new Image(), new Image(), new Image()];
        type.anim.ruinsFrames = [new Image(), new Image(), new Image()];
        type.anim.desertFrames = [new Image(), new Image(), new Image()];
        type.anim.hellFrames = type.anim.hellFrames || [new Image(), new Image(), new Image()];

        const prefix = type.name.toLowerCase();
        type.anim.paradiseFrames[0].src = `p_${prefix}_1.png`;
        type.anim.paradiseFrames[1].src = `p_${prefix}_2.png`;
        type.anim.paradiseFrames[2].src = `p_${prefix}_3.png`;
        type.anim.ruinsFrames[0].src = `r_${prefix}_1.png`;
        type.anim.ruinsFrames[1].src = `r_${prefix}_2.png`;
        type.anim.ruinsFrames[2].src = `r_${prefix}_3.png`;
        type.anim.desertFrames[0].src = `d_${prefix}_1.png`;
        type.anim.desertFrames[1].src = `d_${prefix}_2.png`;
        type.anim.desertFrames[2].src = `d_${prefix}_3.png`;
        type.anim.hellFrames[0].src = `h_${prefix}_1.png`;
        type.anim.hellFrames[1].src = `h_${prefix}_2.png`;
        type.anim.hellFrames[2].src = `h_${prefix}_3.png`;

        // Error logging for themed frames
        ['paradiseFrames', 'ruinsFrames', 'desertFrames', 'hellFrames'].forEach(arrayName => {
            type.anim[arrayName].forEach((frame, i) => {
                frame.onerror = () => console.error(`Failed to load ${arrayName} ${prefix} frame ${i+1}`);
            });
        });
    }
    
});

Object.values(assets).forEach(asset => {
        if (asset instanceof Image) {
            asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
        } else if (typeof asset === 'object') {
            Object.values(asset).forEach(subAsset => {
                subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
            });
        }
    });
    
        assets.themes.dungeon.floor.src = 'floor.png';
        assets.themes.dungeon.wall.src = 'wall.png';
        assets.themes.desert.floor.src = 'sand_floor.png';
        assets.themes.desert.wall.src = 'sand_wall.png';
        assets.themes.desert.special.src = 'quicksand.png';
        assets.themes.paradise.floor.src = 'paradise_floor.png';
        assets.themes.paradise.wall.src = 'paradise_wall.png';
        assets.themes.paradise.special.src = 'pond.png';
        // Normal hell
        assets.themes.hell.floor.src = 'hell_floor.png';
        assets.themes.hell.wall.src = 'hell_wall.png';
        assets.themes.hell.special.src = 'lava.png';
        // Snowy hell overrides (used when snowyHellActive = true)
        assets.themes.hell.snowy_floor = new Image();
        assets.themes.hell.snowy_wall = new Image();
        assets.themes.hell.snowy_floor.src = 'hell_floor_snow.png';
        assets.themes.hell.snowy_wall.src = 'hell_wall.png';     // reuse base texture
        assets.themes.ruins.floor.src = 'ring_floor.png';
        assets.themes.ruins.wall.src = 'ring_wall.png';
        assets.themes.ruins.special.src = 'ring_hole.png';
        
// Random tile variants for desert, paradise, hell, ruins (normal only)
assets.themes.desert.floors = [
    assets.themes.desert.floor,
    new Image(), new Image(), new Image()
];
assets.themes.desert.floors[1].src = 'sand_floor2.png';
assets.themes.desert.floors[2].src = 'sand_floor3.png';
assets.themes.desert.floors[3].src = 'sand_floor4.png';

assets.themes.desert.walls = [
    assets.themes.desert.wall,
    new Image(), new Image(), new Image()
];
assets.themes.desert.walls[1].src = 'sand_wall2.png';
assets.themes.desert.walls[2].src = 'sand_wall3.png';
assets.themes.desert.walls[3].src = 'sand_wall4.png';

assets.themes.paradise.floors = [
    assets.themes.paradise.floor,
    new Image(), new Image(), new Image()
];
assets.themes.paradise.floors[1].src = 'paradise_floor2.png';
assets.themes.paradise.floors[2].src = 'paradise_floor3.png';
assets.themes.paradise.floors[3].src = 'paradise_floor4.png';

assets.themes.paradise.walls = [
    assets.themes.paradise.wall,
    new Image(), new Image(), new Image()
];
assets.themes.paradise.walls[1].src = 'paradise_wall2.png';
assets.themes.paradise.walls[2].src = 'paradise_wall3.png';
assets.themes.paradise.walls[3].src = 'paradise_wall4.png';

assets.themes.hell.floors = [
    assets.themes.hell.floor,
    new Image(), new Image(), new Image()
];
assets.themes.hell.floors[1].src = 'hell_floor2.png';
assets.themes.hell.floors[2].src = 'hell_floor3.png';
assets.themes.hell.floors[3].src = 'hell_floor4.png';

assets.themes.hell.walls = [
    assets.themes.hell.wall,
    new Image(), new Image(), new Image()
];
assets.themes.hell.walls[1].src = 'hell_wall2.png';
assets.themes.hell.walls[2].src = 'hell_wall3.png';
assets.themes.hell.walls[3].src = 'hell_wall4.png';

assets.themes.ruins.floors = [
    assets.themes.ruins.floor,
    new Image(), new Image(), new Image()
];
assets.themes.ruins.floors[1].src = 'ring_floor2.png';
assets.themes.ruins.floors[2].src = 'ring_floor3.png';
assets.themes.ruins.floors[3].src = 'ring_floor4.png';

assets.themes.ruins.walls = [
    assets.themes.ruins.wall,
    new Image(), new Image(), new Image()
];
assets.themes.ruins.walls[1].src = 'ring_wall2.png';
assets.themes.ruins.walls[2].src = 'ring_wall3.png';
assets.themes.ruins.walls[3].src = 'ring_wall4.png';
        
        assets.potion.src = 'potion.png';
        assets.gnome.src = 'gnome.png';
	assets.player.src = 'player.png';
	assets.pickaxe.src = 'pickaxe.png';
	assets.armor.src = 'armor.png';
	assets.player_armor.src = 'player_armor.png';
        assets.stairs.src = 'stairs.png'; 
        assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png';
        assets.sword.src = 'sword.png';
        assets.diamond_hand = new Image(); // Add diamond hand asset
        assets.diamond_hand.src = 'diamond_hand.png';
        assets.pickaxe_sword.src = 'pickaxe-sword.png';
        assets.shoot_sword.src = 'shoot_sword.png';        
        assets.bit_spear = new Image();
        assets.bit_spear.src = 'bit_spear.png';       
        assets.soul_sword = new Image();
        assets.soul_sword.src = 'soul_sword.png';      
        assets.runes.on_floor.src = 'rune_on_floor.png';
	assets.runes.a.src = 'rune-a.png';
	assets.runes.b.src = 'rune-b.png';
	assets.runes.c.src = 'rune-c.png';
	assets.runes.d.src = 'rune-d.png';
	assets.runes.e.src = 'rune-e.png';
	assets.runes.f.src = 'rune-f.png';
	assets.runes.g.src = 'rune-g.png';
	assets.runes.h.src = 'rune-h.png';
	assets.runes.i.src = 'rune-i.png';
	assets.runes.k.src = 'rune-k.png';
	assets.runes.l.src = 'rune-l.png';
	assets.runes.m.src = 'rune-m.png';
	assets.runes.n.src = 'rune-n.png';
	assets.runes.o.src = 'rune-o.png';
	assets.runes.p.src = 'rune-p.png';
	assets.runes.q.src = 'rune-q.png';
	assets.runes.r.src = 'rune-r.png';
	assets.runes.s.src = 'rune-s.png';
	assets.runes.t.src = 'rune-t.png';
	assets.runes.u.src = 'rune-u.png';
	assets.runes.v.src = 'rune-v.png';
	assets.runes.y.src = 'rune-y.png';
	assets.runes.z.src = 'rune-z.png';
	assets.runes.æ.src = 'rune-æ.png';
	assets.runes.ø.src = 'rune-ø.png';
	
	assets.diamond.src = 'diamond.png';
	assets.scroll.src = 'scroll.png';
	assets.town_portal[0].src = 'town_portal_1.png';
	assets.town_portal[1].src = 'town_portal_2.png';
	assets.town_portal[2].src = 'town_portal_3.png';
	assets.themes.hideout.floor.src = 'town_floor.png';
	assets.themes.hideout.wall.src = 'town_wall.png';
	assets.themes.hideout.diamond_wall.src = 'diamond_wall.png';
	assets.smelter = new Image();
        assets.smelter.src = 'smelter.png';
	assets.soul_orb_statue.src = 'soul_orb_statue.png';
	assets.shrine.src = 'shrine.png';

assets.billboard = new Image();
assets.billboard.src = 'billboard.png';

// Puzzle room assets
assets.puzzlePortal = [new Image(), new Image(), new Image()];
assets.puzzlePortal[0].src = 'puzzle_portal_1.png';
assets.puzzlePortal[1].src = 'puzzle_portal_2.png';
assets.puzzlePortal[2].src = 'puzzle_portal_3.png';
assets.boulder = new Image();
assets.boulder.src = 'boulder.png';
assets.heartFramer = new Image();
assets.heartFramer.src = 'heart_framer.png';
assets.chestClosed = new Image();
assets.chestClosed.src = 'chest_closed.png';
assets.chestOpen = new Image();
assets.chestOpen.src = 'chest_open.png';

assets.arrow_up    = new Image(); assets.arrow_up.src    = 'arrow_up.png';
assets.arrow_right = new Image(); assets.arrow_right.src = 'arrow_right.png';
assets.arrow_down  = new Image(); assets.arrow_down.src  = 'arrow_down.png';
assets.arrow_left  = new Image(); assets.arrow_left.src  = 'arrow_left.png';
	
	assets.jeweller.src = 'jeweller.png';
	assets.blacksmith.src = 'blacksmith.png';
	assets.waypoint.src = 'waypoint.png';
	assets.rune_whisperer.src = 'rune_whisperer.png';
	assets.player_diamond_armor.src = 'player_diamond_armor.png';
	assets.soul_stash.src = 'soul_stash.png';
	assets.soul_stone.src = 'soul_stone.png';
	assets.hooded_heirloom.src = 'hooded_heirloom.png';
assets.cursed_ring = new Image(),
assets.cursed_ring.src = 'cursed_ring.png';

assets.farmSpot1 = new Image();
assets.farmSpot1.src = 'farmSpot1.png';
assets.farmSpot2 = new Image();
assets.farmSpot2.src = 'farmSpot2.png';
assets.farmSpot1.onerror = () => console.error('Failed to load farmSpot1.png');
assets.farmSpot2.onerror = () => console.error('Failed to load farmSpot2.png');

assets.echo_warden = new Image();
assets.echo_warden.src = 'ἀρχάγγελος.png';
assets.echo_warden.onerror = () => console.error('Failed to load echo_warden.png');

// Wisp animation frames — per type
assets.wispFrames = {
    cold:  [new Image(), new Image(), new Image()],
    fire:  [new Image(), new Image(), new Image()],
    chain: [new Image(), new Image(), new Image()],
    earth: [new Image(), new Image(), new Image()]
};

assets.wispFrames.cold[0].src = 'wisp1.png';
assets.wispFrames.cold[1].src = 'wisp2.png';
assets.wispFrames.cold[2].src = 'wisp3.png';

assets.wispFrames.fire[0].src = 'wisp-f1.png';
assets.wispFrames.fire[1].src = 'wisp-f2.png';
assets.wispFrames.fire[2].src = 'wisp-f3.png';

assets.wispFrames.chain[0].src = 'wisp-c1.png';
assets.wispFrames.chain[1].src = 'wisp-c2.png';
assets.wispFrames.chain[2].src = 'wisp-c3.png';

assets.wispFrames.earth[0].src = 'wisp-e1.png';
assets.wispFrames.earth[1].src = 'wisp-e2.png';
assets.wispFrames.earth[2].src = 'wisp-e3.png';

// Error handling
Object.values(assets.wispFrames).forEach((frames, typeIndex) => {
    const typeNames = ['cold', 'fire', 'chain', 'earth'];
    frames.forEach((frame, i) => {
        frame.onerror = () => console.error(`Failed to load wisp ${typeNames[typeIndex]} frame ${i+1}`);
    });
});

// Frost Nova animation frames (3-frame)
assets.frostNova = [new Image(), new Image(), new Image()];
assets.frostNova[0].src = 'wisp_nova1.png';
assets.frostNova[1].src = 'wisp_nova2.png';
assets.frostNova[2].src = 'wisp_nova3.png';

// Wisp attack projectiles (3 frames each)
assets.wispFireBolt = [new Image(), new Image(), new Image()];
assets.wispLightning = [new Image(), new Image(), new Image()];
assets.wispEarthquake = [new Image(), new Image(), new Image()];

assets.wispFireBolt[0].src = 'wisp_firebolt1.png';
assets.wispFireBolt[1].src = 'wisp_firebolt2.png';
assets.wispFireBolt[2].src = 'wisp_firebolt3.png';

assets.wispLightning[0].src = 'wisp_lightning1.png';
assets.wispLightning[1].src = 'wisp_lightning2.png';
assets.wispLightning[2].src = 'wisp_lightning3.png';

assets.wispEarthquake[0].src = 'wisp_earthquake1.png';
assets.wispEarthquake[1].src = 'wisp_earthquake2.png';
assets.wispEarthquake[2].src = 'wisp_earthquake3.png';

// Error handling
[assets.wispFireBolt, assets.wispLightning, assets.wispEarthquake].forEach((frames, idx) => {
    const names = ['Fire Bolt', 'Lightning', 'Earthquake'][idx];
    frames.forEach((frame, i) => {
        frame.onerror = () => console.error(`Failed to load ${names} frame ${i+1}`);
    });
});

// Frozen enemy overlays (1 frame)
const frozenTypes = ['shrimp', 'crab', 'squid', 'dolphin', 'shark', 'whale'];
frozenTypes.forEach(type => {
    assets[`frozen_${type}`] = [new Image()];
    assets[`frozen_${type}`][0].src = `frozen_${type}_1.png`;
});

// Entangle animation overlay (3 frames)
assets.entangleFrames = [new Image(), new Image(), new Image()];
assets.entangleFrames[0].src = 'entangle_1.png';
assets.entangleFrames[1].src = 'entangle_2.png';
assets.entangleFrames[2].src = 'entangle_3.png';

// Add to assets (at top with other assets)
assets.passive_sign = new Image();
assets.passive_sign.src = 'passive_sign.png';
assets.passive_tree_background = new Image();
assets.passive_tree_background.src = 'passive_tree_background.png';
assets.ruby = new Image();
assets.ruby.src = 'ruby.png';
assets.sapphire = new Image();
assets.sapphire.src = 'sapphire.png';
assets.emerald = new Image();
assets.emerald.src = 'emerald.png';
assets.citrine = new Image();
assets.citrine.src = 'citrine.png';

// Enemy background circles (16x16px animated)
assets.enemyBg = [new Image(), new Image(), new Image()];
assets.enemyBg[0].src = 'red-bg1.png';
assets.enemyBg[1].src = 'red-bg2.png';
assets.enemyBg[2].src = 'red-bg3.png';
	p.anim.frames.diamond_armor_front = [new Image(), new Image()];
	p.anim.frames.diamond_armor_front[0].src = 'player_diamond_armor-front1.png';
	p.anim.frames.diamond_armor_front[1].src = 'player_diamond_armor-front2.png';
	p.anim.frames.diamond_armor_back = [new Image(), new Image()];
	p.anim.frames.diamond_armor_back[0].src = 'player_diamond_armor-back1.png';
	p.anim.frames.diamond_armor_back[1].src = 'player_diamond_armor-back2.png';
	p.anim.frames.diamond_armor_right = [new Image(), new Image()];
	p.anim.frames.diamond_armor_right[0].src = 'player_diamond_armor-right1.png';
	p.anim.frames.diamond_armor_right[1].src = 'player_diamond_armor-right2.png';

// DRUID class frames
p.anim.frames.druid_front = [new Image(), new Image()];
p.anim.frames.druid_back = [new Image(), new Image()];
p.anim.frames.druid_right = [new Image(), new Image()];
p.anim.frames.druid_armor_front = [new Image(), new Image()];
p.anim.frames.druid_armor_back = [new Image(), new Image()];
p.anim.frames.druid_armor_right = [new Image(), new Image()];
p.anim.frames.druid_diamond_armor_front = [new Image(), new Image()];
p.anim.frames.druid_diamond_armor_back = [new Image(), new Image()];
p.anim.frames.druid_diamond_armor_right = [new Image(), new Image()];

// Load Druid assets
p.anim.frames.druid_front[0].src = 'druid-front1.png';
p.anim.frames.druid_front[1].src = 'druid-front2.png';
p.anim.frames.druid_back[0].src = 'druid-back1.png';
p.anim.frames.druid_back[1].src = 'druid-back2.png';
p.anim.frames.druid_right[0].src = 'druid-right1.png';
p.anim.frames.druid_right[1].src = 'druid-right2.png';
p.anim.frames.druid_armor_front[0].src = 'druid_armor-front1.png';
p.anim.frames.druid_armor_front[1].src = 'druid_armor-front2.png';
p.anim.frames.druid_armor_back[0].src = 'druid_armor-back1.png';
p.anim.frames.druid_armor_back[1].src = 'druid_armor-back2.png';
p.anim.frames.druid_armor_right[0].src = 'druid_armor-right1.png';
p.anim.frames.druid_armor_right[1].src = 'druid_armor-right2.png';
p.anim.frames.druid_diamond_armor_front[0].src = 'druid_diamond_armor-front1.png';
p.anim.frames.druid_diamond_armor_front[1].src = 'druid_diamond_armor-front2.png';
p.anim.frames.druid_diamond_armor_back[0].src = 'druid_diamond_armor-back1.png';
p.anim.frames.druid_diamond_armor_back[1].src = 'druid_diamond_armor-back2.png';
p.anim.frames.druid_diamond_armor_right[0].src = 'druid_diamond_armor-right1.png';
p.anim.frames.druid_diamond_armor_right[1].src = 'druid_diamond_armor-right2.png';

assets.satoshi_scourge = new Image();
assets.satoshi_scourge.src = 'satoshi_scourge.png';
assets.satoshi_scourge.onerror = () => console.error('Failed to load satoshi_scourge.png');

assets.cat = new Image();
assets.cat.src = 'black_cat.png';
assets.cat.onerror = () => console.error('Failed to load black_cat.png');

assets.elixir = new Image();
assets.elixir.src = 'elixir.png';

assets.info_sign = new Image();
assets.info_sign.src = 'info_sign.png';
assets.info_tile = new Image();
assets.info_tile.src = 'info_tile.png';

// Sandworm — 3-frame animation
assets.sandworm = [new Image(), new Image(), new Image()];
assets.sandworm[0].src = 'sandworm.png';
assets.sandworm[1].src = 'sandworm2.png';
assets.sandworm[2].src = 'sandworm3.png';
assets.sandworm.frameIndex = 0;
assets.sandworm.lastFrameTime = 0;
assets.sandworm.frameDuration = 400; // same speed as enemies

// Jester animation frames (3 frames)
assets.jester_frames = [new Image(), new Image(), new Image()];
assets.jester_frames[0].src = 'jester_1.png';
assets.jester_frames[1].src = 'jester_2.png';
assets.jester_frames[2].src = 'jester_3.png';

// Jester shrine
assets.jester_shrine = new Image();
assets.jester_shrine.src = 'jester_shrine.png';

// Acrobatics buff icon
assets.jester_acrobatics = new Image();
assets.jester_acrobatics.src = 'jester_acrobatics.png';

// New top-right UI assets (16x16)
assets.inv_cloth = new Image();
assets.inv_leather = new Image();
assets.inv_diamond_armor = new Image();
assets.inv_cursed_aura = new Image();
assets.inv_maze_aura = new Image();
assets.inv_cloth.src = 'inv_cloth.png';
assets.inv_leather.src = 'inv_leather.png';
assets.inv_diamond_armor.src = 'inv_diamond_armor.png';
assets.inv_cursed_aura.src = 'inv_cursed_aura.png';
assets.inv_maze_aura.src = 'inv_maze_aura.png';

// Red Maze boss — 3-frame animation
assets.red_maze = [new Image(), new Image(), new Image()];
assets.red_maze[0].src = 'red_maze.png';
assets.red_maze[1].src = 'red_maze2.png';
assets.red_maze[2].src = 'red_maze3.png';
assets.red_maze.frameIndex = 0;
assets.red_maze.lastFrameTime = 0;
assets.red_maze.frameDuration = 400;

assets.swap = new Image();
assets.swap.src = 'swap.png';
assets.swap.onerror = () => console.error('Failed to load swap.png');

assets.coolROI = new Image();
assets.coolROI.src = 'Cool_ROI.png';
assets.coolROI.onerror = () => console.error('Failed to load Cool_ROI.png');

assets.coolROI.src = 'Cool_ROI.png';

assets.um_poisonCloud = new Image();
assets.um_poisonCloud.src = 'um_p-cloud.png';
assets.um_frostNova = new Image();
assets.um_frostNova.src = 'um_f-nova.png';
assets.um_lightningStorm = new Image();
assets.um_lightningStorm.src = 'um_l-storm.png';
assets.um_fireWall = new Image();
assets.um_fireWall.src = 'um_f-wall.png';
	
assets.guiHP = new Image();
assets.guiHP.src = 'GUI-HP.png';
assets.guiHPglobe = new Image();
assets.guiHPglobe.src = 'GUI-HP-globe.png';
assets.guiSC = new Image();
assets.guiSC.src = 'GUI-SC.png';
assets.guiSCglobe = new Image();
assets.guiSCglobe.src = 'GUI-SC-globe.png';
	
Object.values(assets.runes).forEach(rune => {
    rune.onerror = () => console.error(`Failed to load rune asset: ${rune.src}`);
});
Object.values(assets).forEach(asset => {
    if (asset instanceof Image) {
        asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
    } else if (typeof asset === 'object') {
        Object.values(asset).forEach(subAsset => {
            subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
        });
    }
});
types.forEach(t => {
    if (t.img) {
        t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`);
    } else if (t.anim) {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});

//
// we use 'hit', 'enemy' and 'e' as the same thing in the game. It is all enemies, this is a reminder of that. :D
//

function placeStairs() {
    if (inHideout) {
        console.warn('Attempted to place stairs in hideout – forbidden');
        return false;
    }
    if (exit) {
        logBattleEvent(`Floor ${floor} - Stairs placement skipped: exit already exists at (${exit.x}, ${exit.y})`);
        return true;
    }
    let x, y, placed = false;
    // Try room-based placement first
    if (rooms && rooms.length > 0) {
        let r = rooms[Math.floor(Math.random() * rooms.length)];
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = r.x + Math.floor(Math.random() * r.w);
            y = r.y + Math.floor(Math.random() * r.h);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    // Fallback to any valid floor tile
    if (!placed) {
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = Math.floor(Math.random() * W);
            y = Math.floor(Math.random() * H);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    if (placed) {
        exit = {x, y};
        updateSatsDisplay();
        logBattleEvent(`Floor ${floor} - Stairs appeared!`);
        needsRedraw = true;
        return true;
    } else {
        logBattleEvent(`Floor ${floor} - Failed to place stairs: no valid position found!`);
        console.warn(`Stairs placement failed: rooms=${rooms.length}, map valid=${map.every(row => row.length === W)}`);
        needsRedraw = true;
        return false;
    }
}

// AudioContext setup – early init for iOS compatibility
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioContext = null;
let masterGain = null;  // NEW: Master gain for all Web Audio

// Volume control – global defaults (MOVED UP to fix initialization order)
let soundVolume = localStorage.getItem('soundVolume') || 1.0;
let musicVolume = localStorage.getItem('musicVolume') || 1.0;
function setSoundVolume(volume) {
    soundVolume = Math.max(0, Math.min(1, volume));
    localStorage.setItem('soundVolume', soundVolume);
    // Update legacy Audio objects
    Object.entries(sounds).forEach(([key, sound]) => {
        if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout') return; // Skip music
        if (sound instanceof Audio) {
            sound.volume = soundVolume;
        }
    });
    // NEW: Update masterGain for Web Audio (including ongoing TTS)
    if (masterGain) {
        masterGain.gain.value = soundVolume * getPlatformMasterGain();
    }
}
function setMusicVolume(volume) {
    musicVolume = Math.max(0, Math.min(1, volume));
    localStorage.setItem('musicVolume', musicVolume);
    if (musicManager) {
        musicManager.volume = musicVolume;
        if (musicManager.current && musicManager.audios[musicManager.current]) {
            musicManager.audios[musicManager.current].volume = musicManager.muted ? 0 : musicVolume;
        }
    }
}

// Platform-specific gain helper (makes sense – Android boost for quiet Web Audio)
// (MOVED UP if it was after, but it's function-hoisted anyway)
function getPlatformMasterGain() {
    const ua = navigator.userAgent || navigator.vendor || window.opera;
    const isAndroid = /android/i.test(ua);
    const calmLevel = 0.5;
    return isAndroid ? calmLevel * 1.5 : calmLevel; // 0.75 Android, 0.5 others
}

function getAudioContext() {
    if (!audioContext) {
        audioContext = new AudioContext();
        masterGain = audioContext.createGain();
        masterGain.gain.value = soundVolume * getPlatformMasterGain();
        masterGain.connect(audioContext.destination);
    }
    return audioContext;
}
audioContext = getAudioContext(); // Early creation (before sounds)

// Sounds object – create Audio instances early
const sounds = {
    attack: new Audio('attack.wav'),
    potion: new Audio('potion.wav'),
    hit: { buffer: null, url: 'hit.wav', isPlaying: false, duration: 720 },
    pickup: { buffer: null, url: 'pickup.wav', isPlaying: false, duration: 950 },
    dungeon: new Audio('dungeon.mp3'),
    desert: new Audio('desert.mp3'),
    hell: new Audio('hell.mp3'),
    paradise: new Audio('paradise.mp3'),
    ruins: new Audio('ruins.mp3'),
    hideout: new Audio('hideout.mp3'),
    gameover: new Audio('gameover.wav'),
    stairs: new Audio('stairs.wav'),
    secret: new Audio('secret.wav'),
    shoot_sword: new Audio('shoot_sword.wav'),
    heads: { buffer: null, url: 'heads.wav', isPlaying: false, duration: 650 },
    tails: { buffer: null, url: 'tails.wav', isPlaying: false, duration: 950 },
    lava: { buffer: null, url: 'lava.wav', isPlaying: false, duration: 900 },
    quicksand: { buffer: null, url: 'quicksand.wav', isPlaying: false, duration: 250 },
    pond: { buffer: null, url: 'pond.wav', isPlaying: false, duration: 500 },
    rune: { buffer: null, url: 'rune.wav', isPlaying: false, duration: 2000 },
    rune_drop: { buffer: null, url: 'rune_drop.wav', isPlaying: false, duration: 1000 },
    hole: { buffer: null, url: 'hole.wav', isPlaying: false, duration: 745 },
    town_portal: { buffer: null, url: 'town_portal.wav', isPlaying: false, duration: 535 },
    buzz: { buffer: null, url: 'buzz.wav', isPlaying: false, duration: 1000 },
    unique_monster: { buffer: null, url: 'unique_monster.wav', isPlaying: false, duration: 1400 }
};

// Web Audio buffer loading (no play during load)
function loadSoundBuffer(url, key) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(data => audioContext.decodeAudioData(data))
        .then(buffer => {
            sounds[key].buffer = buffer;
        })
        .catch(e => console.error(`Failed to load Web Audio buffer for ${key}: ${url}`, e));
}
loadSoundBuffer('hit.wav', 'hit');
loadSoundBuffer('pickup.wav', 'pickup');
loadSoundBuffer('heads.wav', 'heads');
loadSoundBuffer('tails.wav', 'tails');
loadSoundBuffer('lava.wav', 'lava');
loadSoundBuffer('quicksand.wav', 'quicksand');
loadSoundBuffer('pond.wav', 'pond');
loadSoundBuffer('rune.wav', 'rune');
loadSoundBuffer('rune_drop.wav', 'rune_drop');
loadSoundBuffer('hole.wav', 'hole');
loadSoundBuffer('town_portal.wav', 'town_portal');
loadSoundBuffer('buzz.wav', 'buzz');
loadSoundBuffer('unique_monster.wav', 'unique_monster');

// MusicManager class (after sounds + volumes)
class MusicManager {
  constructor() {
    this.audios = {
      dungeon: sounds.dungeon,
      desert: sounds.desert,
      hell: sounds.hell,
      paradise: sounds.paradise,
      ruins: sounds.ruins,
      hideout: sounds.hideout
    };
    this.current = null;
    this.muted = false;
    this.volume = musicVolume;
    Object.values(this.audios).forEach(audio => {
      audio.loop = true;
      audio.onerror = () => console.error(`Failed to load music: ${audio.src}`);
      audio.volume = musicVolume;
    });
  }
  play(theme) {
    if (!this.audios[theme]) return;
    const audio = this.audios[theme];
    if (this.current === theme) {
      if (!this.muted) {
        audio.play().catch(e => console.error('Music play failed:', e));
      }
      return;
    }
    if (this.current) {
      this.fadeOut(this.audios[this.current]);
    }
    audio.volume = this.muted ? 0 : musicVolume;
    audio.muted = this.muted;
    audio.play().catch(e => console.error('Music play failed:', e));
    if (!this.muted) {
      this.fadeIn(audio);
    }
    this.current = theme;
  }
  fadeOut(audio) {
    let vol = audio.volume;
    const interval = setInterval(() => {
      vol = Math.max(0, vol - 0.1);
      audio.volume = vol;
      if (vol <= 0) {
        clearInterval(interval);
        audio.pause();
        audio.currentTime = 0;
      }
    }, 100);
  }
  fadeIn(audio) {
    let vol = 0;
    const interval = setInterval(() => {
      vol = Math.min(this.volume, vol + 0.1);
      audio.volume = vol;
      if (vol >= this.volume) {
        clearInterval(interval);
      }
    }, 100);
  }
  mute(muted) {
    this.muted = muted;
    if (this.current) {
      this.audios[this.current].muted = muted;
      this.audios[this.current].volume = muted ? 0 : musicVolume;
    }
  }
}
const musicManager = new MusicManager();

// Preload function – safe for iOS (no play during load)
function preloadSounds() {
    const savedSoundVolume = soundVolume;
    if (isIOSorSafari()) {
        // iOS: Only create Audio objects (no play – prevents suspension)
        Object.entries(sounds).forEach(([key, sound]) => {
            if (['dungeon','desert','hell','paradise','ruins','hideout'].includes(key)) return;
            if (sound instanceof Audio && sound.src) {
                const temp = new Audio(sound.src);
                temp.volume = 0;
            }
        });
    } else {
        // Non-iOS: Safe preload with play/pause at 0 volume
        Object.entries(sounds).forEach(([key, sound]) => {
            if (['dungeon','desert','hell','paradise','ruins','hideout'].includes(key)) return;
            if (sound instanceof Audio && sound.src) {
                sound.volume = 0;
                sound.play().then(() => {
                    sound.pause();
                    sound.currentTime = 0;
                    sound.volume = 0;
                }).catch(() => {});
            }
        });
    }
    // Restore volume after preload
    setTimeout(() => setSoundVolume(savedSoundVolume), 100);
}
// Start preload immediately (after AudioContext init)
preloadSounds();
Object.values(sounds).forEach(s => {
    if (s instanceof Audio) {
        s.volume = 1.0;
        s.onerror = () => console.error(`Failed to load sound: ${s.src}`);
    }
});
function isIOSorSafari() {
    const ua = navigator.userAgent;
    return /iPad|iPhone|iPod/.test(ua) || /Safari/.test(ua);
}
function preloadSounds() {
    // Save current volume before setting to 0
    const savedSoundVolume = soundVolume;
   
    if (isIOSorSafari()) {
        // iOS/Safari: Preload by setting src without playing
        Object.entries(sounds).forEach(([key, sound]) => {
            if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop' || key === 'hole' || key === 'town_portal' || key === 'buzz' || key === 'unique_monster') return; // Skip music and Web Audio sounds
            if (Array.isArray(sound)) {
                sound.forEach((instance, idx) => {
                    // Create a new Audio object to trigger caching
                    const tempAudio = new Audio(instance.src);
                    tempAudio.volume = 0; // Set volume to 0 during preload
                });
            } else if (sound instanceof Audio && sound.src) {
                // Create a new Audio object to trigger caching
                const tempAudio = new Audio(sound.src);
                tempAudio.volume = 0;
            }
        });
} else {
    // Non-iOS: Existing preload logic
    Object.entries(sounds).forEach(([key, sound]) => {
        if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop' || key === 'hole' || key === 'town_portal' || key === 'buzz' || key === 'unique_monster') return; // Skip music and Web Audio sounds
        if (Array.isArray(sound)) {
            sound.forEach((instance, idx) => {
                if (instance instanceof Audio && instance.src) {
                    instance.volume = 0; // Set volume to 0 during preload
                    instance.play().then(() => {
                        instance.pause();
                        instance.currentTime = 0;
                        instance.volume = 0; // Keep at 0 during preload
                    }).catch(e => console.error(`Preload sound error for ${instance.src}:`, e));
                }
            });
        } else if (sound instanceof Audio && sound.src) {
            sound.volume = 0; // Set volume to 0 during preload
            sound.play().then(() => {
                sound.pause();
                sound.currentTime = 0;
                sound.volume = 0; // Keep at 0 during preload
            }).catch(e => console.error(`Preload sound error for ${sound.src}:`, e));
        }
    });
}
   
    // Restore original volume after preloading is complete
    setTimeout(() => {
        setSoundVolume(savedSoundVolume);
    }, 100);
}
function playWebAudioSound(soundObj) {
    if (!soundObj.buffer) {
        console.warn(`Buffer not loaded for ${soundObj.url}`);
        return;
    }
    if (soundObj.isPlaying) {
                return;
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
                    }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    soundObj.isPlaying = true; // Set flag
    const source = audioContext.createBufferSource();
    source.buffer = soundObj.buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 1.0;  // NEW: Let masterGain handle scaling
    source.connect(gainNode);
    gainNode.connect(masterGain);  // NEW: Connect to masterGain
    source.start(0);
        source.onended = () => {
        soundObj.isPlaying = false; // Clear flag
            };
    // Fallback timeout to clear flag if onended fails
    setTimeout(() => {
        if (soundObj.isPlaying) {
            soundObj.isPlaying = false;
                    }
    }, soundObj.duration);
}
// TTS Wisps voice
const talkOpts = {speed: 72, pitch: 28, throat: 128, mouth: 128};
// wisp voice lines
const talkLines = [
  "DUMMY LINE, DO NOT USE", // 0
  "BITCoOIN,", // 1
  "Nooo. -Shark", // 2
  "BOSS-TIME! - GO GO GO", // 3
  "Watch out", // 4
  "winning", // 5
  "HA HA. Shwrimp!", // 6
  "take your time, no rush", // 7
  "take, a breac!", // 8
  "Oh no.", // 9
  "hello you , go go go", // 10
  "yesh, Bitcoin from bounty", // 11
  "yesh, Deiamond. Soul-Orb . RIP.", // 12
  "yesh, PickAaXe , RIP.", // 13
  "yes,. PickAaXe", // 14
  "too strong, run away", // 15
  "cool., Ealixyr from bounty" // 16
];
// Current speech (for stopping if needed)
let currentTalkSpeech = null;
// Speak a wisp line by index (0-Infinity)
// Call this from your game events
function talkSpeak(lineIndex) {
  if (lineIndex < 0 || lineIndex >= talkLines.length) {
    console.warn("Invalid wisp line index:", lineIndex);
    return;
  }
  const text = talkLines[lineIndex];
  // Stop any ongoing speech
  if (currentTalkSpeech && currentTalkSpeech.abort) {
    currentTalkSpeech.abort();
  }
  if (soundVolume === 0) {
    console.log("Wisp speech muted (soundVolume = 0)");
    return;
  }
  try {
    // Ensure AudioContext is resumed
    if (audioContext && audioContext.state === "suspended") {
      audioContext.resume().catch(e => console.error("Failed to resume AudioContext for talk:", e));
    }
    const talk = new TalkJs(talkOpts);
    currentTalkSpeech = talk.speak(text);
    // No manual gain set here—masterGain handles it
    currentTalkSpeech.catch(err => {
      console.error("Talk speech error:", err);
    });
  } catch (err) {
    console.error("Talk speak failed:", err);
  }
}
// Stop current wisp speech
function talkStop() {
  if (currentTalkSpeech && currentTalkSpeech.abort) {
    currentTalkSpeech.abort();
  }
  currentTalkSpeech = null;
}
// Example calls:
// talkSpeak(0); // greeting
// talkSpeak(3); // danger warning
// talkStop(); // silence the wisp

// Ultra low-fi 8-bit / C64 style wisp voice + music ducking
function wispSpeak(type) {
    // Abort only if the audio system isn’t ready or a wisp line is already playing
    if (!audioContext || wispIsSpeaking) return;

    wispIsSpeaking = true;
    const originalVolume = musicManager.volume;

    // ----- Duck the music **only if it isn’t muted** -----
    // Duck music only if not muted
    if (!musicMuted && musicManager.current) {
        musicManager.audios[musicManager.current].volume = originalVolume * 0.25;
    }

    const osc  = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.type = 'square';
    osc.connect(gain);
    gain.connect(audioContext.destination);
    gain.gain.setValueAtTime(0.18 * soundVolume, audioContext.currentTime); // respect user sound volume

    let duration = 0.38;

    if (type === 'danger') {
        const notes = [220, 277.18, 329.63, 440];
        let t = audioContext.currentTime;
        notes.forEach((f, i) => {
            osc.frequency.setValueAtTime(f * (1 + i * 0.05), t);
            t += 0.09;
        });
    } else if (type === 'victory') {
        duration = 0.85;               // longer for the laugh
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.18 * soundVolume, audioContext.currentTime);

        // ---- “plooiiihhhiihiihhiung” ----
        let t = audioContext.currentTime;

        // ploooooiii (long rising glide)
        osc.frequency.setValueAtTime(880, t);
        osc.frequency.exponentialRampToValueAtTime(1760, t + 0.28);

        // hhhiihiihhi (quick giggle)
        t += 0.30;
        const giggle = [1760, 1396.96, 1760, 1396.96, 1760, 1567.98];
        giggle.forEach((f, i) => {
            osc.frequency.setValueAtTime(f, t + i * 0.07);
        });

        // final “ung” (soft drop)
        osc.frequency.exponentialRampToValueAtTime(880, t + 0.50);
    }

    // ---- start / stop ----
    osc.start();
    osc.stop(audioContext.currentTime + duration);
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

    // ---- restore music after the sound finishes ----
    osc.onended = () => {
        // Victory jingle: restore volume immediately (only if music isn’t muted)
        if (type === 'victory' && !musicMuted && musicManager.current) {
            musicManager.audios[musicManager.current].volume = originalVolume;
        }
        // Danger warning: music stays ducked until some other game logic restores it
        wispIsSpeaking = false;
    };
}

function playThrowSpear() {
// Never ever do this:
// wave += 0.2 * (Math.random() - 0.5); // random broadband component = hiss / white‑noise.

    // Ensure the AudioContext is running (call once after a user gesture)
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error(e));
    }

    const duration = 0.45;
    const sr = audioContext.sampleRate;
    const buffer = audioContext.createBuffer(1, duration * sr, sr);
    const data = buffer.getChannelData(0);

    // ---------- clean waveform (no random noise) ----------
    for (let i = 0; i < data.length; i++) {
        const t = i / sr;

        // low growl component
        const freq1 = 110 + 20 * Math.sin(2 * Math.PI * 1.5 * t);
        let wave = Math.sin(2 * Math.PI * freq1 * t);

        // higher harmonic
        const freq2 = 320 + 50 * Math.sin(2 * Math.PI * 2 * t);
        wave += 0.4 * Math.sin(2 * Math.PI * freq2 * t);

        // envelope (fast attack, quick decay)
        const envelope = Math.exp(-4 * t) * (1 - Math.exp(-15 * t));
        data[i] = wave * envelope;
    }

    // ---------- normalize to full amplitude ----------
    let max = 0;
    for (let i = 0; i < data.length; i++) max = Math.max(max, Math.abs(data[i]));
    if (max > 0) {
        const scale = 1 / max;
        for (let i = 0; i < data.length; i++) data[i] *= scale;
    }

    // ---------- playback chain (boost + master volume) ----------
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    // per‑sound boost for Android (keeps the raw waveform loud)
    const boostGain = audioContext.createGain();
    boostGain.gain.setTargetAtTime(soundVolume * 2, audioContext.currentTime, 0.01);

    // master gain – dynamic based on platform
    const masterGain = audioContext.createGain();
    masterGain.gain.value = getPlatformMasterGain(); // 0.9 on Android, 0.5 elsewhere

    source.connect(boostGain);
    boostGain.connect(masterGain);
    masterGain.connect(audioContext.destination);
    source.start();
}

/* ---------- AUDIO ---------- */
function playScourgeSpin() {
    if (soundVolume === 0) return; // Respect sound volume setting (no music check)

    // Resume AudioContext if needed
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error('Failed to resume AudioContext for scourge spin:', e));
    }

    const now = audioContext.currentTime;

    // Master gain – louder epic
    const master = audioContext.createGain();
    master.gain.value = 0.9 * soundVolume;
    master.connect(audioContext.destination);

    // 1. Angelic WHOOSH sweep
    const whoosh = audioContext.createOscillator();
    whoosh.type = 'triangle';
    whoosh.frequency.setValueAtTime(300, now);
    whoosh.frequency.exponentialRampToValueAtTime(30, now + 0.5);
    const whooshFilter = audioContext.createBiquadFilter();
    whooshFilter.type = 'highpass';
    whooshFilter.frequency.setValueAtTime(200, now);
    whooshFilter.frequency.exponentialRampToValueAtTime(800, now + 0.5);
    const whooshGain = audioContext.createGain();
    whooshGain.gain.setValueAtTime(0, now);
    whooshGain.gain.linearRampToValueAtTime(1.2, now + 0.03);
    whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);
    whoosh.connect(whooshFilter).connect(whooshGain).connect(master);
    whoosh.start(now);
    whoosh.stop(now + 0.55);

    // 2. Four heavy THUNK impacts (cleaner)
    for (let i = 0; i < 4; i++) {
        const t = now + i * 0.09;
        // Deep punch – sine
        const thud = audioContext.createOscillator();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(120, t);
        thud.frequency.exponentialRampToValueAtTime(40, t + 0.15);
        const thudGain = audioContext.createGain();
        thudGain.gain.setValueAtTime(1.0, t);
        thudGain.gain.exponentialRampToValueAtTime(0.01, t + 0.18);
        thud.connect(thudGain).connect(master);
        thud.start(t);
        thud.stop(t + 0.18);

        // Metallic CLANG – layered
        const clang = audioContext.createOscillator();
        clang.type = 'square';
        clang.frequency.setValueAtTime(380 + i * 90, t);
        clang.frequency.exponentialRampToValueAtTime(120, t + 0.08);
        const clang2 = audioContext.createOscillator();
        clang2.type = 'square';
        clang2.frequency.setValueAtTime((380 + i * 90) * 1.5 + 5, t);
        clang2.frequency.exponentialRampToValueAtTime(180, t + 0.08);
        const clangGain = audioContext.createGain();
        clangGain.gain.setValueAtTime(0.45, t);
        clangGain.gain.exponentialRampToValueAtTime(0.02, t + 0.12);
        const clangFilter = audioContext.createBiquadFilter();
        clangFilter.type = 'bandpass';
        clangFilter.frequency.value = 900;
        clangFilter.Q.value = 10;
        clang.connect(clangFilter);
        clang2.connect(clangFilter);
        clangFilter.connect(clangGain).connect(master);
        clang.start(t);
        clang2.start(t);
        clang.stop(t + 0.12);
        clang2.stop(t + 0.12);
    }

    // Longer, smoother reverb tail
    const convolver = audioContext.createConvolver();
    const impulse = audioContext.createBuffer(2, audioContext.sampleRate * 0.4, audioContext.sampleRate);
    const left = impulse.getChannelData(0);
    const right = impulse.getChannelData(1);
    for (let i = 0; i < impulse.length; i++) {
        const decay = Math.exp(-i / (audioContext.sampleRate * 0.3));
        left[i] = (Math.random() * 2 - 1) * decay;
        right[i] = (Math.random() * 2 - 1) * decay;
    }
    convolver.buffer = impulse;
    master.connect(convolver).connect(audioContext.destination);
}

// CAT TRACKER v16
function playCatPurr() {
  // Cat purr is a sound effect — play even when music is muted
  if (typeof soundVolume === 'undefined') soundVolume = 1;
  if (soundVolume === 0) return;
if (audioContext.state === 'suspended') {
    audioContext.resume().catch(e => console.error('Failed to resume AudioContext for cat purr:', e));
}
const now = audioContext.currentTime;
  const osc = audioContext.createOscillator(); osc.type = 'sawtooth';
  const filter = audioContext.createBiquadFilter(); filter.type = 'lowpass';
  filter.frequency.setValueAtTime(3000, now);
  filter.frequency.exponentialRampToValueAtTime(1500, now + 1.0);
  const gain = audioContext.createGain();
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.linearRampToValueAtTime(0.7 * soundVolume, now + 0.08);

  let t = now;

  osc.frequency.setValueAtTime(20 + (Math.random()*20-10), t);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.130);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.430);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.52);
  t += 0.4056;
  osc.frequency.setValueAtTime(20 + (Math.random()*20-10), t);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.130);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.430);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.52);
  t += 0.4056;
  gain.gain.setValueAtTime(0.7 * soundVolume, t - 0.25);
  gain.gain.exponentialRampToValueAtTime(0.001, t);
  osc.connect(filter).connect(gain).connect(audioContext.destination);
  osc.start(now); osc.stop(t + 0.3);
}

function showSkillTree() {
    if (skillTreeActive) return;
    skillTreeActive = true;
    skillTreeSelectedOption = playerClass ? 0 : 0; // only choice at lvl 3
    const overlay = document.getElementById('skill-tree-overlay');
    const content = document.getElementById('skill-tree-content');
    overlay.style.display = 'flex';
    // Trigger reflow to enable transition
    overlay.offsetHeight;
    overlay.classList.add('visible');

    let html = `<h2>LVL ${pendingSkillTreeLevel} Reached!</h2>`;
    if (pendingSkillTreeLevel === 3 && !playerClass) {
        // Responsive container with media-based gap
        html += `<div style="margin:40px 0;text-align:center;display:flex;justify-content:center;align-items:flex-start;gap:clamp(30px, 8vw, 60px);">`;

        // Druid button
        html += `<div id="druid-option" class="class-option" style="width:clamp(200px, 40vw, 260px);height:clamp(180px, 35vw, 220px);padding:clamp(10px, 3vw, 20px);box-sizing:border-box;display:flex;flex-direction:column;justify-content:flex-start;background:#000;border:3px solid #f7931a;box-shadow:0 0 10px #f7931a;color:#f7931a;">`;
        html += `<strong style="font-size:clamp(24px, 5vw, 32px);margin-bottom:clamp(8px, 2vw, 12px);text-align:left;color:#f7931a;text-shadow:0 0 10px #00e8d8;">Druid</strong>`;
        html += `<div style="font-size:clamp(14px, 3.2vw, 18px);line-height:1.4;text-align:left;flex-grow:1;color:#f7931a">`;
        html += `> Birch guard<br>`;
        html += `> Thorns<br>`;
        html += `> Ensnare<br>`;
        html += `> Shrine +2<br>`;
        html += `> Farm unlock`;
        html += `</div>`;
        html += `</div>`;

        // Degen button
        html += `<div id="degen-option" class="class-option" style="width:clamp(200px, 40vw, 260px);height:clamp(180px, 35vw, 220px);padding:clamp(10px, 3vw, 20px);box-sizing:border-box;display:flex;flex-direction:column;justify-content:flex-start;background:#000;border:3px solid #f7931a;box-shadow:0 0 10px #f7931a;color:#f7931a;">`;
        html += `<strong style="font-size:clamp(24px, 5vw, 32px);margin-bottom:clamp(8px, 2vw, 12px);text-align:left;color:#f7931a;text-shadow:0 0 10px #00e8d8;">Degen</strong>`;
        html += `<div style="font-size:clamp(14px, 3.2vw, 18px);line-height:1.4;text-align:left;flex-grow:1;color:#f7931a">`;
        html += `> Farm unlock<br>`;
        html += `> +1 ROI (x5)<br>`;
        html += `> Soul regen`;
        html += `</div>`;
        html += `</div>`;

        html += `</div>`;
    } else {
        const perks = {
            druid: {10:'> Thorns: Enemies lose ~0.25 HP on attack',20:'> Ensnare: Entagle enemies',30:'> Thorns: Enemies lose ~0.5 HP on attack',40:'> Shrine regenerate HP +2',50:'> Farm unlocked +1 Mask of ROI'},
            degen: {10:'> +1 Mask of ROI',20:'> +1 Mask of ROI',30:'> +1 Mask of ROI',40:'> +1 Mask of ROI',50:'> Soul charges +2 every 2 steps'}
        };
        html += `<div style="font-size:28px;padding:30px;background:#000;border:4px solid #f7931a;border-radius:0;box-shadow:0 0 20px #f7931a;margin:40px 0;text-align:center;color:#f7931a">`;
        html += `<strong>${perks[playerClass][pendingSkillTreeLevel]}</strong>`;
        html += `</div>`;
    }
    content.innerHTML = html;

    // Hide instructions for non-level-3 screens
    const instructions = document.getElementById('skill-tree-instructions');
    if (instructions) {
        instructions.style.display = pendingSkillTreeLevel === 3 ? 'block' : 'none';
    }

    // Auto-close non-choice perk screens after 1 minute
    if (pendingSkillTreeLevel !== 3) {
        setTimeout(() => {
            if (skillTreeActive && pendingSkillTreeLevel === pendingSkillTreeLevel) { // still same screen
                closeSkillTree();
            }
        }, 60000);
    }
    
    // For ALL skill tree screens: 1-second protection against accidental B button / tap
    overlay.style.pointerEvents = 'none';
    // Block gamepad B button for first 1 second (ALL levels)
    window.skillTreeInputBlocked = true;
    setTimeout(() => {
        overlay.style.pointerEvents = 'auto';
        overlay.onclick = () => closeSkillTree();
        overlay.ontouchend = () => closeSkillTree();
        window.skillTreeInputBlocked = false;
    }, 1000);
    
    inputBlocked = false; // we keep input allowed for navigation

    // Grey-out buttons + disable gamepad/keyboard selection for first 1 second
    if (pendingSkillTreeLevel === 3 && !playerClass) {
        const druidBox = document.getElementById('druid-option');
        const degenBox = document.getElementById('degen-option');
        if (druidBox && degenBox) {
            druidBox.classList.add('disabled');
            degenBox.classList.add('disabled');

            // Global flag to block gamepad/keyboard selection
            window.skillTreeInputBlocked = true;

            setTimeout(() => {
                druidBox.classList.remove('disabled');
                degenBox.classList.remove('disabled');
                window.skillTreeInputBlocked = false;
            }, 1000);
        }
    }

    // Get elements AFTER inserting HTML
    const druidBox = document.getElementById('druid-option');
    const degenBox = document.getElementById('degen-option');

    // Click/tap support for class choice
    if (druidBox && degenBox) {
        const selectDruid = () => {
            if (pendingSkillTreeLevel === 3 && !playerClass) {
                skillTreeSelectedOption = 0;
                updateClassHighlight();   // instant highlight update (no full rebuild)
                needsRedraw = true;
            }
        };
        const selectDegen = () => {
            if (pendingSkillTreeLevel === 3 && !playerClass) {
                skillTreeSelectedOption = 1;
                updateClassHighlight();
                needsRedraw = true;
            }
        };

        druidBox.onclick = selectDruid;
        degenBox.onclick = selectDegen;

        // Touch support
        druidBox.ontouchend = selectDruid;
        degenBox.ontouchend = selectDegen;
        
    // Auto-confirm after 200 ms click/touch
    let autoConfirmTimer = null;
    
    const setupAutoConfirm = (element, option) => {
        const onSelect = () => {
            if (autoConfirmTimer) clearTimeout(autoConfirmTimer);
            skillTreeSelectedOption = option;
            updateClassHighlight();
            needsRedraw = true;
            
            // Auto-confirm and close after 200 ms
            autoConfirmTimer = setTimeout(() => {
                selectSkillTreeOption();
                autoConfirmTimer = null;
            }, 200);
        };
        
        element.onclick = onSelect;
        element.ontouchend = onSelect;
    };

    // Replace old handlers with auto-confirm versions
    if (druidBox) setupAutoConfirm(druidBox, 0);
    if (degenBox) setupAutoConfirm(degenBox, 1);
        
    }

    updateClassHighlight();
    needsRedraw = true;
}

function updateClassHighlight() {
    const druid = document.getElementById('druid-option');
    const degen = document.getElementById('degen-option');
    if (!druid || !degen) return;

    if (skillTreeSelectedOption === 0) {
        druid.classList.add('selected');
        degen.classList.remove('selected');
    } else {
        druid.classList.remove('selected');
        degen.classList.add('selected');
    }
}

// POURING RAIN AMBIENCE v4 – IOS fix
function startRainAmbience() {
    if (rainAmbienceTimer) return; // already running

    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error('Failed to resume AudioContext for rain:', e));
    }

    const now = audioContext.currentTime;

    // White noise buffer
    const bufferSize = 4 * audioContext.sampleRate;
    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    rainNoiseSource = audioContext.createBufferSource();
    rainNoiseSource.buffer = noiseBuffer;
    rainNoiseSource.loop = true;

    const filter1 = audioContext.createBiquadFilter();
    filter1.type = 'lowpass';
    filter1.frequency.setValueAtTime(1400, now);

    const filter2 = audioContext.createBiquadFilter();
    filter2.type = 'bandpass';
    filter2.frequency.setValueAtTime(1800, now);
    filter2.Q.setValueAtTime(1.5, now);

    const gain = audioContext.createGain();
    gain.gain.setValueAtTime(0.001, now);
    gain.gain.exponentialRampToValueAtTime(0.40 * soundVolume, now + 1.5);
    gain.gain.setValueAtTime(0.38 * soundVolume, now + 30);

    rainNoiseSource.connect(filter1).connect(filter2).connect(gain).connect(audioContext.destination);
    rainNoiseSource.start(now);

    rainAmbienceTimer = true;
}

// COZY FIREPLACE AMBIENCE – same loudness as rain, warm crackling feel
// Fireplace ambience start
function startFireplaceAmbience() {
    if (fireplaceAmbienceTimer) return;               // already running

    // ---- make sure the AudioContext is active (user gesture required once) ----
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e =>
            console.error('Failed to resume AudioContext for fireplace:', e)
        );
    }
    const now = audioContext.currentTime;

    // ------------------- 1. Brown‑noise base -------------------
    const bufferSize = 4 * audioContext.sampleRate;   // ~4 s of noise
    const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    let last = 0;
    for (let i = 0; i < bufferSize; i++) {
        last += (Math.random() * 2 - 1) * 0.02;        // random‑walk → brown noise
        data[i] = last;
        if (Math.abs(last) > 1) last *= 0.95;         // gentle clamp
    }

    fireplaceNoiseSource = audioContext.createBufferSource();
    fireplaceNoiseSource.buffer = noiseBuffer;
    fireplaceNoiseSource.loop = true;

    // ------------------- 2. Filters -------------------
    const lowpass = audioContext.createBiquadFilter();
    lowpass.type = 'lowpass';
    lowpass.frequency.setValueAtTime(1200, now);

    const bandpass = audioContext.createBiquadFilter();
    bandpass.type = 'bandpass';
    bandpass.frequency.setValueAtTime(800, now);
    bandpass.Q.setValueAtTime(1, now);

    const crackleBand = audioContext.createBiquadFilter();
    crackleBand.type = 'bandpass';
    crackleBand.frequency.setValueAtTime(3000, now);
    crackleBand.Q.setValueAtTime(2, now);
    // gentle sweep to keep the crackle lively
    crackleBand.frequency.linearRampToValueAtTime(2500, now + 30);
    crackleBand.frequency.linearRampToValueAtTime(3500, now + 60);

    // ------------------- 3. Main gain (original envelope) -------------------
    const gain = audioContext.createGain();
    gain.gain.setValueAtTime(0.001, now);
    gain.gain.exponentialRampToValueAtTime(0.38 * soundVolume, now + 1.8);
    gain.gain.setValueAtTime(0.36 * soundVolume, now + 30);

    // ------------------- 4. Ember‑flicker LFO -------------------
    lfo = audioContext.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.setValueAtTime(0.07, now); // ~14 s period

    const lfoGain = audioContext.createGain();
    lfoGain.gain.setValueAtTime(0.03 * soundVolume, now);
    lfo.connect(lfoGain).connect(gain.gain);
    lfo.start(now);

    // ------------------- 5. Per‑sound boost (Android) -------------------
    const boostGain = audioContext.createGain();
    // same factor the growl uses – makes the raw waveform louder on Android
    boostGain.gain.setTargetAtTime(soundVolume * 2, now, 0.01);

    // ------------------- 6. Platform‑aware master gain -------------------
    const masterGain = audioContext.createGain();
    masterGain.gain.value = 9.6;

    // ------------------- 7. Connect the whole chain -------------------
    fireplaceNoiseSource
        .connect(lowpass)
        .connect(bandpass)
        .connect(crackleBand)
        .connect(gain)          // internal dynamics
        .connect(boostGain)     // Android boost
        .connect(masterGain)    // platform‑aware final volume
        .connect(audioContext.destination);
    fireplaceNoiseSource.start(now);

    // ------------------- 8. Random pop‑bursts (sparks) -------------------
    function schedulePop() {
        const now = audioContext.currentTime;
        const popSource = audioContext.createBufferSource();

        // 20 ms white‑noise burst
        const popBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.02, audioContext.sampleRate);
        const popData = popBuffer.getChannelData(0);
        for (let i = 0; i < popData.length; i++) {
            // exponential fade‑out for a crisp spark
            popData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (popData.length * 0.3));
        }
        popSource.buffer = popBuffer;

        const popGain = audioContext.createGain();
        popGain.gain.setValueAtTime(0, now);
        popGain.gain.linearRampToValueAtTime(0.12 * soundVolume, now + 0.001);
        popGain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);

        popSource.connect(popGain).connect(audioContext.destination);
        popSource.start(now);

        // schedule next spark (0.3‑2 s random)
        const nextIn = 0.3 + Math.random() * 1.7;
        popTimeout = setTimeout(schedulePop, nextIn * 1000);
    }

    schedulePop();
    fireplaceAmbienceTimer = true;
}

// ------------------------------------------------------------------
// Stop the ambience
function stopFireplaceAmbience() {
    if (fireplaceNoiseSource) {
        fireplaceNoiseSource.stop();
        fireplaceNoiseSource.disconnect();
        fireplaceNoiseSource = null;
    }
    if (lfo) {
        lfo.stop();
        lfo.disconnect();
        lfo = null;
    }
    if (popTimeout) {
        clearTimeout(popTimeout);
        popTimeout = null;
    }
    fireplaceAmbienceTimer = null;
}

// ---------------------------------------------------------------
// Shrimp‑Rage Growl – clean version with platform‑aware gain
// ---------------------------------------------------------------
function playShrimpRageGrowl() {
    // ---- ensure the AudioContext is running (once after a user gesture) ----
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error(e));
    }

    const duration = 0.6;
    const sr = audioContext.sampleRate;
    const buffer = audioContext.createBuffer(1, duration * sr, sr);
    const data = buffer.getChannelData(0);

    // ---------- clean waveform (no random noise) ----------
    for (let i = 0; i < data.length; i++) {
        const t = i / sr;

        // base frequency that slowly modulates
        const freq = 80 + 30 * Math.sin(2 * Math.PI * 3 * t);
        let wave = Math.sin(2 * Math.PI * freq * t);

        // second harmonic for a richer growl
        wave += 0.5 * Math.sin(2 * Math.PI * freq * 2 * t);

        // envelope – fast attack, slower decay
        const envelope = Math.min(1, t * 8) * Math.exp(-3 * t);
        data[i] = wave * envelope * 0.6;
    }

    // ---------- normalize to full amplitude ----------
    let max = 0;
    for (let i = 0; i < data.length; i++) max = Math.max(max, Math.abs(data[i]));
    if (max > 0) {
        const scale = 1.2 / max;          // keep the small overall boost you liked
        for (let i = 0; i < data.length; i++) data[i] *= scale;
    }

    // ---------- playback chain (boost + platform‑aware master volume) ----------
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    // per‑sound boost for Android (keeps the raw waveform loud enough)
    const boostGain = audioContext.createGain();
    boostGain.gain.setTargetAtTime(soundVolume * 2, audioContext.currentTime, 0.01);

    // master gain – louder on Android, calmer elsewhere
    const masterGain = audioContext.createGain();
    masterGain.gain.value = getPlatformMasterGain(); // 0.6 on PC/iOS, ~1.08 on Android

    source.connect(boostGain);
    boostGain.connect(masterGain);
    masterGain.connect(audioContext.destination);
    source.start();
}

function playJesterManiacalLaughter() {
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error(e));
    }

    const duration = 1.8; // longer for full maniacal cackle
    const sr = audioContext.sampleRate;
    const buffer = audioContext.createBuffer(1, duration * sr, sr);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < data.length; i++) {
        const t = i / sr;

        // Base frequency — high-pitched for "small jester" feel
        let baseFreq = 320 + 80 * Math.sin(2 * Math.PI * 4 * t); // quick pitch wobble

        // Erratic "ha-ha-ha" bursts with rising/falling madness
        const burst = Math.sin(2 * Math.PI * 6 * t); // 6 bursts per second
        baseFreq += 120 * (burst > 0 ? 1 : 0); // jump up on "ha"

        let wave = Math.sin(2 * Math.PI * baseFreq * t);

        // Add harmonics for that unhinged cackle texture
        wave += 0.4 * Math.sin(2 * Math.PI * baseFreq * 2 * t + 0.5);
        wave += 0.2 * Math.sin(2 * Math.PI * baseFreq * 3 * t + 1);

        // Fast vibrato for insanity
        const vibrato = Math.sin(2 * Math.PI * 12 * t) * 15;
        wave *= Math.sin(2 * Math.PI * (baseFreq + vibrato) * t);

        // Envelope — quick attacks, laughing decay
        const envelope = Math.min(1, t * 15) * Math.exp(-2.5 * t) * (1 + 0.3 * Math.sin(2 * Math.PI * 20 * t));

        data[i] = wave * envelope * 0.7;
    }

    // Normalize
    let max = 0;
    for (let i = 0; i < data.length; i++) max = Math.max(max, Math.abs(data[i]));
    if (max > 0) {
        const scale = 0.95 / max; // almost full volume, but safe
        for (let i = 0; i < data.length; i++) data[i] *= scale;
    }

    // Playback
    const source = audioContext.createBufferSource();
    source.buffer = buffer;

    const gain = audioContext.createGain();
    gain.gain.value = soundVolume * 1.1; // slightly boosted for impact

    source.connect(gain);
    gain.connect(audioContext.destination);
    source.start();
}

function playShrimpTrollDeathScream() {
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error('Failed to resume AudioContext for troll scream:', e));
    }
    const duration = 1.2; // longer for maximum drama
    const sampleRate = audioContext.sampleRate;
    const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        const t = i / sampleRate;
        // Ultra-distorted, high-pitched troll rage with random glitches
        let freq = 200 + 150 * Math.sin(2 * Math.PI * 8 * t) + 300 * Math.sin(2 * Math.PI * 15 * t);
        let wave = Math.sin(2 * Math.PI * freq * t);
        // Overdrive harmonics + bitcrush
        wave += 0.4 * Math.sin(2 * Math.PI * freq * 2 * t);           // softer harmonic
        wave += 0.3 * Math.sin(2 * Math.PI * freq * 3 * t);           // reduced
        wave += 0.15 * (Math.random() - 0.5) * 2;                     // much less noise
        // Softer distortion instead of extreme clipping
        wave = Math.tanh(wave * 1.8); // reduced overdrive (was *4)
        // Envelope: explosive attack, chaotic decay
        const envelope = Math.min(1, t * 10) * Math.exp(-3.5 * t) * (1 + 0.15 * Math.sin(2 * Math.PI * 12 * t));
        data[i] = wave * envelope * 0.8;
    }
    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = soundVolume * 0.7; // calmer volume
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
}

function playFrostNovaSound() {
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error('Failed to resume AudioContext:', e));
    }
    const duration = 0.8;
    const sampleRate = audioContext.sampleRate;
    const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        const t = i / sampleRate;
        // Chilly whoosh + crystalline sparkle
        let freq = 600 + 400 * Math.sin(2 * Math.PI * 5 * t);
        let wave = Math.sin(2 * Math.PI * freq * t);
        wave += 0.3 * Math.sin(2 * Math.PI * freq * 4 * t);
        wave += 0.2 * (Math.random() - 0.5);
        const envelope = Math.min(1, t * 12) * Math.exp(-5 * t);
        data[i] = wave * envelope * 0.6;
    }
    const source = audioContext.createBufferSource();
    source.buffer = buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = soundVolume * 0.8;
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
}

// Play "Wouah wou wou wauuah" sound
function playDisappearSound() {
    // Ensure the AudioContext is running
    if (audioContext.state === 'suspended') {
        audioContext.resume().catch(e => console.error('Failed to resume AudioContext:', e));
    }

    const duration   = 1.2;                     // total length in seconds
    const sampleRate = audioContext.sampleRate;
    const buffer     = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
    const data       = buffer.getChannelData(0);

    // Build the melody: two phrases, each with a short rise‑fall envelope
    for (let i = 0; i < data.length; i++) {
        const t = i / sampleRate;               // current time (s)

        // Phrase 1: “Ta da da daaa”
        let amp1 = 0;
        if (t < 0.5) {
            const freq1 = 440 + 30 * Math.sin(2 * Math.PI * 3 * t); // bright major tone
            const wave1 = Math.sin(2 * Math.PI * freq1 * t);
            const env1  = Math.min(1, t * 8) * Math.exp(-4 * t);    // quick attack, fast decay
            amp1 = wave1 * env1 * 0.7;
        }

        // Phrase 2: “Ta Ta Ta TATA!”
        let amp2 = 0;
        if (t >= 0.5 && t < 1.2) {
            const rel = t - 0.5;
            const freq2 = 660 + 20 * Math.sin(2 * Math.PI * 5 * rel); // higher, celebratory pitch
            const wave2 = Math.sin(2 * Math.PI * freq2 * rel);
            const env2  = Math.min(1, rel * 10) * Math.exp(-3 * rel);
            amp2 = wave2 * env2 * 0.8;
        }

        // Add a subtle sparkle (high‑frequency noise) to give it that Zelda‑ish sparkle
        const sparkle = 0.12 * (Math.random() - 0.5) * Math.exp(-12 * t);

        data[i] = (amp1 + amp2 + sparkle) * soundVolume;
    }

    // Connect and play
    const source   = audioContext.createBufferSource();
    source.buffer  = buffer;

    const gainNode = audioContext.createGain();
    gainNode.gain.value = 0.9;                 // overall level

    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
}

const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
let currentSplashImage = 'splash.png';
const splashImg = new Image();
splashImg.src = currentSplashImage;

splashImg.onload = () => {
    splashCanvas.clearRect(0, 0, 320, 320);
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);

    // ONLY reveal START button/loading-text handling when loading the initial splash
    if (currentSplashImage === 'splash.png') {
        const loadingText = document.getElementById('loading-text');
        const startButton = document.getElementById('start-button');
        if (loadingText) loadingText.style.display = 'none';
        if (startButton) startButton.style.display = 'block';
    }
};

// Fallback if image is already cached (onload won't fire)
if (splashImg.complete && splashImg.naturalWidth > 0) {
    splashImg.onload();
}

splashImg.onerror = () => {
    console.warn('Splash image failed to load');
    // Safety: still try to show button for initial splash only
    if (currentSplashImage === 'splash.png') {
        const loadingText = document.getElementById('loading-text');
        const startButton = document.getElementById('start-button');
        if (loadingText) loadingText.style.display = 'none';
        if (startButton) startButton.style.display = 'block';
    }
};

function fadeSplash() {
    setTimeout(() => {
        const imgData = splashCanvas.getImageData(0, 0, 320, 320);
        const pixels = imgData.data;
        const totalPixels = 320 * 320;
        const fadePerFrame = totalPixels / 20;
        let fadedPixels = 0;
        const fadeInterval = setInterval(() => {
            for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                const px = Math.floor(Math.random() * totalPixels) * 4;
                pixels[px + 3] = 0;
                fadedPixels++;
            }
            splashCanvas.putImageData(imgData, 0, 0);
            if (fadedPixels >= totalPixels) {
                clearInterval(fadeInterval);
                splashActive = false;
                document.getElementById('splash-screen').style.display = 'none'; // Hide instead of remove
                            }
        }, 75);
    }, 25);
}

function resetSplashScreen() {
    splashActive = true;
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block'; // Show splash screen
    // Redraw splash image
    splashCanvas.clearRect(0, 0, 320, 320);
    splashImg.src = currentSplashImage;
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
}

document.getElementById('start-button').addEventListener('click', () => {
    currentTheme = 'dungeon'; // Force default theme on game start
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }

    // Assign random elemental immunity
    const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
    p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];

wakeLock = null;

// Function to request wake lock
async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake lock activated');
      wakeLock.addEventListener('release', () => {
        console.log('Wake lock released');
      });
    } else {
      console.warn('Wake Lock API not supported in this browser. Adjust OS power settings manually.');
      alert('Wake Lock not supported. To prevent sleep, disable screen timeout in your OS settings or play a silent audio loop.');
    }
  } catch (err) {
    console.error('Wake lock error:', err);
  }
}

// Re-request wake lock if visibility changes (e.g., tab switch)
document.addEventListener('visibilitychange', async () => {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    await requestWakeLock();
  }
});

if (splashActive) {
        preloadSounds();
        // Ensure AudioContext is resumed for iOS
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                // Reset music manager state and play music after AudioContext is resumed
                musicManager.current = null;
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
            }).catch(e => console.error('Failed to resume AudioContext:', e));
        } else {
            // Reset music manager state on restart
            musicManager.current = null;
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
        }
            // Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

        musicManager.mute(musicMuted); // Ensure proper mute state
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }

// Restart current music track from the beginning when unmuting
if (musicManager.current && musicManager.audios[musicManager.current]) {
    const currentAudio = musicManager.audios[musicManager.current];
    currentAudio.currentTime = 0;
}
localStorage.setItem('musicMuted', 'false');
fadeSplash();
setTimeout(() => {
    if (!gameOver && !splashActive) {
        requestWakeLock();  // ← Add this to request wake lock on game start
        fetchTxs();
        lastUpdate = Date.now();
        console.log('Initial fetchTxs triggered after splash, wave=', wave);
        
        // First-time leaderboard cache (only once per browser session)
        if (!localStorage.getItem('leaderboardCached')) {
            fetchLeaderboard().then(() => {
                localStorage.setItem('leaderboardCached', 'true');
                cachedLeaderboard = JSON.parse(localStorage.getItem('leaderboardData') || '[]');
                console.log('Leaderboard cached on first start');
            }).catch(err => console.error('Cache fetch failed:', err));
        } else {
            cachedLeaderboard = JSON.parse(localStorage.getItem('leaderboardData') || '[]');
        }
    }
}, 2000);
    }

});

function toggleMute() {
    const muteButton = document.getElementById('mute');
    const currentState = muteButton.textContent;
    
    // Cycle through the three states: ♪ → X → ☀ → ♪
    if (currentState === '♪') {
        // First state: Music on → Mute music
        musicMuted = true;
        musicManager.mute(true);
        muteButton.textContent = 'X';
        localStorage.setItem('musicMuted', 'true');
} else if (currentState === 'X') {
        // Second state: Music muted → Activate screensaver
        musicMuted = true;
        musicManager.mute(true);
        muteButton.textContent = '☀';
        if (!splashActive) {
            musicManager.current = null; // Reset MusicManager state
            musicManager.play(currentTheme);
        }
        // Activate screensaver when moving to ☀ state
        activateScreensaver();
    } else if (currentState === '☀') {
        // Third state: Screensaver active → Return to music
        // Reset screensaver and return to normal state
        exitScreensaver();
        musicMuted = false;
        musicManager.mute(false);
        muteButton.textContent = '♪';
        if (!splashActive) {
            musicManager.current = null; // Reset MusicManager state
            musicManager.play(currentTheme);
        }
        localStorage.setItem('musicMuted', 'false');
    }
}

function logWhaleHashId(txid) {
    const newEntry = `Floor ${floor}: <a href="https://mempool.space/tx/${txid}" target="_blank">${txid}</a>`;
    whaleHashIds.push(newEntry);
    if (whaleHashIds.length > 50) {
        whaleHashIds = ['Whale Transactions:', ...whaleHashIds.slice(-49)];
        const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
        while (whaleHashIdsDiv.children.length > 49) {
            whaleHashIdsDiv.removeChild(whaleHashIdsDiv.firstChild);
        }
    }
    const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
    const newDiv = document.createElement('div');
    newDiv.innerHTML = newEntry;
    whaleHashIdsDiv.appendChild(newDiv);
    const whaleLog = document.getElementById('whale-log');
    whaleLog.scrollTop = whaleLog.scrollHeight;
    console.log('Whale Hash ID:', txid);
}

function logBattleEvent(event) {
    if (gameOver) return;
    const battleEvents = document.getElementById('battle-events');

    // Only handle the "Kills:" summary — ignore everything else
    if (event.startsWith('Kills:') || event.match(/^(Shrimp|Crab|Squid|Dolphin|Shark|Whale):/)) {
        if (event === 'Kills:') {
            // Start fresh kills summary
            killsLog = ['Kills:'];
        } else {
            // Add individual kill line
            killsLog.push(event);
        }

        // When floor is cleared (stairs exist + no enemies), show full summary
        if (exit && enemies.length === 0) {
            // Always show all enemy types (even if 0 kills)
            killsLog = [
                'Kills:',
                `Shrimp: ${kills.Shrimp}`,
                `Crab: ${kills.Crab}`,
                `Squid: ${kills.Squid}`,
                `Dolphin: ${kills.Dolphin}`,
                `Shark: ${kills.Shark}`,
                `Whale: ${kills.Whale}`,
                '' // extra line to fill 8 lines
            ];

            battleEvents.value = killsLog.join('\n');
            battleEvents.scrollTop = battleEvents.scrollHeight;
            battleEvents.style.transform = 'translateX(0)';
            battleEvents.style.opacity = '1';

            // Cancel any fade-out
            if (battleLogTimeout) {
                clearTimeout(battleLogTimeout);
                battleLogTimeout = null;
            }
        }
        return; // don't fall through to normal log
    }

    // === Normal battle events (everything else) ===
    battleLog.push(event);
    battleLog = battleLog.slice(-3); // keep last 3

    battleEvents.value = battleLog.join('\n');
    battleEvents.scrollTop = battleEvents.scrollHeight;

    // Cancel existing fade
    if (battleLogTimeout) clearTimeout(battleLogTimeout);

    // Show
    battleEvents.style.transform = 'translateX(0)';
    battleEvents.style.opacity = '1';

    // Fade out after 3 seconds
    battleLogTimeout = setTimeout(() => {
        battleEvents.style.transform = 'translateX(-100%)';
        battleEvents.style.opacity = '0';

        setTimeout(() => {
            if (window.getComputedStyle(battleEvents).opacity === '0') {
                battleLog = [];
                battleEvents.value = '';

                // Restore kills summary if floor still cleared
                if (exit && enemies.length === 0) {
                    killsLog = [
                        'Kills:',
                        `Shrimp: ${kills.Shrimp}`,
                        `Crab: ${kills.Crab}`,
                        `Squid: ${kills.Squid}`,
                        `Dolphin: ${kills.Dolphin}`,
                        `Shark: ${kills.Shark}`,
                        `Whale: ${kills.Whale}`,
                        ''
                    ];
                    battleEvents.value = killsLog.join('\n');
                    battleEvents.style.transform = 'translateX(0)';
                    battleEvents.style.opacity = '1';
                    battleEvents.scrollTop = battleEvents.scrollHeight;
                }
            }
        }, 300);
    }, 3000);
}

function updateSatsDisplay() {
    const raw = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
    const mult = getScoreWithMultiplier(raw , floor);

    // Main value (sats or BTC)
    const satsElem   = document.getElementById('sats');
    satsElem.textContent =
        raw < 1e8 ? `${raw} sats` : `${(raw / 1e8).toFixed(1)} BTC`;

    // The calculation – shown on its own line
    const calcElem = document.getElementById('sats-calc');
    calcElem.textContent = `${mult < 1e8 ? `${mult} sats` : `${(mult / 1e8).toFixed(1)} BTC`}`;

    // Trigger kills display only when exit exists and no enemies remain
    if (exit && enemies.length === 0) {
        logBattleEvent(`Kills:`);
        for (const type of types) {
            if (kills[type.name] > 0) {
                logBattleEvent(`${type.name}: ${kills[type.name]}`);
            }
        }
    }
}

function updateXPBar() {
    if (splashActive || gameOver) return;

    const currentReq = getXPForLevel(playerLevel);
    const nextReq = getXPForLevel(playerLevel + 1);
    const current = Math.max(0, playerXP - currentReq);
    const needed = nextReq - currentReq;
    const percent = needed > 0 ? Math.min(100, (current / needed) * 100) : 100;

    const fill = document.getElementById('xp-bar-fill');
    const text = document.getElementById('xp-text');
    if (fill) fill.style.width = percent + '%';
    
    const nextThreshold = getXPForLevel(playerLevel + 1);
    if (text) text.textContent = `LVL ${playerLevel} • ${playerXP.toFixed(0)} / ${nextThreshold.toFixed(0)} XP`;
}

function spawnItemWithChance(item, chance, maxItems, proximityRange, avoidPlayer) {
    let positions = [];
    let attempts = 0;
    const maxAttempts = 100;

    while (positions.length < maxItems && attempts < maxAttempts) {
        if (Math.random() < chance) {
            let x = Math.floor(Math.random() * W);
            let y = Math.floor(Math.random() * H);
            let valid = map[y][x] === 0;

            if (avoidPlayer) {
                valid = valid && Math.abs(x - p.x) >= 3 && Math.abs(y - p.y) >= 3; // Ensure 5x5 clear area
            }

            if (valid) {
                let isNearOtherItem = false;
                for (let pos of positions) {
                    if (Math.abs(x - pos[0]) <= 2 && Math.abs(y - pos[1]) <= 2) {
                        isNearOtherItem = true;
                        break;
                    }
                }
                if (!isNearOtherItem) {
                    positions.push([x, y]);
                    if (item !== -1) {
                        map[y][x] = item;
                    }
                }
            }
        }
        attempts++;
    }

    return positions;
}

function playUniqueMonsterSound(uniqueName) {
    // Check if we have a unique monster sound file
    if (isIOSorSafari()) {
        // iOS/Safari version - use existing audio handling
        const audio = sounds.unique_monster;
        if (audio && audio.src) {
            audio.currentTime = 0;
            audio.play().catch(e => console.error('Unique monster sound error:', e));
        }
    } else {
        // Non-iOS version - use Web Audio
        playWebAudioSound(sounds.unique_monster);
    }
}

function updateSnowState() {
    if (currentTheme === 'hell' && currentThemeBlock === 'hell_snowy') {
        snowyHellActive = true;
        // make sure we have snowflakes if they got cleared
        if (snowflakes.length === 0) {
            for (let i = 0; i < 120; i++) {
                snowflakes.push({
                    x: Math.random() * 320,
                    y: Math.random() * 320 - 100,
                    speed: 0.2 + Math.random() * 0.4,
                    size: 1 + Math.random() * 2,
                    sway: Math.random() * 2
                });
            }
        }
    } else {
        snowyHellActive = false;
        snowflakes = []; // instantly stop snow
    }
}

function initMap() {
// Cleanup any lingering splash screen handlers from previous terminals/overlays
    const splashScreen = document.getElementById('splash-screen');
    if (splashScreen) {
        splashScreen.onclick = null;
        splashScreen.ontouchend = null;
    }
    try {
        if (inHideout) {
            currentTheme = 'hideout';
            updateSnowState();
            stopFireplaceAmbience(); // Stop ambience in hideout
            document.documentElement.style.setProperty('--text-color', '#ff8c00');
            document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                el.style.color = '#ff8c00';
            });
            enemies = [];
            enemiesSpawnedThisFloor = 0;
            window.hugeShrimpSpawnedThisFloor = false; // reset for new floor
            whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
            initialSpawnDoneThisFloor = false;
            initialWaveSpawned = false;
            map = Array(H).fill().map(() => Array(W).fill(1));
            fogMap = Array(H).fill().map(() => Array(W).fill(1));  // Full visibility in hideout – no fog
            rooms = [];
            satoshiDrops = [];
            runeDrops = runeDrops.filter(r => !r.specific);
            scrollDrops = [];
            portals = [];
            dangerousAreas = []; // Clear dangerous areas
            currentRuneTile = null;
            jewellerPos = null;
            blacksmithPos = null;
            waypointPos = null;
            exit = null; // Prevent stairs and related enemy spawning
            echoWardenPos = null; // Clear warden on new floor
            wardenFlashStart = 0; // Clear flash on new floor
                for (let yy = 0; yy < H; yy++) {
                    for (let xx = 0; xx < W; xx++) {
                        if (map[yy][xx] === 24) map[yy][xx] = 0; // Clear warden tile
                    }
                }

            dpadButtons = document.querySelectorAll('#dpad button');
            actionsButtons = document.querySelectorAll('#actions button');

            rooms = [];
            const roomSize = 7;
            const gap = 2;

            const mainRoomX = Math.floor((W - roomSize) / 2);
            const mainRoomY = Math.floor((H - roomSize) / 2);
            rooms.push({ x: mainRoomX, y: mainRoomY, w: roomSize, h: roomSize });
            for (let y = mainRoomY; y < mainRoomY + roomSize; y++) {
                for (let x = mainRoomX; x < mainRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            const leftRoomX = mainRoomX - roomSize - gap;
            const leftRoomY = mainRoomY;
            rooms.push({ x: leftRoomX, y: leftRoomY, w: roomSize, h: roomSize });
            for (let y = leftRoomY; y < leftRoomY + roomSize; y++) {
                for (let x = leftRoomX; x < leftRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            const rightRoomX = mainRoomX + roomSize + gap;
            const rightRoomY = mainRoomY;
            rooms.push({ x: rightRoomX, y: rightRoomY, w: roomSize, h: roomSize });
            for (let y = rightRoomY; y < rightRoomY + roomSize; y++) {
                for (let x = rightRoomX; x < rightRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            for (let x = leftRoomX + roomSize; x < mainRoomX; x++) {
                map[mainRoomY + 3][x] = 0;
            }
            for (let x = mainRoomX + roomSize; x < rightRoomX; x++) {
                map[mainRoomY + 3][x] = 0;
            }

// Place jeweller (unchanged)
jewellerPos = { x: mainRoomX + 3, y: mainRoomY + 3 };
map[jewellerPos.y][jewellerPos.x] = 14;

// All diamond‑wall positions
const diamondWallTiles = [
    {x: mainRoomX + 2, y: mainRoomY + 2}, {x: mainRoomX + 3, y: mainRoomY + 2}, {x: mainRoomX + 4, y: mainRoomY + 2},
    {x: mainRoomX + 2, y: mainRoomY + 3},                               {x: mainRoomX + 4, y: mainRoomY + 3},
    {x: mainRoomX + 2, y: mainRoomY + 4},                               {x: mainRoomX + 4, y: mainRoomY + 4}
];

// Tiles that should stay as diamond walls (the north side)
const keepWallTiles = new Set([
    `${mainRoomX + 2},${mainRoomY + 2}`,
    `${mainRoomX + 3},${mainRoomY + 2}`,
    `${mainRoomX + 4},${mainRoomY + 2}`,
    `${mainRoomX + 2},${mainRoomY + 3}`,
    `${mainRoomX + 4},${mainRoomY + 3}`
]);

// Place walls, skipping the southern tiles
diamondWallTiles.forEach(pos => {
    if (pos.x < 0 || pos.x >= W || pos.y < 0 || pos.y >= H) return; // bounds check
    const key = `${pos.x},${pos.y}`;
    if (!keepWallTiles.has(key)) {
        // southern tiles become empty (0) instead of a wall (13)
        map[pos.y][pos.x] = 0;
    } else {
        map[pos.y][pos.x] = 13;
    }
});

            // Place billboard 3 tiles ABOVE jeweller (main room, north side)
            const billboardX = jewellerPos.x + 1;
            const billboardY = jewellerPos.y - 3;
            if (billboardY >= 0 && map[billboardY][billboardX] === 0) {
                map[billboardY][billboardX] = 32; // Billboard tile ID (pick any unused, e.g. 32)
            } else {
                console.warn('Failed to place billboard: occupied or out of bounds at', billboardX, billboardY);
            }

            // (after placing billboard)
            const infoSignX = billboardX - 2;
            const infoSignY = billboardY;
            if (infoSignY >= 0 && infoSignX >= 0 && map[infoSignY][infoSignX] === 0) {
                map[infoSignY][infoSignX] = 34; // new tile ID for info sign
            }

            // Place blacksmith (unchanged)
            const blacksmithX = leftRoomX + 4;
            const blacksmithY = leftRoomY + 1;
            if (map[blacksmithY][blacksmithX] === 0) {
                map[blacksmithY][blacksmithX] = 15; // Blacksmith
                blacksmithPos = { x: blacksmithX, y: blacksmithY };
                // Place smelter 2 tiles below blacksmith
                const smelterX = blacksmithX;
                const smelterY = blacksmithY + 2;
                if (smelterY < H && map[smelterY][smelterX] === 0) {
                    map[smelterY][smelterX] = 31; // Smelter tile ID
                } else {
                    console.warn('Failed to place smelter: occupied or out of bounds at', smelterX, smelterY);
                }
            } else {
                console.warn('Failed to place blacksmith: tile occupied at', blacksmithX, blacksmithY);
            }
            // Place swap 4 tiles below blacksmith
            const swapX = blacksmithX;
            const swapY = blacksmithY + 4;
            if (swapY >= 0 && map[swapY][swapX] === 0) {
                map[swapY][swapX] = 29; // Swap tile
            } else {
                console.warn('Failed to place swap tile: occupied or out of bounds at', swapX, swapY);
            }

            // Place waypoint at a fixed position in the right room
            const waypointX = rightRoomX + 3;
            const waypointY = rightRoomY + 3;
            if (map[waypointY][waypointX] === 0) {
                map[waypointY][waypointX] = 16; // Waypoint
                waypointPos = { x: waypointX, y: waypointY };
            } else {
                console.warn('Failed to place waypoint: tile occupied at', waypointX, waypointY);
            }
            
            // Place rune whisperer at a fixed position in the right room
            const runeWhispererX = rightRoomX + 1;
            const runeWhispererY = rightRoomY + 5;
            if (map[runeWhispererY][runeWhispererX] === 0) {
                map[runeWhispererY][runeWhispererX] = 17; // Rune Whisperer
                runeWhispererPos = { x: runeWhispererX, y: runeWhispererY };
            } else {
                console.warn('Failed to place rune whisperer: tile occupied at', runeWhispererX, runeWhispererY);
            }

            // Place hooded heirloom (4 tiles north of rune whisperer)
            const heirloomX = runeWhispererX;
            const heirloomY = runeWhispererY - 4;
            if (map[heirloomY][heirloomX] === 0) {
                map[heirloomY][heirloomX] = 18; // Hooded Heirloom
            } else {
                console.warn('Failed to place hooded heirloom: tile occupied at', heirloomX, heirloomY);
            }

            // Place passive sign 2 tiles right of hooded heirloom
            const passiveX = heirloomX + 2;
            const passiveY = heirloomY;
            if (passiveX < W && map[passiveY][passiveX] === 0) {
                map[passiveY][passiveX] = 36; // Passive Sign tile ID
            } else {
                console.warn('Failed to place passive sign: out of bounds or occupied at', passiveX, passiveY);
            }

p.x = mainRoomX + 3;
p.y = mainRoomY + 6;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;
updateFogMap(p.x, p.y);
            needsRedraw = true;
            logBattleEvent(`Hideout - Entered the secret hideout!`);
            document.getElementById('floor-indicator').textContent = `Hideout`;
            return;
        }

// Set bounty if none exists (random unique from any type)  ← OLD CODE, KEEP THIS
if (!window.currentBounty) {
    const allTypes = Object.keys(uniqueMonsterNames);
    const randomType = allTypes[Math.floor(Math.random() * allTypes.length)];
    const names = uniqueMonsterNames[randomType];
    const randomName = names[Math.floor(Math.random() * names.length)];
    window.currentBounty = { type: randomType, name: randomName };
}

// Side Quest assignment  ← NEW, ALSO KEEP
if (!window.currentSideQuest || (window.currentSideQuest && window.currentSideQuest.progress >= window.currentSideQuest.quota)) {
    const questOptions = [
        {type: 'Shrimp', quota: 40},
        {type: 'Crab', quota: 20},
        {type: 'Squid', quota: 15},
        {type: 'Dolphin', quota: 10},
        {type: 'Shark', quota: 7},
        {type: 'Whale', quota: 3}
    ];
    let available = questOptions.filter(q => q.type !== window.lastSideQuestType);
    if (available.length === 0) available = questOptions;
    const chosen = available[Math.floor(Math.random() * available.length)];
    window.currentSideQuest = {
        type: chosen.type,
        quota: chosen.quota,
        progress: 0
    };
}

// ——— THEME BLOCK CONSISTENCY ———
if (floor % 3 === 0 && floor > 1) {
const newTheme = selectNewTheme(currentTheme);

// DEBUG THEME
//let newTheme;
//if (floor === 3) {
//    newTheme = 'desert'; // DEBUG: Force X theme on floor 3
//} else {
//    newTheme = selectNewTheme(currentTheme);
//}

    if (newTheme === 'hell') {
        // First time entering a new hell block?
        if (currentThemeBlock !== 'hell_normal' && currentThemeBlock !== 'hell_snowy') {
            currentThemeBlock = Math.random() < 0.5 ? 'hell_snowy' : 'hell_normal';
            snowyHellActive = (currentThemeBlock === 'hell_snowy');

            if (snowyHellActive) {
                snowflakes = [];
                for (let i = 0; i < 120; i++) {
                    snowflakes.push({
                        x: Math.random() * 320,
                        y: Math.random() * 320 - 100,
                        speed: 0.2 + Math.random() * 0.4,
                        size: 1 + Math.random() * 2,
                        sway: Math.random() * 2
                    });
                }
                logBattleEvent(`Floor ${floor} - Hell froze over! Snowy Hell begins…`);
            }
        }
        currentTheme = 'hell';
    }
    else if (newTheme === 'ruins') {
        // First time entering a new ruins block?
        if (currentThemeBlock !== 'ruins_normal' && currentThemeBlock !== 'ruins_rainy') {
            currentThemeBlock = Math.random() < 0.5 ? 'ruins_rainy' : 'ruins_normal';
            ruinsRainActive = (currentThemeBlock === 'ruins_rainy');

            if (ruinsRainActive) {
                raindrops = [];
                floorSplashes = [];  // ← clear old splashes
                ruinsRainAngle = 0.26 + Math.random() * 0.35;

                for (let i = 0; i < 160; i++) {
                    raindrops.push({
                        x: Math.random() * 320,
                        y: Math.random() * 320 - 100,
                        speed: 3.0 + Math.random() * 3.0
                    });
                }
                logBattleEvent(`Floor ${floor} - The ruins weep... rain begins.`);
                startRainAmbience();  // ← auto-start looping rain (floor load = gesture)
            }
        }
        currentTheme = 'ruins';
    }
    else {
        // Any other theme → reset both variants
        currentThemeBlock = null;
        snowyHellActive = false;
        ruinsRainActive = false;
        snowflakes = [];
        raindrops = [];
        floorSplashes = [];
if (rainAmbienceTimer) {
    rainAmbienceTimer = null;
}
if (rainNoiseSource) {
    rainNoiseSource.stop();
    rainNoiseSource = null;
}
        currentTheme = newTheme;
    }

if (!inPuzzleRoom && !inHideout && currentTheme !== 'desert') {
    desertStreakHasSandworm = false;
    sandworm = null;
}

} else {
    // Not a theme-change floor → preserve current variants if active
    if (currentTheme === 'hell' && currentThemeBlock === 'hell_snowy') {
        snowyHellActive = true;
    } else {
        snowyHellActive = false;
    }

    if (currentTheme === 'ruins' && currentThemeBlock === 'ruins_rainy') {
        ruinsRainActive = true;
    } else {
        ruinsRainActive = false;
        raindrops = [];
        floorSplashes = [];
if (rainAmbienceTimer) {
    rainAmbienceTimer = null;
}
if (rainNoiseSource) {
    rainNoiseSource.stop();
    rainNoiseSource = null;
}
    }
}

updateSnowState(); // keeps snowflakes in sync
sandwormBurrowPaused = false; // resume burrow on normal floors

        // Update text color based on theme
        let textColor;
        switch (currentTheme) {
            case 'hell':
                textColor = '#00ff00'; // Matrix green for hell
                break;
            case 'desert':
            case 'paradise':
            case 'ruins':
                textColor = '#ff8c00'; // Orange for desert, paradise, and ruins
                break;
            default:
                textColor = '#ff8c00'; // Orange for dungeon
        }
        document.documentElement.style.setProperty('--text-color', textColor);
        // Force re-render of text color
        document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
            el.style.color = textColor;
        });
        // Reset enemy spawning variables
        enemies = [];
        enemiesSpawnedThisFloor = 0;
                window.hugeShrimpSpawnedThisFloor = false; // reset for new floor
        whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
        initialSpawnDoneThisFloor = false;
        initialWaveSpawned = false;
        map = Array(H).fill().map(() => Array(W).fill(1));
        fogMap = Array(H).fill().map(() => Array(W).fill(0));
        rooms = [];
        satoshiDrops = [];
        runeDrops = []; // Clear rune drops on map, but keep p.runes, p.runewords, p.immortal
        scrollDrops = []; // Clear scroll drops
        portals = []; // Clear portals
        // Reset rune tracking
        currentRuneTile = null;

        function checkCurrentRuneTile() {
            if (map[p.y][p.x] === 9) {
                const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
                if (rune) {
                    const floorIndicator = document.getElementById('floor-indicator');
                    floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
                    currentRuneTile = { x: p.x, y: p.y };
                    return true;
                }
            }
            return false;
        }

        // Generate rooms
        let maxAttempts = 100;
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        maxAttempts = 50;
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap();
        }

        // Connect rooms with corridors
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r1.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }

        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;

            // Pre-randomize tile variants once per floor (prevents per-frame dizziness)
            tileVariantMap = Array(H).fill().map(() => Array(W).fill(-1)); // -1 = no variant (use single tile)

if (['desert', 'paradise', 'hell', 'ruins'].includes(currentTheme) && !(currentTheme === 'hell' && snowyHellActive)) {
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 0) { // floor tile – full random variant
                tileVariantMap[y][x] = Math.floor(Math.random() * assets.themes[currentTheme].floors.length);
            } else if (map[y][x] === 1) { // wall tile
                if (currentTheme === 'hell') {
                    // Hell normal walls: pre-compute phase offset 0-3 for desynced animation
                    tileVariantMap[y][x] = Math.floor(Math.random() * 4); // 0-3 only
                } else {
                    // Other themes: full random variant
                    tileVariantMap[y][x] = Math.floor(Math.random() * assets.themes[currentTheme].walls.length);
                }
            }
        }
    }
}

            // Cozy fireplace ambience for regular hell
            if (currentTheme === 'hell' && !snowyHellActive) {
                startFireplaceAmbience();
            } else {
                stopFireplaceAmbience();
            }

// Place player
p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;
if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
   for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) {
       p.x = x; p.y = y;
       p.currentX = p.x * S; p.currentY = p.y * S;
       p.targetTileX = p.x; p.targetTileY = p.y;
       break;
    }
}
// Mark initial player area as explored
updateFogMap(p.x, p.y);

        // Place special tiles based on theme (pond, quicksand, lava)
        let specialPositions = [];
        if (currentTheme !== 'dungeon') {
            specialPositions = spawnItemWithChance(6, 0.5, 2, 5, true); // 50% chance, max 2 tiles
        }

        // Place Gnome with X% chance, only if no conflict with special tiles
        let gnomePositions = [];
        if (
            currentTheme === 'dungeon' || 
            currentTheme === 'desert' || 
            currentTheme === 'hell' || 
            currentTheme === 'paradise' || 
            specialPositions.length < 2
        ) {
            if (Math.random() < 0.1) { // 10% chance to spawn a gnome
                gnomePositions = spawnItemWithChance(7, 1.0, 1, 5, true);
                if (gnomePositions.length > 0) {
                } else {
                }
            } else {
            }
        } else {
        }

        /* -------------------------------------------------
           Place potions – 2 total, never in the same room
           ------------------------------------------------- */

        let potionPositions = [];                         // all potion coordinates
        let selectedRooms = rooms
            .sort(() => 0.5 - Math.random())              // random order
            .slice(0, Math.min(3, rooms.length));        // look at up to 3 rooms

        let proximityRange = 5;
        let potionsNeeded = 2;                             // how many potions are still missing

        for (let r of selectedRooms) {
            if (potionsNeeded <= 0) break;                // we already have 2

            let x, y, attempts = 100;

            // try to place **one** potion in this room
            while (attempts > 0 && potionsNeeded > 0) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);

                // empty tile, not the player, not too close to another potion
                if (
                    map[y][x] === 0 &&
                    (x !== p.x || y !== p.y) &&
                    !potionPositions.some(
                        p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange
                    )
                ) {
                    map[y][x] = 2;                        // place the potion
                    potionPositions.push({ x, y });
                    potionsNeeded--;                      // one potion placed
                    break;                                // stop – only one per room
                }

                attempts--;
            }

            // If we ran out of attempts in this room, warn and try again with a tighter range
            if (attempts === 0 && potionsNeeded > 0) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;                           // restart attempts for the same room
            }
        }

        // Place pickaxe (chance to drop a pickaxe)
        let pickaxePositions = [];
        if (Math.random() < 0.25) { // 25% chance to spawn a pickaxe
            pickaxePositions = spawnItemWithChance(4, 1.0, 1, 5, true);
            if (pickaxePositions.length > 0) {
            } else {
            }
        }    

// Place soul stash in the same room as player spawn (only on normal floors)
if (!inHideout) {
    const room = rooms[0]; // Player spawns in first room
    let stashX, stashY;
    let attempts = 100;
    
    // First priority: Spawn near player (2 tiles away)
    let foundNearPlayer = false;
    if (p.x >= 0 && p.y >= 0) {
        const possiblePositions = [];
        for (let dx = -2; dx <= 2; dx++) {
            for (let dy = -2; dy <= 2; dy++) {
                if (Math.abs(dx) + Math.abs(dy) === 2) { // Exactly 2 tiles away
                    const x = p.x + dx;
                    const y = p.y + dy;
                    if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] === 0) {
                        possiblePositions.push({x, y});
                    }
                }
            }
        }
        
        if (possiblePositions.length > 0) {
            const randomPos = possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
            stashX = randomPos.x;
            stashY = randomPos.y;
            foundNearPlayer = true;
        }
    }
    
    // If no near player position found, use original logic
    if (!foundNearPlayer) {
        do {
            stashX = room.x + Math.floor(Math.random() * room.w);
            stashY = room.y + Math.floor(Math.random() * room.h);
            attempts--;
        } while ((map[stashY][stashX] !== 0 || 
                 (stashX === p.x && stashY === p.y)) && attempts > 0);
    }
    
    if (attempts > 0 || foundNearPlayer) {
        map[stashY][stashX] = 19; // Soul stash tile
        soulStashPos = {x: stashX, y: stashY};
    } else {
        // Fallback to player position if no room space found
        if (map[p.y][p.x] === 0) {
            map[p.y][p.x] = 19; // Soul stash tile
            soulStashPos = {x: p.x, y: p.y};
        }
    }
}

// After placing soul stash, spawn soul orb statues
if (!inHideout && floor > 1) { // Don't spawn on floor 1 to avoid conflicts
	// Add soul orb statue spawning logic here
	function spawnSoulOrbStatue() {
		if (inHideout) return; // Don't spawn in hideout
		
		// 5% chance to spawn a soul orb statue
		if (Math.random() < 0.05) {
			let attempts = 0;
			const maxAttempts = 50;
			
			do {
				let x = Math.floor(Math.random() * W);
				let y = Math.floor(Math.random() * H);
				
				// Ensure it's a floor tile, not a wall, not occupied by player or items
				if (map[y][x] === 0 && 
					!(x === p.x && y === p.y) &&
					!enemies.some(e => e.x === x && e.y === y) &&
					!satoshiDrops.some(d => d.x === x && d.y === y) &&
					!runeDrops.some(r => r.x === x && r.y === y) &&
					!scrollDrops.some(s => s.x === x && s.y === y) &&
					!portals.some(p => p.x === x && p.y === y) &&
					Math.abs(x - p.x) > 2 && Math.abs(y - p.y) > 2) {
					
					map[y][x] = 21; // Soul orb statue tile
					return {x, y};
				}
				attempts++;
			} while (attempts < maxAttempts);
		}
	}
	spawnSoulOrbStatue();
}

// In the initMap function where items are placed, add shrine placement:
// Place shrine (20% chance, except in hideout), we now give out a shrine in the first floor
if (!inHideout && (floor === 1 || Math.random() < 0.20)) {
    let attempts = 0;
    const maxAttempts = 50;
    
    do {
        let x = Math.floor(Math.random() * W);
        let y = Math.floor(Math.random() * H);
        
        // Ensure it's a floor tile, not a wall, not occupied by player or items
        if (map[y][x] === 0 && 
            !(x === p.x && y === p.y) &&
            !enemies.some(e => e.x === x && e.y === y) &&
            !satoshiDrops.some(d => d.x === x && d.y === y) &&
            !runeDrops.some(r => r.x === x && r.y === y) &&
            !scrollDrops.some(s => s.x === x && s.y === y) &&
            !portals.some(p => p.x === x && p.y === y) &&
            Math.abs(x - p.x) > 2 && Math.abs(y - p.y) > 2) {
            
            map[y][x] = 22; // Shrine tile
            shrinePositions.push({x, y});
            break;
        }
        attempts++;
    } while (attempts < maxAttempts);
}

        // Jester Shrine spawn (20% chance, not in hideout/puzzle)
        if (!inHideout && !inPuzzleRoom && Math.random() < 0.20) {
            let attempts = 50;
            while (attempts--) {
                const x = Math.floor(Math.random() * W);
                const y = Math.floor(Math.random() * H);
                if (map[y][x] === 0 && 
                    Math.abs(x - p.x) + Math.abs(y - p.y) > 5 && // far from player
                    !enemies.some(e => e.x === x && e.y === y)) {
                    map[y][x] = 35; // Jester shrine tile ID
                    break;
                }
            }
        }

// Cool ROI drop – 2.5% chance on any normal floor (not hideout or puzzle)
// Also called "Mask of ROI"
if (!inHideout && !inPuzzleRoom && Math.random() < 0.025) {
    let attempts = 50;
    do {
        const x = Math.floor(Math.random() * W);
        const y = Math.floor(Math.random() * H);
        if (map[y][x] === 0 && !(x === p.x && y === p.y)) {
            map[y][x] = 30; // new tile ID for Cool ROI
            logBattleEvent(`Floor ${floor} - An ancient Mask of ROI appears!`);
            break;
        }
        attempts--;
    } while (attempts > 0);
}

// Memory cleanup: clear old cat state on new floor to prevent carry-over
catPos = null;
catVisible = false;
catAnimStart = 0;

// 5% chance black cat spawn (once per floor) — NEVER in hideout, puzzle rooms, or Glitch Zone
if (!inHideout && !inPuzzleRoom && puzzleStaticCanvas === null && Math.random() < 0.05) {
    let attempts = 50;
    do {
        const x = Math.floor(Math.random() * W);
        const y = Math.floor(Math.random() * H);
        if (map[y][x] === 0 &&
            !(x === p.x && y === p.y) &&
            Math.abs(x - p.x) > 3 &&
            Math.abs(y - p.y) > 3) {
            map[y][x] = 28; // Cat tile
            catPos = {x, y};
            catVisible = false; // Start invisible, fade in
            catAnimStart = performance.now();
            logBattleEvent(`Floor ${floor} - A black cat lurks in the shadows...`);
            break;
        }
        attempts--;
    } while (attempts > 0);
} else {
    // Safety clear if in special area
    catPos = null;
    catVisible = false;
}

// Sandworm spawn: 25% chance once per desert streak (NEVER in puzzle/hideout)
if (currentTheme === 'desert' && !desertStreakHasSandworm && Math.random() < 0.25 && !inPuzzleRoom && !inHideout) {
    let attempts = 100;
    let sx, sy;
    do {
        sx = Math.floor(Math.random() * W);
        sy = Math.floor(Math.random() * H);
    } while (attempts-- > 0 && (map[sy][sx] !== 0 || Math.abs(sx - p.x) + Math.abs(sy - p.y) < 8));

    if (attempts > 0) {
        sandworm = {
            x: sx, y: sy,
            currentX: sx * S, currentY: sy * S,
            hp: 50,
            nextBurrowTime: performance.now() + 3000 + Math.random() * 4000
        };
        desertStreakHasSandworm = true;
        logBattleEvent(`Floor ${floor} - A Sandworm emerges from the dunes!`);
    }
}

// Initialize dangerous areas array for spells
dangerousAreas = [];

exit = null;

        initialWaveSpawned = false;
        needsRedraw = true;

        // Spawn Cursed Trader (25% chance from floor 2+)
        if (floor >= 2 && Math.random() < 0.25 && !inHideout) {
            let traderX, traderY, attempts = 50;
            do {
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                traderX = r.x + Math.floor(Math.random() * r.w);
                traderY = r.y + Math.floor(Math.random() * r.h);
                attempts--;
            } while (attempts > 0 && 
                     (map[traderY][traderX] !== 0 || 
                      (traderX === p.x && traderY === p.y) || 
                      enemies.some(e => e.x === traderX && e.y === traderY)));
            
            if (attempts > 0) {
                const newTrader = { 
                    x: traderX, y: traderY,
                    currentX: traderX * S, currentY: traderY * S,
                    moving: false, stepsLeft: 0, deltaX: 0, deltaY: 0,
                    targetTileX: 0, targetTileY: 0,
                    type: cursedTraderType,
                    hp: 12,
                    address: 'Cursed Trader',
                    sats: 0, // No sats
                    uniqueName: 'Cursed Trader', // Treat as unique for fog invisibility
                    swordActive: false, swordDir: 'right', swordStart: 0, // For sword animation
                    anim: { frameIndex: 0, lastFrameTime: performance.now() }
                };
                enemies.push(newTrader);
                logBattleEvent(`Floor ${floor} - Cursed Trader appears!`);
              
                needsRedraw = true;
            }
        }

// Global wisp "take a break" reminder every 25 floors
    if (floor % 25 === 0 && floor > 0 && !window.breakReminderSpoken) {
        if (wisps.length > 0) {
            talkSpeak(8); // "take, a breac!"
            window.breakReminderSpoken = true;
        }
    }
    // Reset spoken flag on new floor if needed (optional)
    if (floor % 25 !== 0) {
        window.breakReminderSpoken = false;
    }

        // Check runewords at floor start
        checkRunewordsAtFloorStart();

if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}

// Red Maze boss: spawn immediately on qualifying dungeon floor
if (currentTheme === 'dungeon' && !redMazeActive) {
    const floorsSinceLast = floor - (redMazeLastFloor || 0);
    if ((redMazeLastFloor === 0 && floor >= 33) || floorsSinceLast >= 33) {
        logBattleEvent('RED MAZE HAS ARRIVED!');
        // UNIQUE MONSTER SOUND
        if (isIOSorSafari()) {
            const audio = sounds.unique_monster;
            if (audio && audio.src) {
                audio.currentTime = 0;
                audio.play().catch(e => console.error('Unique monster sound error:', e));
            }
        } else {
            playWebAudioSound(sounds.unique_monster);
        }
        
        playWebAudioSound(sounds.secret);
        // Kill ALL enemies instantly
        enemies.forEach(e => e.hp = 0);
        enemies = [];
        redMazeActive = true;
        
        if (p.hasAcrobaticsBuff) {
            p.hasAcrobaticsBuff = false;
            logBattleEvent(`Red Maze boss is not amused .. Acrobatics buff dispelled!`);
        }
        
        redMazeLastFloor = floor;
        
        // Save mute state
        redMazeSavedMuteState = {
            muted: musicMuted,
            buttonText: document.getElementById('mute').textContent
        };
        musicManager.mute(true);
    }
}

if (redMazeActive) {
    // Spawn the eye on a random floor tile (not player)
    let attempts = 100;
    do {
        const rx = 1 + Math.floor(Math.random() * (W-2));
        const ry = 1 + Math.floor(Math.random() * (H-2));
        if (map[ry][rx] === 0 && !(rx === p.x && ry === p.y)) {
            redMaze = { x: rx, y: ry, hp: 100, teleportTime: Date.now() + 3000 };
            break;
        }
    } while (--attempts);
    if (!redMaze) redMaze = { x: p.x + 2, y: p.y + 2, hp: 100, teleportTime: Date.now() + 3000 }; // fallback

    redMazeLazerTime = Date.now() + 3000; // first volley syncs with first teleport
}

// END OF function initMap()
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

function createSecretRoom(wx, wy, px, py, dir) {
    // Create a 3x3 room based on player's facing direction
    const roomSize = 3;
    let rx, ry;
    // Position room based on direction
    switch (dir) {
        case 'up':
            rx = wx;
            ry = wy - roomSize;
            break;
        case 'down':
            rx = wx;
            ry = wy + 1;
            break;
        case 'left':
            rx = wx - roomSize;
            ry = wy;
            break;
        case 'right':
            rx = wx + 1;
            ry = wy;
            break;
        default:
            console.error(`Invalid direction: ${dir}`);
            p.pickaxes++;
            logBattleEvent(`Floor ${floor} - Secret Room Failed: Invalid direction`);
            return;
    }
    // Check if room fits within map bounds
    if (rx < 1 || rx + roomSize > W - 1 || ry < 1 || ry + roomSize > H - 1) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): out of bounds`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Check if the 3x3 area is all walls
    let allWalls = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (map[y][x] !== 1) {
                allWalls = false;
                break;
            }
        }
        if (!allWalls) break;
    }
    if (!allWalls) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): not a 3x3 wall block`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No 3x3 wall block for secret room! Pickaxe refunded`);
        return;
    }
    // Validate room placement - allow overlap with existing rooms
    let valid = true;
    let overlappingRooms = 0;

    // Count how many existing rooms this new room overlaps with
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            // Check if any existing room overlaps with this tile
            rooms.forEach(r => {
                if (x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h) {
                    overlappingRooms++;
                }
            });
            
            // Check for conflicts (items, player, enemies)
            if (
                [2, 3, 4, 5].includes(map[y][x]) || // Items
                (x === px && y === py) || // Player
                enemies.some(e => e.x === x && e.y === y) // Enemies
            ) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
    }

    // If we have conflicts, but it's a valid 3x3 wall area, proceed anyway
    // (This allows for rooms that slightly overlap corridors)
    if (!valid && overlappingRooms > 0) {
        // Check specifically if the room can be placed in this location
        let canPlace = true;
        for (let y = ry; y < ry + roomSize; y++) {
            for (let x = rx; x < rx + roomSize; x++) {
                // Allow overlap with items, player, or enemies if they're not in the main area
                if (map[y][x] !== 0 && map[y][x] !== 1) { // Not a floor or wall
                    canPlace = false;
                    break;
                }
            }
            if (!canPlace) break;
        }
        valid = canPlace;
    }

    if (!valid) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): invalid placement (items, player, or overlap)`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Carve out the room
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            map[y][x] = 0;
        }
    }
    // Clear the broken wall
    map[wy][wx] = 0;
// Punch a non-directional hole (clear one adjacent tile)
const adjacent = [
    { x: wx - 1, y: wy }, // Left
    { x: wx + 1, y: wy }, // Right
    { x: wx, y: wy - 1 }, // Up
    { x: wx, y: wy + 1 }  // Down
].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] !== 0);

if (adjacent.length > 0) {
    const hole = adjacent[Math.floor(Math.random() * adjacent.length)];
    map[hole.y][hole.x] = 0;
}

// Carve a corridor to a nearby floor tile
let floorTiles = [];
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        if (map[y][x] === 0 && !(x === px && y === py) && !(x === wx && y === wy)) {
            floorTiles.push({ x, y });
        }
    }
}

if (floorTiles.length > 0) {
    floorTiles.sort((a, b) => {
        const distA = Math.abs(a.x - wx) + Math.abs(a.y - wy);
        const distB = Math.abs(b.x - wx) + Math.abs(b.y - wy);
        return distA - distB;
    });
    const target = floorTiles[0];
    let x = wx, y = wy;
    while (x !== target.x || y !== target.y) {
        if (Math.abs(target.x - x) > Math.abs(target.y - y)) {
            x += target.x > x ? 1 : -1;
        } else {
            y += target.y > y ? 1 : -1;
        }
        if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 0) {
            map[y][x] = 0;
        }
    }
} else {
    console.warn(`No floor tile found to connect secret room at (${wx}, ${wy})`);
}
    // Place armor in the center
    const armorX = rx + 1;
    const armorY = ry + 1;
    map[armorY][armorX] = 5;

    // place a diamond with 50 % chance
    const dirs = [
        {dx: -1, dy: 0},
        {dx:  1, dy: 0},
        {dx:  0, dy: -1},
        {dx:  0, dy:  1}
    ];
    dirs.sort(() => Math.random() - 0.5);
    for (const d of dirs) {
        const nx = armorX + d.dx;
        const ny = armorY + d.dy;
        if (
            nx >= 0 && nx < W &&
            ny >= 0 && ny < H &&
            map[ny][nx] === 0          // only on an empty floor tile
        ) {
            if (Math.random() < 0.25) {   // ← 25 % chance
                map[ny][nx] = 10;          // diamond tile
            }
            break;
        }
    }

// Show "Found Secret!" in Whale alert area and log success
const floorIndicator = document.getElementById('floor-indicator');
floorIndicator.textContent = `Found Secret!`;
logBattleEvent(`Floor ${floor} - Secret Room Created!`);
setTimeout(() => {
    floorIndicator.textContent = `Floor ${floor}`;
}, 5000);
updateFogMap(px, py);
needsRedraw = true;
}

// Modified updatePlayerState to ensure immortality works correctly
function updatePlayerState() {
if (gameOver) return; // Prevent spam calls post-death
if (p.hp <= 48 && p.hasDiamondArmor) {  // Tie to <= 48 HP
    p.hasDiamondArmor = false;
    p.hasArmor = true;
    p.armorImmunity = null; // Reset armor immunity
    p.maxHP = 48;  // Revert to leather max
    logBattleEvent(`Floor ${floor} - Diamond Armor lost! Found Leather Armor beneath.`);
    document.getElementById('armorStatus').textContent = 'Leather';
} else if (p.hp <= 24 && p.hasArmor) {
        p.hasArmor = false;
        p.armorImmunity = null; // Reset armor immunity
        p.maxHP = 24;  // Revert to base max
        // Also remove any cursed ring effects if active (no stacking with resistances)
        if (p.hasCursedRing) {
            p.elementImmunity = null;
        }
        logBattleEvent(`Floor ${floor} - Armor boost lost!`);
        document.getElementById('armorStatus').textContent = 'Cloth'; // Essential line
}

    // HODL immortality protection
    if (p.immortal && p.hp <= 0) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
    }

    // Sync wisp HP to half player HP and check for death (all damage types)
    if (wisps.length > 0) {
        const wisp = wisps[0];
        wisp.hp = Math.floor(p.hp / 2);
        wisp.maxHP = Math.floor(p.maxHP / 2);
        if (wisp.hp <= 0) {
            wisps = [];
            logBattleEvent(`Floor ${floor} - Wisp perishes!`);
            sounds.gameover.currentTime = 0;
            sounds.gameover.play().catch(e => console.error('Wisp death sound error:', e));
            deadWispCorpse = {
                x: wisp.x, y: wisp.y,
                type: wisp.type.name,
                frameIndex: wisp.anim.frameIndex,
                fadeStart: Date.now()
            };
        }
    }

    // Wisp low-fi danger voice (8 HP or less)
    if (p.hp <= 8 && wisps.length > 0) {
        staticWispDangerSpoken = false; // reset flag
    }
    if (p.hp <= 8 && wisps.length > 0 && !staticWispDangerSpoken) {
        wispSpeak('danger');
        staticWispDangerSpoken = true; // speak only once per low-HP event
    }

    // Restore music when healing above 8 HP (after danger voice ducked it)
    if (p.hp > 8 && wisps.length > 0) {
        if (musicManager.current && !musicMuted) {
            musicManager.audios[musicManager.current].volume = musicManager.volume;
        }
        staticWispDangerSpoken = false; // reset so it can speak again next time
    }

    // Check if player is on blacksmith tile and can get diamond armor or diamond hand
    if (map[p.y][p.x] === 15 && p.perfectlyCutDiamonds > 0) {
        if (!p.hasDiamondArmor) {
            p.hasDiamondArmor = true;
            p.perfectlyCutDiamonds--;
            p.maxHP = 1000;  // Set diamond max
            p.hp = Math.min(p.hp, p.maxHP);  // Cap at new max
            logBattleEvent(`Floor ${floor} - Diamond Armor acquired from Blacksmith!`);
            document.getElementById('armorStatus').textContent = 'Diamond';
        } else if (!p.hasDiamondHand) {
            p.hasDiamondHand = true;
            p.perfectlyCutDiamonds--;
            p.atk = 3; // Increase attack power for diamond hand
            logBattleEvent(`Floor ${floor} - Diamond Hand acquired from Blacksmith!`);
        }
    }

    // Check if player lost diamond armor and should lose diamond hand
    if (!p.hasDiamondArmor && p.hasDiamondHand) {
        p.hasDiamondHand = false;
        logBattleEvent(`Floor ${floor} - Diamond Hand lost! Back to normal sword.`);
        p.atk = 2; // Reset attack power
    }

    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('diamonds').textContent = diamonds;
    document.getElementById('perfectlyCutDiamonds').textContent = p.perfectlyCutDiamonds;
    document.getElementById('resonance').textContent = `${soulResonance}%`;
    
    // Add soul items to display
    if (p.inSoulTerminal) {
        // In terminal, update both regular and soul inventory
        document.getElementById('runes').textContent = p.runes.join(' ');
    }

    // Regenerate aura shield (1 per "turn" - every 64 moves) - separate from shrine
    if (p.hasCursedRing && p.auraMoveCounter >= 64 && p.auraShield < p.auraMax && p.lastAuraRefillMove !== p.auraMoveCounter) {
        p.auraShield = Math.min(p.auraMax, p.auraShield + 1);
        p.lastAuraRefillMove = p.auraMoveCounter; // Track last refill move to prevent spam
        p.auraMoveCounter = 0;  // Reset aura counter after refill
        logBattleEvent(`Floor ${floor} - Aura regenerates +1 (now ${p.auraShield}/${p.auraMax})`);
    }

    // Break ring if aura depleted
    if (p.hasCursedRing && p.auraShield <= 0) {
        p.hasCursedRing = false;
        p.auraMax = 0;
        p.auraShield = 0;
        // Keep curseActive true until pond dispel
        // Restore a random immunity
        const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
        p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];
      
    if (redMazeAuraGiven) {
        logBattleEvent(`Floor ${floor} - Red Maze Aura depleted!`);
    } else {
        logBattleEvent(`Floor ${floor} - Cursed Ring shattered!`);
    }
    redMazeAuraGiven = false; // Reset so next Red Maze boss can grant aura again
    }

// Centralized death check (immortal + resonance + normal)
if (p.hp <= 0 && !gameOver) {
    // -------------------------------------------------
    // 1️⃣ Immortal hero – never dies
    // -------------------------------------------------
    if (p.immortal) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
        return;
    }

    // -------------------------------------------------
    // 2️⃣ Echo Warden revival attempt (integer math)
    // -------------------------------------------------
    if (wardenUses < 3 && !wardenRollPending) {
        wardenRollPending = true; // guard against double-rolls
        const roll = Math.floor(Math.random() * 100) + 1;
        const success = roll <= soulResonance;

        if (success) {
            // ----- successful revival -----
            wardenUses++;
            soulResonance = 0; // consume resonance
            wardenRollPending = false;

            const reviveHP = wardenUses === 1 ? 100 :
                             wardenUses === 2 ? 10 : 1;

            // ----- player stats -----
            p.hp = reviveHP;
            p.hasArmor = true;
            p.maxHP = 36;
            p.soulStormCharges = 256;

            // ----- clear enemies & spawn Echo Warden -----
            enemies.forEach(enemy => {
                kills[enemy.type.name]++;
                if (enemy.type.name !== 'Cursed Trader' && enemy.type.name !== 'Jester' && !enemy.uniqueName && !enemy.isHuge) {
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 3;
                        satoshiDrops.push({
                            x: enemy.x,
                            y: enemy.y,
                            sats: enemy.sats,
                            type: enemy.type.name
                        });
                    }
                }
// === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(enemy.type.name, enemy.x, enemy.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(enemy);
            });
            enemies = [];

            const wx = p.x;
            const wy = p.y;
            echoWardenPos = { x: wx, y: wy };
            map[wy][wx] = 24;

            playWebAudioSound(sounds.rune);
            const lifeMsg = reviveHP.toString();
            logBattleEvent(
                `Floor ${floor} - Echo Warden revives you with ${lifeMsg} HP! (${wardenUses}/3 uses)`
            );
            
            // Reset skill tree system
            playerXP = 0;
            playerLevel = 1;
            playerClass = null;
            pendingSkillTreeLevel = null;
            skillTreeActive = false;
            skillTreeSelectedOption = 0;
            
            updateSatsDisplay();
            needsRedraw = true;
            wardenFlashStart = Date.now();
            gameOver = false;

            return; // ← CRITICAL: Exit early - NO death penalties on success!
        } else {
            // ----- failed roll – instant death -----
            logBattleEvent(
                `Floor ${floor} - Echo Warden fails... (${Math.floor(soulResonance)}% chance missed, rolled ${roll})`
            );
        }
    }

    // -------------------------------------------------
    // 3️⃣ Normal death (no revives left / failed roll / no resonance)
    // -------------------------------------------------
    p.hp = 0;
    diamonds = 0;

    if (p.farmLocked) {
        logBattleEvent(
            `Floor ${floor} - Your farm withered... all planted SATS lost forever.`
        );
        p.farmLocked = false;
        p.farmLockedFloor = 0;
        p.farmLockedSats = 0;
    }

    playerXP = 0;
    playerLevel = 1;
    updateXPBar();

    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
    gameOver = true;
    inputBlocked = true;
    setTimeout(() => {
        inputBlocked = false;
    }, 1000);
}

// Gem inventory display (safe here – called often during gameplay)
    if (document.getElementById('rubies')) document.getElementById('rubies').textContent = p.gems.ruby;
    if (document.getElementById('sapphires')) document.getElementById('sapphires').textContent = p.gems.sapphire;
    if (document.getElementById('emeralds')) document.getElementById('emeralds').textContent = p.gems.emerald;
    if (document.getElementById('citrines')) document.getElementById('citrines').textContent = p.gems.citrine;

    if (document.getElementById('fire-atk')) document.getElementById('fire-atk').textContent = p.gemAtk.fire.toFixed(1);
    if (document.getElementById('cold-atk')) document.getElementById('cold-atk').textContent = p.gemAtk.cold.toFixed(1);
    if (document.getElementById('earth-atk')) document.getElementById('earth-atk').textContent = p.gemAtk.earth.toFixed(1);
    if (document.getElementById('lightning-atk')) document.getElementById('lightning-atk').textContent = p.gemAtk.lightning.toFixed(1);

    if (document.getElementById('shrimpcrab-def')) document.getElementById('shrimpcrab-def').textContent = p.gemDef.shrimpCrab.toFixed(1);
    if (document.getElementById('dolphin-def')) document.getElementById('dolphin-def').textContent = p.gemDef.dolphin.toFixed(1);
    if (document.getElementById('shark-def')) document.getElementById('shark-def').textContent = p.gemDef.shark.toFixed(1);
    if (document.getElementById('squid-def')) document.getElementById('squid-def').textContent = p.gemDef.squid.toFixed(1);

    needsRedraw = true;
}  // ← Add this closing brace here (end of function)

function updateFogMap(px, py) {
    const radius = 3; // Visibility radius
    
    // Quick optimization: Only process tiles within radius and visible from player
    const start_x = Math.max(0, px - radius);
    const end_x = Math.min(W, px + radius + 1);
    const start_y = Math.max(0, py - radius);
    const end_y = Math.min(H, py + radius + 1);
    
    // Track newly visible Shrimps
    const newlyVisibleShrimps = [];
    for (let y = start_y; y < end_y; y++) {
        for (let x = start_x; x < end_x; x++) {
            const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (dist <= radius) {
                // Simple line-of-sight check for performance
                const hasLOS = true; // Simplified for performance
                if (hasLOS && fogMap[y][x] !== 1) { // Tile was not previously explored
                    fogMap[y][x] = 1; // Mark as explored
                    // Check for Shrimp at this position
                    const shrimp = enemies.find(e => e.x === x && e.y === y && e.type.name === 'Shrimp' && currentTheme === 'hell');
                    if (shrimp) {
                        newlyVisibleShrimps.push(shrimp);
                    }
                }
            }
        }
    }
    // Log evolution for newly visible Shrimps
    if (newlyVisibleShrimps.length > 0) {
        logBattleEvent(`Floor ${floor} - Shrimp evolves to Hell Shrimp!`);
    }
}

let lastKeyMoveTime = 0; // Track last keyboard move time
let pendingKeyDir = null; // Track latest keyboard direction
let isKeyHeld = false; // Track if a key is held
let enemiesSpawnedThisFloor = 0;
        window.hugeShrimpSpawnedThisFloor = false; // reset for new floor
let uniqueMonstersSpawnedThisFloor = 0; // Track unique monsters spawned this floor
let scrollDroppedThisFloor = false; // Track if a scroll has dropped on this floor
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 30000; // 30 seconds

function shouldSpawn() {
  // If we are in hideout, or we have just stepped into it, abort.
  return !inHideout;
}

async function fetchTxs() {


    if (gameOver || splashActive || floor === 0 || inHideout || screensaverActive) {
        console.log(`Skipping fetchTxs: gameOver=${gameOver}, splashActive=${splashActive}, floor=${floor}, inHideout=${inHideout}, screensaverActive=${screensaverActive}`);
        return;
    }
    
    // Prevent duplicate calls
    if (isFetchingTxs) {
        console.log('fetchTxs: Already running, skipping');
        return;
    }
    
    isFetchingTxs = true; // Set flag

if (redMazeActive) {
    isFetchingTxs = false; // QUICK HACK! look away :)
    return; // Red Maze boss
}

    // 1. Cancel any pending scheduled call first
    // Prevent concurrent calls to the same function
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }

    // 2. Then check the rate-limit    
    const now = Date.now();
    // Prevent duplicate calls within API_INTERVAL
    if (nextApiCallTime && now < nextApiCallTime) {
        console.log(`fetchTxs: Already scheduled, skipping`);
        isFetchingTxs = false;
        return;
    }
    

    
    try {
        console.log(`fetchTxs: floor=${floor}, wave=${wave}, enemiesSpawnedThisFloor=${enemiesSpawnedThisFloor}, initialSpawnDoneThisFloor=${initialSpawnDoneThisFloor}, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}, enemies=${enemies.length}`);
        await new Promise(resolve => setTimeout(resolve, 25));
        
        // Check if we're still in the right state before making API call
        if (gameOver || splashActive || floor === 0 || inHideout) {
            console.log(`fetchTxs: State changed during API call, aborting`);
            return;
        }
        
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }
        
        // *** NEW *** Abort early if we have stepped into hideout while the request was still processing.
        if (!shouldSpawn()) {
          console.log('Player entered hideout while fetchTxs was in progress. Aborting enemy spawn.');
          return;
        }
        
        let enemyCount = 0;
        const processedTxids = new Set();
        console.warn(`[WHALE ATTEMPT] Checking ${res.data.length} transactions for Whale spawns (> 100 BTC)`);
        
        for (const tx of res.data.slice(0, 10)) {
          // *** NEW *** Stop the loop if hideout has been entered during this loop.
          if (!shouldSpawn()) {
            console.log('Player entered hideout. Stopping spawn loop.');
            break;
          }
          
          if (processedTxids.has(tx.txid)) continue;
          processedTxids.add(tx.txid);
          
          let value = 0;
          let address = 'Invalid address';
          try {
              await new Promise(resolve => setTimeout(resolve, 25));
              const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
              if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                  value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                  address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
              } else {
                  continue;
              }
          } catch (e) {
              continue;
          }
          
          if (value <= 0) {
              continue;
          }
          
          const btc = value / 1e8;
          const type = types.find(t => btc > t.min && btc <= t.max);
          if (!type) {
              continue;
          }

          // Handle initial spawn (up to 10 enemies, including Whales)
          if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10 && enemies.length < 10) {
              if (type.name !== 'Whale' && exit) {
                  continue;
              }
              //console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`); // ORIGINAL
              console.log(`Spawn > Type: ${type.name}, BTC: ${btc}`);
              //console.log('Initial Spawn Tx: Checking 10 transactions for Enemies spawns'); // less bloat means win in the long run // TO LITTLE INFORMATION
              const r = rooms[Math.floor(Math.random() * rooms.length)];
              let x, y, attempts = 50;
              const auraRadius = 2; // 5x5 grid
              let validPosition = false;
              do {
                  x = r.x + Math.floor(Math.random() * r.w);
                  y = r.y + Math.floor(Math.random() * r.h);
                  validPosition = (
                      map[y][x] === 0 &&
                      !(x === p.x && y === p.y) &&
                      !enemies.some(e => e.x === x && e.y === y) &&
                      Math.abs(x - p.x) > auraRadius &&
                      Math.abs(y - p.y) > auraRadius
                  );
                  attempts--;
              } while (attempts > 0 && !validPosition);

// DEBUFF genius! START
// Inside fetchTxs() — when creating newEnemy (replace the hp line)
let baseHp = type.hp;

// Hell Shrimp bonus HP (keep your existing logic)
if (type.name === 'Shrimp' && currentTheme === 'hell') {
    baseHp = 3;
}

// Apply player gem defense as HP debuff to newly spawned enemies
let hpReduction = 0;
if (type.name === 'Shrimp' || type.name === 'Crab') {
    hpReduction = Math.floor(p.gemDef.shrimpCrab);
}
else if (type.name === 'Dolphin') {
    hpReduction = Math.floor(p.gemDef.dolphin);
}
else if (type.name === 'Shark') {
    hpReduction = Math.floor(p.gemDef.shark);
}
else if (type.name === 'Squid') {
    hpReduction = Math.floor(p.gemDef.squid);
}
              
              const newEnemy = {
                 x,
                 y,
                  currentX: x * S,
                  currentY: y * S,
                  moving: false,
                  stepsLeft: 0,
                  deltaX: 0,
                  deltaY: 0,
                  targetTileX: 0,
                  targetTileY: 0,
                 type,
                 // Final HP (never below 1)
                 hp: Math.max(1, baseHp - hpReduction),

// DEBUFF genius! END

                 address,
                 sats: Math.round(btc * 1e8),
                 anim: {
                     frameIndex: Math.floor(Math.random() * type.anim.frames.length),
                     lastFrameTime: performance.now()
                 },
                 // Bit ammo (normal enemies always have 2)
                 bits: 2,
                 bitAmmo: 2,
                 lastBitShot: 0,
                 shieldFlash: { active: false, startTime: 0 } // for bit shield visual
              };
    
// I am starting to think 10% chance to spawn an unique monster actually means per regular enemy spawned (10%,10%,10%,10%,10%,10%,10%,10%,10%,10% instead of just 10%)
if (floor > 1 && Math.random() < 0.10) {
    const randomUniqueName = uniqueMonsterNames[type.name][Math.floor(Math.random() * uniqueMonsterNames[type.name].length)];
    // Check if we've already spawned a unique monster of this type on this floor
    const hasUniqueSpawned = enemies.some(e => e.uniqueName && 
        e.uniqueName.includes(type.name) && 
        !e.uniqueName.includes('Shrimp') || // Allow multiple Shrimp types
        (type.name === 'Shrimp' && e.type.name === 'Shrimp'));
    
    if (!hasUniqueSpawned && uniqueMonstersSpawnedThisFloor < 1) {
        const isUnique = true; // ← THIS WAS MISSING
        newEnemy.uniqueName = randomUniqueName;
        // Make unique monster stronger
        newEnemy.atk = type.atk * 2;
            newEnemy.hp = type.hp * 2;
            // Bounty target gets 10× HP (beefed up)
            if (window.currentBounty && randomUniqueName === window.currentBounty.name) {
                newEnemy.hp *= 10; // 10× instead of 2×
                logBattleEvent(`Bounty Target Detected! ${randomUniqueName}`);
                if (wisps.length > 0) {
                talkSpeak(15); // "too strong, run away"
                }
            }
        
        // Assign a spell to this unique monster
        const spell = assignUniqueMonsterSpell(newEnemy);
        
        // Play unique monster sound on first spawn of this type
        playUniqueMonsterSound(randomUniqueName);        
        
        // Harbinger message handled in draw() for fog visibility only
logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${btc.toFixed(2)} BTC`); // Generic spawn log
        uniqueMonstersSpawnedThisFloor++;
        
// Add bit ammo for uniques
        newEnemy.bits = 4;
        newEnemy.bitAmmo = 4;
        newEnemy.lastBitShot = 0;
    } else {
        const isUnique = false; // ← normal enemy
        const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
        logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
// Add bit ammo for normal enemies
        newEnemy.bits = 2;
        newEnemy.bitAmmo = 2;
        newEnemy.lastBitShot = 0;
    }
} else {
    const isUnique = false; // ← normal enemy
    const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
    logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
// Add bit ammo for normal enemies
        newEnemy.bits = 2;
        newEnemy.bitAmmo = 2;
        newEnemy.lastBitShot = 0;
}
          
              if (!validPosition) {
                  // Fallback: try any floor tile in any room
                  for (let r of rooms) {
                      for (let y = r.y; y < r.y + r.h; y++) {
                          for (let x = r.x; x < r.x + r.w; x++) {
                              if (
                                  map[y][x] === 0 &&
                                  !(x === p.x && y === p.y) &&
                                  Math.abs(x - p.x) > auraRadius &&
                                  Math.abs(y - p.y) > auraRadius &&
                                  !enemies.some(e => e.x === x && e.y === y)
                              ) {
                                  newEnemy.x = x;
                                  newEnemy.y = y;
                                  newEnemy.currentX = newEnemy.x * S;
                                  newEnemy.currentY = newEnemy.y * S;
                                  newEnemy.targetTileX = newEnemy.x;
                                  newEnemy.targetTileY = newEnemy.y;
                                  
                                  validPosition = true;
                                  break;
                              }
                          }
                          if (validPosition) break;
                      }
                      if (validPosition) break;
                  }
              }
              
              if (!validPosition) {
                  console.log(`No valid spawn position found for tx ${tx.txid}, skipping`);
                  continue;
              }
              
              // *** NEW *** Check again before pushing the new enemy.
              if (!shouldSpawn()) {
                console.log('Player entered hideout. Skipping enemy spawn.');
                continue;
              }
              
              enemies.push(newEnemy);
              const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
              logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
              enemiesSpawnedThisFloor++;
              enemyCount++;
              
              if (type.name === 'Whale') {
                  console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                  logWhaleHashId(tx.txid);
                  document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                  setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
              }
              
              if (enemiesSpawnedThisFloor >= 10) {
                  initialSpawnDoneThisFloor = true;
              }
          } else if (type.name === 'Whale') {
              console.log(`[WHALE SPAWN ATTEMPT] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}`);
              const r = rooms[Math.floor(Math.random() * rooms.length)];
              let x, y, attempts = 50;
              const auraRadius = 2; // 5x5 grid
              let validPosition = false;
              do {
                  x = r.x + Math.floor(Math.random() * r.w);
                  y = r.y + Math.floor(Math.random() * r.h);
                  validPosition = (
                      map[y][x] === 0 &&
                      !(x === p.x && y === p.y) &&
                      !enemies.some(e => e.x === x && e.y === y) &&
                      Math.abs(x - p.x) > auraRadius &&
                      Math.abs(y - p.y) > auraRadius
                  );
                  attempts--;
              } while (attempts > 0 && !validPosition);
              
              if (!validPosition) {
                  // Fallback: try any floor tile in any room
                  for (let r of rooms) {
                      for (let y = r.y; y < r.y + r.h; y++) {
                          for (let x = r.x; x < r.x + r.w; x++) {
                              if (
                                  map[y][x] === 0 &&
                                  !(x === p.x && y === p.y) &&
                                  Math.abs(x - p.x) > auraRadius &&
                                  Math.abs(y - p.y) > auraRadius &&
                                  !enemies.some(e => e.x === x && e.y === y)
                              ) {
                                  x = x;
                                  y = y;
                                  validPosition = true;
                                  break;
                              }
                          }
                          if (validPosition) break;
                      }
                      if (validPosition) break;
                  }
              }
              
              if (!validPosition) {
                  console.log(`No valid spawn position found for Whale tx ${tx.txid}, skipping`);
                  continue;
              }
              
              if (type.name === 'Whale' && whalesSpawnedThisFloor >= 10) {
                  console.log(`Whale spawn skipped: reached cap of 10 Whales on floor ${floor}`);
                  continue;
              }
              
              const newEnemy = { x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8),
                   anim: {
                       frameIndex: Math.floor(Math.random() * type.anim.frames.length),
                       lastFrameTime: performance.now()
                   },
                   bits: 2,
                   bitAmmo: 2,
                   lastBitShot: 0,
                   shieldFlash: { active: false, startTime: 0 } // for bit shield visual
                 };

              enemies.push(newEnemy);
              
              if (type.name === 'Whale') {
                  whalesSpawnedThisFloor++; // Increment Whale counter
              }
              
              const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
              logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
              console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
              logWhaleHashId(tx.txid);
              document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
              setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
              enemyCount++;
          }
        }
        
// Apply RIP blast to all on-screen enemies if active
if (p.ripBlast && enemies.length > 0) {
    logBattleEvent(`Floor ${floor} - RIP Blast annihilates all enemies!`);
    playWebAudioSound(sounds.hit);
    ripBlastActive = true; // Set flag for firestorm effect
    ripBlastStartTime = Date.now();

    enemies.forEach(enemy => {
        enemy.hp = 0; // Instant kill

        // === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(enemy.type.name, enemy.x, enemy.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(enemy);
        kills[enemy.type.name]++;
        let xp = 0;
        if (enemy.type.name === 'Shrimp') xp = 1;
        else if (enemy.type.name === 'Crab') xp = 2;
        else if (enemy.type.name === 'Squid') xp = 3;
        else if (enemy.type.name === 'Dolphin') xp = 4;
        else if (enemy.type.name === 'Shark') xp = 5;
        else if (enemy.type.name === 'Whale') xp = 15;
        else if (enemy.type.name === 'Cursed Trader') xp = 10;
        else if (enemy.type.name === 'Jester') xp = 2;
        if (enemy.uniqueName) xp *= 2; // Unique monsters give 2x XP
        playerXP += xp;
        checkLevelUp();
        updateXPBar();

if (enemy.type.name === 'Jester' && Math.random() < 0.25) {
    const gemTypes = ['ruby', 'sapphire', 'emerald', 'citrine'];
    const gem = gemTypes[Math.floor(Math.random() * gemTypes.length)];
    
    // Try to place on death spot
    let placed = false;
    if (map[enemy.y][enemy.x] === 0) {
        map[enemy.y][enemy.x] = GEM_TILES[gem];
        placed = true;
    } else {
        // Try adjacent tiles
        const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
        for (const d of dirs) {
            const nx = enemy.x + d.dx;
            const ny = enemy.y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                map[ny][nx] = GEM_TILES[gem];
                placed = true;
                break;
            }
        }
    }
    
    if (placed) {
        logBattleEvent(`Jester dropped a ${gem} on the floor!`);
        playWebAudioSound(sounds.pickup);
    } else {
        // Fallback: add directly to inventory if no space
        p.gems[gem]++;
        logBattleEvent(`Jester dropped a ${gem} directly to you (no floor space)!`);
        playWebAudioSound(sounds.pickup);
    }
    
    updatePlayerState();
}

        if (enemy.type.name === 'Cursed Trader') {
            dropSoulStone(enemy.x, enemy.y);
        }
        logBattleEvent(`Floor ${floor} - ${enemy.type.name} destroyed!`);

        let dropPlaced = false;
        // No sats/BTC drop for uniques OR Cursed Trader
        if (!enemy.uniqueName && enemy.type.name !== 'Cursed Trader' && enemy.type.name !== 'Jester' && !enemy.isHuge) {
            if (map[enemy.y][enemy.x] === 0) {
                map[enemy.y][enemy.x] = 3;
                satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                dropPlaced = true;
            } else {
                const adjacent = [
                    {x: enemy.x, y: enemy.y - 1},
                    {x: enemy.x, y: enemy.y + 1},
                    {x: enemy.x - 1, y: enemy.y},
                    {x: enemy.x + 1, y: enemy.y}
                ];
                for (const pos of adjacent) {
                    const nx = pos.x, ny = pos.y;
                    if (
                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                        map[ny][nx] === 0 &&
                        !enemies.some(e => e.x === nx && e.y === ny)
                    ) {
                        map[ny][nx] = 3;
                        satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                        dropPlaced = true;
                        break;
                    }
                }
            }
        }

        // Cursed Ring drop (50% for Cursed Trader only, even in blast)
        if (enemy.type.name === 'Cursed Trader' && Math.random() < 0.5 && !p.hasCursedRing) {
            let ringPlaced = false;
            if (map[enemy.y][enemy.x] === 0) {
                map[enemy.y][enemy.x] = 23;
                ringPlaced = true;
            } else {
                const adjacent = [
                    { x: enemy.x, y: enemy.y - 1 },
                    { x: enemy.x, y: enemy.y + 1 },
                    { x: enemy.x - 1, y: enemy.y },
                    { x: enemy.x + 1, y: enemy.y }
                ];
                for (const pos of adjacent) {
                    const nx = pos.x, ny = pos.y;
                    if (
                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                        map[ny][nx] === 0 &&
                        !enemies.some(e => e.x === nx && e.y === ny)
                    ) {
                        map[ny][nx] = 23;
                        ringPlaced = true;
                        break;
                    }
                }
            }
            if (ringPlaced) {
                logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                playWebAudioSound(sounds.pickup);
            }
        }
                
                // Rune drop logic (20% for Hell Shrimp, 10% for others)
                if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                        const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 8;
                        runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: enemy.x, y: enemy.y - 1 },
                            { x: enemy.x, y: enemy.y + 1 },
                            { x: enemy.x - 1, y: enemy.y },
                            { x: enemy.x + 1, y: enemy.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8;
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
            });
            
            const deadEnemies = enemies.filter(e => e.hp <= 0);
            enemies = enemies.filter(e => e.hp > 0);
            deadEnemies.forEach(dead => {
                enemyBgFrameTimes.delete(dead);

                // Mark death time + rewards for huge shrimp
                if (dead.isHuge) {
                    if (!dead.deathTime) dead.deathTime = performance.now();
                    dropSoulStone(dead.x, dead.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[dead.y][dead.x] === 0) {
            map[dead.y][dead.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = dead.x + d.dx, ny = dead.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
            });
            
deadEnemies.forEach(dead => enemyBgFrameTimes.delete(dead)); // Clear bg tracking for dead
            // Delay stairs placement until fire wave animation completes
            if (enemies.length === 0 && !exit && waveActive) {
                // Stairs will be placed in draw() after animation completes
            }
            p.ripBlast = false; // Disable blast after use
            needsRedraw = true;
        } else if (p.ripBlast && enemies.length === 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast activated but no enemies to destroy!`);
            // Delay stairs placement until fire wave animation completes
            p.ripBlast = false; // Consume RIP even if no enemies
            needsRedraw = true;
        }
        
        if (enemyCount > 0 && enemies.length > 0 && !exit) {
            if (!waveActive) {
                initialWaveSpawned = true;
                waveActive = true;
                document.getElementById('wave').textContent = wave;
                logBattleEvent(`Floor ${floor} - Wave ${wave} Started!`);
                console.log(`New wave started: wave=${wave}, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
            } else {
                console.log(`Additional enemies added to wave ${wave}, enemies=${enemies.length}, waveActive=${waveActive}`);
            }
            needsRedraw = true;
        } else {
            console.log(`No enemies spawned, wave=${wave}, scheduling retry in ${API_INTERVAL / 1000}s`);
        }
        
} catch (e) {
    console.error('fetchTxs Error:', e, e.stack);
} finally {
    // Set next API call time after successful execution
    nextApiCallTime = now + API_INTERVAL;
    apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    isFetchingTxs = false; // Clear flag when done
}
}

function isSolid(x, y) {
    return map[y][x] === 1 || map[y][x] === 13; // Standard walls and diamond walls
}

function move(dir) {
    if (gameOver || splashActive || inputBlocked || skillTreeActive || passiveTreeActive) return;

if (infoGracePeriod) {
    return; // Block ALL movement during 0.5s grace period
}

    // Check if player is in hideout and trying to pause from waypoint tile
    if (inHideout && map[p.y][p.x] === 16) {
        // Allow pausing when on waypoint in hideout
        // This is handled by the existing logic but we want to ensure it works properly
    }

    // Save previous position for boulder pushing
    if (!p.previousX) p.previousX = p.x;
    if (!p.previousY) p.previousY = p.y;

    swordDir = dir;
    let nx = p.x, ny = p.y;
    
// === BLOCK MOVEMENT ON HAZARDS IN PUZZLE ROOMS ===
    if (inPuzzleRoom) {
        const hazardTile = map[ny] && map[ny][nx] === 6;
        if (hazardTile) {
            return; // Cannot walk on lava/quicksand/pond
        }
    }
    
    let newDirection = p.anim.direction;

    if (dir === 'up') { ny--; newDirection = 'back'; }
    if (dir === 'down') { ny++; newDirection = 'front'; }
    if (dir === 'left') { nx--; newDirection = 'left'; }
    if (dir === 'right') { nx++; newDirection = 'right'; }

// In the move function, after updating position:
p.moveCounter++;
if (playerClass === 'degen' && playerLevel >= 50 && p.moveCounter >= 2) {
    p.soulStormCharges = Math.min(256, p.soulStormCharges + 2);
}
p.auraMoveCounter++;
if (p.moveCounter >= 2) {
if (p.shrineCharges > 0) {
    const regenAmount = (playerClass === 'druid' && playerLevel >= 40 ? 2 : 1); // Druid lvl 40+
    p.hp += regenAmount;
    p.shrineCharges--;
    // Log only every 8 charges spent to reduce spam
    if ((p.maxShrineCharges - p.shrineCharges) % 8 === 0) {
        const effectiveMax = p.maxShrineCharges * regenAmount;
        const effectiveCurrent = (p.maxShrineCharges - p.shrineCharges) * regenAmount;
        logBattleEvent(`Floor ${floor} - Shrine refills health! (${effectiveCurrent}/${effectiveMax} HP)`);
    }
}
    p.moveCounter = 0;  // Reset only shrine counter
    updatePlayerState();  // Call every 2 moves (shrine tick) to check aura too
}

if (map[ny][nx] === 31 && inHideout) { // Smelter tile
    if (p.hasDiamondHand) {
        p.hasDiamondHand = false;
        p.perfectlyCutDiamonds++;
        logBattleEvent(`Floor ${floor} - Diamond Hand smelted into a Perfectly Cut Diamond!`);
        playWebAudioSound(sounds.secret); // or a custom smelter sound
        updatePlayerState();
    } else {
        logBattleEvent(`Smelter: Bring a Diamond Hand to smelt!`);
    }
}

// Inside your move() function, after other item pickups
if (map[ny][nx] === GEM_TILES.ruby) {
    p.gems.ruby++;
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Ruby collected!`);
    updatePlayerState();
}
if (map[ny][nx] === GEM_TILES.sapphire) {
    p.gems.sapphire++;
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Sapphire collected!`);
    updatePlayerState();
}
if (map[ny][nx] === GEM_TILES.emerald) {
    p.gems.emerald++;
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Emerald collected!`);
    updatePlayerState();
}
if (map[ny][nx] === GEM_TILES.citrine) {
    p.gems.citrine++;
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Citrine collected!`);
    updatePlayerState();
}

    // === VALIDATE MOVE + BOULDER PUSHING (L2 style) ===
    if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
        p.anim.direction = newDirection;
        needsRedraw = true;
        return;
    }

    // Block walls
    if (isSolid(nx, ny)) {
        p.anim.direction = newDirection;
        needsRedraw = true;
        return;
    }

// ———————————————————————————————————————
// PUZZLE ROOM: BOULDER & LAVA LOGIC (FINAL – NO BLACK TILES)
// ———————————————————————————————————————
if (inPuzzleRoom) {
    const targetTile = map[ny][nx];

    // 1. Raw lava (no boulder) → blocked
    if (targetTile === 6 && !puzzleBoulders.some(b => b.x === nx && b.y === ny)) {
        p.anim.direction = newDirection;
        needsRedraw = true;
        return;
    }

    // 2. There is a boulder on the target tile
    if (puzzleBoulders.some(b => b.x === nx && b.y === ny)) {
        const boulder = puzzleBoulders.find(b => b.x === nx && b.y === ny);

        // 2a. Boulder on lava → walkable bridge
        if (puzzleHazards.some(h => h.x === nx && h.y === ny)) {
            // do nothing — player walks on bridge
        }
        // 2b. Boulder is pushable
        else {
            const pushX = nx + (dir === 'right' ? 1 : dir === 'left' ? -1 : 0);
            const pushY = ny + (dir === 'down' ? 1 : dir === 'up' ? -1 : 0);

            // Sacred blocks
            if (puzzleChest && pushX === puzzleChest.x && pushY === puzzleChest.y) return;
            if (puzzleHeartFramers.some(h => h.x === pushX && h.y === pushY)) return;

            if (pushX >= 0 && pushX < W && pushY >= 0 && pushY < H) {
                if (map[pushY][pushX] === 6) {
                    // ——— SINK INTO LAVA ———
                    const oldX = boulder.x;
                    const oldY = boulder.y;

                    // Remove boulder + lava
                    map[oldY][oldX] = 0;
                    map[pushY][pushX] = 0;
                    puzzleBoulders = puzzleBoulders.filter(b => b !== boulder);
                    puzzleHazards = puzzleHazards.filter(h => h.x !== pushX || h.y !== pushY);

                    // Patch BOTH tiles in static canvas → floor
                    patchStaticCanvas(oldX, oldY);
                    patchStaticCanvas(pushX, pushY);

                    // Flash effect
                    highlightTiles.push({x: oldX, y: oldY, highlightStart: performance.now(), color: 'rgba(120,120,120,0.7)'});
                    highlightTiles.push({x: pushX, y: pushY, highlightStart: performance.now(), color: 'rgba(255,100,0,0.9)'});

                    logBattleEvent("Boulder sinks and cools into permanent stone!");
                    playWebAudioSound(sounds.lava);
                }
                else if (map[pushY][pushX] === 0) {
                    // ——— NORMAL PUSH ———
                    const oldX = boulder.x;
                    const oldY = boulder.y;
                    // Patch old position (restore underlying floor/arrow)
                    patchStaticCanvas(oldX, oldY);
                    // If the push destination had an arrow tile underneath, clear it
                    if (puzzleArrows.some(a => a.x === pushX && a.y === pushY)) {
                        puzzleArrows = puzzleArrows.filter(a => !(a.x === pushX && a.y === pushY));
                        // Patch the destination to plain floor (arrow is gone)
                        puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, pushX * S, pushY * S, S, S);
                    }
                    // Move boulder
                    map[oldY][oldX] = 0;
                    map[pushY][pushX] = 26;
                    boulder.x = pushX;
                    boulder.y = pushY;
                }
                else {
                    p.anim.direction = newDirection;
                    needsRedraw = true;
                    return;
                }

                needsRedraw = true;
                return;
            }
        }
    }
}

// Save previous position for next frame's push detection
p.previousX = p.x;
p.previousY = p.y;

    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return; // Don't start animation
    }

// Block movement if enemy, Red Maze eye, or sandworm is on target tile
if (enemies.some(e => e.x === nx && e.y === ny) ||
    (redMazeActive && redMaze && redMaze.x === nx && redMaze.y === ny) ||
    (sandworm && sandworm.x === nx && sandworm.y === ny)) {
    p.anim.direction = newDirection;
    needsRedraw = true;
    return; // Don't start animation
}

    // Update direction and position (will be interpolated during draw)
    p.anim.direction = newDirection;
    
    // Always update direction for rendering, even if blocked by enemy
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        needsRedraw = true; // Ensure redraw to reflect new direction
        return;
    }
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
    
const oldX = p.x;
const oldY = p.y;
p.startX = p.x; // Track actual start for lerp
p.startY = p.y;
p.x = nx;
p.y = ny;

        // ——— SMOOTH WARDEN MIRROR: Interpolates between tiles ———
        if (floor === 1 && echoWardenPos && p.echoWardenBlessingGiven) {
            const oldWX = echoWardenPos.x;
            const oldWY = echoWardenPos.y;

            // Opposite direction
            let newWX = echoWardenPos.x - (nx - oldX);
            let newWY = echoWardenPos.y - (ny - oldY);

            // Clamp bounds
            newWX = Math.max(0, Math.min(W - 1, newWX));
            newWY = Math.max(0, Math.min(H - 1, newWY));

            // Valid target?
            if (map[newWY][newWX] === 0 || (newWX === p.x && newWY === p.y)) {
                // Clear old tile
                map[oldWY][oldWX] = 0;

                // Start smooth move (8 steps, 2px/step like enemies)
                echoWardenPos.targetX = newWX * S;
                echoWardenPos.targetY = newWY * S;
                echoWardenPos.deltaX = (newWX - oldWX) * 2;
                echoWardenPos.deltaY = (newWY - oldWY) * 2;
                echoWardenPos.stepsLeft = 8;
                echoWardenPos.moving = true;
                echoWardenPos.x = newWX;
                echoWardenPos.y = newWY;

                // Set new tile
                map[newWY][newWX] = 24;
            }

            needsRedraw = true;
        }

p.targetTileX = nx;
p.targetTileY = ny;
p.deltaX = (nx - oldX) * 2;
p.deltaY = (ny - oldY) * 2;
p.stepsLeft = 8;
p.moving = true;
p.anim.direction = newDirection;
    p.moveStartTime = performance.now(); // Track start for smooth lerp
    p.moveDuration = 200; // ms per tile (tune for feel)



        // Apply spell damage when standing or moving onto a spell effect tile
        if (dangerousAreas.some(effect => effect.x === p.x && effect.y === p.y)) {
            applySpellDamage(p.x, p.y);
        }
        
        if (map[ny][nx] === 2) { 
            p.potions++; 
            map[ny][nx] = 0; 
            playWebAudioSound(sounds.pickup);
        }
        
if (map[ny][nx] === 6 && !inHideout) {
            if (currentTheme === 'paradise') {
    if (p.hasCursedRing || p.curseActive) {
        p.hasCursedRing = false;
        p.curseActive = false;
        p.auraMax = 0;
        p.auraShield = 0;
        redMazeAuraGiven = false; // Reset for next Red Maze boss
        p.armorImmunity = null;
        logBattleEvent(`Floor ${floor} - Pond dispels Aura!`);
        playWebAudioSound(sounds.pond);
        // Restore a random immunity
        const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
        p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];
    }
    // Restore HP only if below max (36 base, 48 with armor) — do nothing if already full
    const maxHP = 36 + (p.hasArmor ? 12 : 0);
    if (p.hp < maxHP) {
        const oldHP = p.hp;
        p.hp = maxHP;
        logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
        playWebAudioSound(sounds.pond);
    }
    }            
            // If p.hp > 36, do nothing and continue
            
            // Desert – Sludge pit
            if (currentTheme === 'desert') {
                // Check for poison immunity
                if (p.elementImmunity === 'Poison' || p.armorImmunity === 'Poison') {
                    logBattleEvent(`Floor ${floor} - Sludge Pit: Immune to Poison damage!`);
} else {
    const damage = p.hasCursedRing ? 4 : 2;
    p.hp = Math.max(0, p.hp - damage);
    logBattleEvent(`Floor ${floor} - Sludge Pit: -${damage} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hit);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;                // ← reset diamonds
                        
            playerXP = 0;          // reset XP meter on death
            playerLevel = 1;           // reset level to 1
            updateXPBar();         // immediately update the bar to 0                        
                        
                        updatePlayerState();          // ← update display
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    }
                }
            }

            // Hell – Lava
            if (currentTheme === 'hell') {
                // Check for fire immunity
                if (p.elementImmunity === 'Fire' || p.armorImmunity === 'Fire') {
                    logBattleEvent(`Floor ${floor} - Lava: Immune to Fire damage!`);
} else {
    const damage = p.hasCursedRing ? 16 : 8;
    p.hp = Math.max(0, p.hp - damage);
    logBattleEvent(`Floor ${floor} - Lava: -${damage} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hit);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;
                        
            playerXP = 0;          // reset XP meter on death
            playerLevel = 1;           // reset level to 1
            updateXPBar();         // immediately update the bar to 0                        
                        
                        updatePlayerState();
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    }
                }
            }

            // Ruins – Falling into a hole
            if (currentTheme === 'ruins') {
                if (p.hp === 1) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Fell into Hole: Hero Fell! Reached Floor ${floor}`);
                    playWebAudioSound(sounds.hole);
                    updatePlayerState(); // Run death/resonance check
                } else {
                    const oldHP = p.hp;
                    p.hp = Math.ceil(p.hp / 2);
                    logBattleEvent(`Floor ${floor} - Fell into Hole: -${oldHP - p.hp} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hole);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;
                        
            playerXP = 0;          // reset XP meter on death
            playerLevel = 1;           // reset level to 1
            updateXPBar();         // immediately update the bar to 0                        
                        
                        updatePlayerState();
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    }
                }
            }

            updatePlayerState();
        }
        
if (map[ny][nx] === 7) {
    if (p.curseActive) {
        logBattleEvent(`Gnome refuses: Lingering curse blocks extra life!`);
        playWebAudioSound(sounds.buzz);
        p.potions = 0;
        map[ny][nx] = 0;
        updatePlayerState();
        return;  // Skip coin toss
    }
    const coinToss = Math.random() < 0.5; // 50/50 chance
    if (coinToss) {
    if (p.hasCursedRing && !redMazeAuraGiven) {
        logBattleEvent(`Gnome flips a coin.. Heads! But Cursed Aura blocks extra life!`);
        playWebAudioSound(sounds.heads); // Play heads.wav
    } else {
            // Grant max health (original behavior)
            const healthGain = p.potions * 12;
            p.maxHP += healthGain;
            p.hp += healthGain;
            logBattleEvent(`Gnome flips a coin.. Heads! Traded ${p.potions} potions for +${healthGain} max HP (new max HP: ${p.hp})`);
            playWebAudioSound(sounds.heads); // Play heads.wav
        }
    } else {
        // Remove excess health and adjust armor
        let currentMaxHP = 36; // Base HP
        let newArmorStatus = 'Cloth';
        if (p.hp > 1000) {
            currentMaxHP = 1000; // Diamond armor max
            newArmorStatus = 'Diamond';
        } else if (p.hp > 48) {
            currentMaxHP = 48; // Leather armor max
            newArmorStatus = 'Leather';
        } else if (p.hp > 36) {
            currentMaxHP = 36; // Cloth max
            newArmorStatus = 'Cloth';
        }
        if (p.hp > currentMaxHP) {
            const healthLost = p.hp - currentMaxHP;
            p.hp = currentMaxHP;
            p.hasDiamondArmor = currentMaxHP >= 1000;
            p.hasArmor = currentMaxHP === 48;
            document.getElementById('armorStatus').textContent = newArmorStatus;
            logBattleEvent(`Gnome flips a coin.. Tails! A mischievous cackle echoes as ${healthLost} HP is lost! (HP: ${p.hp})`);
        } else {
            logBattleEvent(`Gnome flips a coin.. Tails! The gnome giggles but finds no excess HP to take! (HP: ${p.hp})`);
        }
        playWebAudioSound(sounds.tails); // Play tails.wav
    }
    p.potions = 0;
    map[ny][nx] = 0;
    updatePlayerState();
}
        
        if (map[ny][nx] === 3) {
            const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
            if (drop) {
                if (satsEarned[drop.type] !== undefined) {
                    satsEarned[drop.type] += drop.sats;
                }
                map[ny][nx] = 0;
                satoshiDrops = satoshiDrops.filter(d => d !== drop);
                playWebAudioSound(sounds.pickup);
                updateSatsDisplay();
            }
        }
        
        if (map[ny][nx] === 4) {
            p.pickaxes++;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Pickaxe Found!`);
        }
        
        if (map[ny][nx] === 5) {
            // Cursed Aura now stacks with armor (no dispel)
            if (p.hp >= 36) {
                p.hp += 12;
            } else {
                p.hp = 36 + 12;
            }
p.hasArmor = true;
const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
let available = elements.filter(el => el !== p.elementImmunity);
if (available.length > 0 && !p.curseActive) {
    p.armorImmunity = available[Math.floor(Math.random() * available.length)];
    logBattleEvent(`Floor ${floor} - Leather Armor grants 100% ${p.armorImmunity} resistance!`);
}
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Armor Found: HP set to ${p.hp}`);
            updatePlayerState();
        }
        
        if (map[ny][nx] === 10) {            // diamond tile
            diamonds++;                      // collect it
            map[ny][nx] = 0;                 // remove from map
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Diamond collected!`);
            updatePlayerState();              // updates inventory display
        }
        
if (map[ny][nx] === 11) { // Scroll pickup → spawn portal nearby
    const scroll = scrollDrops.find(s => s.x === nx && s.y === ny);
    if (scroll) {
        map[ny][nx] = 0;
        scrollDrops = scrollDrops.filter(s => s !== scroll);
        playWebAudioSound(sounds.pickup);

        // ——— WIDE SEARCH: try up to 2 tiles away + diagonals (13 positions) ———
        const candidates = [];
        for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
                if (dx === 0 && dy === 0) continue;               // skip the scroll tile itself
                const px = nx + dx;
                const py = ny + dy;
                if (px >= 0 && px < W && py >= 0 && py < H &&
                    map[py][px] === 0 &&                          // empty floor
                    !enemies.some(e => e.x === px && e.y === py) && // no enemy
                    !(exit && exit.x === px && exit.y === py)       // don’t overwrite stairs
                ) {
                    // give closer tiles higher priority (optional – looks nicer)
                    const distance = Math.abs(dx) + Math.abs(dy);
                    candidates.push({ x: px, y: py, dist: distance });
                }
            }
        }

        // Sort by distance so the portal prefers the closest free spot
        candidates.sort((a, b) => a.dist - b.dist);

        if (candidates.length > 0) {
            const portalPos = candidates[0]; // take the closest valid spot

            if (Math.random() < 0.5) {
                // 50% → Puzzle Portal
                map[portalPos.y][portalPos.x] = 25;
                portals.push({
                    x: portalPos.x,
                    y: portalPos.y,
                    type: 'puzzle',
                    frameIndex: 0,
                    lastFrameTime: performance.now(),
                    frameDuration: 200
                });
                logBattleEvent(`Floor ${floor} - The scroll ignites... a Puzzle Portal opens nearby!`);
                playWebAudioSound(sounds.secret);
            } else {
                // 50% → Town Portal
                map[portalPos.y][portalPos.x] = 12;
                portals.push({
                    x: portalPos.x,
                    y: portalPos.y,
                    frameIndex: 0,
                    lastFrameTime: performance.now(),
                    frameDuration: 400
                });
                logBattleEvent(`Floor ${floor} - The scroll unrolls... a Town Portal appears!`);
                playWebAudioSound(sounds.town_portal);
            }
        } else {
            logBattleEvent(`Floor ${floor} - The scroll crumbles... no space for a portal!`);
        }
    }
}

        // Check for adjacent special tiles (type 6) and play ambient sound once per floor
        if (currentTheme !== 'dungeon') {
            const adjacent = [
                {x: p.x, y: p.y - 1}, // Up
                {x: p.x, y: p.y + 1}, // Down
                {x: p.x - 1, y: p.y}, // Left
                {x: p.x + 1, y: p.y}  // Right
            ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 6);
            if (adjacent.length > 0) {
                let soundKey;
                switch (currentTheme) {
                    case 'hell':
                        soundKey = 'lava';
                        break;
                    case 'desert':
                        soundKey = 'quicksand';
                        break;
                    case 'paradise':
                        soundKey = 'pond';
                        break;
                }
                if (soundKey && !specialSoundsPlayedThisFloor[soundKey]) {
                    playWebAudioSound(sounds[soundKey]);
                    specialSoundsPlayedThisFloor[soundKey] = true;
                    logBattleEvent(`Floor ${floor} - Heard ${soundKey === 'quicksand' ? 'sludge pit' : soundKey} nearby!`);
                }
            }
        }


        // Check for falling animation (only on Ruins theme)
        if (
            currentTheme === 'ruins' &&
            map[ny][nx] === 6 && // Ring hole tile
            !p.isFalling // Not already falling
        ) {
            inputBlocked = true;
            p.isFalling = true;
            const direction = p.anim.direction; // Save current direction for push
            const oldX = p.x;
            const oldY = p.y;

            // Start fall animation - ensure it starts from frame 0
            let frameIndex = 0;
            const fallDuration = 100; // ms per frame
            const totalFrames = 6;
            const startTime = Date.now();

            function animateFall() {
                const elapsed = Date.now() - startTime;
                frameIndex = Math.min(Math.floor(elapsed / fallDuration), totalFrames - 1);

                // Update animation - cycle through 0,1,2
                p.anim.frameIndex = frameIndex;
                needsRedraw = true;

                if (frameIndex < totalFrames - 1) {
                    requestAnimationFrame(animateFall);
                } else {
                    // Animation complete, now push player one tile away
                    let pushX = oldX;
                    let pushY = oldY;

                    switch (direction) {
                        case 'up': pushY--; break;
                        case 'down': pushY++; break;
                        case 'left': pushX--; break;
                        case 'right': pushX++; break;
                    }

                    // Ensure player lands on a valid floor tile (not wall or hole), preferring same direction
                    pushX = oldX; // Reuse existing pushX
                    pushY = oldY; // Reuse existing pushY
                    let validPosition = false;

                    // Log original position for debugging
                    //console.log(`Original position: (${oldX}, ${oldY}), tile=${oldX >= 0 && oldX < W && oldY >= 0 && oldY < H ? map[oldY][oldX] : 'out of bounds'}`);

                    // Try pushing one tile in the original direction
                    //console.log(`Direction before initial push: ${direction}`);
                    switch (direction) {
                        case 'back': pushY--; break; // Up
                        case 'front': pushY++; break; // Down
                        case 'left': pushX--; break;
                        case 'right': pushX++; break;
                    }

                    //console.log(`Initial push: direction=${direction}, position=(${pushX}, ${pushY}), tile=${pushX >= 0 && pushX < W && pushY >= 0 && pushY < H ? map[pushY][pushX] : 'out of bounds'}`);

                    // Check if initial push position is the hole; if so, player is already on it
                    if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] === 6 // Initial push is the hole
                    ) {
                        // Try one tile before the hole (opposite direction, same side)
                        let backX = oldX;
                        let backY = oldY;
                        switch (direction) {
                            case 'front': backY--; break; // Up (opposite of front)
                            case 'back': backY++; break; // Down (opposite of back)
                            case 'left': backX++; break; // Right (opposite of left)
                            case 'right': backX--; break; // Left (opposite of right)
                        }
                        //console.log(`Back push (opposite direction): position=(${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                        if (
                            backX >= 0 && backX < W &&
                            backY >= 0 && backY < H &&
                            map[backY][backX] !== 1 && // Not a wall
                            map[backY][backX] !== 6 // Not a hole
                        ) {
                            pushX = backX;
                            pushY = backY;
                            validPosition = true;
                            //console.log(`Valid back push position found at (${pushX}, ${pushY})`);
                        } else {
                            //console.log(`Back push invalid at (${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                            // Try adjacent tiles on same side (left/right for front/back, up/down for left/right)
                            const adjacent = [
                                direction === 'front' || direction === 'back' ? { x: oldX - 1, y: oldY } : { x: oldX, y: oldY - 1 }, // Left or up
                                direction === 'front' || direction === 'back' ? { x: oldX + 1, y: oldY } : { x: oldX, y: oldY + 1 }  // Right or down
                            ];
                            for (let i = 0; i < adjacent.length; i++) {
                                const adjX = adjacent[i].x;
                                const adjY = adjacent[i].y;
                                //console.log(`Adjacent push ${i+1}: position=(${adjX}, ${adjY}), tile=${adjX >= 0 && adjX < W && adjY >= 0 && adjY < H ? map[adjY][adjX] : 'out of bounds'}`);
                                if (
                                    adjX >= 0 && adjX < W &&
                                    adjY >= 0 && adjY < H &&
                                    map[adjY][adjX] !== 1 && // Not a wall
                                    map[adjY][adjX] !== 6 // Not a hole
                                ) {
                                    pushX = adjX;
                                    pushY = adjY;
                                    validPosition = true;
                                    //console.log(`Valid adjacent push position found at (${pushX}, ${pushY})`);
                                    break;
                                }
                            }
                        }
                    } else if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] !== 1 && // Not a wall
                        map[pushY][pushX] !== 6 // Not a hole
                    ) {
                        validPosition = true;
                        //console.log(`Valid initial position found at (${pushX}, ${pushY})`);
                    } else if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] === 1 // Wall detected
                    ) {
                        // Try one tile before the hole (opposite direction, same side)
                        let backX = oldX;
                        let backY = oldY;
                        switch (direction) {
                            case 'front': backY--; break; // Up
                            case 'back': backY++; break; // Down
                            case 'left': backX++; break; // Right
                            case 'right': backX--; break; // Left
                        }
                        //console.log(`Back push (opposite direction): position=(${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                        if (
                            backX >= 0 && backX < W &&
                            backY >= 0 && backY < H &&
                            map[backY][backX] !== 1 && // Not a wall
                            map[backY][backX] !== 6 // Not a hole
                        ) {
                            pushX = backX;
                            pushY = backY;
                            validPosition = true;
                            //console.log(`Valid back push position found at (${pushX}, ${pushY})`);
                        } else {
                            //console.log(`Back push invalid at (${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                            // Try adjacent tiles on same side
                            const adjacent = [
                                direction === 'front' || direction === 'back' ? { x: oldX - 1, y: oldY } : { x: oldX, y: oldY - 1 }, // Left or up
                                direction === 'front' || direction === 'back' ? { x: oldX + 1, y: oldY } : { x: oldX, y: oldY + 1 }  // Right or down
                            ];
                            for (let i = 0; i < adjacent.length; i++) {
                                const adjX = adjacent[i].x;
                                const adjY = adjacent[i].y;
                                //console.log(`Adjacent push ${i+1}: position=(${adjX}, ${adjY}), tile=${adjX >= 0 && adjX < W && adjY >= 0 && adjY < H ? map[adjY][adjX] : 'out of bounds'}`);
                                if (
                                    adjX >= 0 && adjX < W &&
                                    adjY >= 0 && adjY < H &&
                                    map[adjY][adjX] !== 1 && // Not a wall
                                    map[adjY][adjX] !== 6 // Not a hole
                                ) {
                                    pushX = adjX;
                                    pushY = adjY;
                                    validPosition = true;
                                    //console.log(`Valid adjacent push position found at (${pushX}, ${pushY})`);
                                    break;
                                }
                            }
                        }
                    }

                    // Final check to ensure player doesn't land on hole
                    if (validPosition && pushX >= 0 && pushX < W && pushY >= 0 && pushY < H && map[pushY][pushX] === 6) {
                        //console.log(`Error: Final position is a hole at (${pushX}, ${pushY}); resetting to invalid`);
                        validPosition = false;
                    }

                    if (!validPosition) {
                        console.log(`No valid position found; player may be stuck at (${pushX}, ${pushY}), tile=${pushX >= 0 && pushX < W && pushY >= 0 && pushY < H ? map[pushY][pushX] : 'out of bounds'}`);
                    }

                    // Update player position if valid
                    if (validPosition) {
p.x = pushX;
p.y = pushY;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
needsRedraw = true;
                    } else {
                        // Fallback: keep player at original position if no valid move
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;

needsRedraw = true;
return;
                    }

                    // Reset falling flag and animation state
                    p.isFalling = false;
                    p.anim.frameIndex = 0; // Reset to first frame
                    p.anim.direction = direction; // Restore original direction
                    // ⬅️ UNBLOCK INPUT HERE
                    setTimeout(() => {
                        inputBlocked = false;
                    }, 200); // Small delay to ensure smooth transition
                    needsRedraw = true;
                }
            }
            // Ensure we reset to first frame before starting animation
            p.anim.frameIndex = 0;
            animateFall();
            return; // Exit move early to prevent further movement
        }


// Add this after the stairs logic in move function:
if (exit && p.x === exit.x && p.y === exit.y && !inHideout) { // ← Removed !inPuzzleRoom check (puzzle room now uses same stairs)
    // clear console log for each stage to keep it from blowing up
    console.clear()
    // NEW: make sure the scroll flag is reset for the next floor
    scrollDroppedThisFloor = false;
    sounds.stairs.play().catch(e => console.error('Stairs sound error:', e));
    if (p.immortal) {
        p.immortal = false;
        logBattleEvent(`Floor ${floor} - HODL immortality has worn off!`);
    }
   
    enemiesSpawnedThisFloor = 0;
            window.hugeShrimpSpawnedThisFloor = false; // reset for new floor
    uniqueMonstersSpawnedThisFloor = 0; // Reset unique monster spawn counter
    initialSpawnDoneThisFloor = false;
    enemies = [];
   
    // ← Removed the old inPuzzleRoom return logic — we now always go to next floor
    // (finishPuzzleRoom() already set inPuzzleRoom = false and placed stairs)

    // Save rainy ruins state before floor advance (puzzle exit case)
    let tempSavedRain = null;
    if (currentTheme === 'ruins' && ruinsRainActive) {
        tempSavedRain = {
            active: true,
            angle: ruinsRainAngle,
            drops: raindrops.map(d => ({ ...d })),
            splashes: floorSplashes.map(s => ({ ...s }))
        };
    }
   
    floor++;
    
    // CRITICAL: FULL WAVE & ENEMY RESET — this fixes dead Floor 2 after puzzle
    wave = 1;
    document.getElementById('wave').textContent = wave;
    waveActive = false;
    initialWaveSpawned = false;
    initialSpawnDoneThisFloor = false;
    enemiesSpawnedThisFloor = 0;
            window.hugeShrimpSpawnedThisFloor = false; // reset for new floor
    uniqueMonstersSpawnedThisFloor = 0;
    whalesSpawnedThisFloor = 0;
    enemies = [];
    exit = null;  // Let placeStairs() work normally on new floor

    // Build soul resonance +2% per floor (every 50 floors, max 100%)
    soulResonance = Math.min(100, soulResonance + 2);
    resonanceTriggeredThisRun = false; // Reset for new run
    logBattleEvent(`Floor ${floor} - Soul Resonance: ${soulResonance}%`); // Optional subtle log
    
    // Spawn wisp on floor 3
    if (floor === 3 && wisps.length === 0) {
    
        // DEBUG wisp
        //const wispType = WISP_TYPES[0]; // COLD wisp (index 0), FIRE wisp (index 1) etc ..
        const wispType = WISP_TYPES[Math.floor(Math.random() * WISP_TYPES.length)];
        wisps.push({
            x: p.x, y: p.y,
            currentX: p.x * S, currentY: p.y * S,
            hp: Math.floor(p.hp / 2), maxHP: Math.floor(p.maxHP / 2),
            type: wispType,
            attackCounter: 0,
            targetTileX: p.x, targetTileY: p.y,
            deltaX: 0, deltaY: 0, stepsLeft: 0, moving: false,
            anim: { frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 }, // Cycle every 200ms
            lastPos: null
        });
        logBattleEvent(`Floor ${floor} - A loyal wisp companion appears!`);
        const floorIndicator = document.getElementById('floor-indicator');
        // Triple wisp spawn chime (staggered for audibility)
        playWebAudioSound(sounds.pickup);
        setTimeout(() => playWebAudioSound(sounds.pickup), 100);
        setTimeout(() => playWebAudioSound(sounds.pickup), 200);
        floorIndicator.textContent = `Floor ${floor} - Wisp joined!`;
        talkSpeak(10); //'hello you , go go go'
        wispPromptTimeout = setTimeout(() => {
            floorIndicator.textContent = `Floor ${floor}`;
        }, 3000);
    }
   
    p.shrineUsedThisFloor = false; // Reset shrine flag for new floor
    initialWaveSpawned = false;
    waveActive = false;
    exit = null;
    killsLog = [];
    battleLog = []; // Clear battleLog to prevent memory buildup
   
    // Reset special sound tracking for the new floor
    specialSoundsPlayedThisFloor.lava = false;
    specialSoundsPlayedThisFloor.quicksand = false;
    specialSoundsPlayedThisFloor.pond = false;
    specialSoundsPlayedThisFloor.rune = false;
    specialSoundsPlayedThisFloor.hole = false;
   
    // Reset runewords to allow reactivation on new floor
    p.runewords = [];
    
catPos = null;
catVisible = false;
    
    // Clear runeDrops specific runes to prevent stale entries
    runeDrops = runeDrops.filter(r => !r.specific);
   
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
   
    // Reset attack to base value before new floor (accounts for diamond hand)
    p.atk = p.hasDiamondHand ? 3 : 2;

    initMap();

    // === RESTORE RAINY RUINS AFTER PUZZLE EXIT ===
    if (previousFloorState && previousFloorState.savedRuinsRain) {
        ruinsRainActive = true;
        ruinsRainAngle = previousFloorState.savedRuinsRain.angle;
        raindrops = previousFloorState.savedRuinsRain.drops.map(d => ({ ...d }));
        floorSplashes = previousFloorState.savedRuinsRain.splashes.map(s => ({ ...s }));
        startRainAmbience();

        // Clear saved state so it doesn't leak to unrelated floors
        previousFloorState.savedRuinsRain = null;
    }

    puzzleCurrentLayout = null;
    isFetchingTxs = false; // ← THIS IS THE FIX – clears the stuck flag!
    nextApiCallTime = null;
    deadWispCorpse = null; // Clear wisp corpse on floor transition
   
    // Show runeword message if active, otherwise show theme name for 3 s then revert to floor number
    const floorIndicator = document.getElementById('floor-indicator');
    if (themeTimeoutId) clearTimeout(themeTimeoutId); // cancel any old timer
   
    // Check if any runewords are active
    const hasActiveRunewords = p.runewords.length > 0;
   
    if (hasActiveRunewords) {
        // Show runeword message with the whole rune part in uppercase
        const uppercasedRunewords = p.runewords.map(r => r.toUpperCase());
        floorIndicator.textContent = `Runeword${uppercasedRunewords.length > 1 ? 's' : ''} ${uppercasedRunewords.join(', ')} found!`;
        themeTimeoutId = setTimeout(() => {
            floorIndicator.textContent = `Floor ${floor}`;
            themeTimeoutId = null;
        }, 5000);
    } else {
        // Show theme name for 3 s, then revert to floor number
        const themeName = currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1);
        floorIndicator.textContent = themeName; // show theme
        themeTimeoutId = setTimeout(() => { // after 3 s …
            floorIndicator.textContent = `Floor ${floor}`; // revert
            themeTimeoutId = null;
        }, 3000);
    }
   
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value = '';
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
   
    // Immediately trigger fetchTxs after floor transition
    if (!gameOver && !splashActive && floor > 0) {
        fetchTxs();
        console.log(`Triggered fetchTxs for wave ${wave} on floor ${floor}`);
    }
   
    // Add proper exit handling to prevent teleportation issues
    return; // This is CRUCIAL - stops further execution after exit
}

        // In move function - before calling fetchTxs
        // Town Portal
if (map[ny][nx] === 12 && !inHideout) {
    playWebAudioSound(sounds.town_portal);

    // Save rainy ruins state before leaving
    if (currentTheme === 'ruins' && ruinsRainActive) {
        previousFloorState.savedRuinsRain = {
            active: true,
            angle: ruinsRainAngle,
            drops: raindrops.map(d => ({ ...d })),
            splashes: floorSplashes.map(s => ({ ...s }))
        };
    } else {
        previousFloorState.savedRuinsRain = null;
    }

    inHideout = true;
    
catPos = null;
catVisible = false;
sandworm = null;
    
    initMap();  // this actually switches to hideout map/theme
    sandwormBurrowPaused = true; // pause burrow in hideout
    needsRedraw = true;  // force immediate redraw
    return;
}
// Puzzle Portal — Enter the trial!
if (map[ny][nx] === 25) {
    const portal = portals.find(p => p.x === nx && p.y === ny && p.type === 'puzzle');
    if (portal) {
        playWebAudioSound(sounds.secret);

        // Save position + theme
        puzzleReturnPos = { x: p.x, y: p.y };
        puzzlePreviousTheme = currentTheme;

        // Save rainy ruins state
        if (currentTheme === 'ruins' && ruinsRainActive) {
            previousFloorState.savedRuinsRain = {
                active: true,
                angle: ruinsRainAngle,
                drops: raindrops.map(d => ({ ...d })),
                splashes: floorSplashes.map(s => ({ ...s }))
            };
        } else {
            previousFloorState.savedRuinsRain = null;
        }

        logBattleEvent("You step into the shimmering rift... a sacred trial begins!");
        sandwormBurrowPaused = true; // pause burrow while in puzzle
        startPuzzleRoom();
        return;
    }
}

        if (map[ny][nx] === 16 && inHideout) {
            playWebAudioSound(sounds.town_portal);
            if (previousFloorState) {
                // Restore previous floor state
                map = previousFloorState.map.map(row => [...row]);
                enemies = previousFloorState.enemies.map(e => ({ ...e, type: { ...e.type } }));
                rooms = previousFloorState.rooms.map(r => ({ ...r }));
                exit = previousFloorState.exit ? { ...previousFloorState.exit } : null;
                satoshiDrops = [...previousFloorState.satoshiDrops];
                runeDrops = [...previousFloorState.runeDrops];
                scrollDrops = [...previousFloorState.scrollDrops];
                portals = previousFloorState.portals.map(p => ({ ...p }));
                floor = previousFloorState.floor;
                wave = previousFloorState.wave;
                enemiesSpawnedThisFloor = previousFloorState.enemiesSpawnedThisFloor;
                whalesSpawnedThisFloor = previousFloorState.whalesSpawnedThisFloor;
                initialSpawnDoneThisFloor = previousFloorState.initialSpawnDoneThisFloor;
                initialWaveSpawned = previousFloorState.initialWaveSpawned;
                waveActive = previousFloorState.waveActive;
currentTheme = previousFloorState.currentTheme;
updateSnowState();

        // Restore rainy ruins if saved before hideout
        if (previousFloorState.savedRuinsRain) {
            ruinsRainActive = true;
            ruinsRainAngle = previousFloorState.savedRuinsRain.angle;
            raindrops = previousFloorState.savedRuinsRain.drops.map(d => ({ ...d }));
            floorSplashes = previousFloorState.savedRuinsRain.splashes.map(s => ({ ...s }));
            startRainAmbience();
            previousFloorState.savedRuinsRain = null;  // prevent leak
        }

fogMap = previousFloorState.fogMap.map(row => [...row]);  // ← Add this line
const portal = previousFloorState.portals.find(p => p.x !== undefined && p.y !== undefined);
p.x = portal ? portal.x : 2;
p.y = portal ? portal.y : 2;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;

inHideout = false;

// Restart ambience if returning to regular hell
    if (currentTheme === 'hell' && !snowyHellActive) {
        startFireplaceAmbience();
    }

document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
updateFogMap(p.x, p.y);
needsRedraw = true;
logBattleEvent(`Floor ${floor} - Returned from hideout via waypoint!`);
sandwormBurrowPaused = false; // resume burrow on normal floors
                document.documentElement.style.setProperty('--text-color', currentTheme === 'hell' ? '#00ff00' : '#ff8c00');
                document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                    el.style.color = currentTheme === 'hell' ? '#00ff00' : '#ff8c00';
                });
                return;
            } else {
                inHideout = false;
                initMap();
                portals = [{ x: p.x, y: p.y, frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 }];
                map[p.y][p.x] = 12;
                logBattleEvent(`Floor ${floor} - Returned to a new floor via waypoint!`);
                document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
                needsRedraw = true;
                document.documentElement.style.setProperty('--text-color', currentTheme === 'hell' ? '#00ff00' : '#ff8c00');
                document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                    el.style.color = currentTheme === 'hell' ? '#00ff00' : '#ff8c00';
                });
                return;
            }
        }

if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}

const bountyTile = 32;
const onBounty = map[p.y][p.x] === bountyTile && inHideout;

if (onBounty && !bountyBoardActive) {
    // Create/reuse overlay
    let overlay = document.getElementById('bounty-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'bounty-overlay';
        overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:1000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:"VT323",monospace;color:#ff8c00;pointer-events:none;';
        document.body.appendChild(overlay);
    }
    let content = document.getElementById('bounty-content');
    if (!content) {
        content = document.createElement('div');
        content.id = 'bounty-content';
        content.style.cssText = 'width:90%;max-width:800px;height:80%;background:rgba(17,17,17,0.95);border:4px solid #ff8c00;padding:20px;box-sizing:border-box;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;';
        overlay.appendChild(content);
    }

    // Build HTML
    let html = `<div style="margin:10px 0;"></div>`;
    html += `<h2 style="font-size:clamp(32px, 8vw, 48px);color:#ff4444;margin:0 0 20px 0;">Most Wanted:</h2>`;
    let bountyText = window.currentBounty.name;
    if (window.seenBountyTypes?.includes(window.currentBounty.type)) {
        bountyText += ' (cousin)';
    }
    html += `<p style="font-size:clamp(28px, 7vw, 42px);color:#ff4444;margin:0 0 20px 0;font-weight:bold;">${bountyText}</p>`;
    html += `<p style="font-size:clamp(20px, 5vw, 28px);color:#ff4444;">Reward: Slay and get paid in BTC!</p>`;
    html += `<div style="margin:10px 0;"></div>`;
    html += `<h2 style="font-size:clamp(32px, 8vw, 48px);margin:0 0 20px 0;">Side Quest</h2>`;
    if (window.currentSideQuest) {
        html += `<p style="font-size:clamp(24px, 6vw, 36px);color:#ff8c00;margin:10px 0;">Slay ${window.currentSideQuest.quota} ${window.currentSideQuest.type}s</p>`;
        html += `<p style="font-size:clamp(22px, 5.5vw, 32px);color:#ff8c00;margin:10px 0;">Progress: ${window.currentSideQuest.progress}/${window.currentSideQuest.quota}</p>`;
        html += `<p style="font-size:clamp(20px, 5vw, 28px);color:#ff8c00;margin-top:15px;">Reward: Elixir</p>`;
    } else {
        html += `<p style="font-size:clamp(20px, 5vw, 28px);color:#888;">No active side quest</p>`;
    }
    content.innerHTML = html;

    // Show overlay
    overlay.style.display = 'flex';
    overlay.offsetHeight;
    overlay.classList.add('visible');

    // Start 0.5s grace period (blocks taps + movement) .. we are borrowing this from the info board
    infoGracePeriod = true;
    overlay.style.pointerEvents = 'none';

    setTimeout(() => {
        infoGracePeriod = false; // Unlock movement .. we are borrowing this from the info board
        overlay.style.pointerEvents = 'auto'; // Allow intentional tap close

        // Optional intentional tap close after grace
        const closeBounty = () => {
            overlay.style.display = 'none';
            overlay.classList.remove('visible');
            overlay.onclick = null;
            overlay.ontouchend = null;
            bountyBoardActive = false;
            needsRedraw = true;
        };
        overlay.onclick = closeBounty;
        overlay.ontouchend = closeBounty;
    }, 500);

    bountyBoardActive = true;
    needsRedraw = true;
    logBattleEvent(`Bounty Board: Most Wanted - ${window.currentBounty.name} (${window.currentBounty.type})`);
} else if (!onBounty && bountyBoardActive) {
    // Hide when stepping off
    const overlay = document.getElementById('bounty-overlay');
    if (overlay) {
        overlay.style.display = 'none';
        overlay.classList.remove('visible');
    }
    bountyBoardActive = false;
    needsRedraw = true;
    logBattleEvent('Bounty Board inspected');
}

// Handle soul stash interaction
if (map[ny][nx] === 19 && !inHideout) { // Soul stash tile
    // Lock player movement while in terminal
    inputBlocked = true;
    // Store the exact position of the soul stash for proper positioning
    const stashX = nx;
    const stashY = ny;
    openSoulTerminal();
    return;
}

// In the move function, add shrine pickup logic:
if (map[ny][nx] === 22 && !inHideout) { // Shrine tile
    if (!p.shrineUsedThisFloor) {
        p.shrineCharges = 24; // Give 24 charges immediately
        p.shrineUsedThisFloor = true; // Mark that shrine was used on this floor
        logBattleEvent(`Floor ${floor} - Shrine charges activated!`);
        playWebAudioSound(sounds.pond);
    } else {
        logBattleEvent(`Floor ${floor} - Shrine already used this floor!`);
    }
}

if (map[ny][nx] === 27 && inPuzzleRoom && farmSpot && farmSpot.x === nx && farmSpot.y === ny) {
    const rawSats = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
if (!p.farmLocked) {
    // Can only plant if player has at least 1 Cool ROI
    if (p.coolROI < 1) {
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Farm: Need Mask of ROI!`;
        setTimeout(() => floorIndicator.textContent = `Floor ${floor}`, 3000);
        logBattleEvent(`Floor ${floor} - Farm locked — find an ancient Mask of ROI first!`);
        return;
    }

    // PLANT: First visit – take half the sats, lock the rest
    const halfSats = Math.floor(rawSats / 2);
    p.farmLockedSats = halfSats;           // store the locked half
    // Zero current sats and give player the other half immediately
    Object.keys(satsEarned).forEach(key => satsEarned[key] = 0);
    if (halfSats > 0) {
        satsEarned.Farm = (satsEarned.Farm || 0) + halfSats;
    }
    updateSatsDisplay();
    p.farmLocked = true;
    p.farmLockedFloor = floor;
    logBattleEvent(`Floor ${floor} - BTC planted! Half kept, half locked. Return later for 2× total.`);
    playWebAudioSound(sounds.pickup);
    // Graphics handled on room entry — no redraw here
} else {
    // REVISIT: Check if on a different floor than when planted
    if (floor === p.farmLockedFloor) {
        // Same floor → blocked
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Farm: Come back later!`;
        setTimeout(() => floorIndicator.textContent = `Floor ${floor}`, 3000);
        logBattleEvent(`Floor ${floor} - Farm not ready yet — visit on a different floor.`);
        return;
    }

    // Different floor → mature and harvest
    // Real fee: start at 49% with 1 Cool ROI, reduce 1% per Cool ROI, never below 25%
    let feePercent = 49 - (p.coolROI - 1) * 1; // 49% at 1 ROI, 48% at 2, etc.
    feePercent = Math.max(25, feePercent); // cap at minimum 25%
    const multiplier = (100 - feePercent) / 100; // e.g., 25% fee → 0.75x harvest
    const harvest = Math.floor(p.farmLockedSats * 2 * multiplier);
    satsEarned.Farm = (satsEarned.Farm || 0) + harvest;
    const floorIndicator = document.getElementById('floor-indicator');
    // Show ROI: BTC if ≥ 100,000 sats (0.001 BTC), else sats
    const btc = harvest / 100000000;
    const displayText = harvest >= 100000 ? `ROI: ${btc.toFixed(3)} BTC` : `ROI: ${harvest} sats`;
    floorIndicator.textContent = displayText;
    setTimeout(() => floorIndicator.textContent = `Floor ${floor}`, 3000);
    logBattleEvent(`Floor ${floor} - Farm matured! +${harvest} sats (fee ${feePercent}%)`);
    playWebAudioSound(sounds.pickup);
    updateSatsDisplay();

    // Immediately switch matured farmSpot2 → empty farmSpot1 (dirt) in real-time
    if (puzzleStaticCtx) {
        puzzleStaticCtx.drawImage(assets.farmSpot1, nx * S, ny * S, S, S);
    }

    // Reset farm state
    p.farmLocked = false;
    p.farmLockedFloor = 0;
    p.farmLockedSats = 0;
    p.farmROI = 0;
}
    // Allow player to stand on the tile
    return;
}

// Cool ROI pickup
if (map[ny][nx] === 30) {
    p.coolROI++;
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Floor ${floor} - An ancient Mask of ROI collected! (${p.coolROI} total)`);
    // If we have an active farm, automatically place one if possible
    if (p.farmLocked && p.farmROI === undefined) p.farmROI = 0; // init if needed
    if (p.farmLocked) p.farmROI++;
    updatePlayerState();
    needsRedraw = true;
    return;
}

if (map[ny][nx] === 33) {
    p.hp += 24;
    p.soulStormCharges = Math.min(256, p.soulStormCharges + 256);
    logBattleEvent(`Elixir consumed! +24 HP and +256 Soul Charges`);
    playWebAudioSound(sounds.pickup);
    map[ny][nx] = 0;
    if (wisps.length > 0) {
        talkSpeak(16); // 'cool., Ealixyr from bounty'
    }
    updatePlayerState();
    needsRedraw = true;
}

if (map[ny][nx] === 35) { // Jester shrine
    logBattleEvent(`Jester's Shrine activated! 5 Jesters appear!`);
    playJesterManiacalLaughter();

const floorIndicator = document.getElementById('floor-indicator');
floorIndicator.textContent = `Maniacal laughter echoes...`;
setTimeout(() => {
    floorIndicator.textContent = `Floor ${floor}`;
}, 5000);

    const jesterType = types.find(t => t.name === 'Jester');
    if (jesterType) {
        for (let i = 0; i < 5; i++) {
            let attempts = 100; // more attempts for better placement
            let jx, jy;
            while (attempts--) {
                jx = Math.floor(Math.random() * W);
                jy = Math.floor(Math.random() * H);

                // Better validation: floor tile, not player, not occupied, some distance
                const distFromPlayer = Math.abs(jx - p.x) + Math.abs(jy - p.y);
                if (map[jy][jx] === 0 &&
                    !(jx === p.x && jy === p.y) &&
                    !enemies.some(e => e.x === jx && e.y === jy) &&
                    distFromPlayer > 3 && distFromPlayer < 12) { // avoid too close/far
                    const jester = {
                        x: jx, y: jy,
                        currentX: jx * S, currentY: jy * S,
                        type: jesterType,
                        hp: 10,
                        atk: 2,
                        move: 1,
                        isJester: true,
                        fleeing: false,
                        sats: 0, // No sats
                        uniqueName: 'Jester', // Treat as unique for fog invisibility
                        anim: {
                            frames: assets.jester_frames,
                            frameIndex: Math.floor(Math.random() * 3), // random start frame
                            lastFrameTime: performance.now()
                        }
                    };
                    enemies.push(jester);
                    break;
                }
            }
        }
    }

    map[ny][nx] = 0; // remove shrine after activation
    needsRedraw = true;
}

// Updated info sign block in move()
const infoSignTile = 34;
const onInfoSign = map[p.y][p.x] === infoSignTile;

if (onInfoSign && !infoSignActive) {
    // Show the info board
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block';
    splashScreen.style.zIndex = '60';

    // Hide UI elements
    document.getElementById('start-button').style.display = 'none';
    document.getElementById('info-icon').style.display = 'none';

    currentSplashImage = 'info_tile.png';
    splashImg.src = currentSplashImage;
    splashCanvas.clearRect(0, 0, 320, 320);
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);

    // Start 0.5s grace period (blocks movement + taps)
    infoGracePeriod = true;
    splashScreen.style.pointerEvents = 'none';

    setTimeout(() => {
        infoGracePeriod = false; // Unlock movement
        splashScreen.style.pointerEvents = 'auto'; // Allow taps

        const closeInfoBoard = () => {
            splashScreen.style.display = 'none';
            if (!splashActive) {
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('info-icon').style.display = 'flex';
            }
            infoSignActive = false;
            needsRedraw = true;

            // Cleanup
            splashScreen.onclick = null;
            splashScreen.ontouchend = null;
            document.removeEventListener('keydown', keyClose);
        };

        // Intentional close handlers
        splashScreen.onclick = closeInfoBoard;
        splashScreen.ontouchend = closeInfoBoard;

        const keyClose = e => {
            if (['Enter', ' '].includes(e.key)) {
                e.preventDefault();
                closeInfoBoard();
            }
        };
        document.addEventListener('keydown', keyClose, { once: true });
    }, 500);

    infoSignActive = true;
    needsRedraw = true;
    logBattleEvent('Info Board inspected');
} else if (!onInfoSign && infoSignActive) {
    // Hide when stepping off
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'none';

    if (!splashActive) {
        document.getElementById('start-button').style.display = 'block';
        document.getElementById('info-icon').style.display = 'flex';
    }

    infoSignActive = false;
    needsRedraw = true;
}


// 3.)
// PASSIVE TREE -- CONTINUE FROM MIDDLE
//

// Passive tree open/close logic (in move())
const passiveSignTile = 36;
const onPassiveSign = map[p.y][p.x] === passiveSignTile;

if (onPassiveSign && !passiveTreeActive) {
    // Show splash-screen for background
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block';
    splashScreen.style.zIndex = '60';

    // Hide UI elements
    document.getElementById('start-button').style.display = 'none';
    document.getElementById('info-icon').style.display = 'none';

    // Load and draw passive background
    currentSplashImage = 'passive_tree_background.png';
    splashImg.src = currentSplashImage;
    splashCanvas.clearRect(0, 0, 320, 320);
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);

    // Open terminal (sets flags, shows overlay, focuses input)
    openPassiveTerminal();

    // Get input reference once (now available after openPassiveTerminal)
    const input = document.getElementById('passive-input');

    // Block movement + grace period
    inputBlocked = true;
    passiveGracePeriod = true;
    splashScreen.style.pointerEvents = 'none';

    setTimeout(() => {
        passiveGracePeriod = false;
        splashScreen.style.pointerEvents = 'auto';

        // Ensure focus (redundant but safe)
        input.focus();

        // Close handler
        const closePassiveBoard = () => {
            splashScreen.style.display = 'none';
            document.getElementById('passive-terminal-overlay').style.display = 'none';
            if (!splashActive) {
                document.getElementById('start-button').style.display = 'block';
                document.getElementById('info-icon').style.display = 'flex';
            }
            passiveTreeActive = false;
            needsRedraw = true;

            splashScreen.onclick = null;
            splashScreen.ontouchend = null;
            document.removeEventListener('keydown', keyClose);

            // Clean close
            closePassiveTerminal();
        };

        //splashScreen.onclick = closePassiveBoard;
        //splashScreen.ontouchend = closePassiveBoard;

        const keyClose = e => {
            if (['Enter', ' '].includes(e.key)) {
                e.preventDefault();
                closePassiveBoard();
            }
        };
        document.addEventListener('keydown', keyClose, { once: true });

        // Command handler (now input is defined)
const processCommand = (e) => {
    if (e.key === 'Enter') {
        e.preventDefault();
        const cmd = input.value.trim();
        input.value = ''; // Clear input immediately
        
        // Echo command
        //addPassiveLineToContent(`> ${cmd}`);
        
        if (cmd === '') return; // Skip empty
        
        if (cmd.toLowerCase() === 'exit') {
            closePassiveBoard();
            return;
        }
        
        processPassiveCommand(cmd);
    }
};
        input.addEventListener('keydown', processCommand);
        console.log('Enter pressed, command:', input.value);

    }, 500);

    passiveTreeActive = true;
    needsRedraw = true;
    logBattleEvent('Passive Tree accessed');
} else if (!onPassiveSign && passiveTreeActive) {
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'none';
    document.getElementById('passive-terminal-overlay').style.display = 'none';
    if (!splashActive) {
        document.getElementById('start-button').style.display = 'block';
        document.getElementById('info-icon').style.display = 'flex';
    }
    passiveTreeActive = false;
    needsRedraw = true;
}

// Process commands
function processPassiveCommand(command) {
    const trimmed = command.trim();
    
    if (trimmed === '') {
        addPassiveLineToContent('> '); // Echo empty line
        return;
    }
    
    addPassiveLineToContent(`> ${trimmed}`); // Echo command
    
    const parts = trimmed.split(/\s+/);
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1);
    
    // Short to full gem mapping
    const gemMap = {
        r: 'ruby',
        s: 'sapphire',
        e: 'emerald',
        c: 'citrine'
    };
    
    // Resolve gem name (short or full)
    let gem = cmd;
    if (gemMap[cmd]) {
        gem = gemMap[cmd];
    }
    if (!['ruby', 'sapphire', 'emerald', 'citrine'].includes(gem)) {
        // Not a gem command — handle other commands
        
    // Declare content ONCE here (shared across cases)
    const content = document.getElementById('passive-terminal-content');
        
        switch (cmd) {
            case 'skills':
            content.innerHTML = '';
            // Display gems/bonuses (mimic soul inventory structure)
            addPassiveLineToContent('--- Gemstones Inventory ---');
            addPassiveLineToContent(`Ruby: ${p.gems.ruby}`);
            addPassiveLineToContent(`Citrine: ${p.gems.citrine}`);
            addPassiveLineToContent(`Sapphire: ${p.gems.sapphire}`);
            addPassiveLineToContent(`Emerald: ${p.gems.emerald}`);
            addPassiveLineToContent('Enchant Diamond Hand, (attack+):');
            addPassiveLineToContent('  r atk - Trade rubys,         fire atk');
            addPassiveLineToContent('  c atk - Trade citrines, lightning atk');
            addPassiveLineToContent('  s atk - Trade sapphires,     cold atk');
            addPassiveLineToContent('  e atk - Trade emeralds,     earth atk');
            addPassiveLineToContent('Debuff enemies, (enemy defense-):');
            addPassiveLineToContent('  r def - Trade rubys, shrimp/crab def');
            addPassiveLineToContent('  c def - Trade citrines,    squid def');
            addPassiveLineToContent('  s def - Trade sapphires, dolphin def');
            addPassiveLineToContent('  e def - Trade emeralds,    shark def');
                addPassiveLineToContent('_____________________');
                addPassiveLineToContent('Type "help" for help.');
                break;
        
            case 'help':
            content.innerHTML = '';
            addPassiveLineToContent('Tree Terminal ver 0.9');
            addPassiveLineToContent('Available commands:');
            addPassiveLineToContent('  skills - Enchants and debuffs');
            addPassiveLineToContent('  ls ----- View current gems & bonuses');
            addPassiveLineToContent('  clear -- Clear screen');
            addPassiveLineToContent('  exit --- Exit terminal');
                addPassiveLineToContent('_____________________');
                addPassiveLineToContent('Type "help" for help.');
                break;
                
            case 'ls':
                updatePassiveInventory(); // Show current state
                break;
                
            case 'clear':
                content.innerHTML = '';
                if (args.length > 0) {
                    const asciiText = args.join(' ');
                    addPassiveLineToContent(asciiText.padEnd(54));
                }
                break;
                
            case 'exit':
                // Handled by input handler
                break;
                
            default:
                content.innerHTML = '';
                addPassiveLineToContent(`Unknown command: ${cmd}`);
                addPassiveLineToContent('_____________________');
                addPassiveLineToContent('Type "help" for help.');
        }
        addPassiveLineToContent(''); // Spacer
        return;
    }
    
    // Gem command (r/s/e/c or full name + atk/def)
    if (args.length < 1) {
        addPassiveLineToContent(`Usage: ${cmd} atk [count] or ${cmd} def [count]`);
        addPassiveLineToContent('');
        return;
    }
    
    const type = args[0].toLowerCase();
    let count = 1;
    if (args.length > 1 && !isNaN(args[1])) {
        count = Math.max(1, parseInt(args[1]));
    }
    
    if (type !== 'atk' && type !== 'def') {
        addPassiveLineToContent(`Invalid type: use "atk" or "def"`);
        addPassiveLineToContent('');
        return;
    }
    
    if (p.gems[gem] < count) {
        addPassiveLineToContent(`Not enough ${gem}s (have ${p.gems[gem]}, need ${count})`);
        addPassiveLineToContent('');
        return;
    }
    
    // Spend gems
    p.gems[gem] -= count;
    
    if (type === 'atk') {
        // Elemental attack — NO CAP (only useful with Diamond Hand)
        switch (gem) {
            case 'ruby':     p.gemAtk.fire      += 0.1 * count; break;
            case 'sapphire': p.gemAtk.cold      += 0.1 * count; break;
            case 'emerald':  p.gemAtk.earth     += 0.1 * count; break;
            case 'citrine':  p.gemAtk.lightning += 0.1 * count; break;
        }
        addPassiveLineToContent(`Traded ${count} ${gem}(s) for +${(0.1 * count).toFixed(1)} elemental attack!`);
    } else {
        // Defense — WITH CAPS per enemy type
        let added = 0.1 * count;
        switch (gem) {
            case 'ruby':     // Shrimp/Crab def (cap -1.0 total reduction)
                const newDef = p.gemDef.shrimpCrab + added;
                p.gemDef.shrimpCrab = Math.min(newDef, 1.0);
                added = p.gemDef.shrimpCrab - (newDef - added); // actual added after cap
                addPassiveLineToContent(`Traded r -${(0.1 * count).toFixed(1)} shrimp/crab defense!`);
                break;
            case 'sapphire': // Dolphin def (cap -1.0)
                const newD = p.gemDef.dolphin + added;
                p.gemDef.dolphin = Math.min(newD, 1.0);
                addPassiveLineToContent(`Traded s for -${(0.1 * count).toFixed(1)} dolphin defense!`);
                break;
            case 'emerald':  // Shark def (cap -2.0)
                const newSh = p.gemDef.shark + added;
                p.gemDef.shark = Math.min(newSh, 2.0);
                addPassiveLineToContent(`Traded e for -${(0.1 * count).toFixed(1)} shark defense!`);
                break;
            case 'citrine':  // Squid def (cap -1.0)
                const newSq = p.gemDef.squid + added;
                p.gemDef.squid = Math.min(newSq, 1.0);
                addPassiveLineToContent(`Traded c for -${(0.1 * count).toFixed(1)} squid defense!`);
                break;
        }
        if (added < 0.1 * count) {
            addPassiveLineToContent(`Gemstone broke, debuff is maxed out!`);
            addPassiveLineToContent(`Notes:`);
            addPassiveLineToContent(`Max shrimp/crab defense debuff is -1.0 HP`);
            addPassiveLineToContent(`Max squid defense debuff is -1.0 HP`);
            addPassiveLineToContent(`Max dolphin defense debuff is -1.0 HP`);
            addPassiveLineToContent(`Max shark defense debuff is -2.0 HP`);            
        }
    }
    
    updatePlayerState(); // Refresh display
    addPassiveLineToContent(''); // Spacer
}

// Handle passive input (mimic handleTerminalInput)
function handlePassiveInput(e) {
    const key = e.key;
   
    // If terminal is not focused, focus it and add the key
    if (!document.activeElement.matches('#passive-input')) {
        const input = document.getElementById('passive-input');
        input.focus();
        input.value = p.passiveTerminalCommand; // Update value to reflect current command
       
        // Handle key press immediately
        if (key.length === 1 && key !== 'Enter') {
            const before = p.passiveTerminalCommand.slice(0, p.passiveTerminalCursorPos);
            const after = p.passiveTerminalCommand.slice(p.passiveTerminalCursorPos);
            p.passiveTerminalCommand = before + key + after;
            p.passiveTerminalCursorPos++;
            input.value = p.passiveTerminalCommand.substring(1); // One-liner hack to remove first character if needed (mimic soul if you have prompt hack)
        }
       
        return;
    }
   
    if (key === 'Enter') {
        e.preventDefault();
        processPassiveCommand(p.passiveTerminalCommand);
        p.passiveTerminalCommand = '';
        p.passiveTerminalCursorPos = 0;
        // Blur the input field when Enter is pressed
        const input = document.getElementById('passive-input');
        if (input) {
            input.blur();
        }
        return;
    }
   
    if (key === 'Backspace') {
        if (p.passiveTerminalCursorPos > 0) {
            p.passiveTerminalCommand =
                p.passiveTerminalCommand.slice(0, p.passiveTerminalCursorPos - 1) +
                p.passiveTerminalCommand.slice(p.passiveTerminalCursorPos);
            p.passiveTerminalCursorPos--;
        }
        return;
    }
   
    if (key === 'ArrowLeft' && p.passiveTerminalCursorPos > 0) {
        p.passiveTerminalCursorPos--;
        return;
    }
   
    if (key === 'ArrowRight' && p.passiveTerminalCursorPos < p.passiveTerminalCommand.length) {
        p.passiveTerminalCursorPos++;
        return;
    }
   
    // Add regular character
    if (key.length === 1 && key !== 'Enter') {
        const before = p.passiveTerminalCommand.slice(0, p.passiveTerminalCursorPos);
        const after = p.passiveTerminalCommand.slice(p.passiveTerminalCursorPos);
        p.passiveTerminalCommand = before + key + after;
        p.passiveTerminalCursorPos++;
    }
}

// Handle blurred passive input (mimic handleBlurredTerminalInput)
function handleBlurredPassiveInput(key) {
    const input = document.getElementById('passive-input');
    if (input && !input.matches(':focus')) {
        // Focus the input field
        input.focus();
       
        // Update command with new key
        const before = p.passiveTerminalCommand.slice(0, p.passiveTerminalCursorPos);
        const after = p.passiveTerminalCommand.slice(p.passiveTerminalCursorPos);
        p.passiveTerminalCommand = before + key + after;
        p.passiveTerminalCursorPos++;
       
        // Update display
        input.value = p.passiveTerminalCommand.substring(1); // Mimic soul's hack if you have it
    }
}

// 4.)
// PASSIVE TREE -- END
//

// Add soul orb statue interaction
if (map[ny][nx] === 21 && !inHideout) { // Soul orb statue tile
	// Check if player already collected from this statue on current floor
	const currentFloorStatueKey = `statue_${floor}_${nx}_${ny}`;
	if (!p.collectedFromStatue || !p.collectedFromStatue[currentFloorStatueKey]) {
		p.soulOrbs++;
		logBattleEvent(`Block 74638: You received 1 Soul Orb!`);
		if (!p.collectedFromStatue) {
			p.collectedFromStatue = {};
		}
		p.collectedFromStatue[currentFloorStatueKey] = true;
		//map[ny][nx] = 0; // Remove statue after collection
		playWebAudioSound(sounds.buzz);
		updatePlayerState();
	} else {
		logBattleEvent(`Block 74638: Seek the masked relics’ refuge, where souls gather.`);
		needsRedraw = true;
	}
	return;
}
        
if (map[ny][nx] === 20) { // Soul stone tile
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Floor ${floor} - Soul Stone collected!`);
    updatePlayerState();
}

        if (map[ny][nx] === 14 && inHideout) { // Jeweller
            if (diamonds >= 3) {
                diamonds -= 3;
                p.perfectlyCutDiamonds++;
                logBattleEvent(`Jeweller refined 3 diamonds into a Perfectly Cut Diamond!`);
                playWebAudioSound(sounds.pickup);
                updatePlayerState();
            } else {
                logBattleEvent(`Jeweller requires 3 diamonds to refine!`);
            }
        }
        
        if (map[ny][nx] === 15 && inHideout) { // Blacksmith
            if (p.perfectlyCutDiamonds >= 1 && !p.hasDiamondArmor) {
                p.perfectlyCutDiamonds--;
p.hasDiamondArmor = true;
p.hasArmor = false; // Remove regular armor
p.armorImmunity = null; // Reset previous armor immunity
const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
let available = elements.filter(el => el !== p.elementImmunity);
if (available.length > 0 && !p.curseActive) {
    p.armorImmunity = available[Math.floor(Math.random() * available.length)];
    logBattleEvent(`Floor ${floor} - Diamond Armor grants 100% ${p.armorImmunity} resistance!`);
}
                p.hp += 1000;
                logBattleEvent(`Blacksmith forged Diamond Armor! HP increased to ${p.hp}`);
                playWebAudioSound(sounds.pickup);
                updatePlayerState();
            } else if (p.hasDiamondArmor) {
                logBattleEvent(`Blacksmith: You already have Diamond Armor!`);
            } else {
                logBattleEvent(`Blacksmith requires a Perfectly Cut Diamond!`);
            }
        }

        if (map[ny][nx] === 17 && inHideout) { // Rune Whisperer
            if (p.runes.length > 0) {
                const runeCount = p.runes.length;
                const healthGain = runeCount * 2;
                p.hp += healthGain;
                p.runes = [];
                runeDrops = runeDrops.filter(r => !r.specific);
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        if (map[y][x] === 9) {
                            map[y][x] = 0; // Clear specific rune tiles
                        }
                    }
                }
                logBattleEvent(`Rune Whisperer traded ${runeCount} runes for +${healthGain} HP! (HP now: ${p.hp})`);
                playWebAudioSound(sounds.pickup);
                checkRunewords();
                updatePlayerState();
            } else {
                logBattleEvent(`Rune Whisperer: No runes to trade!`);
            }
        }

if (map[ny][nx] === 18 && inHideout) { // Hooded Heirloom
    // Player can turn in soul orbs here for 256 charges each
    if (p.soulOrbs > 0) {
        if (p.soulStormCharges >= 256) {
            logBattleEvent(`Hooded Heirloom: You already have the maximum 256 Soul Storm Charges!`);
        } else {
            p.soulOrbs--;
            const chargesToAdd = Math.min(256 - p.soulStormCharges, 256);
            p.soulStormCharges += chargesToAdd;
            logBattleEvent(`Hooded Heirloom: Received ${chargesToAdd} Soul Storm Charges!`);
            playWebAudioSound(sounds.pickup);
        }
    } else {
        logBattleEvent(`Hooded Heirloom: No Soul Orbs to trade!`);
    }
}

        if (map[ny][nx] === 8) {
            const rune = runeDrops.find(r => r.x === nx && r.y === ny);
            if (rune) {
                p.runes.push(rune.letter);
                map[ny][nx] = 9; // Specific rune image
                runeDrops = runeDrops.filter(r => r !== rune);
                runeDrops.push({ x: nx, y: ny, letter: rune.letter, specific: true }); // Mark as specific rune for drawing
                playWebAudioSound(sounds.pickup);
                logBattleEvent(`Floor ${floor} - Picked up Rune ${rune.letter.toUpperCase()}!`);
                
                // Show rune name in floor indicator when picking up rune
                const floorIndicator = document.getElementById('floor-indicator');
                floorIndicator.textContent = `Rune Found: ${rune.letter.toUpperCase()}`;
                setTimeout(() => {
                    if (!currentRuneTile || !(p.x === currentRuneTile.x && p.y === currentRuneTile.y)) {
                        floorIndicator.textContent = `Floor ${floor}`;
                    }
                }, 3000); // Reset after 3 seconds

                //checkRunewords();
                // Track that player is currently on a rune tile
                currentRuneTile = { x: nx, y: ny };
            }
        }

// Puzzle: Collect Heart Keys
if (inPuzzleRoom) {
    const heartIndex = puzzleHeartFramers.findIndex(h => h.x === p.x && h.y === p.y);
    if (heartIndex !== -1) {
        puzzleHeartFramers.splice(heartIndex, 1);
        playWebAudioSound(sounds.pickup);

        puzzleCollectedHearts++; // Increment collected

        logBattleEvent(`Heart Key ${puzzleCollectedHearts}/${puzzleTotalHearts} collected!`);
        needsRedraw = true;
    }

    // Step on chest when all hearts collected
    if (puzzleHeartFramers.length === 0 && puzzleChest && p.x === puzzleChest.x && p.y === puzzleChest.y) {
        finishPuzzleRoom();
    }
}

if (map[ny][nx] === 23) { // Cursed ring
    if (redMazeAuraGiven) {
        // Red Maze Aura destroys the ring – no pickup, no curse
        map[ny][nx] = 0;
        playWebAudioSound(sounds.hit); // strong feedback (or sounds.buzz if you prefer)
        logBattleEvent(`Floor ${floor} - Red Maze Aura destroys the cursed ring!`);
    } else if (p.hasCursedRing) {
        logBattleEvent(`Floor ${floor} - Cannot equip another Cursed Ring!`);
    } else {
        const originalHP = p.hp; // Store pre-halving HP for aura calc
        const oldMax = p.maxHP;
        p.maxHP = Math.floor(oldMax / 2);
        p.hp = Math.floor(p.hp / 2); // Halve current HP too
        p.auraMax = originalHP * 2; // Double original (pre-halving) HP for aura
        p.auraShield = p.auraMax;
        p.hasCursedRing = true;
        p.curseActive = true;  // Lingering curse effects
        p.elementImmunity = null;
        p.armorImmunity = null;
        p.hasArmor = false; // Remove armor
        p.hasDiamondArmor = false;
        map[ny][nx] = 0;
        playWebAudioSound(sounds.pickup);
        logBattleEvent(`Floor ${floor} - Cursed Ring equipped! HP ${p.hp}, Aura Shield: ${p.auraShield}`);
        updatePlayerState();
    }
}

if (map[p.y][p.x] === 28 && catPos && catPos.x === p.x && catPos.y === p.y) {
    p.soulStormCharges = 256;
    map[p.y][p.x] = 0;
    catPos = null;
    catVisible = false;
    catAnimStart = 0;
    playCatPurr();
    needsRedraw = true;
    logBattleEvent(`Floor ${floor} - Black cat blesses you! Soul charges maxed.`);
    updatePlayerState();
}

// Add the swap tile interaction code here
if (map[ny][nx] === 29) { // Swap tile
    // Handle weapon swapping
    if (p.currentWeapon === 'sword') {
        p.currentWeapon = 'satoshi_scourge';
        logBattleEvent('Satoshi\'s Scourge equipped');
    } else if (p.currentWeapon === 'satoshi_scourge') {
        p.currentWeapon = 'sword';
        logBattleEvent('Returned to sword');
    } else if (p.currentWeapon === 'soul_sword') {
        p.currentWeapon = 'sword';
        logBattleEvent('Soul Sword dismissed');
    }

    updatePlayerState();
    needsRedraw = true;
}

// Check for unique monster in fog of war
function checkUniqueMonsterInFog() {
    if (activeUniqueMonsterName) return;
    
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0 && !activeUniqueMonsterName) {
        const firstVisible = visibleUniqueMonsters[0];
        activeUniqueMonsterName = firstVisible.uniqueName;
        
        // Show unique monster name in floor indicator
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName === firstVisible.uniqueName) {
                activeUniqueMonsterName = null;
                const currentText = floorIndicator.textContent;
                if (currentText === activeUniqueMonsterName || 
                    currentText.includes(firstVisible.uniqueName)) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }
        }, 5000);
    }
}

// Check for unique monster in fog of war when moving
// Only check when we DON'T have an active unique monster name
if (!activeUniqueMonsterName) {
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0) {
        const firstVisible = visibleUniqueMonsters[0];
        activeUniqueMonsterName = firstVisible.uniqueName;
        
        // Show unique monster name in floor indicator
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName === firstVisible.uniqueName) {
                activeUniqueMonsterName = null;
                const currentText = floorIndicator.textContent;
                if (currentText === activeUniqueMonsterName || 
                    currentText.includes(firstVisible.uniqueName)) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }
        }, 5000);
    }
}

// Check for unique monster in fog of war
const uniqueMonstersInFog = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 0);

// Check if player moved from a rune tile
if (currentRuneTile && !(p.x === currentRuneTile.x && p.y === currentRuneTile.y)) {
    const floorIndicator = document.getElementById('floor-indicator');
    if (floorIndicator.textContent.startsWith("Rune Found:") || 
        floorIndicator.textContent.startsWith("Rune:")) {
        // Reset to normal floor text if leaving rune tile
        setTimeout(() => {
            // Double-check that player is still not on a rune tile before resetting
            const stillOnRuneTile = map[p.y][p.x] === 9 && 
                runeDrops.some(r => r.x === p.x && r.y === p.y && r.specific);
            
            if (!stillOnRuneTile) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 100); // Small delay to prevent flicker
    }
}

        // === ARROW TILES FORCE MOVEMENT ===
        if (inPuzzleRoom) {
            const arrow = puzzleArrows.find(a => a.x === p.x && a.y === p.y);
            if (arrow) {
                let dir = null;
                switch(arrow.dir) {
                    case 'right': dir = 'right'; break;
                    case 'left':  dir = 'left';  break;
                    case 'up':    dir = 'up';    break;
                    case 'down':  dir = 'down';  break;
                }
                if (dir) {
                    // Force move in arrow direction
                    move(dir);
                    return; // Prevent normal movement this frame
                }
            }
        }

        updateFogMap(p.x, p.y);
        
    // ——— ECHO WARDEN AWAKENS: First step on Floor 1 only ———
    if (floor === 1 && !p.echoWardenBlessingGiven) {
        p.hp += 100;
        p.maxHP += 100;
        p.echoWardenBlessingGiven = true;

        // 1. FLASH FIRST
        wardenFlashStart = Date.now();

// Force assign side quest at game start if missing
if (!window.currentSideQuest) {
    const questOptions = [
        {type: 'Shrimp', quota: 40},
        {type: 'Crab', quota: 20},
        {type: 'Squid', quota: 15},
        {type: 'Dolphin', quota: 10},
        {type: 'Shark', quota: 7},
        {type: 'Whale', quota: 3}
    ];

    let available = questOptions.filter(q => q.type !== window.lastSideQuestType);
    if (available.length === 0) available = questOptions;

    const chosen = available[Math.floor(Math.random() * available.length)];
    window.currentSideQuest = {
        type: chosen.type,
        quota: chosen.quota,
        progress: 0
    };

    //console.log('[DEBUG Startup] Side quest auto-assigned:', window.currentSideQuest);
}

        // 2. AXIS-PRIORITY SPAWN: Right → Left → Down → Up → Diagonals → Safety
        setTimeout(() => {
            const candidates = [
                // Cardinal directions (closest first)
                { x: p.x + 1, y: p.y },   // right
                { x: p.x - 1, y: p.y },   // left
                { x: p.x,     y: p.y + 1 }, // down
                { x: p.x,     y: p.y - 1 }, // up

                // Diagonals (next closest)
                { x: p.x + 1, y: p.y + 1 },
                { x: p.x + 1, y: p.y - 1 },
                { x: p.x - 1, y: p.y + 1 },
                { x: p.x - 1, y: p.y - 1 },

                // 2-step cardinals (if really cramped)
                { x: p.x + 2, y: p.y },
                { x: p.x - 2, y: p.y },
                { x: p.x,     y: p.y + 2 },
                { x: p.x,     y: p.y - 2 },
            ];

            let placed = false;
            for (const pos of candidates) {
                if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 0) {
                    echoWardenPos = { x: pos.x, y: pos.y, spawnTime: Date.now() };
echoWardenPos.currentX = echoWardenPos.x * S;
echoWardenPos.currentY = echoWardenPos.y * S;
echoWardenPos.moving = false;
echoWardenPos.stepsLeft = 0;
echoWardenPos.deltaX = 0;
echoWardenPos.deltaY = 0;
                    map[pos.y][pos.x] = 24;
                    placed = true;
                    break;
                }
            }

            // Final emergency fallback (should never trigger)
            if (!placed) {
                echoWardenPos = { x: p.x, y: p.y, spawnTime: Date.now() };
                map[p.y][p.x] = 24; // spawn on player if no space (dramatic!)
            }

            logBattleEvent(`Floor 1 - You take your first step...`);
        }, 0);

        // 3. Message + sound
        setTimeout(() => {
            logBattleEvent(`The Echo Warden awakens from the void! +100 HP granted forever!`);
            playWebAudioSound(sounds.pickup);
        }, 600);

        needsRedraw = true;
    }
        
    }
    
    moveEnemies();
updateWisps(); // Update wisp pos/attacks synced to player/enemy turns
applyEnsnare();    // Druid Ensnare (lvl 20+)
    updatePlayerState();
    
    // Check if player is standing on a rune tile (specifically placed rune)
    if (map[p.y][p.x] === 9) {
        const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
        if (rune) {
            const floorIndicator = document.getElementById('floor-indicator');
            // Show rune name when stepping on rune tile
            if (!floorIndicator.textContent.startsWith("Rune:")) {
                floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
            } else {
                // Update rune letter if it's different from what's currently displayed
                const currentRuneText = floorIndicator.textContent;
                const expectedRune = `Rune: ${rune.letter.toUpperCase()}`;
                if (currentRuneText !== expectedRune) {
                    floorIndicator.textContent = expectedRune;
                }
            }
            currentRuneTile = { x: p.x, y: p.y };
        }
    } else if (currentRuneTile && map[p.y][p.x] !== 9) {
        // Player moved away from rune tile
        const floorIndicator = document.getElementById('floor-indicator');
        if (floorIndicator.textContent.startsWith("Rune:")) {
            // Reset to floor text after a delay, but only if not currently on another rune tile
            setTimeout(() => {
                // Check again if player is now on a different rune tile
                const stillOnRuneTile = map[p.y][p.x] === 9 && 
                    runeDrops.some(r => r.x === p.x && r.y === p.y && r.specific);
                
                if (!stillOnRuneTile) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }, 100);
        }
    }
    
    needsRedraw = true;

}

function moveEnemies() {
    if (gameOver || splashActive) return;

    // Unique monster spells damage player even when standing still
    dangerousAreas.forEach(area => {
        if (area.x === p.x && area.y === p.y) {
            applySpellDamage(p.x, p.y);
        }
    });    

enemies.forEach(e => {
    e.playerPushedThisTurn = false; // reset push flag each turn


    // Dolphin push (one-time, smooth interpolated)
if (e.type.name === 'Dolphin' && !e.pushUsed && 
    Math.abs(e.x - p.x) + Math.abs(e.y - p.y) === 1 &&
    !e.frozen) {  // ← added: no push if frozen
    e.pushUsed = true;
    const pushX = p.x + (p.x - e.x); // opposite direction
    const pushY = p.y + (p.y - e.y);
    
    // Validate push path
    const dx = pushX - p.x;
    const dy = pushY - p.y;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    let valid = true;
    for (let i = 1; i <= steps; i++) {
        const checkX = Math.round(p.x + (dx / steps) * i);
        const checkY = Math.round(p.y + (dy / steps) * i);
        if (checkX < 0 || checkX >= W || checkY < 0 || checkY >= H || map[checkY][checkX] !== 0) {
            valid = false;
            break;
        }
    }
    
    if (valid) {
        // Start smooth push animation (same as huge shrimp)
        p.startX = p.x; p.startY = p.y;
        p.x = pushX; p.y = pushY;
        p.targetTileX = pushX; p.targetTileY = pushY;
        p.deltaX = (pushX - p.startX) * 2;
        p.deltaY = (pushY - p.startY) * 2;
        p.stepsLeft = 8;
        p.moving = true;
        p.moveStartTime = performance.now();
        p.moveDuration = 200;
        logBattleEvent(`Floor ${floor} - Dolphin pushes you away!`);
        needsRedraw = true;
    }
}
    
    if (e.frozen && e.frozenTurns > 0) {
        e.frozenTurns--;
        if (e.frozenTurns <= 0) e.frozen = false;
        return; // Skip move
    }
    let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
        if (dist <= 5) {
// Mark first time they see the player this turn
            if (!e.justSawPlayer && fogMap[e.y][e.x] === 1) {
                e.justSawPlayer = true;
            }
            let moves = e.type.move, steps = 0;
let startX = e.x, startY = e.y;
let finalX = e.x, finalY = e.y;
moves = e.type.move;
if (e.isHuge) moves = 2; // huge shrimp gets 2 moves (move + attack)
let numTileSteps = 0;
let tempDx = dx, tempDy = dy;
while (steps < moves) {
    let nx = finalX, ny = finalY;
    if (e.type.name === 'Crab') {
        nx += tempDx > 0 ? 1 : -1;
    } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
        if (Math.abs(tempDx) > Math.abs(tempDy)) nx += tempDx > 0 ? 1 : -1;
        else ny += tempDy > 0 ? 1 : -1;
    } else {
        if (Math.abs(tempDx) > Math.abs(tempDy)) nx += tempDx > 0 ? 1 : -1;
        else ny += tempDy > 0 ? 1 : -1;
    }
    if (
       nx >= 0 && nx < W && ny >= 0 && ny < H &&
       map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) &&
        !enemies.some(en => en.x === nx && en.y === ny && en !== e)
    ) {
        finalX = nx;
        finalY = ny;
        numTileSteps++;
    } else break;
    steps++;
    tempDx = p.x - finalX; tempDy = p.y - finalY;
}

if (e.type.name === 'Jester') {
    // Track previous HP for "on hit" vanish detection (self-contained)
    if (e.lastHp === undefined) e.lastHp = e.hp;

    // Jester logic (runs even if not visible — flee/buff can happen off-screen)
    const livingJesters = enemies.filter(en => en.type.name === 'Jester' && en.hp > 0).length;
    if (livingJesters === 1 && !e.fleeing) {
        e.fleeing = true;
        e.fleeStartTime = performance.now();
        logBattleEvent(`Last Jester flees in terror!`);
        if (!p.hasAcrobaticsBuff) {
            // Jester invisible in fog of war
            fogMap = Array(H).fill().map(() => Array(W).fill(0));
            playJesterManiacalLaughter();
            p.hasAcrobaticsBuff = true;
            logBattleEvent(`Jester's Acrobatics buff granted! 20% dodge chance.`);
            logBattleEvent(`Jester lurks in the shadows, ready to ambush.`);
        } else {
            logBattleEvent(`Jester's Acrobatics already active, no additional buff.`);
        }
    }

    if (e.fleeing) {
        // 50% chance to vanish when damaged this turn — ONLY while fleeing (panicked trickster)
        if (e.hp < e.lastHp && Math.random() < 0.50) {
            let attempts = 30;
            let found = false;
            while (attempts-- > 0) {
                const rx = Math.floor(Math.random() * W);
                const ry = Math.floor(Math.random() * H);
                if (map[ry][rx] === 0 &&
                    !enemies.some(en => en.x === rx && en.y === ry) &&
                    !(rx === p.x && ry === p.y) &&               // never on player
                    Math.abs(rx - p.x) + Math.abs(ry - p.y) >= 4) { // keep some distance
                    e.x = rx;
                    e.y = ry;
                    e.currentX = rx * S;
                    e.currentY = ry * S;
                    found = true;
                    break;
                }
            }

            if (found) {
                logBattleEvent(`The Jester cackles and vanishes in a puff of smoke!`);
                playJesterManiacalLaughter();
            }
        }

        // Flee fast (2 steps per turn) – original behavior preserved
        for (let step = 0; step < 2; step++) {
            const dirs = [{dx:-1,dy:0},{dx:1,dy:0},{dx:0,dy:-1},{dx:0,dy:1}];
            const playerDirX = p.x - e.x;
            const playerDirY = p.y - e.y;
            const awayDirs = dirs.filter(d => d.dx * playerDirX + d.dy * playerDirY <= 0);
            const chosen = awayDirs.length > 0 ? awayDirs[Math.floor(Math.random() * awayDirs.length)] : dirs[Math.floor(Math.random() * dirs.length)];

            const nx = e.x + chosen.dx;
            const ny = e.y + chosen.dy;

            // Collision check + NEVER step on player
            if (nx >= 0 && nx < W && ny >= 0 && ny < H &&
                map[ny][nx] === 0 &&
                !enemies.some(en => en.x === nx && en.y === ny && en !== e) &&
                !(nx === p.x && ny === p.y)) {  // ← prevents stepping on player

                e.x = nx;
                e.y = ny;
                e.currentX = nx * S;
                e.currentY = ny * S;
            }
        }
    } else {
        // Normal move toward player
        const dx = p.x - e.x;
        const dy = p.y - e.y;
        const dist = Math.abs(dx) + Math.abs(dy);
        if (dist > 1) {
            const nx = e.x + (dx > 0 ? 1 : (dx < 0 ? -1 : 0));
            const ny = e.y + (dy > 0 ? 1 : (dy < 0 ? -1 : 0));

            // Collision check + NEVER step on player
            if (nx >= 0 && nx < W && ny >= 0 && ny < H &&
                map[ny][nx] === 0 &&
                !enemies.some(en => en.x === nx && en.y === ny && en !== e) &&
                !(nx === p.x && ny === p.y)) {  // ← prevents stepping on player

                e.x = nx;
                e.y = ny;
                e.currentX = nx * S;
                e.currentY = ny * S;
            }
        }
    }

    // Update lastHp for next turn comparison
    e.lastHp = e.hp;
}

if (numTileSteps > 0) {
    const totalDeltaX = (finalX - startX) * S;
    const totalDeltaY = (finalY - startY) * S;
    const totalDistance = Math.abs(totalDeltaX) + Math.abs(totalDeltaY);
    const numSubSteps = totalDistance / 2;
    e.deltaX = totalDeltaX > 0 ? 2 : (totalDeltaX < 0 ? -2 : 0);
    e.deltaY = totalDeltaY > 0 ? 2 : (totalDeltaY < 0 ? -2 : 0);
    e.stepsLeft = numSubSteps;
    e.moving = true;
    e.x = finalX;
    e.y = finalY;
    e.targetTileX = finalX;
    e.targetTileY = finalY;
    e.currentX = startX * S;
    e.currentY = startY * S;
    
    // Rage scream every ~2 moves for huge shrimp
    if (e.isHuge && numTileSteps > 0 && performance.now() - e.lastRageScream > 400) {
        playShrimpRageGrowl();
        e.lastRageScream = performance.now();
    }
    
}
dx = p.x - e.x; dy = p.y - e.y;  // Update for attack

// Smooth huge shrimp player push (interpolated like normal movement)
if (e.isHuge && Math.abs(e.x - p.x) + Math.abs(e.y - p.y) === 1) {
    const pushX = p.x + (p.x - e.x);
    const pushY = p.y + (p.y - e.y);
    if (pushX >= 0 && pushX < W && pushY >= 0 && pushY < H && map[pushY][pushX] === 0 && !enemies.some(en => en.x === pushX && en.y === pushY)) {
        // Start smooth push animation (same as player/enemy movement)
        p.startX = p.x; p.startY = p.y;
        p.x = pushX; p.y = pushY;
        p.targetTileX = pushX; p.targetTileY = pushY;
        p.deltaX = (pushX - p.startX) * 2;
        p.deltaY = (pushY - p.startY) * 2;
        p.stepsLeft = 8;
        p.moving = true;
        p.moveStartTime = performance.now();
        p.moveDuration = 200;
        logBattleEvent(`Enraged Huge Shrimp pushes you!`);
        needsRedraw = true;
    }
}

            }
            if (
                (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark' || e.type.name === 'Cursed Trader') ?
                (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
            ) {
                // Set sword animation for Cursed Trader
                if (e.type.name === 'Cursed Trader') {
                    e.swordActive = true;
                    e.swordStart = Date.now();
                    // Determine sword direction towards player
                    const dx = p.x - e.x;
                    const dy = p.y - e.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        e.swordDir = dx > 0 ? 'right' : 'left';
                    } else {
                        e.swordDir = dy > 0 ? 'down' : 'up';
                    }
                }
                
                // Calculate base damage
                const damage = e.type.name === 'Whale' ? Math.ceil(p.hp / 10) + 3 : e.type.atk;

// Player dodge chances (Birch Shield + Acrobatics buff)
let damageTaken = true;

// Acrobatics buff (Jester reward) — 20% dodge chance vs any attack
if (p.hasAcrobaticsBuff && Math.random() < 0.2) {
    logBattleEvent(`Acrobatics dodge!`);

    highlightTiles.push({x: p.x, y: p.y, highlightStart: performance.now(), color: 'circle-cyan'});
    damageTaken = false;
}

// Birch Shield (Druid perk) — 10% block chance
else if (playerClass === 'druid' && Math.random() < 0.10) {
    logBattleEvent(`Birch Shield blocks the attack!`);
    highlightTiles.push({x: p.x, y: p.y, highlightStart: performance.now(), color: 'circle-white'});
    damageTaken = false;
}

                if (damageTaken) {
                    // Aura absorbs first if active
                    if (p.hasCursedRing && p.auraShield > 0) {
                        const oldAura = p.auraShield;
                        p.auraShield -= damage;
                        if (p.auraShield < 0) {
                            p.hp += p.auraShield; // overflow to HP
                            logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks Aura! ${damage} DMG (overflow ${Math.abs(p.auraShield)} to HP; Aura now 0/${p.auraMax})`);
                            p.auraShield = 0;
                        } else {
                            logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks Aura! ${damage} DMG (now ${p.auraShield}/${p.auraMax})`);
                        }
                        auraHitStartTime = Date.now();
                    } else {
                        // Normal HP damage
                        p.hp -= damage;
                    }

// Thorns only if damage was actually taken (not blocked by shield) AND enemy is adjacent (1 tile away)
if (playerClass === 'druid' && playerLevel >= 10) {
    const dist = Math.abs(e.x - p.x) + Math.abs(e.y - p.y);
    if (dist === 1) { // Only enemies directly adjacent (cardinal, not diagonal)
        let thornDmg = playerLevel >= 30 ? 0.5 : 0.25; // fractional damage
        if (e.type.name === 'Shrimp' || (playerLevel >= 30 && e.type.name === 'Crab')) {
            thornDmg *= 0.5; // 50% on small enemies
        }
        if (thornDmg > 0) {
            const oldHp = e.hp;
            e.hp -= thornDmg;
            logBattleEvent(`${e.type.name} takes ${thornDmg} thorn damage!`);

            if (e.hp <= 0 && oldHp > 0) {
                // Immediate kill handling for thorns (same as normal attack)
                kills[e.type.name]++;
                
// === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(e.type.name, e.x, e.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(e);
                tryDropScroll(e.x, e.y);

                // Drop sats if not unique or Cursed Trader
                if (!e.uniqueName && e.type.name !== 'Cursed Trader' && e.type.name !== 'Jester' && !e.isHuge) {
                    if (map[e.y][e.x] === 0) {
                        map[e.y][e.x] = 3;
                        satoshiDrops.push({x: e.x, y: e.y, sats: e.sats, type: e.type.name});
                    }
                }

                // Rune drop chance
                if (Math.random() < (e.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    if (map[e.y][e.x] === 0 || map[e.y][e.x] === 3) {
                        map[e.y][e.x] = 8;
                        const runeLetter = 'r'; // placeholder
                        runeDrops.push({x: e.x, y: e.y, letter: runeLetter});
                    }
                }

                // 5% soul stone drop chance
                if (Math.random() < 0.05) {
                    dropSoulStone(e.x, e.y);
                }

                // Guaranteed Soul Stone drop for Cursed Trader
                if (e.type.name === 'Cursed Trader') {
                    let placed = false;
                    if (map[e.y][e.x] === 0) {
                        map[e.y][e.x] = 20;
                        placed = true;
                    } else {
                        const adjDirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
                        for (let ad of adjDirs) {
                            let nx = e.x + ad.dx, ny = e.y + ad.dy;
                            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(en => en.x === nx && en.y === ny)) {
                                map[ny][nx] = 20;
                                placed = true;
                                break;
                            }
                        }
                    }
                    if (placed) {
                        logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Soul Stone!`);
                        playWebAudioSound(sounds.pickup);
                    }
                }

                logBattleEvent(`${e.type.name} killed by thorns!`);                
                // Cleanup + huge shrimp rewards

                if (e.isHuge) {
                    if (!e.deathTime) e.deathTime = performance.now();
                    dropSoulStone(e.x, e.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[e.y][e.x] === 0) {
            map[e.y][e.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = e.x + d.dx, ny = e.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
                enemies = enemies.filter(en => en !== e);

                // Thorns highlightTiles                
                highlightTiles.push({
                    x: e.x,
                    y: e.y,
                    highlightStart: performance.now(),
                    color: 'rgba(139, 69, 19, 0.6)'
                });
            }
        }
    }
}

                playWebAudioSound(sounds.hit);

// Wisp vulnerability: Attack wisp if close (like player)
if (wisps.length > 0) {
    const wisp = wisps[0];
    let wdx = wisp.x - e.x, wdy = wisp.y - e.y;
    let wdist = Math.abs(wdx) + Math.abs(wdy);
    if (wdist <= 1) { // Adjacent
        let wDmg = e.type.atk;
        wisp.hp -= wDmg;
        logBattleEvent(`Floor ${floor} - ${e.type.name} attacks wisp for ${wDmg} dmg! (Wisp HP: ${wisp.hp})`);
        if (wisp.hp <= 0) {
            wisps = []; // Remove from active array
            logBattleEvent(`Floor ${floor} - Wisp perishes!`);
            sounds.gameover.currentTime = 0;
            sounds.gameover.play().catch(e => console.error('Wisp death sound error:', e));
            // Place dead wisp on ground
            deadWispCorpse = {
                x: wisp.x, y: wisp.y,
                type: wisp.type.name,
                frameIndex: wisp.anim.frameIndex,
                fadeStart: Date.now()
            };
        }
    }
}
                }
logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${damage} DMG`);

playWebAudioSound(sounds.hit);
if (p.hp <= 0 && p.immortal) {
    p.hp = 1;
    logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
} else if (p.hp <= 0) {
    p.hp = 0;
    diamonds = 0;                // reset diamonds
    
            playerXP = 0;          // reset XP meter on death
            playerLevel = 1;           // reset level to 1
            updateXPBar();         // immediately update the bar to 0    
    
    updatePlayerState();          // update inventory
    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
}

updatePlayerState(); // Check HP and armor state after damage
            }
            
            // —— BIT SHOOTING (ranged attack) ——
            if (e.bitAmmo > 0 && fogMap[e.y][e.x] === 1) {
                const dx = p.x - e.x;
                const dy = p.y - e.y;
                const dist = Math.abs(dx) + Math.abs(dy);

                if (dist >= 2 && dist <= 7) {
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                            // Zelda-ish aiming: only fire when clearly aligned horizontally or vertically
                            let dirX = 0, dirY = 0;
                            if (absDx >= 2 * absDy && absDx > 0) {
                                dirX = dx > 0 ? 1 : -1;
                            } else if (absDy >= 2 * absDx && absDy > 0) {
                                dirY = dy > 0 ? 1 : -1;
                            } else {
                                // Not aligned enough – no shot
                                // Mark that enemy can see player this turn (for immediate shooting next time)
                                if (fogMap[e.y][e.x] === 1 && !e.justSawPlayer) {
                                    e.justSawPlayer = true;
                                }
                                return; // safe inside forEach – skips rest of this enemy's turn
                            }

                    // Strict tile-by-tile LOS along the chosen cardinal direction
                    let hasLOS = true;
                    let testX = e.x + dirX;
                    let testY = e.y + dirY;
                    while (testX !== p.x || testY !== p.y) {
                        if (map[testY][testX] === 1) {
                            hasLOS = false;
                            break;
                        }
                        testX += dirX;
                        testY += dirY;
                    }

                    if (hasLOS) {
                        const now = Date.now();
                        if (now - e.lastBitShot > 1200) {
                            e.lastBitShot = now;

                            if (e.justSawPlayer) {
                                e.justSawPlayer = false;
                                logBattleEvent(`Floor ${floor} - ${e.uniqueName || e.type.name} spots you!`);
                                playThrowSpear();
                            }

                            // Fire the spear
                            e.bitAmmo--;
                            e.bits = e.bitAmmo;

                            projectiles.push({
                                x: e.x, y: e.y,
                                currentX: e.x * S, currentY: e.y * S,
                                dirX: dirX, dirY: dirY,
                                value: 1,
                                moveStartTime: now,
                                moving: true
                            });
                            const proj = projectiles[projectiles.length - 1];
                            proj.targetTileX = e.x + dirX;
                            proj.targetTileY = e.y + dirY;
                            proj.targetX = proj.targetTileX * S;
                            proj.targetY = proj.targetTileY * S;

                            logBattleEvent(`Floor ${floor} - ${e.uniqueName || e.type.name} fires a bit spear!`);
                            needsRedraw = true;
                        }
                    }
                }

                // Mark that enemy can see player this turn (for immediate shooting next time)
                if (fogMap[e.y][e.x] === 1 && !e.justSawPlayer) {
                    e.justSawPlayer = true;
                }
            }
            
    });

    if (!window.hugeShrimpSpawnedThisFloor && enemies.filter(e => e.type.name === 'Shrimp' && !e.isHuge).length >= 3 && currentTheme !== 'hell') {
        // Find visible shrimp cluster center
        let clusterX = 0, clusterY = 0, shrimpCount = 0;
        enemies.forEach(e => {
            if (e.type.name === 'Shrimp' && !e.isHuge && fogMap[e.y][e.x] === 1) {
                clusterX += e.x;
                clusterY += e.y;
                shrimpCount++;
            }
        });

        if (shrimpCount >= 3) {
            const hx = Math.floor(clusterX / shrimpCount);
            const hy = Math.floor(clusterY / shrimpCount);

            // Try 8 adjacent tiles for huge shrimp spawn
            const dirs = [[0,-1],[0,1],[-1,0],[1,0],[-1,-1],[-1,1],[1,-1],[1,1]];
            for (let d of dirs) {
                const tx = hx + d[0], ty = hy + d[1];
                if (tx >= 0 && tx < W && ty >= 0 && ty < H && map[ty][tx] === 0 &&
                    !enemies.some(e => e.x === tx && e.y === ty)) {

                    // === WALL SLAM: Push up to 3 nearby shrimps into nearest wall ===
                    const slamCandidates = enemies.filter(e =>
                        e.type.name === 'Shrimp' && !e.isHuge && !e.uniqueName &&  // exclude uniques
                        Math.abs(e.x - tx) <= 2 && Math.abs(e.y - ty) <= 2
                    ).slice(0, 3);

                    slamCandidates.forEach(shrimp => {
                        const wallDirs = [[0,-1],[0,1],[-1,0],[1,0]];
                        let pushX = shrimp.x, pushY = shrimp.y;
                        for (let wd of wallDirs) {
                            const wx = shrimp.x + wd[0];
                            const wy = shrimp.y + wd[1];
                            if (wx >= 0 && wx < W && wy >= 0 && wy < H && map[wy][wx] === 1) {
                                pushX = wx;
                                pushY = wy;
                                break;
                            }
                        }
                        // Mark for dramatic wall-crush death
                        shrimp.crushedToWall = { targetX: pushX, targetY: pushY, startTime: performance.now() };
                        shrimp.hp = 0;
                    });

                    // === SPAWN HUGE SHRIMP ===
                    const huge = {
                        x: tx, y: ty,
                        currentX: tx * S, currentY: ty * S,
                        moving: false, stepsLeft: 0, deltaX: 0, deltaY: 0,
                        targetTileX: tx, targetTileY: ty,
                        type: types[0],
                        sats: 0, // No blockchain value
                        hp: cursedTraderType.hp,
                        atk: 2,
                        move: 2,
                        isHuge: true,
                        anim: {
                            frameIndex: 0,
                            lastFrameTime: performance.now()
                        },
                        ragePulseStart: performance.now(),
                        lastRageScream: performance.now(),
                        bits: 0, bitAmmo: 0
                    };
                    enemies.push(huge);

                    // === VAPORIZE ALL nearby normal shrimps (range 3) ===
                    const vaporizeRange = 3;
                    const vaporized = enemies.filter(en =>
                        en.type.name === 'Shrimp' && !en.isHuge && !en.uniqueName &&
                        Math.abs(en.x - tx) <= vaporizeRange && Math.abs(en.y - ty) <= vaporizeRange
                    );

                    vaporized.forEach(shrimp => {
                        // NO SATS DROP EVER
                        // Just mark for vaporize death animation
                        shrimp.vaporizeDeath = { startTime: performance.now() };
                        shrimp.hp = 0;
                    });

                    // Blood drip effect on vaporized shrimp floor tiles
                    vaporized.forEach(shrimp => {
                        shrimpBloodDrips.push({
                            x: shrimp.x,
                            y: shrimp.y,
                            startTime: performance.now()
                        });
                    });

                    // === WALL BREAK: Vaporized shrimps crack nearby inner walls ===
                    vaporized.forEach(shrimp => {
                        const wallDirs = [[0,-1],[0,1],[-1,0],[1,0]];
                        wallDirs.forEach(dir => {
                            const wx = shrimp.x + dir[0];
                            const wy = shrimp.y + dir[1];
                            if (wx > 0 && wx < W-1 && wy > 0 && wy < H-1 && map[wy][wx] === 1) {
                                map[wy][wx] = 0; // Crack → floor
                            }
                        });
                    });

                    // Epic scream + log
                    playShrimpTrollDeathScream();
                    window.hugeShrimpSpawnedThisFloor = true;
                    logBattleEvent(`MASS SHRIMP FUSION! ALL NEARBY SHRIMPS VAPORIZED IN RAGE!`);
                    needsRedraw = true;
                    break; // Only spawn one huge shrimp per trigger
                }
            }
        }
    }
        
    // Single death/surge check after all enemy actions
    updatePlayerState();
    
// === ONLY PLACE STAIRS IN NORMAL DUNGEON — NEVER IN PUZZLE ROOMS ===
if (!inPuzzleRoom && enemies.length === 0 && !exit && waveActive && !p.ripBlast && !ripBlastActive && !inHideout && !redMazeActive) {
    if (placeStairs()) {
        wave++;
        if (wisps.length > 0) wispSpeak('victory');
        waveActive = false;
        document.getElementById('wave').textContent = wave;
        logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);

        // Reveal entire floor when wave cleared (player sees stairs + map)
        fogMap = Array(H).fill().map(() => Array(W).fill(1));
        needsRedraw = true;
    } else {
        logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
    }
}
}

function updateRedMaze() {
    if (!redMazeActive || !redMaze) return;

    const now = Date.now();

    // Teleport every 3 seconds to a random floor tile (not on player)
    if (now >= redMaze.teleportTime) {
        let attempts = 50;
        let nx, ny;
        do {
            nx = Math.floor(Math.random() * W);
            ny = Math.floor(Math.random() * H);
        } while (attempts-- && (map[ny][nx] !== 0 || (nx === p.x && ny === p.y)));

        if (attempts > 0) {
            redMaze.x = nx;
            redMaze.y = ny;
        }
        redMaze.teleportTime = now + 3000;
    }

    // Single lazer from eye to player every 3 seconds (syncs with teleport)
    if (now >= redMazeLazerTime) {
        // Store the single instant lazer beam for drawing
        activeLazers = [{
            wallX: redMaze.x,
            wallY: redMaze.y,
            px: p.x,
            py: p.y,
            startTime: now
        }];

// Direct browser playback for Red Maze lazer (bypasses Web Audio issues)
if (sounds.secret) {
    sounds.secret.currentTime = 0;
    sounds.secret.play().catch(() => {});
}

        // Deal 2% HP damage
        const dmg = Math.ceil(p.hp * 0.02);
        p.hp -= dmg;
        logBattleEvent(`Red Maze floor eye lazer hits! -${dmg} HP (2%)`);
        updatePlayerState();

// Flash cross-shaped red damage on player (center + N/E/S/W)
const pinkFlash = { highlightStart: performance.now(), color: 'rgba(255, 0, 0, 0.6)' };
highlightTiles.push({ ...pinkFlash, x: p.x, y: p.y }); // center

// 4 directions (clamped to bounds)
const dirs = [
    {x: p.x, y: p.y - 1}, // north
    {x: p.x + 1, y: p.y}, // east
    {x: p.x, y: p.y + 1}, // south
    {x: p.x - 1, y: p.y}  // west
];
dirs.forEach(dir => {
    if (dir.x >= 0 && dir.x < W && dir.y >= 0 && dir.y < H && map[dir.y][dir.x] !== 1) {
        highlightTiles.push({ ...pinkFlash, x: dir.x, y: dir.y });
    }
});

        redMazeLazerTime = now + 3000;
    }

    // Boss defeat check (melee damage is applied in attack() function)
    if (redMaze.hp <= 0) {
        logBattleEvent('RED MAZE defeated!');
        redMazeActive = false;
        redMaze = null;

        // Reward: red maze aura
        if (!redMazeAuraGiven) {
            if (p.elementImmunity !== null) {
                const baseHP = p.hp;
                p.auraMax = baseHP * 2;
                p.auraShield = p.auraMax;
                p.hasCursedRing = true; // reuse flag for red aura visuals
                redMazeAuraGiven = true;
                logBattleEvent(`Red Aura gained! Shield: ${p.auraShield}/${p.auraMax}`);
              } else {              
                logBattleEvent(`Cursed Aura blocks Red Maze Aura grant!`);
            }
        }

// Restore exact mute state user had before boss fight
if (redMazeSavedMuteState !== null) {
    const { muted, buttonText } = redMazeSavedMuteState;

    musicMuted = muted;
    musicManager.mute(muted);

    const muteButton = document.getElementById('mute');
    muteButton.textContent = buttonText;

    // If user had screensaver active (☀), re-activate it
    if (buttonText === '☀') {
        activateScreensaver();
        if (!splashActive) {
            musicManager.current = null;
            musicManager.play(currentTheme);
        }
    } else if (buttonText === '♪' && !splashActive) {
        // Only play normal music if button was ♪
        musicManager.play(currentTheme);
    }

    redMazeSavedMuteState = null;
}

        // Reset cooldown from current floor
        redMazeLastFloor = floor;

playerXP += 30;
logBattleEvent(`+30 XP (Red Maze defeated)`);
checkLevelUp();

        // Force stairs to spawn immediately after boss defeat
        if (!exit) {
            placeStairs();
            wave++;
            waveActive = false;
            document.getElementById('wave').textContent = wave;
            logBattleEvent(`Floor ${floor} - RED MAZE defeated! Stairs appeared!`);
            playDisappearSound()
        }
    }
}

function doScourgeSpinAttack() {
    const dirs = [
        {dx:-1,dy:-1},{dx:0,dy:-1},{dx:1,dy:-1},
        {dx:-1,dy:0}, {dx:1,dy:0},
        {dx:-1,dy:1}, {dx:0,dy:1},{dx:1,dy:1}
    ];
    dirs.forEach(d => {
        const x = p.x + d.dx;
        const y = p.y + d.dy;
        if (x < 0 || x >= W || y < 0 || y >= H || map[y][x] === 1) return;
        const enemy = enemies.find(e => e.x === x && e.y === y);
        if (enemy) {
            enemy.hp -= 2;
            enemy.scourgeHit = Date.now();
            if (enemy.hp <= 0) {
                kills[enemy.type.name]++;

                let xp = 0;
                if (enemy.type.name === 'Shrimp') xp = 1;
                else if (enemy.type.name === 'Crab') xp = 2;
                else if (enemy.type.name === 'Squid') xp = 3;
                else if (enemy.type.name === 'Dolphin') xp = 4;
                else if (enemy.type.name === 'Shark') xp = 5;
                else if (enemy.type.name === 'Whale') xp = 15;
                else if (enemy.type.name === 'Cursed Trader') xp = 10;
                else if (enemy.type.name === 'Jester') xp = 2;
                if (enemy.uniqueName) xp *= 2; // Unique monsters give 2x XP

                playerXP += xp;
                //if (xp > 0) logBattleEvent(`+${xp} XP`);
                checkLevelUp();
                updateXPBar(); // Only called on kills - super efficient
                
if (enemy.type.name === 'Jester' && Math.random() < 0.25) {
    const gemTypes = ['ruby', 'sapphire', 'emerald', 'citrine'];
    const gem = gemTypes[Math.floor(Math.random() * gemTypes.length)];
    
    // Try to place on death spot
    let placed = false;
    if (map[enemy.y][enemy.x] === 0) {
        map[enemy.y][enemy.x] = GEM_TILES[gem];
        placed = true;
    } else {
        // Try adjacent tiles
        const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
        for (const d of dirs) {
            const nx = enemy.x + d.dx;
            const ny = enemy.y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                map[ny][nx] = GEM_TILES[gem];
                placed = true;
                break;
            }
        }
    }
    
    if (placed) {
        logBattleEvent(`Jester dropped a ${gem} on the floor!`);
        playWebAudioSound(sounds.pickup);
    } else {
        // Fallback: add directly to inventory if no space
        p.gems[gem]++;
        logBattleEvent(`Jester dropped a ${gem} directly to you (no floor space)!`);
        playWebAudioSound(sounds.pickup);
    }
    
    updatePlayerState();
}
                
        // === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(enemy.type.name, enemy.x, enemy.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(enemy);
                tryDropScroll(enemy.x, enemy.y);

                // Normal sats drop for non-unique enemies (skip Cursed Trader to avoid bitcoin glitch)
                if (!enemy.uniqueName && enemy.type.name !== 'Cursed Trader' && enemy.type.name !== 'Jester' && !enemy.isHuge && map[y][x] === 0) {
                    map[y][x] = 3;
                    satoshiDrops.push({x, y, sats: enemy.sats, type: enemy.type.name});
                }

                // Guaranteed Soul Stone drop for Cursed Trader
                if (enemy.type.name === 'Cursed Trader') {
                    let placed = false;
                    if (map[y][x] === 0) {
                        map[y][x] = 20; // Soul stone tile
                        placed = true;
                    } else {
                        const adjDirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
                        for (let ad of adjDirs) {
                            let nx = enemy.x + ad.dx, ny = enemy.y + ad.dy;
                            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                map[ny][nx] = 20;
                                placed = true;
                                break;
                            }
                        }
                    }
                    if (placed) {
                        logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Soul Stone!`);
                        playWebAudioSound(sounds.pickup);
                    }
                }


                if (enemy.isHuge) {
                    if (!enemy.deathTime) enemy.deathTime = performance.now();
                    dropSoulStone(enemy.x, enemy.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[enemy.y][enemy.x] === 0) {
            map[enemy.y][enemy.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = enemy.x + d.dx, ny = enemy.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
                enemies = enemies.filter(e => e !== enemy);
                
            }
        }
    });
}

function handleSideQuestKill(enemyType, enemyX, enemyY) {
    // Only process if there's an active side quest and type matches
    if (window.currentSideQuest && window.currentSideQuest.type === enemyType) {
        window.currentSideQuest.progress++;
        
        if (window.currentSideQuest.progress >= window.currentSideQuest.quota) {
            logBattleEvent(`Side Quest Complete! Elixir dropped from the ${enemyType}!`);
            playWebAudioSound(sounds.secret);
            
            // Try to drop elixir
            let placed = false;
            if (map[enemyY][enemyX] === 0) {
                map[enemyY][enemyX] = 33;
                placed = true;
            } else {
                const dirs = [{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];
                for (const d of dirs) {
                    const nx = enemyX + d.dx;
                    const ny = enemyY + d.dy;
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                        map[ny][nx] = 33;
                        placed = true;
                        break;
                    }
                }
            }
            
            window.lastSideQuestType = window.currentSideQuest.type;
            window.currentSideQuest = null;
        } else {
            logBattleEvent(`Side quest progress: ${window.currentSideQuest.progress}/${window.currentSideQuest.quota} ${enemyType}s`);
        }
    }
}

// ——— SCROLL DROP — 5% chance on any enemy kill ———
function tryDropScroll(deadX, deadY) {
    if (!scrollDroppedThisFloor && Math.random() < 0.05) {
        scrollDroppedThisFloor = true;
        let placed = false;
        const positions = [{ x: deadX, y: deadY }];
        const adj = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
        for (const d of adj) positions.push({ x: deadX + d.dx, y: deadY + d.dy });
        for (const pos of positions) {
            if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 0) {
                map[pos.y][pos.x] = 11; // SCROLL TILE
                scrollDrops.push({ x: pos.x, y: pos.y });
                logBattleEvent(`Floor ${floor} - A mysterious scroll drops from the enemy!`);
                playWebAudioSound(sounds.pickup);
                placed = true;
                break;
            }
        }
        if (!placed) {
            console.warn("No space for scroll drop");
        }
    }
}

function updateWisps() {
    if (wisps.length === 0 || gameOver || splashActive) return;
    const wisp = wisps[0]; // Only 1 wisp
    wisp.attackCounter++;
        // Paralyzed wisp skips turn
        if (wisp.paralyzed && wisp.paralyzedTurns > 0) {
            wisp.paralyzedTurns--;
            if (wisp.paralyzedTurns <= 0) wisp.paralyzed = false;
            return; // Skip entire turn
        }
        
    // Define inRangeEnemies once for both Ensnare and normal attack
    const inRangeEnemies = enemies.filter(e => {
        let edist = Math.abs(e.x - wisp.x) + Math.abs(e.y - wisp.y);
        return edist <= wisp.type.range && e.hp > 0; // allow 1-HP for Ensnare
    });

    // Move close to player (realtime, random bob within 1-2 tiles)
    let dx = p.x - wisp.x, dy = p.y - wisp.y;
    let dist = Math.abs(dx) + Math.abs(dy);
    if (dist > 2 || Math.random() < 0.3) {
        let nx = wisp.x, ny = wisp.y;
        if (dist > 2) {
            nx += dx > 0 ? 1 : (dx < 0 ? -1 : 0);
            ny += dy > 0 ? 1 : (dy < 0 ? -1 : 0);
        } else {
            const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
            const randDir = dirs[Math.floor(Math.random() * dirs.length)];
            nx += randDir.dx; ny += randDir.dy;
        }
        if (nx >= 0 && nx < W && ny >= 0 && ny < H &&
            map[ny][nx] === 0 &&
            !(nx === p.x && ny === p.y) &&
            ![7,23].includes(map[ny][nx])) {
            const oldX = wisp.x, oldY = wisp.y;
            wisp.x = nx; wisp.y = ny;
            wisp.targetTileX = nx; wisp.targetTileY = ny;
            wisp.deltaX = (nx - oldX) * 2;
            wisp.deltaY = (ny - oldY) * 2;
            wisp.stepsLeft = 8;
            wisp.moving = true;
        }
    }

    // Normal wisp attack every 2nd turn (skip 1-HP enemies for mercy rule)
    if (wisp.attackCounter % 2 === 0) {
        const attackTargets = inRangeEnemies.filter(e => e.hp > 1);
        if (attackTargets.length > 0) {
            const target = attackTargets[0];
            applyWispAttack(wisp, target);
        }
    }

    // Animate idle bob
    const now = performance.now();
    if (now - wisp.anim.lastFrameTime >= 400) {
        wisp.anim.frameIndex = (wisp.anim.frameIndex + 1) % 3;
        wisp.anim.lastFrameTime = now;
    }
    needsRedraw = true;
}

function applyEnsnare() {
    if (!(playerClass === 'druid' && playerLevel >= 20)) return;

    // Find enemies in range (max 3 tiles, same as wisp)
    const inRangeEnemies = enemies.filter(e => {
        const dist = Math.abs(e.x - p.x) + Math.abs(e.y - p.y);
        return dist <= 3 && e.hp > 0;
    });

    if (inRangeEnemies.length === 0) return;

    // Entangle only the nearest single enemy
    let nearest = null;
    let minDist = Infinity;
    inRangeEnemies.forEach(e => {
        // Skip already frozen enemies — wisp freeze has priority
        if (e.frozen) return;

        // NEW: Jesters are immune to Ensnare (trickster flavor)
        if (e.type.name === 'Jester') return;

        const dist = Math.abs(e.x - p.x) + Math.abs(e.y - p.y);
        if (dist < minDist) {
            minDist = dist;
            nearest = e;
        }
    });

    if (nearest) {
        nearest.frozen = true;
        nearest.frozenTurns = 2;
        nearest.frozenByEnsnare = true; // mark as frozen by Ensnare
       
        // Spawn 3-frame entangle animation overlay
        entangleAnimations.push({
            x: nearest.x,
            y: nearest.y,
            frameIndex: 0,
            startTime: performance.now(),
            enemyRef: nearest
        });

        // Throttled message — once every 1 second
        const now = performance.now();
        if (now - lastMessageTime >= 1000) {
            logBattleEvent(`Ensnare entangles ${nearest.type.name}!`);
            lastMessageTime = now;
        }

        playWebAudioSound(sounds.attack);
        needsRedraw = true;
    }
}

function applyWispAttack(wisp, primaryTarget) {
    const now = Date.now();
    const now2 = performance.now();
    let hitEnemies = new Set();
    let novaTriggered = false;

    // ——— MAIN TARGET ———
    if (wisp.type.damage > 0) {
        // Fire / Earth / Chain respect bit shield
        if (primaryTarget.bitAmmo > 0) {
            primaryTarget.bitAmmo--;
            primaryTarget.bits = primaryTarget.bitAmmo;
            primaryTarget.shieldFlash = { active: true, startTime: now };
            logBattleEvent(`Wisp ${wisp.type.name.toUpperCase()} blocked by shield!`);
        } else {
            const dmg = wisp.type.damage;
            const actualDmg = Math.min(dmg, primaryTarget.hp - 1);
            if (actualDmg > 0) {
                primaryTarget.hp -= actualDmg;
                let verb = '';
                let effect = '';
                let attackSound = sounds.attack;
                switch (wisp.type.name) {
                    case 'fire':
                        verb = 'scorches';
                        effect = '[FIRE BOLT]';
                        attackSound = sounds.lava; // lava sizzle for fire
                        break;
                    case 'chain':
                        verb = 'zaps';
                        effect = '[CHAIN LIGHTNING]';
                        attackSound = sounds.rune_drop;
                        break;
                    case 'earth':
                        verb = 'smashes';
                        effect = '[EARTHQUAKE]';
                        break;
                }
                logBattleEvent(`Wisp ${verb} ${primaryTarget.type.name} for ${actualDmg} damage! ${effect}`);
                playWebAudioSound(attackSound);

                // Spawn fire bolt projectile (single target)
                if (wisp.type.name === 'fire') {
                    wispFireBoltProjectiles.push({
                        x: wisp.x,
                        y: wisp.y,
                        currentX: wisp.x * S,
                        currentY: wisp.y * S,
                        targetX: primaryTarget.x * S,
                        targetY: primaryTarget.y * S,
                        frameIndex: 0,
                        startTime: now2
                    });
                }
            }
        }
        hitEnemies.add(primaryTarget);
    }

    // ——— AOE EFFECTS ———
    const range = wisp.type.range;
    enemies.forEach(enemy => {
        if (enemy === primaryTarget) return;
        const dist = Math.abs(enemy.x - wisp.x) + Math.abs(enemy.y - wisp.y);
        if (dist > range) return;

        let affected = false;

        if (wisp.type.name === 'cold' && wisp.type.aoe === 'medium') {
            const dx = Math.abs(enemy.x - primaryTarget.x);
            const dy = Math.abs(enemy.y - primaryTarget.y);
            if (dx <= 1 && dy <= 1) {
                // Cursed Trader & Jester immune to freeze
                if (enemy.type.name === 'Cursed Trader' || enemy.type.name === 'Jester') {
                    affected = true;
                } else {
                    if (!enemy.frozenByEnsnare) {
                        enemy.frozen = true;
                        enemy.frozenTurns = 2;
                        delete enemy.frozenByEnsnare;
                        novaTriggered = true;
                    }
                    affected = true;
                }

                // Frost Nova projectile (staggered for visibility)
                frostNovaProjectiles.push({
                    x: wisp.x,
                    y: wisp.y,
                    currentX: wisp.x * S,
                    currentY: wisp.y * S,
                    targetX: enemy.x * S,
                    targetY: enemy.y * S,
                    frameIndex: 0,
                    startTime: now2 + Math.random() * 150
                });
            }
        }
        else if (wisp.type.name === 'chain' && wisp.type.aoe === 'large') {
            if (enemy.bitAmmo > 0) {
                enemy.bitAmmo--;
                enemy.bits = enemy.bitAmmo;
                enemy.shieldFlash = { active: true, startTime: now2 };
                logBattleEvent(`[CHAIN LIGHTNING] jumps to ${enemy.type.name} — blocked!`);
            } else {
                const chainDmg = Math.min(1, enemy.hp - 1);
                if (chainDmg > 0) {
                    enemy.hp -= 1;
                    logBattleEvent(`[CHAIN LIGHTNING] jumps to ${enemy.type.name} for 1 dmg!`);
                } else {
                    logBattleEvent(`[CHAIN LIGHTNING] jumps to ${enemy.type.name} — spared!`);
                }
            }
            affected = true;

            // Chain lightning projectile (staggered)
            wispLightningProjectiles.push({
                x: wisp.x,
                y: wisp.y,
                currentX: wisp.x * S,
                currentY: wisp.y * S,
                targetX: enemy.x * S,
                targetY: enemy.y * S,
                frameIndex: 0,
                startTime: now2 + Math.random() * 100
            });
        }
        else if (wisp.type.name === 'earth' && wisp.type.aoe === 'huge') {
            const dx = Math.abs(enemy.x - primaryTarget.x);
            const dy = Math.abs(enemy.y - primaryTarget.y);
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                const quakeDmg = Math.min(2, enemy.hp - 1);
if (quakeDmg > 0) {
                    enemy.hp -= quakeDmg;
                    logBattleEvent(`Earthquake hits ${enemy.type.name} for ${quakeDmg} dmg!`);
                    playWebAudioSound(sounds.hole); // sound per hit
                } else {
                    logBattleEvent(`Earthquake shakes ${enemy.type.name} — spared!`);
                }
                affected = true;

                // Earthquake projectile per hit (staggered for visibility)
                wispEarthquakeProjectiles.push({
                    x: wisp.x,
                    y: wisp.y,
                    currentX: wisp.x * S,
                    currentY: wisp.y * S,
                    targetX: enemy.x * S,
                    targetY: enemy.y * S,
                    frameIndex: 0,
                    startTime: now2 + Math.random() * 200 // more stagger
                });
            }
        }

        if (affected) {
            hitEnemies.add(enemy);
            enemy.wispHitFlash = { time: now, type: wisp.type.name };
        }
    });

    // Frost Nova sound — once per burst
    if (novaTriggered) {
        playFrostNovaSound();
    }

    // Final flash on all hit enemies
    hitEnemies.forEach(e => {
        e.wispHitFlash = { time: now, type: wisp.type.name };
    });

    // Wisp death check
    if (wisp.hp <= 0) {
        wisps = [];
        logBattleEvent(`Floor ${floor} - Wisp slain!`);
        sounds.gameover.currentTime = 0;
        sounds.gameover.play().catch(() => {});
        deadWispCorpse = {
            x: wisp.x, y: wisp.y,
            type: wisp.type.name,
            frameIndex: wisp.anim.frameIndex,
            fadeStart: now2
        };
    }

    needsRedraw = true;
}

function applySpellDamage(x, y) {
    const effect = dangerousAreas.find(e => e.x === x && e.y === y);
    if (!effect) return;

    let damage = 0;
    let damageType = "";

    switch (effect.spellType) {
        case SPELL_TYPES.FIRE_WALL:
            damage = 2;
            damageType = "Fire";
            break;
        case SPELL_TYPES.LIGHTNING_STORM:
            damage = 1;
            damageType = "Lightning";
            break;
        case SPELL_TYPES.FROST_NOVA:
            damage = 2;
            damageType = "Frost";
            break;
        case SPELL_TYPES.POISON_CLOUD:
            damage = 1;
            damageType = "Poison";
            break;
    }

    if (p.elementImmunity === damageType || p.armorImmunity === damageType) {
        logBattleEvent(`Floor ${floor} - Immune to ${damageType} spell! No damage taken.`);
    } else {
        p.hp -= damage;
        // 20% chance to paralyze wisp on spell damage
        if (wisps.length > 0 && Math.random() < 0.20) {
            const wisp = wisps[0];
            wisp.paralyzed = true;
            wisp.paralyzedTurns = 2;
            logBattleEvent(`Floor ${floor} - Spell paralyzes your wisp!`);
        }
        // Throttled spell log (every 1 second max)
        if (Date.now() - (window.lastSpellLogTime || 0) > 1000) {
            logBattleEvent(`Floor ${floor} - ${damageType} spell damage! ${damage} DMG`);
            window.lastSpellLogTime = Date.now();
        }
        // Throttled sound (every 1 second max)
        if (Date.now() - (window.lastSpellSoundTime || 0) > 1000) {
            playWebAudioSound(sounds.hit);
            window.lastSpellSoundTime = Date.now();
        }
    }

    updatePlayerState(); // Centralized: surge if eligible, no early gameOver
}

// Fixed updateProjectiles – pure cardinal movement, spears always destroy on player hit, no laying on ground
function updateProjectiles() {
    if (gameOver || splashActive) return;

    projectiles = projectiles.filter(proj => {
        const now = Date.now();

        // --------------------------------------------------------------
        // 1. Smooth interpolation to current target tile (200ms per tile)
        // --------------------------------------------------------------
        if (proj.moving && proj.moveStartTime) {
            const elapsed = now - proj.moveStartTime;
            const playerSpeed = (proj.value === undefined) ? 67 : 200; // Player swords 3x faster (67ms/tile)
            const progress = Math.min(elapsed / playerSpeed, 1);
            const eased = 0.5 + 0.5 * Math.sin(Math.PI * progress - Math.PI / 2);

            proj.currentX = proj.x * S + eased * (proj.targetX - proj.x * S);
            proj.currentY = proj.y * S + eased * (proj.targetY - proj.y * S);

            if (progress >= 1) {
                // Arrived → snap position and stop moving this step
                proj.currentX = proj.targetX;
                proj.currentY = proj.targetY;
                proj.x = proj.targetTileX;
                proj.y = proj.targetTileY;
                proj.moving = false;
            }
        }

        // --------------------------------------------------------------
        // 2. When not moving (or just arrived), advance to next tile
        // --------------------------------------------------------------
        if (!proj.moving) {
            const nx = proj.x + (proj.dirX || 0);
            const ny = proj.y + (proj.dirY || 0);

            // Out of bounds → destroy
            if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
                needsRedraw = true;
                return false;
            }

            // Wall → destroy
            if (map[ny][nx] === 1) {
                needsRedraw = true;
                return false;
            }

            // --------------------- Player sword hits enemy ---------------------
            if (proj.value === undefined) { // player shooting sword
                const hit = enemies.find(e => e.x === nx && e.y === ny);
                if (hit) {
                    // Bit shield: absorb 1 melee hit if any bits left
                    if (hit.bitAmmo > 0) {
                        hit.bitAmmo--;
                        hit.bits = hit.bitAmmo;
                        hit.shieldFlash = { active: true, startTime: Date.now() };
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} blocks with bit shield!`);
                        playWebAudioSound(sounds.hit);
                    } else {
                    // Bit shield works on any melee hit (close or far)
                    // Soul Sword / Diamond Hand ignore bit shield on shooting sword too
                    // Pickaxe sword does NOT ignore it
                    const ignoreShield = (p.soulStormCharges >= 4 || p.hasDiamondHand) && !usePickaxeSword;

                    if (ignoreShield) {
                        const damage = Math.floor(p.atk * 0.5);
                        hit.hp -= damage;
                        logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (shield ignored)`);
                        playWebAudioSound(sounds.hit);
                    } else if (hit.bitAmmo > 0) {
                        hit.bitAmmo--;
                        hit.bits = hit.bitAmmo;
                        hit.shieldFlash = { active: true, startTime: Date.now() };
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} blocks shooting sword with bit shield!`);
                        playWebAudioSound(sounds.hit);
                    } else {
                        const damage = Math.floor(p.atk * 0.5);
                        hit.hp -= damage;
                        logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (HP: ${hit.hp})`);
                        playWebAudioSound(sounds.hit);
                    }
                    }

                    if (hit.hp <= 0) {
kills[hit.type.name]++;
let xp = 0;
if (hit.type.name === 'Shrimp') xp = 1;
else if (hit.type.name === 'Crab') xp = 2;
else if (hit.type.name === 'Squid') xp = 3;
else if (hit.type.name === 'Dolphin') xp = 4;
else if (hit.type.name === 'Shark') xp = 5;
else if (hit.type.name === 'Whale') xp = 15;
else if (hit.type.name === 'Cursed Trader') xp = 10;
else if (hit.type.name === 'Jester') xp = 2;
if (hit.uniqueName) xp *= 2; // Unique monsters give 2x XP
playerXP += xp;
//if (xp > 0) logBattleEvent(`+${xp} XP`);
checkLevelUp();
updateXPBar(); // Only called on kills - super efficient
                        tryDropScroll(hit.x, hit.y);

if (hit.type.name === 'Jester' && Math.random() < 0.25) {
    const gemTypes = ['ruby', 'sapphire', 'emerald', 'citrine'];
    const gem = gemTypes[Math.floor(Math.random() * gemTypes.length)];
    
    // Try to place on death spot
    let placed = false;
    if (map[hit.y][hit.x] === 0) {
        map[hit.y][hit.x] = GEM_TILES[gem];
        placed = true;
    } else {
        // Try adjacent tiles
        const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
        for (const d of dirs) {
            const nx = hit.x + d.dx;
            const ny = hit.y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                map[ny][nx] = GEM_TILES[gem];
                placed = true;
                break;
            }
        }
    }
    
    if (placed) {
        logBattleEvent(`Jester dropped a ${gem} on the floor!`);
        playWebAudioSound(sounds.pickup);
    } else {
        // Fallback: add directly to inventory if no space
        p.gems[gem]++;
        logBattleEvent(`Jester dropped a ${gem} directly to you (no floor space)!`);
        playWebAudioSound(sounds.pickup);
    }
    
    updatePlayerState();
}

        // === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(hit.type.name, hit.x, hit.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(hit);

                        // Cursed Trader special: soul stone + possible ring, NO sats drop
                        if (hit.type.name === 'Cursed Trader') {
                            dropSoulStone(hit.x, hit.y);

                            // Cursed Ring drop (50% chance)
                            if (Math.random() < 0.5 && !p.hasCursedRing) {
                                let ringPlaced = false;
                                if (map[hit.y][hit.x] === 0) {
                                    map[hit.y][hit.x] = 23;
                                    ringPlaced = true;
                                } else {
                                    const adjacent = [
                                        {x: hit.x, y: hit.y - 1},
                                        {x: hit.x, y: hit.y + 1},
                                        {x: hit.x - 1, y: hit.y},
                                        {x: hit.x + 1, y: hit.y}
                                    ];
                                    for (const pos of adjacent) {
                                        const ax = pos.x, ay = pos.y;
                                        if (ax >= 0 && ax < W && ay >= 0 && ay < H && map[ay][ax] === 0 && !enemies.some(e => e.x === ax && e.y === ay)) {
                                            map[ay][ax] = 23;
                                            ringPlaced = true;
                                            break;
                                        }
                                    }
                                }
                                if (ringPlaced) {
                                    logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                                    playWebAudioSound(sounds.pickup);
                                }
                            }
                        } else {
                            // Normal enemies only (including uniques — they get handled in handleUniqueMonsterReward)
                            if (!hit.uniqueName && hit.type.name !== 'Cursed Trader' && hit.type.name !== 'Jester' && !hit.isHuge) {
                                let dropPlaced = false;
                                if (map[hit.y][hit.x] === 0) {
                                    map[hit.y][hit.x] = 3;
                                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                                    dropPlaced = true;
                                } else {
                                    const adjacent = [
                                        {x: hit.x, y: hit.y - 1},
                                        {x: hit.x, y: hit.y + 1},
                                        {x: hit.x - 1, y: hit.y},
                                        {x: hit.x + 1, y: hit.y}
                                    ];
                                    for (const pos of adjacent) {
                                        const ax = pos.x, ay = pos.y;
                                        if (ax >= 0 && ax < W && ay >= 0 && ay < H && map[ay][ax] === 0 && !enemies.some(e => e.x === ax && e.y === ay)) {
                                            map[ay][ax] = 3;
                                            satoshiDrops.push({x: ax, y: ay, sats: hit.sats, type: hit.type.name});
                                            dropPlaced = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        // Rune drop (20% Hell Shrimp, 10% others) — applies to all except Cursed Trader
                        if (hit.type.name !== 'Cursed Trader' && !hit.isHuge && Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                            let runeLetter;
                            if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                                const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                                runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                            } else {
                                const runeLetters = ['a','b','c','d','e','f','g','h','i','k','l','m','n','o','p','q','r','s','t','u','v','y','z','æ','ø'];
                                runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                            }
                            let runePlaced = false;
                            if (map[hit.y][hit.x] === 0) {
                                map[hit.y][hit.x] = 8;
                                runeDrops.push({x: hit.x, y: hit.y, letter: runeLetter});
                                runePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: hit.x, y: hit.y - 1},
                                    {x: hit.x, y: hit.y + 1},
                                    {x: hit.x - 1, y: hit.y},
                                    {x: hit.x + 1, y: hit.y}
                                ];
                                for (const pos of adjacent) {
                                    const ax = pos.x, ay = pos.y;
                                    if (ax >= 0 && ax < W && ay >= 0 && ay < H && map[ay][ax] === 0 && !enemies.some(e => e.x === ax && e.y === ay)) {
                                        map[ay][ax] = 8;
                                        runeDrops.push({x: ax, y: ay, letter: runeLetter});
                                        runePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (runePlaced) {
                                logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                                playWebAudioSound(sounds.rune_drop);
                            }
                        }


                if (hit.isHuge) {
                    if (!hit.deathTime) hit.deathTime = performance.now();
                    dropSoulStone(hit.x, hit.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[hit.y][hit.x] === 0) {
            map[hit.y][hit.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = hit.x + d.dx, ny = hit.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
                enemies = enemies.filter(e => e !== hit);
                        
                    }
                    needsRedraw = true;
                    return false; // sword stops on hit
                }
                
                // Shooting sword also damages Red Maze eye
if (redMazeActive && redMaze && redMaze.x === nx && redMaze.y === ny) {
    const eyeDmg = Math.floor(p.atk * 0.5); // half damage like normal ranged
    redMaze.hp -= eyeDmg;
    logBattleEvent(`Floor ${floor} - Shooting Sword hits Red Maze eye! ${eyeDmg} DMG (HP: ${redMaze.hp}/100)`);
    playShrimpRageGrowl(); // rage growl on hit
    highlightTiles.push({
        x: redMaze.x,
        y: redMaze.y,
        highlightStart: Date.now(),
        color: 'rgba(247, 147, 26, 0.7)'
    });
    return false; // stop projectile
}

// Shooting sword scares the Sandworm — it burrows away!
if (sandworm && sandworm.x === nx && sandworm.y === ny) {
    logBattleEvent(`Floor ${floor} - Shooting Sword scares the Sandworm — it burrows away!`);
    playShrimpRageGrowl(); // angry burrow sound

    // Visual flash (orange dust burst)
    highlightTiles.push({
        x: sandworm.x,
        y: sandworm.y,
        highlightStart: Date.now(),
        color: 'rgba(247, 147, 26, 0.7)'
    });

    // Instantly relocate sandworm to a new random floor tile (like normal burrow)
    let attempts = 50;
    let nx, ny;
    do {
        nx = Math.floor(Math.random() * W);
        ny = Math.floor(Math.random() * H);
    } while (attempts-- > 0 && (map[ny][nx] !== 0 ||
        Math.abs(nx - p.x) + Math.abs(ny - p.y) < 6)); // keep some distance

    if (attempts > 0) {
        sandworm.x = nx;
        sandworm.y = ny;
        sandworm.currentX = nx * S;
        sandworm.currentY = ny * S;
        // Reset burrow timer so it doesn’t immediately burrow again
        sandworm.nextBurrowTime = performance.now() + 3000 + Math.random() * 4000;
    }

    return false; // stop projectile (it “misses” visually)
}              
            }

            // --------------------- Bit spear hits player ---------------------
if (nx === p.targetTileX && ny === p.targetTileY) {
    const dmg = proj.value === 1 ? 2 : 0;
    p.hp -= dmg;

    // Decrement shooter ammo
    const shooter = enemies.find(e =>
        e.x === proj.x - (proj.dirX || 0) &&
        e.y === proj.y - (proj.dirY || 0)
    );
    if (shooter && shooter.bitAmmo > 0) {
        shooter.bitAmmo--;
        shooter.bits = shooter.bitAmmo;
    }
    const shooterName = shooter ? (shooter.uniqueName || shooter.type.name) : 'Enemy';
    
    if (dmg > 0) {
        logBattleEvent(`Floor ${floor} - ${shooterName} spear hits! ${dmg} DMG`);
    } else {
        logBattleEvent(`Floor ${floor} - ${shooterName} spear flies by!`);
    }
    playWebAudioSound(sounds.hit);
    updatePlayerState();
    needsRedraw = true;
    return false; // spear destroyed
}

            // --------------------- Continue flying ---------------------
            proj.targetTileX = nx;
            proj.targetTileY = ny;
            proj.targetX = nx * S;
            proj.targetY = ny * S;
            proj.moveStartTime = now;
            proj.moving = true;
        }

        needsRedraw = true;
        return true; // keep alive
    });
}

function updateAndDrawMatrix() {
    const now = performance.now();

    // === ENEMY AURA RINGS + FLOATING BITS (makes dull emojis feel alive & powerful) ===
    enemies.forEach(e => {
        // Skip effects if enemy is in fog of war
        if (fogMap[e.y][e.x] === 0) return;

        const dist = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);
        if (dist > 7) return; // only nearby enemies

        const isUnique = !!e.uniqueName;
        // Individual per-enemy sync + more flamboyant energy
        const phaseOffset = e.x * 123.45 + e.y * 678.9; // unique phase per enemy position
        const baseSpeed = isUnique ? 280 : 450;
        const flamboyant = Math.sin(now / 180 + phaseOffset * 0.01) * 0.3; // quick flashy bursts
        const pulse = 0.5 + 0.5 * Math.sin(now / baseSpeed + phaseOffset * 0.02) + flamboyant;

        // === DRAW EFFECTS IN FRONT OF THE ENEMY (cleaner, no composite issues) ===
        c.save();

        // 2. Clean, performant floating bits (visible but mobile-friendly)
        const bitCount = e.bits;
        if (bitCount > 0) {
            const angleIncrement = Math.PI * 2 / bitCount;
            const baseRadius = S / 2 + 5;        // nicely spaced
            const bitSize = 3;                   // 3x3 – clear but tiny

            for (let i = 0; i < bitCount; i++) {
                // Simple smooth orbit – no extra Math.sin wobble (saves CPU)
                const angle = now * 0.001 + i * angleIncrement;
                const bx = e.currentX + S / 2 + Math.cos(angle) * baseRadius;
                const by = e.currentY + S / 2 + Math.sin(angle) * baseRadius;

                c.fillStyle = isUnique ? '#ff3366' : '#f7931a';
                c.fillRect(bx - bitSize/2, by - bitSize/2, bitSize, bitSize);
            }
        }

        // 3. Matrix rain – 4 pillars, stepped random length 2/4/6/8, custom chars
        const matrixText = "0B1";
        const textSize = 6;
        const textColor = isUnique ? '#ff3366' : '#f7931a';
        const baseR = parseInt(textColor.slice(1,3),16);
        const baseG = parseInt(textColor.slice(3,5),16);
        const baseB = parseInt(textColor.slice(5,7),16);

        c.font = `${textSize}px 'VT323', monospace`;
        c.textAlign = 'center';
        c.textBaseline = 'middle';

        const pillarCount = 4;
        const pillarWidth = S / pillarCount;
        const speedBase = 0.001;

        for (let i = 0; i < pillarCount; i++) {
            const pillarX = e.currentX + (i + 0.5) * pillarWidth;
            const speed = speedBase + (i + Math.floor(phaseOffset * 10)) * 0.004;

            // Stepped random length: 2, 4, 6, or 8 characters
            const enemySeed = Math.floor(phaseOffset * 1000);
            const pillarSeed = enemySeed + i * 7919;
            const stepIndex = Math.abs(pillarSeed + Math.floor(now / 1200)) % 4;
            const length = [2, 4, 6][stepIndex]; // ← now shorter and cleaner

            for (let j = 0; j < length; j++) {
                const yPos = e.currentY - j * textSize;
                const charIdx = Math.floor((now * speed + j * 1.8) % matrixText.length);
                const alpha = 0.7 * (1 - j / length);
                c.fillStyle = `rgba(${baseR},${baseG},${baseB},${alpha})`;
                c.fillText(matrixText[charIdx], pillarX, yPos);
            }
        }

        // 4. Subtle screen distortion ripple (using canvas drawing methods)
        if (Math.random() < 0.3) {
            c.globalAlpha = 0.15;
            const rippleX = e.currentX - 2 + Math.random() * 4;
            const rippleY = e.currentY - 2 + Math.random() * 4;
            const rippleSize = S + 4;

            c.beginPath();
            c.arc(rippleX + rippleSize / 2, rippleY + rippleSize / 2, rippleSize / 2, 0, Math.PI * 2);
            c.fillStyle = 'rgba(255, 255, 255, 0.1)';
            c.fill();
        }

        c.restore();
    });
}


let usePickaxeSword = false; // Global flag for draw
let ripBlastActive = false; // Flag for RIP blast gradient overlay effect
let ripBlastStartTime = 0; // Timestamp for RIP blast start
let columnProgress = 0; // Progress of gradient columns (0 to 1)

let previousHP = 36;
let hpOverfillFlashStart = 0;

let enemyTempCanvas = document.createElement('canvas');
enemyTempCanvas.width = S;
enemyTempCanvas.height = S;
let enemyTempCtx = enemyTempCanvas.getContext('2d');

let auraTempCanvas = document.createElement('canvas');
auraTempCanvas.width = W * S;
auraTempCanvas.height = H * S;
let auraTempCtx = auraTempCanvas.getContext('2d');

// Initialize gradient column overlay for RIP blast effect
function initGradientOverlay() {
    columnProgress = 0; // Start at beginning of animation
}

// Modified checkRunewords function to display 5x5 rune grid with counts
function checkRunewords() {
    // Define all possible runes
    const allRunes = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
    
    // Count occurrences of each rune, capped at 9
    const runeCounts = {};
    allRunes.forEach(rune => runeCounts[rune] = 0);
    p.runes.forEach(rune => {
        if (runeCounts[rune] < 9) {
            runeCounts[rune]++;
        }
    });
    
// Build 5x5 grid display
let displayText = '<br>'; // Start with a <br> for the first row
for (let i = 0; i < 5; i++) {
    const row = allRunes.slice(i * 5, (i + 1) * 5).map(rune => {
        const count = runeCounts[rune];
        const letter = rune.toUpperCase();
        const display = `${letter}<sup style="font-size: 0.6em;">${count}</sup>`;
        if (count > 0) {
            return display;
        }
        return `<span style="opacity: 0;">${display}</span>`;
    }).join('  '); // Two spaces for separation
    //displayText += row + (i < 4 ? '<br>' : ''); // Newline except for last row
    displayText += row + (i < 4 ? ' ' : ''); // Newline except for last row
}
    
    // Wrap displayText in a span with Safari-compatible nbsp styling
    const wrappedDisplayText = `<span style="-webkit-nbsp-mode: normal;">${displayText}</span>`;
    
    // Update inventory display
    document.getElementById('runes').innerHTML = wrappedDisplayText; // Apply wrapped text to runes element
}

// Modified checkRunewordsAtFloorStart function to check for BTC, HODL, RIP and SAT runes in any order
function checkRunewordsAtFloorStart() {
    // Only check for runewords at start of floor (no continuous checking)
    const runewords = [
        { name: 'btc', runes: ['b', 't', 'c'], effect: () => {
            p.hp += 444;
            p.maxHP = Math.max(p.maxHP, p.hp);
            p.runewords.push('btc');
            logBattleEvent(`Floor ${floor} - Runeword BTC activated! +444 HP (now ${p.hp})`);
            updatePlayerState();
            needsRedraw = true;
        }},
        { name: 'hodl', runes: ['h', 'o', 'd', 'l'], effect: () => {
            p.immortal = true;
            p.runewords.push('hodl');
            logBattleEvent(`Floor ${floor} - Runeword HODL activated! You are immortal!`);
            updatePlayerState();
            needsRedraw = true;
        }},
	{ name: 'rip', runes: ['r', 'i', 'p'], effect: () => {
	    p.ripBlast = true;
	    p.runewords.push('rip');
	    logBattleEvent(`Floor ${floor} - Runeword RIP activated! Incoming blast...`);
	    needsRedraw = true;
	}},
	{ name: 'sat', runes: ['s', 'a', 't'], effect: () => {
	    p.atk *= 2;
	    p.runewords.push('sat');
	    logBattleEvent(`Floor ${floor} - Runeword SAT activated! Attack doubled to ${p.atk}! (Satoshi's blessing)`);
	    updatePlayerState();
	    needsRedraw = true;
	}}
    ];

    // Compute rune counts and indices in a single pass
    const runeData = { counts: {}, indices: {} };
    p.runes.forEach((rune, i) => {
        if (!runeData.counts[rune]) {
            runeData.counts[rune] = 0;
            runeData.indices[rune] = [];
        }
        runeData.counts[rune]++;
        runeData.indices[rune].push(i);
    });

    let usedIndices = [];
    let activatedRunewords = [];

    // Check each runeword
    for (const runeword of runewords) {
        if (p.runewords.includes(runeword.name)) continue; // Skip already activated runewords

        // Check if all required runes are available
        const hasAllRunes = runeword.runes.every(rune => (runeData.counts[rune] || 0) > 0);
        if (hasAllRunes) {
            // Collect indices for the required runes
            const indices = [];
            for (const rune of runeword.runes) {
                if (runeData.indices[rune].length > 0) {
                    indices.push(runeData.indices[rune].shift()); // Take first available index
                    runeData.counts[rune]--;
                } else {
                    break; // Missing a rune, stop checking this runeword
                }
            }
            if (indices.length === runeword.runes.length) { // All runes found
                runeword.effect();
                usedIndices.push(...indices);
                activatedRunewords.push(runeword.name.toUpperCase());
            }
        }
    }

    // Display runeword message if any were activated
    if (activatedRunewords.length > 0) {
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Runeword${activatedRunewords.length > 1 ? 's' : ''} ${activatedRunewords.join(', ')} found!`;
        if (!specialSoundsPlayedThisFloor.rune) {
            playWebAudioSound(sounds.rune);
            specialSoundsPlayedThisFloor.rune = true;
        }
        setTimeout(() => {
            const currentText = floorIndicator.textContent;
            if (currentText.startsWith("Runeword")) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 5000);
    }

    // Remove used runes
    if (usedIndices.length > 0) {
        usedIndices.sort((a, b) => b - a); // Sort descending to avoid index issues
        for (const index of usedIndices) {
            p.runes.splice(index, 1);
        }
    }

    // Clear specific rune drops
    runeDrops = runeDrops.filter(r => !r.specific);
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 9) {
                map[y][x] = 0; // Clear specific rune tiles
            }
        }
    }

    checkRunewords(); // Update inventory display
    needsRedraw = true;
}

// Modified handleUniqueMonsterReward function with fadeout before removing dangerous areas
function handleUniqueMonsterReward(hit) {
    if (!hit.uniqueName) return false;
    
    // Reward for unique monster: at least 2X (up to 4X) the normal sats/btc
    const baseReward = hit.sats;
    const floorMultiplier = floor / 100; // Calculate floor multiplier
    const added = Math.floor(baseReward * floorMultiplier); // Apply floor multiplier
    const baseWithMultiplier = baseReward + added; // Base reward with floor multiplier
    
// Apply additional random multiplier for unique monsters (2x to 4x)
    const randomMultiplier = 2 + Math.random() * 2; // Random multiplier from 2x to 4x
    const reward = Math.round(baseWithMultiplier * randomMultiplier);
    
    // Add bitcoin drops around the monster position (skip for Cursed Trader)
    let dropPlaced = false;
    if (hit.type.name !== 'Cursed Trader' && hit.type.name !== 'Jester' && !hit.isHuge) {
        if (map[hit.y][hit.x] === 0) {
            map[hit.y][hit.x] = 3;
            satoshiDrops.push({x: hit.x, y: hit.y, sats: reward, type: hit.type.name});
            dropPlaced = true;
        } else {
            const adjacent = [
                {x: hit.x, y: hit.y - 1},
                {x: hit.x, y: hit.y + 1},
                {x: hit.x - 1, y: hit.y},
                {x: hit.x + 1, y: hit.y}
            ];
            for (const pos of adjacent) {
                const nx = pos.x, ny = pos.y;
                if (
                    nx >= 0 && nx < W && ny >= 0 && ny < H &&
                    map[ny][nx] === 0 &&
                    !enemies.some(e => e.x === nx && e.y === ny)
                ) {
                    map[ny][nx] = 3;
                    satoshiDrops.push({x: nx, y: ny, sats: reward, type: hit.type.name});
                    dropPlaced = true;
                    break;
                }
            }
        }
    }
    
    // Tag spell areas for fade-out when unique monster dies
    if (hit.uniqueName && hit.spell) {
        const deathTime = Date.now();
        dangerousAreas.forEach(area => {
            if (area.spellType === hit.spell && !area.deathTime) {
                area.deathTime = deathTime; // start smooth fade-out
            }
        });
        
    // Bounty reward: 10% current sats if matching current bounty
    if (window.currentBounty && hit.uniqueName === window.currentBounty.name) {
        const totalSats = Object.values(satsEarned).reduce((a, b) => a + b, 0);
        const bountyReward = Math.floor(totalSats * 0.10);
        
        // Distribute 10% proportionally across types
        Object.keys(satsEarned).forEach(key => {
            satsEarned[key] += Math.floor(satsEarned[key] * 0.10);
        });
        
        logBattleEvent(`Bounty Claimed! +${bountyReward} sats for killing ${hit.uniqueName}!`);
        if (wisps.length > 0) {
        talkSpeak(11); // 'yes , Bitcoin from bounty'
        }
        
        // Track seen type for "cousin" NEXT time (before reset)
        if (!window.seenBountyTypes.includes(window.currentBounty.type)) {
            window.seenBountyTypes.push(window.currentBounty.type);
        }
        
        window.currentBounty = null; // Reset bounty
        updateSatsDisplay();
    }     
}

    // === UNIQUE REWARD MESSAGE ===
    if (hit.type.name !== 'Jester') {
        const multiplier = Math.round(randomMultiplier * 10) / 10;
        const rewardBtc = reward / 100000000;
        const displayAmount = rewardBtc >= 0.001
            ? rewardBtc.toFixed(3) + ' BTC'
            : Math.round(reward) + ' sats';
        logBattleEvent(`UNIQUE: ${hit.uniqueName} defeated!`);
        logBattleEvent(`Multiplier: ${multiplier}x`);
        logBattleEvent(`Reward: ${displayAmount}`);
    } else {
        logBattleEvent(`Jester defeated!`); // optional minimal message
    }

    activeUniqueMonsterName = null; // Also clear any lingering visible name
    // Add reward to earned stats (skip Cursed Trader)
    if (hit.type.name !== 'Cursed Trader' && hit.type.name !== 'Jester' && !hit.isHuge) {
        satsEarned[hit.type.name] = (satsEarned[hit.type.name] || 0) + reward;
    }
    // Clear harbinger if it was this monster
    const floorIndicator = document.getElementById('floor-indicator');
    if (floorIndicator.textContent === "A harbinger of doom is near.") {
        floorIndicator.textContent = `Floor ${floor}`;
    }
    updateSatsDisplay();
    
    return true;
}

// Function to assign a spell to a unique monster when it spawns
function assignUniqueMonsterSpell(enemy) {
    // Only assign spells to unique monsters
    if (!enemy.uniqueName || !uniqueMonsterNames[enemy.type.name]) {
        return null;
    }

    // Elemental keyword correlations (case-insensitive)
    const correlations = {
        fire: SPELL_TYPES.FIRE_WALL, blaze: SPELL_TYPES.FIRE_WALL, inferno: SPELL_TYPES.FIRE_WALL,
        storm: SPELL_TYPES.LIGHTNING_STORM, lightning: SPELL_TYPES.LIGHTNING_STORM, bolt: SPELL_TYPES.LIGHTNING_STORM, thunder: SPELL_TYPES.LIGHTNING_STORM,
        cold: SPELL_TYPES.FROST_NOVA, frost: SPELL_TYPES.FROST_NOVA, ice: SPELL_TYPES.FROST_NOVA, chill: SPELL_TYPES.FROST_NOVA,
        poison: SPELL_TYPES.POISON_CLOUD, viper: SPELL_TYPES.POISON_CLOUD, snot: SPELL_TYPES.POISON_CLOUD, plague: SPELL_TYPES.POISON_CLOUD,
        bile: SPELL_TYPES.POISON_CLOUD, pox: SPELL_TYPES.POISON_CLOUD, ooze: SPELL_TYPES.POISON_CLOUD, venom: SPELL_TYPES.POISON_CLOUD
    };

    // Check for matching keyword in name
    const nameLower = enemy.uniqueName.toLowerCase();
    let matchedSpell = null;
    for (const [keyword, spell] of Object.entries(correlations)) {
        if (nameLower.includes(keyword)) {
            matchedSpell = spell;
            break;
        }
    }

    // Assign matched spell or fallback to random
    const spell = matchedSpell || Object.values(SPELL_TYPES)[Math.floor(Math.random() * Object.keys(SPELL_TYPES).length)];
    enemy.spell = spell;
    return spell;
}

// Modified attack function with Hell Shrimp rune drop rate changed to 20%
function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    
    // Update player direction
    let newDirection = p.anim.direction;
    if (swordDir === 'up') newDirection = 'back';
    if (swordDir === 'down') newDirection = 'front';
    if (swordDir === 'left') newDirection = 'left';
    if (swordDir === 'right') newDirection = 'right';
    p.anim.direction = newDirection;
    
    const initialPickaxes = p.pickaxes;
    
    // Check for enemy or wall one tile away in swordDir
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    
    const isEnemyNearby = enemies.some(e => e.x === sx && e.y === sy);
    const isWallNearby = sx >= 0 && sx < W && sy >= 0 && sy < H && map[sy][sx] === 1;

    // Applies to Diamond Hand as of now ..
    const elementalBonus = p.gemAtk.fire + p.gemAtk.cold + p.gemAtk.earth + p.gemAtk.lightning;
    
    if (initialPickaxes > 0 || isEnemyNearby || isWallNearby) {
        usePickaxeSword = initialPickaxes > 0;
        let hit = enemies.find(e => e.x === sx && e.y === sy);
        
if (hit) {

    // Check if the enemy is a unique monster that can cast spells
    if (hit.uniqueName && hit.spell) {
        // Unique monster uses its spell
        const spellEffect = hit.spell;
        //logBattleEvent(`Floor ${floor} - ${hit.uniqueName} casts ${spellEffect}!`);
        
        // Create the spell effect area around the enemy position
        // Create spell effect areas (now handled by animated assets)
        switch (spellEffect) {
            case SPELL_TYPES.FIRE_WALL:
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H &&
                            map[y][x] !== 1 &&
                            !dangerousAreas.some(e => e.x === x && e.y === y)) {
                            createDangerousArea(x, y, spellEffect);
                        }
                    }
                }
                break;
            case SPELL_TYPES.LIGHTNING_STORM:
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H &&
                            map[y][x] !== 1 &&
                            !dangerousAreas.some(e => e.x === x && e.y === y)) {
                            createDangerousArea(x, y, spellEffect);
                        }
                    }
                }
                break;
            case SPELL_TYPES.FROST_NOVA:
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H &&
                            map[y][x] !== 1 &&
                            !dangerousAreas.some(e => e.x === x && e.y === y)) {
                            createDangerousArea(x, y, spellEffect);
                        }
                    }
                }
                break;
            case SPELL_TYPES.POISON_CLOUD:
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H &&
                            map[y][x] !== 1 &&
                            !dangerousAreas.some(e => e.x === x && e.y === y)) {
                            createDangerousArea(x, y, spellEffect);
                        }
                    }
                }
                break;
        }
    }
    if (p.hasDiamondHand && !(p.pickaxes > 0 && usePickaxeSword)) {
        // Diamond hand AOE damage - updated to match the specified pattern
        const damageArea = [];
        
        // Determine damage tiles based on direction
        if (swordDir === 'up') {
            const close_y = p.y - 1;
            const far_y = p.y - 2;
            for (let dx = -1; dx <= 1; dx++) {
                damageArea.push({x: p.x + dx, y: close_y});
            }
            for (let dx = -2; dx <= 2; dx++) {
                damageArea.push({x: p.x + dx, y: far_y});
            }
        } else if (swordDir === 'down') {
            const close_y = p.y + 1;
            const far_y = p.y + 2;
            for (let dx = -1; dx <= 1; dx++) {
                damageArea.push({x: p.x + dx, y: close_y});
            }
            for (let dx = -2; dx <= 2; dx++) {
                damageArea.push({x: p.x + dx, y: far_y});
            }
        } else if (swordDir === 'left') {
            const close_x = p.x - 1;
            const far_x = p.x - 2;
            for (let dy = -1; dy <= 1; dy++) {
                damageArea.push({x: close_x, y: p.y + dy});
            }
            for (let dy = -2; dy <= 2; dy++) {
                damageArea.push({x: far_x, y: p.y + dy});
            }
        } else if (swordDir === 'right') {
            const close_x = p.x + 1;
            const far_x = p.x + 2;
            for (let dy = -1; dy <= 1; dy++) {
                damageArea.push({x: close_x, y: p.y + dy});
            }
            for (let dy = -2; dy <= 2; dy++) {
                damageArea.push({x: far_x, y: p.y + dy});
            }
        }

        // Apply damage to all valid tiles in the area
        const damage = 3; // Diamond hand AOE damage
        let enemiesHit = 0;
        let totalDamage = damage + elementalBonus; // Unlimited elemental bonus

highlightTiles = []; // Clear previous highlights
for (const tile of damageArea) {
    const {x, y} = tile;
    
    // Check if tile is within bounds and not a wall
    if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 1) {
        highlightTiles.push({x, y, highlightStart: performance.now()});
        
        // Check if there's an enemy at this tile
        const enemy = enemies.find(e => e.x === x && e.y === y);
        
        if (enemy) {
            enemy.hp -= totalDamage;
            enemiesHit++;
            
            // Log with breakdown if enchanted
            if (elementalBonus > 0) {
                logBattleEvent(`Diamond Hand wave hits ${enemy.type.name} for ${damage} base + ${elementalBonus.toFixed(1)} elemental (${totalDamage.toFixed(1)} total)!`);
            } else {
                logBattleEvent(`Diamond Hand wave hits ${enemy.type.name} for ${damage} DMG!`);
            }
            
            playWebAudioSound(sounds.hit);
                    
                    if (enemy.hp <= 0) {
                        kills[enemy.type.name]++;

                        let xp = 0;
                        if (enemy.type.name === 'Shrimp') xp = 1;
                        else if (enemy.type.name === 'Crab') xp = 2;
                        else if (enemy.type.name === 'Squid') xp = 3;
                        else if (enemy.type.name === 'Dolphin') xp = 4;
                        else if (enemy.type.name === 'Shark') xp = 5;
                        else if (enemy.type.name === 'Whale') xp = 15;
                        else if (enemy.type.name === 'Cursed Trader') xp = 10;
                        else if (enemy.type.name === 'Jester') xp = 2;
                        if (enemy.uniqueName) xp *= 2; // Unique monsters give 2x XP

                        playerXP += xp;
                        //if (xp > 0) logBattleEvent(`+${xp} XP`);
                        checkLevelUp();
                        updateXPBar(); // Only called on kills - super efficient
                        let dropPlaced = false;

if (enemy.type.name === 'Jester' && Math.random() < 0.25) {
    const gemTypes = ['ruby', 'sapphire', 'emerald', 'citrine'];
    const gem = gemTypes[Math.floor(Math.random() * gemTypes.length)];
    
    // Try to place on death spot
    let placed = false;
    if (map[enemy.y][enemy.x] === 0) {
        map[enemy.y][enemy.x] = GEM_TILES[gem];
        placed = true;
    } else {
        // Try adjacent tiles
        const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
        for (const d of dirs) {
            const nx = enemy.x + d.dx;
            const ny = enemy.y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                map[ny][nx] = GEM_TILES[gem];
                placed = true;
                break;
            }
        }
    }
    
    if (placed) {
        logBattleEvent(`Jester dropped a ${gem} on the floor!`);
        playWebAudioSound(sounds.pickup);
    } else {
        // Fallback: add directly to inventory if no space
        p.gems[gem]++;
        logBattleEvent(`Jester dropped a ${gem} directly to you (no floor space)!`);
        playWebAudioSound(sounds.pickup);
    }
    
    updatePlayerState();
}

        // === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(enemy.type.name, enemy.x, enemy.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(enemy);
tryDropScroll(enemy.x, enemy.y);
                        
                        // Drop satoshi — ONLY for normal blockchain enemies (not uniques or Cursed Trader)
                        if (!enemy.uniqueName && enemy.type.name !== 'Cursed Trader' && enemy.type.name !== 'Jester' && !enemy.isHuge) {
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 3;
                                satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                                dropPlaced = true;
                            } else {
                                const adjacent = [
                                    {x: enemy.x, y: enemy.y - 1},
                                    {x: enemy.x, y: enemy.y + 1},
                                    {x: enemy.x - 1, y: enemy.y},
                                    {x: enemy.x + 1, y: enemy.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 3;
                                        satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                                        dropPlaced = true;
                                        break;
                                    }
                                }
                            }
                        }
                        
                        if (!dropPlaced) {
                            // No space for satoshi drop
                        }

                        // Soul stone drop logic (5% chance)
                        if (Math.random() < 0.05) {
                            let stonePlaced = false;
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 20; // Soul stone tile
                                stonePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: enemy.x, y: enemy.y - 1},
                                    {x: enemy.x, y: enemy.y + 1},
                                    {x: enemy.x - 1, y: enemy.y},
                                    {x: enemy.x + 1, y: enemy.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 20; // Soul stone tile
                                        stonePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (stonePlaced) {
                                p.soulStones++;
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a Soul Stone!`);
                                playWebAudioSound(sounds.buzz);
                            }
                        }

                        // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
                        if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                            let runeLetter;
                            if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                                // Hell Shrimp: Use specific rune letters
                                const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                                runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                            } else {
                                // Regular rune drop
                                const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                                runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                            }
                            let runePlaced = false;
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 8; // Generic rune on floor
                                runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                                runePlaced = true;
                            } else {
                                const adjacent = [
                                    { x: enemy.x, y: enemy.y - 1 },
                                    { x: enemy.x, y: enemy.y + 1 },
                                    { x: enemy.x - 1, y: enemy.y },
                                    { x: enemy.x + 1, y: enemy.y }
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 8; // Generic rune on floor
                                        runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                        runePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (runePlaced) {
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                                playWebAudioSound(sounds.rune_drop);
                            }
                        }
if (enemy.type.name === 'Cursed Trader') {
        dropSoulStone(enemy.x, enemy.y);
    }

                if (enemy.isHuge) {
                    if (!enemy.deathTime) enemy.deathTime = performance.now();
                    dropSoulStone(enemy.x, enemy.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[enemy.y][enemy.x] === 0) {
            map[enemy.y][enemy.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = enemy.x + d.dx, ny = enemy.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
                enemies = enemies.filter(en => en !== enemy);
                        
                        enemiesHit++;
                    }
                    totalDamage += damage;
                }
            }
        }
    } else {
        // Regular sword attack
        const damage = p.atk; // Remove armor bonus
                // Soul Sword / Diamond Hand ignore bit shield
                // Pickaxe sword does NOT ignore it
                const ignoreShield = (p.soulStormCharges >= 4 || p.hasDiamondHand) && !usePickaxeSword;

                if (ignoreShield) {
                    hit.hp -= damage;
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG (shield ignored)!`);
                } else if (hit.bitAmmo > 0) {
                    hit.bitAmmo--;
                    hit.bits = hit.bitAmmo;
                    hit.shieldFlash = { active: true, startTime: Date.now() };
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} blocks with bit shield!`);
                } else {
                    hit.hp -= damage;
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG`);
                }
                playWebAudioSound(sounds.hit);

// Damage Red Maze eye if adjacent during melee attack
if (redMazeActive && redMaze && Math.abs(redMaze.x - p.x) + Math.abs(redMaze.y - p.y) <= 1) {
    const eyeDmg = p.atk; // Same as normal attack damage
    redMaze.hp -= eyeDmg;
    logBattleEvent(`Red Maze eye hit! ${eyeDmg} DMG (HP: ${redMaze.hp}/100)`);
    playShrimpRageGrowl(); // rage growl on hit

    // Orange flash on eye
    highlightTiles.push({
        x: redMaze.x,
        y: redMaze.y,
        highlightStart: Date.now(),
        color: 'rgba(247, 147, 26, 0.7)' // Bitcoin orange
    });
}
        
        // Wisp sync attack: Assist player's target
        if (wisps.length > 0) {
            const wisp = wisps[0];
            applyWispAttack(wisp, hit);
        }
        
                    if (hit.hp <= 0) {
kills[hit.type.name]++;
let xp = 0;
if (hit.type.name === 'Shrimp') xp = 1;
else if (hit.type.name === 'Crab') xp = 2;
else if (hit.type.name === 'Squid') xp = 3;
else if (hit.type.name === 'Dolphin') xp = 4;
else if (hit.type.name === 'Shark') xp = 5;
else if (hit.type.name === 'Whale') xp = 15;
else if (hit.type.name === 'Cursed Trader') xp = 10;
else if (hit.type.name === 'Jester') xp = 2;
if (hit.uniqueName) xp *= 2; // Unique monsters give 2x XP
playerXP += xp;
//if (xp > 0) logBattleEvent(`+${xp} XP`);
checkLevelUp();
updateXPBar(); // Only called on kills - super efficient
                        tryDropScroll(hit.x, hit.y);

if (hit.type.name === 'Jester' && Math.random() < 0.25) {
    const gemTypes = ['ruby', 'sapphire', 'emerald', 'citrine'];
    const gem = gemTypes[Math.floor(Math.random() * gemTypes.length)];
    
    // Try to place on death spot
    let placed = false;
    if (map[hit.y][hit.x] === 0) {
        map[hit.y][hit.x] = GEM_TILES[gem];
        placed = true;
    } else {
        // Try adjacent tiles
        const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
        for (const d of dirs) {
            const nx = hit.x + d.dx;
            const ny = hit.y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                map[ny][nx] = GEM_TILES[gem];
                placed = true;
                break;
            }
        }
    }
    
    if (placed) {
        logBattleEvent(`Jester dropped a ${gem} on the floor!`);
        playWebAudioSound(sounds.pickup);
    } else {
        // Fallback: add directly to inventory if no space
        p.gems[gem]++;
        logBattleEvent(`Jester dropped a ${gem} directly to you (no floor space)!`);
        playWebAudioSound(sounds.pickup);
    }
    
    updatePlayerState();
}

        // === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(hit.type.name, hit.x, hit.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(hit);

                        // Cursed Trader special: soul stone + possible ring, NO sats drop
                        if (hit.type.name === 'Cursed Trader') {
                            dropSoulStone(hit.x, hit.y);

                            // Cursed Ring drop (50% chance)
                            if (Math.random() < 0.5 && !p.hasCursedRing) {
                                let ringPlaced = false;
                                if (map[hit.y][hit.x] === 0) {
                                    map[hit.y][hit.x] = 23;
                                    ringPlaced = true;
                                } else {
                                    const adjacent = [
                                        {x: hit.x, y: hit.y - 1},
                                        {x: hit.x, y: hit.y + 1},
                                        {x: hit.x - 1, y: hit.y},
                                        {x: hit.x + 1, y: hit.y}
                                    ];
                                    for (const pos of adjacent) {
                                        const nx = pos.x, ny = pos.y;
                                        if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                            map[ny][nx] = 23;
                                            ringPlaced = true;
                                            break;
                                        }
                                    }
                                }
                                if (ringPlaced) {
                                    logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                                    playWebAudioSound(sounds.pickup);
                                }
                            }
                        } else if (!hit.uniqueName && hit.type.name !== 'Cursed Trader' && hit.type.name !== 'Jester' && !hit.isHuge) {
                            // Normal enemies only — drop sats visually
                            if (map[hit.y][hit.x] === 0) {
                                map[hit.y][hit.x] = 3;
                                satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                            } else {
                                const adjacent = [
                                    {x: hit.x, y: hit.y - 1},
                                    {x: hit.x, y: hit.y + 1},
                                    {x: hit.x - 1, y: hit.y},
                                    {x: hit.x + 1, y: hit.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                        map[ny][nx] = 3;
                                        satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                                        break;
                                    }
                                }
                            }
                        }

                        // Soul stone drop logic (5% chance) — all enemies except Cursed Trader
                        if (hit.type.name !== 'Cursed Trader' && !hit.isHuge && Math.random() < 0.05) {
                            let stonePlaced = false;
                            if (map[hit.y][hit.x] === 0) {
                                map[hit.y][hit.x] = 20;
                                stonePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: hit.x, y: hit.y - 1},
                                    {x: hit.x, y: hit.y + 1},
                                    {x: hit.x - 1, y: hit.y},
                                    {x: hit.x + 1, y: hit.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                        map[ny][nx] = 20;
                                        stonePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (stonePlaced) {
                                p.soulStones++;
                                logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a Soul Stone!`);
                                playWebAudioSound(sounds.buzz);
                            }
                        }

                        // Rune drop logic (20% for Hell Shrimp, 10% for others)
                        if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                            let runeLetter;
                            if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                                const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                                runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                            } else {
                                const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                                runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                            }
                            let runePlaced = false;
                            if (map[hit.y][hit.x] === 0) {
                                map[hit.y][hit.x] = 8;
                                runeDrops.push({x: hit.x, y: hit.y, letter: runeLetter});
                                runePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: hit.x, y: hit.y - 1},
                                    {x: hit.x, y: hit.y + 1},
                                    {x: hit.x - 1, y: hit.y},
                                    {x: hit.x + 1, y: hit.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                                        map[ny][nx] = 8;
                                        runeDrops.push({x: nx, y: ny, letter: runeLetter});
                                        runePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (runePlaced) {
                                logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                                playWebAudioSound(sounds.rune_drop);
                            }
                        }


                if (hit.isHuge) {
                    if (!hit.deathTime) hit.deathTime = performance.now();
                    dropSoulStone(hit.x, hit.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[hit.y][hit.x] === 0) {
            map[hit.y][hit.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = hit.x + d.dx, ny = hit.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
                enemies = enemies.filter(e => e !== hit);
                    }
    }
} else if (initialPickaxes > 0 && isWallNearby) {
    if (inPuzzleRoom) {
        logBattleEvent("The trial forbids breaking walls – complete it first!");
        // optional short sound feedback
        playWebAudioSound(sounds.buzz || sounds.hit);
    } else {
        p.pickaxes--;
        sounds.secret.play().catch(e => console.error('Secret sound error:', e));
        logBattleEvent(`Floor ${floor} - Wall Broken!`);
        createSecretRoom(sx, sy, p.x, p.y, swordDir);
    }
}

    }
    
// ——— PROJECTILE SPAWNING: SOUL SWORD & NORMAL FULL HP ———
// Only allowed if NO enemy is touching the player (8 surrounding tiles)
function canShootProjectile() {
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue; // Skip player tile
            const nx = p.x + dx;
            const ny = p.y + dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                if (enemies.some(e => e.x === nx && e.y === ny)) {
                    return false; // Enemy touching → NO projectile
                }
            }
        }
    }
    return true; // All clear → can shoot
}

// ——— SATOSHI'S SCOURGE: Full 360° spin attack ———
if (p.currentWeapon === 'satoshi_scourge' && !usePickaxeSword) {
    // Prevent spam + cost
    if (p.scourgeCooldown > Date.now()) return;
    if (p.soulStormCharges >= 8) {
        p.soulStormCharges -= 8;
        p.scourgeSpin = { start: Date.now() };
        p.scourgeCooldown = Date.now() + 400; // 400ms cooldown
        doScourgeSpinAttack();
        playScourgeSpin();
       
        moveEnemies();
        updateWisps();
        applyEnsnare();    // Druid Ensnare (lvl 20+)
        needsRedraw = true;
        return; // Exit early — no other attack
    }
}

// ——— SOUL SWORD: 4+ charges → AOE wave + ranged projectile ———
if (p.soulStormCharges >= 4 && !p.hasDiamondHand && projectiles.length === 0 && !usePickaxeSword) {
    if (!canShootProjectile()) {
        // Still consume charges and do AOE, but NO projectile
        p.soulStormCharges -= 4;
        activateSoulStorm();
        //logBattleEvent(`Soul Sword AOE unleashed — too close for ranged strike!`);
    } else {
        p.soulStormCharges -= 4;
        activateSoulStorm();

        // Fire projectile
        let dirX = 0, dirY = 0;
        if (swordDir === 'right') dirX = 1;
        else if (swordDir === 'left') dirX = -1;
        else if (swordDir === 'down') dirY = 1;
        else if (swordDir === 'up') dirY = -1;

        projectiles.push({
            x: p.x, y: p.y,
            currentX: p.x * S, currentY: p.y * S,
            dirX, dirY,
            moveStartTime: Date.now(),
            moving: true
        });

        const proj = projectiles[projectiles.length - 1];
        proj.targetTileX = p.x + dirX;
        proj.targetTileY = p.y + dirY;
        proj.targetX = proj.targetTileX * S;
        proj.targetY = proj.targetTileY * S;

        sounds.shoot_sword.currentTime = 0;
        sounds.shoot_sword.play().catch(() => {});
    }
}

// ——— NORMAL FULL HP PROJECTILE (HP ≥ 24 + not using special swords) ———
else if (p.hp >= 24 && !p.hasDiamondHand && projectiles.length === 0 && !usePickaxeSword) {
    if (!canShootProjectile()) {
        // Do nothing — no free ranged attack when snugging
        // (Optional: add a subtle "clank" sound or log?)
        // logBattleEvent(`Too close — sword strike only!`);
    } else {
        let dirX = 0, dirY = 0;
        if (swordDir === 'right') dirX = 1;
        else if (swordDir === 'left') dirX = -1;
        else if (swordDir === 'down') dirY = 1;
        else if (swordDir === 'up') dirY = -1;

        projectiles.push({
            x: p.x, y: p.y,
            currentX: p.x * S, currentY: p.y * S,
            dirX, dirY,
            moveStartTime: Date.now(),
            moving: true
        });

        const proj = projectiles[projectiles.length - 1];
        proj.targetTileX = p.x + dirX;
        proj.targetTileY = p.y + dirY;
        proj.targetX = proj.targetTileX * S;
        proj.targetY = proj.targetTileY * S;

        sounds.shoot_sword.currentTime = 0;
        sounds.shoot_sword.play().catch(() => {});
    }
}

// Standalone melee damage to Red Maze eye (runs on every attack swing)
if (redMazeActive && redMaze) {
    const dx = Math.abs(redMaze.x - p.x);
    const dy = Math.abs(redMaze.y - p.y);
    // Adjacent: cardinal or diagonal
    if (dx + dy === 1 || (dx === 1 && dy === 1)) {
        const eyeDmg = p.atk; // Full melee damage
        redMaze.hp -= eyeDmg;
        logBattleEvent(`Floor ${floor} - Red Maze eye hit! ${eyeDmg} DMG (HP: ${redMaze.hp}/100)`);
        playShrimpRageGrowl(); // rage growl on hit

        // Bitcoin orange flash on the eye
        highlightTiles.push({
            x: redMaze.x,
            y: redMaze.y,
            highlightStart: Date.now(),
            color: 'rgba(247, 147, 26, 0.8)'
        });
    }
}

// Sandworm melee hit (sword types only — no wisp)
if (sx === sandworm?.x && sy === sandworm?.y) {
    sandworm.hp -= p.atk; // or higher damage if you want
    playShrimpRageGrowl();
    logBattleEvent(`Sandworm takes ${p.atk} damage! (${sandworm.hp} HP left)`);

// Red flash on hit
    highlightTiles.push({
        x: sandworm.x,
        y: sandworm.y,
        highlightStart: Date.now(),
        color: 'rgba(247, 147, 26, 0.7)'
    });

    if (sandworm.hp <= 0) {
        // Rewards
    const maxHP = 36 + (p.hasArmor ? 12 : 0);
    if (p.hp < maxHP) {
        const oldHP = p.hp;
        p.hp = maxHP;
        logBattleEvent(`Sandworm vanish! HP restored to ${p.hp}`);
        playDisappearSound()
    }
        p.soulStormCharges = 256;

        // Drop diamond
        if (map[sandworm.y][sandworm.x] === 0) {
            map[sandworm.y][sandworm.x] = 10; // diamond tile
        } else {
            // Try adjacent if center occupied
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = sandworm.x + d.dx, ny = sandworm.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 10;
                    break;
                }
            }
        }

        logBattleEvent(`Sandworm vanish! 256 soul charges + Diamond!`);
        playDisappearSound()
        sandworm = null;
    }
    needsRedraw = true;
}
    
    moveEnemies();
updateWisps(); // Update wisp pos/attacks synced to player/enemy turns
applyEnsnare();    // Druid Ensnare (lvl 20+)
    needsRedraw = true;
    setTimeout(() => {
        swordActive = false;
        usePickaxeSword = false;
        highlightTiles = []; // Clear highlights after flash
        needsRedraw = true;
    }, 200);
}

function usePotion() {
    if (gameOver || splashActive || p.potions <= 0) return;
if (p.curseActive) {
    logBattleEvent(`Floor ${floor} - Cannot use potion: Lingering curse blocks healing!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Block and play sound for feedback
    }
    if (p.hp >= 36) {
        logBattleEvent(`Floor ${floor} - Potion Returned: HP already at max (36)!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Do not consume potion
    }
    p.potions--;
    const oldHP = p.hp;
    p.hp = Math.min(36, p.hp + 12);
    logBattleEvent(`Floor ${floor} - Potion Used: +${p.hp - oldHP} HP (now ${p.hp}/36)`);
    sounds.potion.play().catch(e => console.error('Potion sound error:', e));
    moveEnemies();
updateWisps(); // Update wisp pos/attacks synced to player/enemy turns
applyEnsnare();    // Druid Ensnare (lvl 20+)
    updatePlayerState();
    needsRedraw = true;
}

// 1.)
// PASSIVE TREE -- START
//

// Add these functions (mimic soul terminal exactly)
function openPassiveTerminal() {
    if (p.inPassiveTerminal) return; // Already in terminal
   
    p.inPassiveTerminal = true;
    p.passiveTerminalActive = true;
    p.passiveTerminalCommand = '';
    p.passiveTerminalCursorPos = 0;
   
    // Show passive terminal overlay
    const overlay = document.getElementById('passive-terminal-overlay');
    const content = document.getElementById('passive-terminal-content');
    const input = document.getElementById('passive-input');
   
    // Clear content and add welcome message
    content.innerHTML = '';
    addPassiveLineToContent('Welcome to Passive Terminal!');
    addPassiveLineToContent('Type "help" for available commands.');
    updatePassiveInventory();  // Mimic updateSoulTerminalInventory
   
    // Show overlay and focus input
    overlay.style.display = 'flex';
    console.log('Passive terminal opened, input element:', document.getElementById('passive-input'));
    setTimeout(() => {
        input.focus();
    }, 100);
}

function closePassiveTerminal() {
    if (!p.inPassiveTerminal) return;

    // Reset all passive flags
    p.inPassiveTerminal = false;
    p.passiveTerminalActive = false;
    passiveTreeActive = false;              // ← CRITICAL: reset this one too!
    passiveGracePeriod = false;             // if you use this

    p.passiveTerminalCommand = '';
    p.passiveTerminalCursorPos = 0;

    // Hide overlays
    document.getElementById('splash-screen').style.display = 'none';
    document.getElementById('passive-terminal-overlay').style.display = 'none';

    // FULL unblock — cover all bases
    inputBlocked = false;

    // Restore splash UI only if actually on splash
    if (splashActive) {
        document.getElementById('start-button').style.display = 'block';
        document.getElementById('info-icon').style.display = 'flex';
    }

    // Cleanup handlers (prevents stuck events)
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.onclick = null;
    splashScreen.ontouchend = null;

    const input = document.getElementById('passive-input');
    if (window.currentPassiveHandler) {
        input.removeEventListener('keydown', window.currentPassiveHandler);
        window.currentPassiveHandler = null;
    }

    // Refresh game state
    updateFogMap(p.x, p.y);
    needsRedraw = true;
}

function addPassiveLine(line) {
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value += line + '\n';
    battleEvents.scrollTop = battleEvents.scrollHeight;
}

function addPassiveLineToContent(line) {
    const content = document.getElementById('passive-terminal-content');
    const lineElement = document.createElement('div');
    lineElement.textContent = line;
    content.appendChild(lineElement);
    content.scrollTop = content.scrollHeight;
}

// Mimic updateSoulTerminalInventory for passive
function updatePassiveInventory() {  // Or keep as updatePassiveLog if preferred
    const content = document.getElementById('passive-terminal-content');
    content.innerHTML = '';
    // Display gems/bonuses (mimic soul inventory structure)
    addPassiveLineToContent('--- Gemstones Inventory ---');
    addPassiveLineToContent(`Ruby: ${p.gems.ruby}`);
    addPassiveLineToContent(`Citrine: ${p.gems.citrine}`);
    addPassiveLineToContent(`Sapphire: ${p.gems.sapphire}`);
    addPassiveLineToContent(`Emerald: ${p.gems.emerald}`);
    addPassiveLineToContent('--- Diamond Hand Enchants ---');
    addPassiveLineToContent(`Fire attack: +${p.gemAtk.fire.toFixed(1)}`);
    addPassiveLineToContent(`Cold attack: +${p.gemAtk.cold.toFixed(1)}`);
    addPassiveLineToContent(`Earth attack: +${p.gemAtk.earth.toFixed(1)}`);
    addPassiveLineToContent(`Lightning attack: +${p.gemAtk.lightning.toFixed(1)}`);
    addPassiveLineToContent('--- Enemy Debuffs ---');
    addPassiveLineToContent(`Shrimp / Crab defence: -${p.gemDef.shrimpCrab.toFixed(1)}`);
    addPassiveLineToContent(`Squid defence: -${p.gemDef.squid.toFixed(1)}`);
    addPassiveLineToContent(`Dolphin defence: -${p.gemDef.dolphin.toFixed(1)}`);
    addPassiveLineToContent(`Shark defence: -${p.gemDef.shark.toFixed(1)}`);
    addPassiveLineToContent('_____________________');
    addPassiveLineToContent('Type "help" for help.'); 
}

// 2.)
// PASSIVE TREE -- MIDDLE
//



// Add these functions near the other utility functions
function openSoulTerminal() {
    if (p.inSoulTerminal) return; // Already in terminal
    
    p.inSoulTerminal = true;
    p.soulTerminalActive = true;
    p.soulTerminalCommand = '';
    p.soulTerminalCursorPos = 0;
    
    // Show soul terminal overlay
    const overlay = document.getElementById('soul-terminal-overlay');
    const content = document.getElementById('soul-terminal-content');
    const input = document.getElementById('soul-terminal-input');
    
    // Clear content and add welcome message
    content.innerHTML = '';
    addTerminalLineToContent('Welcome to Soul Terminal!');
    addTerminalLineToContent('Type "help" for available commands.');
    updateSoulTerminalInventory();
    
    // Show overlay and focus input
    overlay.style.display = 'flex';
    setTimeout(() => {
        input.focus();
    }, 100);
}

function closeSoulTerminal() {
    p.inSoulTerminal = false;
    p.soulTerminalActive = false;
    p.soulTerminalCommand = '';
    p.soulTerminalCursorPos = 0;
    
    // Hide soul terminal overlay
    const overlay = document.getElementById('soul-terminal-overlay');
    overlay.style.display = 'none';
    
    // Restore input control
    inputBlocked = false;
    
    // Ensure player is properly positioned after terminal exit
    // This prevents teleportation issues when exiting soul terminal
    updateFogMap(p.x, p.y);
    
    needsRedraw = true;
}

function addTerminalLine(line) {
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value += line + '\n';
    battleEvents.scrollTop = battleEvents.scrollHeight;
}

function addTerminalLineToContent(line) {
    const content = document.getElementById('soul-terminal-content');
    const lineElement = document.createElement('div');
    lineElement.textContent = line;
    content.appendChild(lineElement);
    content.scrollTop = content.scrollHeight;
}

function updateSoulTerminalInventory() {
checkRunewords();
//    addTerminalLineToContent('');
            const clearContent = document.getElementById('soul-terminal-content');
            clearContent.innerHTML = '';
            addTerminalLineToContent('Soul Terminal ver 1.0');
            addTerminalLineToContent('');  
    // Display soul-related items
    addTerminalLineToContent('---- Soul Inventory ----');
    addTerminalLineToContent(`Soul Resonance: ${soulResonance}%`);
    addTerminalLineToContent(`Soul Stones: ${p.soulStones}`);
    addTerminalLineToContent(`Soul Orbs: ${p.soulOrbs}`);
    addTerminalLineToContent(`Soul Storm Charges: ${p.soulStormCharges}/256`);
    addTerminalLineToContent('');

    // Display regular inventory items
    addTerminalLineToContent('---- Regular Inventory ----');
    
// Display resistances (elemental and armor)
let resistanceText = '';
if (p.elementImmunity) {
    resistanceText += `${p.elementImmunity} 100%`;
}
if (p.armorImmunity) {
    if (resistanceText) resistanceText += ', ';
    resistanceText += `${p.armorImmunity} 100%`;
}
if (resistanceText) {
    addTerminalLineToContent(`Resistances: ${resistanceText}`);
    addTerminalLineToContent('');
}
// Cursed Ring vulnerability warning
if (p.hasCursedRing) {
    addTerminalLineToContent(`WARNING: Cursed Ring active, -100% to ALL resistances!`);
    addTerminalLineToContent(`Aura Shield: ${p.auraShield}/${p.auraMax}`);
    addTerminalLineToContent('');
}
    
    addTerminalLineToContent(`Health: ${p.hp}`);
    addTerminalLineToContent(`Potions: ${p.potions}`);
    addTerminalLineToContent(`Pickaxes: ${p.pickaxes}`);
    addTerminalLineToContent(`Diamonds: ${diamonds}`);
    addTerminalLineToContent(`Perfectly Cut Diamonds: ${document.getElementById('perfectlyCutDiamonds').textContent}`);
let fee = p.coolROI > 0 ? 49 - (p.coolROI - 1) * 1 : 50; // 49% at 1 ROI, 50% if none
fee = Math.max(25, fee); // cap at minimum 25%
addTerminalLineToContent(`Farm Spot Fee: ${fee}%`);    
    //addTerminalLineToContent(`Runes: ${document.getElementById('runes').textContent}`); // all runes
    // Get runes text and filter out runes ending with 0 (like p0)
    let runesText = document.getElementById('runes').textContent;
    let displayRunes = 'None'; // Default to 'None' if no runes remain
    if (runesText) {
        // Split by spaces and filter out runes ending with 0
        const runeArray = runesText.split(/\s+/).filter(rune => rune && !rune.endsWith('0'));
        if (runeArray.length > 0) {
            displayRunes = runeArray.join(' ');
        }
    }
    addTerminalLineToContent(`Runes: ${displayRunes}`);
    addTerminalLineToContent('');
//    addTerminalLineToContent('--- Audio Settings ---');
//    addTerminalLineToContent(`Sound Volume: ${(soundVolume * 100).toFixed(0)}%`);
//    addTerminalLineToContent(`Music Volume: ${(musicVolume * 100).toFixed(0)}%`);
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
}

function processSoulCommand(command) {
    const trimmed = command.trim();
    
    if (trimmed === '') return;
    
    // Clear screen before executing any command (always)
    const content = document.getElementById('soul-terminal-content');
    content.innerHTML = '';
            addTerminalLineToContent('Soul Terminal ver 1.0');
            addTerminalLineToContent('');
    // Parse command and arguments
    const parts = trimmed.split(' ');
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1);
    
    switch (cmd) {
case 'ls':
            updateSoulTerminalInventory();
            break;
case 'clear':
            const clearContent = document.getElementById('soul-terminal-content');
            // Check if there are arguments after 'clear'
            if (args.length > 0) {
                // Join all arguments with spaces to create the ASCII art text
                const asciiText = args.join(' ');
                // Create a simple ASCII art effect by displaying each character
                clearContent.innerHTML = '';
                addTerminalLineToContent(asciiText.padEnd(54));
            } else {
                clearContent.innerHTML = '';
            }
            break;
        case 'exit':
            closeSoulTerminal();
            return;
case 'help':
    addTerminalLineToContent('Available commands:');
    addTerminalLineToContent('  ls ---------- View inventory');
    addTerminalLineToContent('  convert ----- Convert stones');
    addTerminalLineToContent('  ------------> Or resurrect your wisp');
    addTerminalLineToContent('  reset ------- Restart puzzle trial');
    addTerminalLineToContent('  set --------- Settings');
    addTerminalLineToContent('  clear ------- Clear screen');
    addTerminalLineToContent('  leaderboard - View top 10 scores');
    addTerminalLineToContent('  exit -------- Exit terminal');
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
case 'convert':
    if (args.length === 0) {
        addTerminalLineToContent('Usage: convert stones [count]');
        addTerminalLineToContent('Usage: convert wisp');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
    } else {
        const type = args[0].toLowerCase();
        let count = 1; // Default to 1 if no count specified

        // Optional count (second argument)
        if (args.length > 1 && !isNaN(args[1])) {
            count = parseInt(args[1]);
            if (count < 1) count = 1;
        }

        switch (type) {
            case 'stones':
                // Convert in multiples of 6
                const maxStonesToConvert = Math.floor(p.soulStones / 6) * 6;
                count = Math.min(count, maxStonesToConvert);

                if (count >= 6) {
                    const orbsToGain = Math.floor(count / 6);
                    p.soulStones -= count;
                    p.soulOrbs += orbsToGain;
                    addTerminalLineToContent(
                        `Converted ${count} Soul Stones into ${orbsToGain} Soul Orb${orbsToGain === 1 ? '' : 's'}.`
                    );
                } else if (p.soulStones >= 6) {
                    // If no (or invalid) count given → convert minimum batch
                    p.soulStones -= 6;
                    p.soulOrbs += 1;
                    addTerminalLineToContent('Converted 6 Soul Stones into 1 Soul Orb.');
                } else {
                    addTerminalLineToContent(
                        `Need at least 6 Soul Stones (you have ${p.soulStones}).`
                    );
                }
                addTerminalLineToContent('_____________________');
                addTerminalLineToContent('Type "help" for help.');
                break;

            case 'wisp':
                if (floor < 3) {
                    addTerminalLineToContent('You must reach Floor 3 to resurrect a wisp.');
                } else if (wisps.length > 0) {
                    addTerminalLineToContent('You already have a loyal wisp companion.');
                } else if (p.soulOrbs >= 10) {
                    p.soulOrbs -= 10;
                    const wispType = WISP_TYPES[Math.floor(Math.random() * WISP_TYPES.length)];
                    wisps.push({
                        x: p.x,
                        y: p.y,
                        currentX: p.x * S,
                        currentY: p.y * S,
                        hp: Math.floor(p.hp / 2),
                        maxHP: Math.floor(p.maxHP / 2),
                        type: wispType,
                        attackCounter: 0,
                        targetTileX: p.x,
                        targetTileY: p.y,
                        deltaX: 0,
                        deltaY: 0,
                        stepsLeft: 0,
                        moving: false,
                        anim: { frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 },
                        lastPos: null
                    });
                    addTerminalLineToContent('10 Soul Orbs consumed – a loyal wisp came back to life!');
                    logBattleEvent(`Floor ${floor} - Wisp resurrected from the Soul Terminal!`);
                    playWebAudioSound(sounds.pickup);
                    setTimeout(() => playWebAudioSound(sounds.pickup), 100);
                    setTimeout(() => playWebAudioSound(sounds.pickup), 200);
                } else {
                    addTerminalLineToContent(`Need 10 Soul Orbs (you have ${p.soulOrbs}).`);
                }
                addTerminalLineToContent('_____________________');
                addTerminalLineToContent('Type "help" for help.');
                break;

            default:
                addTerminalLineToContent(`Unknown command: ${cmd} ${type}`);
                addTerminalLineToContent('Available: stones, wisp');
                addTerminalLineToContent('_____________________');
                addTerminalLineToContent('Type "help" for help.');
                break;
        }
    }
    break;
case 'reset':
    if (!inPuzzleRoom) {
        addTerminalLineToContent('ERROR: Can only reset from inside a trial!');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
        break;
    }
    puzzleCollectedHearts = 0;
    addTerminalLineToContent('Trial is reset!');
    addTerminalLineToContent('Type exit or press start on the gamepad.');
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');

        if (wisps.length > 0) {
            talkSpeak(7); // "take your time, no rush"
        }

    // Save current player position (so we don't teleport to @)
    const savedPlayerX = p.x;
    const savedPlayerY = p.y;

    // Reset puzzle state
    puzzleReturnPos = { x: p.x, y: p.y };
    puzzlePreviousTheme = currentTheme;
    enemies = [];
    isFetchingTxs = true;
    exit = null;
    currentTheme = 'dungeon';
    updateSnowState();
    musicManager.play('hideout');
    musicManager.current = 'hideout';

    puzzleHazards = [];
    puzzleArrows = [];
    puzzleBoulders = [];
    puzzleHeartFramers = [];
    puzzleChest = null;
    soulStashPos = null;
    farmSpot = null;

    const PX = 3, PY = 2;

    // Clear puzzle area
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (x >= PX && x < PX + 14 && y >= PY && y < PY + 12) {
                map[y][x] = 0;
            } else {
                map[y][x] = 1;
            }
        }
    }

    fogMap = Array(H).fill().map(() => Array(W).fill(1));

    const layoutStr = puzzleCurrentLayout;
    const layout = layoutStr.trim().split('\n');

    // Parse layout but PRESERVE player position
    for (let y = 0; y < layout.length; y++) {
        for (let x = 0; x < layout[y].length; x++) {
            const cx = PX + x;
            const cy = PY + y;
            const ch = layout[y][x];

            if (ch === '#') map[cy][cx] = 1;
            if (ch === '@') {
                // DO NOT move player — keep saved position
                // Just treat as floor
                map[cy][cx] = 0;
            }
            if (ch === 'B') { puzzleBoulders.push({x:cx, y:cy, pushed: false}); map[cy][cx] = 26; }
            if (ch === 'H') puzzleHeartFramers.push({x:cx,y:cy});
            if (ch === 'C') puzzleChest = {x:cx,y:cy};
            if (ch === 'L') { puzzleHazards.push({x:cx,y:cy,type:'lava'}); map[cy][cx] = 6; }
            if (ch === '>') puzzleArrows.push({x:cx,y:cy,dir:'right'});
            if (ch === '<') puzzleArrows.push({x:cx,y:cy,dir:'left'});
            if (ch === '^') puzzleArrows.push({x:cx,y:cy,dir:'up'});
            if (ch === 'v') puzzleArrows.push({x:cx,y:cy,dir:'down'});
            if (ch === 'S') { map[cy][cx] = 19; soulStashPos = {x:cx, y:cy}; }
            if (ch === 'F') { map[cy][cx] = 27; farmSpot = {x:cx, y:cy}; }
        }
    }

    // Restore saved player position
    p.x = savedPlayerX;
    p.y = savedPlayerY;
    p.currentX = p.x * S;
    p.currentY = p.y * S;

    // Rebuild static background (same as startPuzzleRoom)
    puzzleStaticCanvas = document.createElement('canvas');
    puzzleStaticCanvas.width = 320;
    puzzleStaticCanvas.height = 320;
    puzzleStaticCtx = puzzleStaticCanvas.getContext('2d');

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, x*S, y*S, S, S);
            if (map[y][x] === 1) puzzleStaticCtx.drawImage(assets.themes.dungeon.wall, x*S, y*S, S, S);
            if (map[y][x] === 6) puzzleStaticCtx.drawImage(assets.themes.hell.special, x*S, y*S, S, S);
            if (map[y][x] === 19) puzzleStaticCtx.drawImage(assets.soul_stash, x*S, y*S, S, S);
if (map[y][x] === 27) {
    // Choose farm spot image based on farm state
    const img = p.farmLocked && floor > p.farmLockedFloor ? assets.farmSpot2 : assets.farmSpot1;
    puzzleStaticCtx.drawImage(img, x * S, y * S, S, S);
}
        }
    }

    // Arrows (if you have pre-rotated sprites)
    const arrowSprites = {
        up: assets.arrow_up,
        right: assets.arrow_right,
        down: assets.arrow_down,
        left: assets.arrow_left
    };
    puzzleArrows.forEach(a => {
        const sprite = arrowSprites[a.dir];
        if (sprite?.complete) {
            puzzleStaticCtx.drawImage(sprite, a.x * S, a.y * S, S, S);
        }
    });
    
    logBattleEvent("The trial has been reborn from the void...");
    needsRedraw = true;
    closeSoulTerminal();
    break;
case 'set':
    if (args.length === 0) {
        addTerminalLineToContent('Settings:');
        addTerminalLineToContent(' set sound [0-100] – Control sound volume');
        addTerminalLineToContent(' set music [0-100] – Control music volume');
        addTerminalLineToContent(' set zoom [on/off] – 2× zoom on playfield');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
    } else {
        const subCmd = args[0].toLowerCase();
        if (subCmd === 'sound') {
            if (args.length < 2) {
                addTerminalLineToContent('Usage: set sound [volume]');
                addTerminalLineToContent('Example: set sound 50');
            } else {
                const volume = parseFloat(args[1]);
                if (isNaN(volume) || volume < 0 || volume > 100) {
                    addTerminalLineToContent('ERROR! Volume must be 0–100');
                } else {
                    setSoundVolume(volume / 100);
                    addTerminalLineToContent(`Sound volume set to ${volume}%`);
                }
            }
        }
        else if (subCmd === 'music') {
            if (args.length < 2) {
                addTerminalLineToContent('Usage: set music [volume]');
                addTerminalLineToContent('Example: set music 75');
            } else {
                const volume = parseFloat(args[1]);
                if (isNaN(volume) || volume < 0 || volume > 100) {
                    addTerminalLineToContent('ERROR! Volume must be 0–100');
                } else {
                    setMusicVolume(volume / 100);
                    addTerminalLineToContent(`Music volume set to ${volume}%`);
                }
            }
        }
        else if (subCmd === 'zoom') {
            if (args.length < 2) {
                addTerminalLineToContent('Usage: set zoom [on/off]');
                addTerminalLineToContent('Current: ' + (zoomEnabled ? 'ON' : 'OFF'));
            } else {
                const state = args[1].toLowerCase();
                if (state === 'on' || state === 'true' || state === '1') {
                    zoomEnabled = true;
                    localStorage.setItem('zoomEnabled', 'true');
                    minimapVisible = zoomEnabled;
                    needsRedraw = true;
                    addTerminalLineToContent('2× ZOOM ACTIVATED – PLAYFIELD ONLY');
                }
                else if (state === 'off' || state === 'false' || state === '0') {
                    zoomEnabled = false;
                    localStorage.setItem('zoomEnabled', 'false');
                    camera.x = p.x * S + S/2 - 160;
                    camera.y = p.y * S + S/2 - 160;
                    addTerminalLineToContent('2× zoom deactivated');
                    addTerminalLineToContent('Back to classic 1:1 view');
                }
                else {
                    addTerminalLineToContent('Invalid argument – set "on" or "off"');
                }
                needsRedraw = true;
            }
        }
        else {
            addTerminalLineToContent('Unknown setting – set sound, music or zoom');
        }
    }
    break;
case 'leaderboard':
    if (!cachedLeaderboard || cachedLeaderboard.length === 0) {
        addTerminalLineToContent('No cached leaderboard available. Play more to fetch!');
    } else {
        const leaderboardTotalSats = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
        const displayedMultText = document.getElementById('sats-calc').textContent.trim();
        const multMatch = displayedMultText.match(/:\s*([\d.]+)\s*(sats|BTC)/);
        const leaderboardPlayerScore = multMatch ? (multMatch[2] === 'BTC' ? parseFloat(multMatch[1]) * 1e8 : parseInt(multMatch[1])) : leaderboardTotalSats;
        const playerEst = getPlayerEstimatedRank(cachedLeaderboard, leaderboardTotalSats, floor);
        
        // Format cached list with player inserted
        const maxUsernameLength = 20;
        const numberWidth = 10;
        
        let rows = cachedLeaderboard.slice(0, 10).map((entry, index) => {
            const rank = (index + 1).toString().padStart(2, '0');
            const username = entry.username.length > maxUsernameLength
                ? entry.username.substring(0, maxUsernameLength - 2) + '..'
                : entry.username;
            const scoreValue = entry.score;
            let numberPart, unitPart;
            if (scoreValue >= 1e8) {
                numberPart = (scoreValue / 1e8).toFixed(1);
                unitPart = 'BTC';
            } else {
                numberPart = scoreValue.toString();
                unitPart = 'sats';
            }
            return `Rank: ${rank}, ${username}, ${numberPart} ${unitPart}`;
        });
        
        // Insert player at estimated rank if in top 10
        const playerUsername = 'You';
        let playerNumberPart, playerUnitPart;
        if (leaderboardPlayerScore >= 1e8) {
            playerNumberPart = (leaderboardPlayerScore / 1e8).toFixed(1);
            playerUnitPart = 'BTC';
        } else {
            playerNumberPart = leaderboardPlayerScore.toString();
            playerUnitPart = 'sats';
        }
        const playerRow = `Rank: ${playerEst.rank.toString().padStart(2, '0')}, ${playerUsername}, ${playerNumberPart} ${playerUnitPart}`;
        
        if (playerEst.rank <= 10) {
            rows.splice(playerEst.rank - 1, 0, playerRow); // Insert at rank (shifts others down)
            rows = rows.slice(0, 10); // Limit to top 10 including player
        }
        
        // Format for display (no header)
        let fullText = `Top 10 scores (leaderboard)`;
        rows.forEach(row => {
            fullText += `\n${row}`;
        });
        
        if (playerEst.rank > 10) {
            const estRow = `Rank: ??, ${playerUsername}, ${playerNumberPart} ${playerUnitPart}`;
            fullText += `\n${estRow}`;
        }
        
        const lines = fullText.split('\n');
        lines.forEach(line => addTerminalLineToContent(line));
    }
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
        default:
            addTerminalLineToContent(`Command not found: ${cmd}`);
            addTerminalLineToContent('_____________________');
            addTerminalLineToContent('Type "help" for help.');
    }
}

function activateSoulStorm() {
    // Create a horizontal wave of 3 tiles that lights up with soul light
    const damageArea = [];
    
    // Determine damage tiles based on direction
    if (swordDir === 'up') {
        const close_y = p.y - 1;
        const far_y = p.y - 2;
        for (let dx = -1; dx <= 1; dx++) {
            damageArea.push({x: p.x + dx, y: close_y});
        }
        for (let dx = -2; dx <= 2; dx++) {
            damageArea.push({x: p.x + dx, y: far_y});
        }
    } else if (swordDir === 'down') {
        const close_y = p.y + 1;
        const far_y = p.y + 2;
        for (let dx = -1; dx <= 1; dx++) {
            damageArea.push({x: p.x + dx, y: close_y});
        }
        for (let dx = -2; dx <= 2; dx++) {
            damageArea.push({x: p.x + dx, y: far_y});
        }
    } else if (swordDir === 'left') {
        const close_x = p.x - 1;
        const far_x = p.x - 2;
        for (let dy = -1; dy <= 1; dy++) {
            damageArea.push({x: close_x, y: p.y + dy});
        }
        for (let dy = -2; dy <= 2; dy++) {
            damageArea.push({x: far_x, y: p.y + dy});
        }
    } else if (swordDir === 'right') {
        const close_x = p.x + 1;
        const far_x = p.x + 2;
        for (let dy = -1; dy <= 1; dy++) {
            damageArea.push({x: close_x, y: p.y + dy});
        }
        for (let dy = -2; dy <= 2; dy++) {
            damageArea.push({x: far_x, y: p.y + dy});
        }
    }
    
    // Apply damage to all valid tiles in the area
    const damage = 1; // 1 damage per hit
    let enemiesHit = 0;
    let totalDamage = 0;
    
    highlightTiles = []; // Clear previous highlights
    for (const tile of damageArea) {
        const {x, y} = tile;
        
        // Check if tile is within bounds and not a wall
        if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 1) {
            highlightTiles.push({x, y, highlightStart: Date.now()}); // Add tile to highlight
            // And add this ONCE per frame (best in draw() or gameLoop):
            highlightTiles = highlightTiles.filter(t => Date.now() - t.highlightStart < 500);
            // Check if there's an enemy at this tile
            const enemy = enemies.find(e => e.x === x && e.y === y);
            
if (enemy) {
    const isSoulSword = p.soulStormCharges >= 4;
    const isDiamondHand = p.hasDiamondHand && !usePickaxeSword;

    let actualDamage = 0;
    let message = "";

// Elemental Damage patch
if (isDiamondHand) {
    const baseDmg = 3;
    const elemDmg = elementalBonus; // Unlimited — no cap
    const totalDmg = baseDmg + elemDmg;
    
    enemy.hp -= totalDmg;
    
    if (elemDmg > 0) {
        // Enchanted: show breakdown
        message = `Diamond Hand hits ${enemy.type.name} for ${baseDmg} base + ${elemDmg.toFixed(1)} elemental (${totalDmg.toFixed(1)} total)!`;
    } else {
        // Not enchanted: simple message
        message = `Diamond Hand hits ${enemy.type.name} for ${baseDmg} DMG!`;
    }   
    playWebAudioSound(sounds.hit);
}
    else if (isSoulSword) {
        // Soul Sword AOE wave = only 1 damage, ignores shield
        actualDamage = 1;
        enemy.hp -= 1;
        message = `Soul Sword wave hits ${enemy.type.name} for 1 DMG!`;
    }
    else if (enemy.bitAmmo > 0) {
        // Normal attack blocked by bit shield
        enemy.bitAmmo--;
        enemy.bits = enemy.bitAmmo;
        enemy.shieldFlash = { active: true, startTime: Date.now() };
        message = `${enemy.type.name} blocks with bit shield!`;
        playWebAudioSound(sounds.hit);
    }
    else {
        // Normal melee attack = 2 damage
        actualDamage = 2;
        enemy.hp -= 2;
        message = `Hit ${enemy.type.name} for 2 DMG!`;
    }

    // Only log and play sound if damage was actually dealt
    if (actualDamage > 0) {
        logBattleEvent(`Floor ${floor} - ${message}`);
        playWebAudioSound(sounds.hit);
    }

    // FULL DEATH — no mercy rule, no 1 HP leftovers
    if (enemy.hp <= 0) {
        kills[enemy.type.name]++;
        let xp = 0;
        if (enemy.type.name === 'Shrimp') xp = 1;
        else if (enemy.type.name === 'Crab') xp = 2;
        else if (enemy.type.name === 'Squid') xp = 3;
        else if (enemy.type.name === 'Dolphin') xp = 4;
        else if (enemy.type.name === 'Shark') xp = 5;
        else if (enemy.type.name === 'Whale') xp = 15;
        else if (enemy.type.name === 'Cursed Trader') xp = 10;
        else if (enemy.type.name === 'Jester') xp = 2;
        else if (enemy.type.name === 'Red Maze') xp = 30; // just in case
        if (enemy.uniqueName) xp *= 2; // Unique monsters give 2x XP
        playerXP += xp;
        //if (xp > 0) logBattleEvent(`+${xp} XP`);
        checkLevelUp();
        updateXPBar(); // Only called on kills - super efficient
        
if (enemy.type.name === 'Jester' && Math.random() < 0.25) {
    const gemTypes = ['ruby', 'sapphire', 'emerald', 'citrine'];
    const gem = gemTypes[Math.floor(Math.random() * gemTypes.length)];
    
    // Try to place on death spot
    let placed = false;
    if (map[enemy.y][enemy.x] === 0) {
        map[enemy.y][enemy.x] = GEM_TILES[gem];
        placed = true;
    } else {
        // Try adjacent tiles
        const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
        for (const d of dirs) {
            const nx = enemy.x + d.dx;
            const ny = enemy.y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                map[ny][nx] = GEM_TILES[gem];
                placed = true;
                break;
            }
        }
    }
    
    if (placed) {
        logBattleEvent(`Jester dropped a ${gem} on the floor!`);
        playWebAudioSound(sounds.pickup);
    } else {
        // Fallback: add directly to inventory if no space
        p.gems[gem]++;
        logBattleEvent(`Jester dropped a ${gem} directly to you (no floor space)!`);
        playWebAudioSound(sounds.pickup);
    }
    
    updatePlayerState();
}
        
        // === SIDE QUEST PROGRESS (new) ===
        handleSideQuestKill(enemy.type.name, enemy.x, enemy.y);

        // === EXISTING REWARDS (unchanged – bounty works via this call) ===
        handleUniqueMonsterReward(enemy);
        tryDropScroll(enemy.x, enemy.y);

        // Drop satoshi (skip uniques & Cursed Trader)
        if (!enemy.uniqueName && enemy.type.name !== 'Cursed Trader' && enemy.type.name !== 'Jester' && !enemy.isHuge) {
            let dropPlaced = false;
            if (map[enemy.y][enemy.x] === 0) {
                map[enemy.y][enemy.x] = 3;
                satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                dropPlaced = true;
            } else {
                const adjacent = [
                    {x: enemy.x, y: enemy.y - 1},
                    {x: enemy.x, y: enemy.y + 1},
                    {x: enemy.x - 1, y: enemy.y},
                    {x: enemy + 1, y: enemy.y}
                ];
                for (const pos of adjacent) {
                    const {x: nx, y: ny} = pos;
                    if (nx >= 0 && nx < W && ny >= 0 && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                        map[ny][nx] = 3;
                        satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                        dropPlaced = true;
                        break;
                    }
                }
            }
        }

        // Cursed Ring drop (50% chance for Cursed Trader only)
        if (enemy.type.name === 'Cursed Trader' && Math.random() < 0.5 && !p.hasCursedRing) {
            let ringPlaced = false;
            if (map[enemy.y][enemy.x] === 0) {
                map[enemy.y][enemy.x] = 23;
                ringPlaced = true;
            } else {
                const adjacent = [
                    {x: enemy.x, y: enemy.y - 1},
                    {x: enemy.x, y: enemy.y + 1},
                    {x: enemy.x - 1, y: enemy.y},
                    {x: enemy.x + 1, y: enemy.y}
                ];
                for (const pos of adjacent) {
                    const {x: nx, y: ny} = pos;
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                        map[ny][nx] = 23;
                        ringPlaced = true;
                        break;
                    }
                }
            }
            if (ringPlaced) {
                logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                playWebAudioSound(sounds.pickup);
            }
        }

        // Cursed Trader soul stone drop
        if (enemy.type.name === 'Cursed Trader') {
            dropSoulStone(enemy.x, enemy.y);
        }

        // Remove the dead enemy

                if (enemy.isHuge) {
                    if (!enemy.deathTime) enemy.deathTime = performance.now();
                    dropSoulStone(enemy.x, enemy.y);
                    
// 50% potion drop
    if (Math.random() < 0.5) {
        if (map[enemy.y][enemy.x] === 0) {
            map[enemy.y][enemy.x] = 2;
        } else {
            const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
            for (let d of dirs) {
                const nx = enemy.x + d.dx, ny = enemy.y + d.dy;
                if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0) {
                    map[ny][nx] = 2;
                    break;
                }
            }
        }
        logBattleEvent(`Huge Shrimp dropped a Potion!`);
        playWebAudioSound(sounds.pickup);
    }                    
                    
                    playerXP += 15;
                    logBattleEvent(`+15 XP`);
                    checkLevelUp();
                    updateXPBar();
                }
                enemies = enemies.filter(en => en !== enemy);
        
        enemiesHit++;
    }

    totalDamage += actualDamage;
}
        }
    }
    
    if (enemiesHit > 0) {
        logBattleEvent(`Soul Storm hit ${enemiesHit} enemies for ${totalDamage} total damage!`);
    }
}

function handleTerminalInput(e) {
    const key = e.key;
    
    // If terminal is not focused, focus it and add the key
    if (!document.activeElement.matches('#soul-terminal-input')) {
        const input = document.getElementById('soul-terminal-input');
        input.focus();
        input.value = p.soulTerminalCommand; // Update value to reflect current command
        
        // Handle key press immediately
        if (key.length === 1 && key !== 'Enter') {
            const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
            const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
            p.soulTerminalCommand = before + key + after;
            p.soulTerminalCursorPos++;
            input.value = p.soulTerminalCommand.substring(1); // One-liner hack to remove first character
        }
        
        return;
    }
    
    if (key === 'Enter') {
        e.preventDefault();
        processSoulCommand(p.soulTerminalCommand);
        p.soulTerminalCommand = '';
        p.soulTerminalCursorPos = 0;
        // Blur the input field when Enter is pressed
        const input = document.getElementById('soul-terminal-input');
        if (input) {
            input.blur();
        }
        return;
    }
    
    if (key === 'Backspace') {
        if (p.soulTerminalCursorPos > 0) {
            p.soulTerminalCommand = 
                p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos - 1) + 
                p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
            p.soulTerminalCursorPos--;
        }
        return;
    }
    
    if (key === 'ArrowLeft' && p.soulTerminalCursorPos > 0) {
        p.soulTerminalCursorPos--;
        return;
    }
    
    if (key === 'ArrowRight' && p.soulTerminalCursorPos < p.soulTerminalCommand.length) {
        p.soulTerminalCursorPos++;
        return;
    }
    
    // Add regular character
    if (key.length === 1 && key !== 'Enter') {
        const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
        const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
        p.soulTerminalCommand = before + key + after;
        p.soulTerminalCursorPos++;
    }
}

// Add this function to handle terminal input when not focused
function handleBlurredTerminalInput(key) {
    const input = document.getElementById('soul-terminal-input');
    if (input && !input.matches(':focus')) {
        // Focus the input field
        input.focus();
        
        // Update command with new key
        const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
        const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
        p.soulTerminalCommand = before + key + after;
        p.soulTerminalCursorPos++;
        
        // Update display
        input.value = p.soulTerminalCommand.substring(1);
    }
}

// Function to create dangerous spell area (called when unique monster uses a spell)
function createDangerousArea(x, y, spellType) {
    dangerousAreas.push({
        x: x,
        y: y,
        spellType: spellType,
        startTime: Date.now()  // For pulse animation
    });
    needsRedraw = true;
}

// ———————————————————————————————————————————————————————
// PUZZLE ROOM SYSTEM — L2 Style (final, perfect)
// ———————————————————————————————————————————————————————

// Puzzle designs
// NOTICE!
// parsing REQUIRE no spaces or empty lines here to work
const PUZZLE_TEMPLATES = {
    common: [
`##############
#BHB.........#
#.B......B...#
#.<<<<<<<L<<.#
#.vLL.....L^.#
#.vLL.B.LLL^.#
#.vLLBCBLLL^.#
#.vLLBBBLLL^.#
#.v>>>>>>>>^.#
S............#
F....@.......#
##############`,
`##############
#..L.....BBB.#
#.BHB....BHB.#
#.BBB.....L..#
#............#
#............#
#.....C......#
#......B.....#
#...@........#
S............#
F............#
##############`,
`##############
#C........HLL#
#.LLLLLLLLLLL#
#.LLLLLLLLLLL#
#BLL.........#
#.LL..B......#
#LLL.B.......#
#HLL.........#
#LLL......@..#
S............#
F............#
##############`,
`##############
##L.L....L.L##
###HLL..L.L###
####.L..LH####
#####L..L#####
######..######
#.....@......#
#.B..........#
#............#
S.....HC...B.#
F............#
##############`,
`##############
#LLL...#.....#
#LHL...#.##..#
#LLL...#..#..#
#......#.B#..#
#......##....#
#............#
#.....C......#
#..@.........#
S............#
F............#
##############`,
`##############
##############
#............#
#.LLL.B...LL.#
#.LH.......L.#
#.L.#####..L.#
#...#C..>....#
#.L.#.@.#..L.#
#.L.#...#.HL.#
S.L.#####LLL.#
F............#
##############`,
`##############
#####L.#######
#####L.C.#####
##BLLLBBLLLB##
##..H....H..##
##..........##
#............#
#............#
#............#
S.........@..#
F............#
##############`,
`##############
#..LLLLLLLLL.#
#..#LLLLLLL#.#
#..##LLLLL##.#
#..#H<...<H#.#
#..#HH#B#HH#.#
#..<HHLLLHH#.#
#..#LLLCLLL#.#
#..#.......#.#
S..#...B...#.#
F....@.......#
##############`,
`##############
#............#
#...###LLL...#
#...#HHHLL#..#
#.B.#LLCLL#..#
#...#LL>HBL..#
#...#LL###...#
#...##.......#
#...##.....B.#
S.B....@.....#
F............#
##############`,
`##############
#......#.....#
#.....#H#....#
#....#HHH#...#
#...#HHHHH#..#
#...#LLHLL#..#
#.@.#HLLLH#..#
#..#LLLBLLL#.#
#..#...C...#.#
S..#.B...B.#.#
F............#
##############`,
    ],
    rare: [
`##############
#..#..#..#...#
#.BL..#.BL.B.#
#..#..#..#BCB#
#..#..#..#.B.#
#..#..#..#...#
#..#..#..#LLL#
#..#..#..#LLL#
#@.#..#..#...#
S..#.BL..#.H.#
F..#..#..#...#
##############`,
`##############
#....BLLL....#
#...B.##..H..#
#..B..##BBBBB#
#.....##..L..#
#.....###LLL##
#.....##..L..#
#.....##.....#
#.@...##.....#
S.....##..C..#
F.....##.....#
##############`,
`##############
#H.#....#...H#
#..#....<....#
#L##....#.B..#
#.......#....#
#.......######
#..@.........#
#....B.......#
#.....C...##L#
S.........#..#
F.........#.H#
##############`,
`##############
##########LCL#
##########LBL#
#LHLLHLLHLLHL#
#............#
#............#
#............#
#LHLLHLLHLLHL#
#.B..B..B....#
S...@........#
F............#
##############`,
`##############
##############
#..#HLBHLLH#.#
#..#.LL#LLL..#
#..#v..B..v..#
#....B...B...#
#............#
#............#
#.....C.@....#
S............#
F............#
##############`,
`##############
#LLLLLLLLLLLL#
#L>.^......<L#
#L>@^......<.#
#L>.^......<H#
#L>........<L#
#L>.^......<L#
#L>.^...###<L#
#...^...#.B.L#
S.LLL...#...L#
F.LCL......LL#
##############`,
`##############
#............#
#.#####.####.#
#.#....B...#.#
#.#..##L##.#.#
#.#..#.C.#.#.#
#.#.H#LLL#H#.#
#.#LL#.###.#.#
#.#....LH..#.#
S..@.B.#####.#
F............#
##############`,
`##############
#............#
#...H...H....#
#....LLLL....#
#..B.LCHL....#
#....LLLL.B..#
#.@..LLL.....#
#....LLLL....#
#....LHHL....#
S...HLLLL....#
F.......H....#
##############`,
`##############
#............#
#...####.....#
#...LCL#.....#
#...LLL##....#
#...LLLL#....#
#......B.....#
#......LLL#..#
#..@...CHB<..#
S......LLLL..#
F............#
##############`,
`##############
#......#.....#
#.....#L#....#
#....#LLL#...#
#...#LHLHL#..#
#..#LLLBLLL#.#
#.#H.LBCBL.H##
######LLL#####
#......B.....#
S.........@..#
F............#
##############`,
    ],
    legendary: [
`##############
#LHLLLLLLLLLL#
#LLLLLLLLLLLL#
#.BLLL.LLLLLL#
#.BLBLCLBLLLL#
#.BLLL.LLLBHB#
#..LLLLLLL.B.#
#..LLLLLLL...#
#..v<<<>>#<<<#
S..>>>@....B.#
F............#
##############`,
`##############
#BC.B.###....#
#B.BB.LHL....#
#BB.B.###....#
#.....######.#
#.....##...#.#
#.....B....#.#
#.....##...#.#
#.....##...#.#
S...@...B..#.#
F.....##H###H#
##############`,
`##############
#........LLLL#
#..B.B...BLHL#
#..@...B.LLLL#
#.......LLLLL#
#..BBB..LLLLL#
#.....LLLLLLL#
#.....LLLLLLL#
#..LLLLLLLH.L#
S..LHLLLLL.CL#
F..LLLLLLLLLL#
##############`,
`##############
#....LvHL....#
#....Lv^L....#
#....Lv^L....#
#.B..Lv^L....#
#....Lv^L....#
#....Lv^L....#
#..B.Lv^L....#
#....Lv^L....#
S..@.Lv^L..C.#
F....<H^L....#
##############`,
`##############
#............#
#LLL..B.B.LLL#
#LLL......LLL#
#vvvv^LLLLvvv#
#...L^LLLL...#
#.B.LC>H>..B.#
#...LLLLL....#
#.L........L.#
S.LL...@..LL.#
F............#
##############`,
`##############
#............#
#.#...B....#L#
#.LL<<<<<<<<L#
#...#LLLL#..L#
#....LC#L...L#
#.@..L#H....L#
#...#LLLL#..L#
#.>>>>>>>>>>.#
S.#....B...#.#
F............#
##############`,
`##############
#............#
#.H..........#
#....LvLLL...#
#....L...>.@.#
#....L.B.>...#
#....LLLLLLLL#
#....L.B.LLLL#
#....>.HBLLCL#
S.H..LvLLLLLL#
F............#
##############`,
`##############
#............#
#....##......#
#...#HL#.....#
#..#LLLL#....#
#.#LLBCLL#...#
#..<..^B..#..#
#...#H^..>...#
#....#^.#....#
S.@...#v..B..#
F............#
##############`,
`##############
#LLLL........#
#HLvL........#
##LLL........#
###.......B..#
#....B.......#
#............#
#.........@..#
#.....C......#
S............#
F............#
##############`,
`##############
#...L.L.L.L..#
#.B.L.L.L.L..#
#.B.LBLBLHL..#
#.L.L.L.L.L..#
#.L.L.L.L.L..#
#.L.L.L.L.L.C#
#@L.L.L.L.L..#
#.L.L.L.L.L..#
S.L.L.L.L.L..#
F.L.L.L.L.L..#
##############`,
    ],
};

function startPuzzleRoom() {
    inPuzzleRoom = true;
catPos = null;
catVisible = false;
sandworm = null;
    puzzleReturnPos = { x: p.x, y: p.y };
    puzzlePreviousTheme = currentTheme;
    enemies = [];
    stopFireplaceAmbience(); // Stop ambience in puzzle rooms
    // Kill ALL enemies instantly (including invisible Cursed Trader) — ensures death effects/drops if any carry over
    enemies.forEach(e => e.hp = 0);
    isFetchingTxs = true;
    exit = null;

    const PX = 3, PY = 2;
    const PW = 14, PH = 12;

    currentTheme = 'dungeon';
    updateSnowState();
    musicManager.play('hideout');
    musicManager.current = 'hideout';

    // Clear puzzle area
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (x >= PX && x < PX + PW && y >= PY && y < PY + PH) {
                map[y][x] = 0;
            } else {
                map[y][x] = 1;
            }
        }
    }
    fogMap = Array(H).fill().map(() => Array(W).fill(1));

    // Reset puzzle state
    puzzleHazards = [];
    puzzleArrows = [];
    puzzleBoulders = [];
    puzzleHeartFramers = [];
    puzzleChest = null;
    soulStashPos = null;
    farmSpot = null;

    // Layout selection
    let tierTemplates;
    if (floor >= 30) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare, ...PUZZLE_TEMPLATES.legendary];
    else if (floor >= 15) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare];
    else tierTemplates = PUZZLE_TEMPLATES.common;

    // Use saved layout if resetting, else pick new and save it
    if (!puzzleCurrentLayout) {
        let tierTemplates;
        if (floor >= 30) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare, ...PUZZLE_TEMPLATES.legendary];
        else if (floor >= 15) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare];
        else tierTemplates = PUZZLE_TEMPLATES.common;
        puzzleCurrentLayout = tierTemplates[Math.floor(Math.random() * tierTemplates.length)];
    }
    const layoutStr = puzzleCurrentLayout;
    const layout = layoutStr.trim().split('\n');

    // Parse layout
    for (let y = 0; y < layout.length; y++) {
        for (let x = 0; x < layout[y].length; x++) {
            const cx = PX + x;
            const cy = PY + y;
            const ch = layout[y][x];

            if (ch === '#') map[cy][cx] = 1;
            if (ch === '@') { p.x = cx; p.y = cy; p.currentX = cx * S; p.currentY = cy * S; }
            if (ch === 'B') { puzzleBoulders.push({x:cx, y:cy, pushed: false}); map[cy][cx] = 26; }
            if (ch === 'H') puzzleHeartFramers.push({x:cx, y:cy});
            if (ch === 'C') puzzleChest = {x:cx, y:cy};
            if (ch === 'L') { puzzleHazards.push({x:cx, y:cy, type:'lava'}); map[cy][cx] = 6; }
            if (ch === '>') puzzleArrows.push({x:cx, y:cy, dir:'right'});
            if (ch === '<') puzzleArrows.push({x:cx, y:cy, dir:'left'});
            if (ch === '^') puzzleArrows.push({x:cx, y:cy, dir:'up'});
            if (ch === 'v') puzzleArrows.push({x:cx, y:cy, dir:'down'});
            if (ch === 'S') { map[cy][cx] = 19; soulStashPos = {x:cx, y:cy}; }
            if (ch === 'F') { map[cy][cx] = 27; farmSpot = {x:cx, y:cy}; }
        }
    }

    // ───── PRE-RENDER STATIC BACKGROUND (walls, floors, lava, arrows) ─────
    puzzleStaticCanvas = document.createElement('canvas');
    puzzleStaticCanvas.width = 320;
    puzzleStaticCanvas.height = 320;
    puzzleStaticCtx = puzzleStaticCanvas.getContext('2d');

// Static tiles + puzzle objects – FLOOR FIRST, then overlays (no black background)
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        // Always draw floor under everything
        puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, x*S, y*S, S, S);

        // Then overlay walls, lava, soul stash, farm spot
        if (map[y][x] === 1) puzzleStaticCtx.drawImage(assets.themes.dungeon.wall, x*S, y*S, S, S);
        if (map[y][x] === 6) puzzleStaticCtx.drawImage(assets.themes.hell.special, x*S, y*S, S, S);
        if (map[y][x] === 19) puzzleStaticCtx.drawImage(assets.soul_stash, x*S, y*S, S, S);
if (map[y][x] === 27) {
    let img = assets.farmSpot1; // default: empty dirt

    if (p.farmLocked) {
        // Farm is still active (waiting for harvest)
        // Show matured version ONLY while waiting on a later floor
        if (floor > p.farmLockedFloor) {
            img = assets.farmSpot2;
        }
        // else: still on planting floor → show farmSpot1 (just planted)
    }
    // If not locked → already harvested → stay farmSpot1 (empty)

    puzzleStaticCtx.drawImage(img, x * S, y * S, S, S);
}
    }
}

    // Pre-rotated arrows
    const arrowSprites = {
        up:    assets.arrow_up,
        right: assets.arrow_right,
        down:  assets.arrow_down,
        left:  assets.arrow_left
    };
    puzzleArrows.forEach(a => {
        const sprite = arrowSprites[a.dir];
        if (sprite?.complete) {
            puzzleStaticCtx.drawImage(sprite, a.x * S, a.y * S, S, S);
        }
    });

puzzleTotalHearts = puzzleHeartFramers.length;
puzzleCollectedHearts = 0; // safety reset

    // UI
    document.getElementById('floor-indicator').textContent =
        floor >= 30 ? 'LEGENDARY TRIAL' :
        floor >= 15 ? 'Rare Trial' : 'Trial of Wisdom';
    logBattleEvent("A sacred trial of wisdom begins...");
    needsRedraw = true;
}

function finishPuzzleRoom() {
// Force clear cat in Glitch Zone transition
catPos = null;
catVisible = false;
catAnimStart = 0;
    logBattleEvent("The ancient chest opens... power surges through you!");
    if (wisps.length > 0) wispSpeak('victory');

// REWARDS BASED ON FLOOR — fair, consistent, feels earned
if (floor >= 30) {
    // Legendary tier floors — always give diamond + soul orb + RIP runes
    diamonds += 1;
    p.soulOrbs += 1;
    p.runes.push('r','i','p');
    logBattleEvent("LEGENDARY REWARD: +1 Diamond +1 Soul Orb + RIP runes!");
    if (wisps.length > 0) {
    talkSpeak(12); // "yes, Deiamond. Soul-Orb . RIP"
    }
} else if (floor >= 15) {
    // Rare tier floors — always give pickaxe + RIP runes
    p.pickaxes += 1;
    p.runes.push('r','i','p');
    logBattleEvent("RARE REWARD: +1 Pickaxe + RIP runes!");
    if (wisps.length > 0) {
    talkSpeak(13); // "yes,. PiickAaXe , RIP"
    }
} else {
    // Common tier floors — just pickaxe
    p.pickaxes += 1;
    logBattleEvent("Trial complete! +1 Pickaxe");
    if (wisps.length > 0) {
    talkSpeak(14); // "yes,. PiickAaXe"
    }
}

// ——— EXIT PUZZLE ROOM ———
    inPuzzleRoom = false;
    inHideout = false;

// Restore the ORIGINAL theme we had before entering the puzzle
if (puzzlePreviousTheme !== null) {
    currentTheme = puzzlePreviousTheme;
    puzzlePreviousTheme = null;
}

// Properly restore snowy hell state if we were in a snowy hell block
if (currentTheme === 'hell') {
    if (currentThemeBlock === 'hell_snowy') {
        snowyHellActive = true;
    } else {
        snowyHellActive = false;
    }
    updateSnowState();
}

// Properly restore rainy ruins state if we were in a rainy ruins block
if (currentTheme === 'ruins') {
    if (currentThemeBlock === 'ruins_rainy') {
        ruinsRainActive = true;
        // Re-create rain particles with fresh random angle
        raindrops = [];
        floorSplashes = [];
        ruinsRainAngle = 0.26 + Math.random() * 0.35;
        for (let i = 0; i < 160; i++) {
            raindrops.push({
                x: Math.random() * 320,
                y: Math.random() * 320 - 100,
                speed: 3.0 + Math.random() * 3.0
            });
        }
        startRainAmbience();  // restart the looping ambience
    } else {
        ruinsRainActive = false;
        raindrops = [];
        floorSplashes = [];
        // Stop ambience if it was running
if (rainAmbienceTimer) {
    rainAmbienceTimer = null;
}
if (rainNoiseSource) {
    rainNoiseSource.stop();
    rainNoiseSource = null;
}
    }
}

// Restart ambience if back to regular hell
if (currentTheme === 'hell' && !snowyHellActive) {
    startFireplaceAmbience();
}

    // Restore music without triggering full initMap reset
    if (!musicMuted && !inPuzzleRoom) {
        musicManager.play(currentTheme);  // play the restored theme directly
    }
    puzzlePreviousTheme = null;

    // Clear all puzzle state
    puzzleHazards = [];
    puzzleArrows = [];
    puzzleBoulders = [];
    puzzleHeartFramers = [];
    puzzleChest = null;
    // ——— CLEAR ALL PUZZLE TILES FROM THE MAP ———
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if ([19, 27].includes(map[y][x])) {  // 19 = soul stash, 27 = farm spot
                map[y][x] = 0;
            }
        }
    }
    soulStashPos = null;
    farmSpot = null;
    puzzleReturnPos = null;
    puzzleCurrentLayout = null;  // ← NEW: prevents reusing old layout on next floor
    puzzleStaticCanvas = null;
    puzzleStaticCtx = null;

puzzleTotalHearts = 0;
puzzleCollectedHearts = 0;

    // Stairs appear under player
    exit = { x: p.x, y: p.y };
    map[p.y][p.x] = 0;

    logBattleEvent("Stairs appear beneath you!");
    needsRedraw = true;
}

function cleanupEventListeners() {
    // Clear any existing intervals
    if (touchMoveInterval) {
        clearInterval(touchMoveInterval);
        touchMoveInterval = null;
    }
    if (touchTimeout) {
        clearTimeout(touchTimeout);
        touchTimeout = null;
    }
    
    // Clear existing touch listeners from dpad buttons
    dpadButtons.forEach(button => {
        button.classList.remove('pressed');
        // Remove all event listeners for each button
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
            button._touchstartHandler = null;
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
            button._touchendHandler = null;
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
            button._touchcancelHandler = null;
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
            button._clickHandler = null;
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
            button._contextmenuHandler = null;
        }
    });

    // Clear existing touch listeners from actions buttons
    actionsButtons.forEach(button => {
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
            button._touchstartHandler = null;
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
            button._touchendHandler = null;
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
            button._touchcancelHandler = null;
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
            button._clickHandler = null;
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
            button._contextmenuHandler = null;
        }
    });
    
    // Clear existing touch listeners from gamepad buttons
    if (gamepadIndex !== null && navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        if (gamepads[gamepadIndex]) {
            const gamepad = gamepads[gamepadIndex];
            if (gamepad.buttons && gamepad.buttons.length > 0) {
                // Remove event listeners from gamepad buttons
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    if (gamepad.buttons[i]._clickHandler) {
                        gamepad.buttons[i].removeEventListener('click', gamepad.buttons[i]._clickHandler);
                        gamepad.buttons[i]._clickHandler = null;
                    }
                }
            }
        }
    }
    
    // Clear existing event listeners from document
    if (document._keydownHandler) {
        document.removeEventListener('keydown', document._keydownHandler);
        document._keydownHandler = null;
    }
    if (document._keyupHandler) {
        document.removeEventListener('keyup', document._keyupHandler);
        document._keyupHandler = null;
    }

    // Clear keyboard movement interval
    if (keyboardMovementTimer) {
        clearInterval(keyboardMovementTimer);
        keyboardMovementTimer = null;
    }
    if (document._touchstartHandler) {
        document.removeEventListener('touchstart', document._touchstartHandler);
        document._touchstartHandler = null;
    }
    if (document._touchmoveHandler) {
        document.removeEventListener('touchmove', document._touchmoveHandler);
        document._touchmoveHandler = null;
    }
    if (document._touchendHandler) {
        document.removeEventListener('touchend', document._touchendHandler);
        document._touchendHandler = null;
    }
    if (document._gamepadConnectedHandler) {
        window.removeEventListener('gamepadconnected', document._gamepadConnectedHandler);
        document._gamepadConnectedHandler = null;
    }
    if (document._gamepadDisconnectedHandler) {
        window.removeEventListener('gamepaddisconnected', document._gamepadDisconnectedHandler);
        document._gamepadDisconnectedHandler = null;
    }
}

/* ------------------------------------------------------------------
   Enhanced touch controls with 200ms movement delay
   ------------------------------------------------------------------ */
function initTouchControls() {
    let activeTouchId = null;
    let currentTouchDir = null;
    let isMoving = false;
    let lastMoveTime = 0;

    // Use the global dpadButtons
    dpadButtons.forEach(button => {
        button._touchstartHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (inputBlocked || splashActive || gameOver) return;

            const touch = e.changedTouches[0];
            if (!activeTouchId) {
                activeTouchId = touch.identifier;
                button.classList.add('pressed');
                currentTouchDir = button.id;
                isMoving = true;

                // Start continuous movement with 200ms delay
                const moveLoop = () => {
                    if (isMoving && currentTouchDir && !inputBlocked && !gameOver) {
                        const now = Date.now();
                        if (now - lastMoveTime >= 200) { // Enforce 200ms delay
                            move(currentTouchDir);
                            lastMoveTime = now;
                        }
                        requestAnimationFrame(moveLoop);
                    }
                };
                requestAnimationFrame(moveLoop);
            }
        };

        button._touchmoveHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            // Keep touch active but don't trigger move
            const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
            if (touch && currentTouchDir && !inputBlocked && !gameOver) {
                // No move call here; let moveLoop handle movement
            }
        };

        button._touchendHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.changedTouches[0];
            if (touch.identifier === activeTouchId) {
                button.classList.remove('pressed');
                activeTouchId = null;
                currentTouchDir = null;
                isMoving = false;
            }
        };

        button._touchcancelHandler = button._touchendHandler;
        button._contextmenuHandler = function (e) { 
            e.preventDefault(); 
            e.stopPropagation();
        };
        button._clickHandler = function (e) { 
            e.preventDefault(); 
            e.stopPropagation();
        };

        // Remove existing listeners and add new ones
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
        }
        if (button._touchmoveHandler) {
            button.removeEventListener('touchmove', button._touchmoveHandler);
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
        }

        button.addEventListener('touchstart', button._touchstartHandler, { passive: false });
        button.addEventListener('touchmove', button._touchmoveHandler, { passive: false });
        button.addEventListener('touchend', button._touchendHandler, { passive: false });
        button.addEventListener('touchcancel', button._touchcancelHandler, { passive: false });
        button.addEventListener('contextmenu', button._contextmenuHandler, { passive: false });
        button.addEventListener('click', button._clickHandler, { passive: false });
    });

    /* Clean up on restart */
    document.addEventListener('restart', () => {
        dpadButtons.forEach(button => {
            button.classList.remove('pressed');
            if (button._touchstartHandler) button.removeEventListener('touchstart', button._touchstartHandler);
            if (button._touchmoveHandler) button.removeEventListener('touchmove', button._touchmoveHandler);
            if (button._touchendHandler) button.removeEventListener('touchend', button._touchendHandler);
            if (button._touchcancelHandler) button.removeEventListener('touchcancel', button._touchcancelHandler);
            if (button._clickHandler) button.removeEventListener('click', button._clickHandler);
            if (button._contextmenuHandler) button.removeEventListener('contextmenu', button._contextmenuHandler);
        });
        activeTouchId = null;
        currentTouchDir = null;
        isMoving = false;
        lastMoveTime = 0;
        initTouchControls(); // Re-attach listeners     
    });
}

/* ------------------------------------------------------------------
   Restart the game – reset state & re‑initialise listeners
   ------------------------------------------------------------------ */
function restart() {
// IMMEDIATELY nuke the splash screen to prevent ANY artifact/flash
    const splashScreen = document.getElementById('splash-screen');
    if (splashScreen) {
        // Clear image source first (prevents old image from lingering in memory)
        const splashImg = splashScreen.querySelector('img') || document.getElementById('splash-img');
        if (splashImg) {
            splashImg.src = ''; // blank source → kills old image load
        }
        
        splashScreen.style.display = 'none';
        splashScreen.style.zIndex = '';
        splashScreen.onclick = null;
        splashScreen.ontouchend = null;
        
        // Remove any lingering key listener
        document.removeEventListener('keydown', splashScreen._keyClose);
        if (splashScreen._keyClose) delete splashScreen._keyClose;
    }
    
    // Force reflow + paint cycle to ensure hide happens now
    document.body.offsetHeight;
    void document.body.offsetWidth; // double reflow for stubborn browsers
    
    infoSignActive = false;
    infoGracePeriod = false;
    
    // Now safe to set new state
    splashActive = true;
    currentSplashImage = 'splash.png';

    /* ------------------------------------------------------------------
       1. Clean up old listeners/timers
       ------------------------------------------------------------------ */
    cleanupEventListeners();
    document.dispatchEvent(new Event('restart')); // Trigger custom restart event

    // Reset fetch flag
    isFetchingTxs = false;

    // Reset skill tree system
    playerXP = 0;
    playerLevel = 1;
    playerClass = null;
    pendingSkillTreeLevel = null;
    skillTreeActive = false;
    skillTreeSelectedOption = 0;

window.currentSideQuest = null;
window.lastSideQuestType = null;

    infoSignActive = false;
    bountyBoardActive = false;
    infoGracePeriod = false;
    tileVariantMap = [];

passiveTreeActive = false;
passiveGracePeriod = false;

puzzleTotalHearts = 0;
puzzleCollectedHearts = 0;

    fireplaceNoiseSource = null;
    fireplaceAmbienceTimer = null;
    lfo = null;               // ember‑flicker LFO
    popTimeout = null;        // handle for the next pop burst
    // Hide and clear skill tree overlay
    const overlay = document.getElementById('skill-tree-overlay');
    if (overlay) {
        overlay.style.display = 'none';
        overlay.classList.remove('visible');
    }
    const content = document.getElementById('skill-tree-content');
    if (content) content.innerHTML = '';

    updateXPBar();
    
    /* ------------------------------------------------------------------
       2. Reset all game state variables
       ------------------------------------------------------------------ */
    floor = 1;
    inHideout = false;
    previousFloorState = null;
    jewellerPos = null;
    blacksmithPos = null;
    waypointPos = null;
    p.hasDiamondArmor = false;
    p.hasDiamondHand = false;
    p.currentWeapon = 'sword';
    p.hasCursedRing = false;
    redMazeLastFloor = 0;
    redMazeActive = false; // explicitly reset boss state on new run
    redMazeAuraGiven = false;
    p.echoWardenBlessingGiven = false;
p.curseActive = false;  // Lift lingering curse

    p.gems = { ruby: 0, sapphire: 0, emerald: 0, citrine: 0 };
    p.gemAtk = { fire: 0, cold: 0, earth: 0, lightning: 0 };
    p.gemDef = { shrimpCrab: 0, dolphin: 0, shark: 0, squid: 0 };
    hpReduction = 0;

p.inPassiveTerminal = false;
p.passiveTerminalActive = false;
p.passiveTerminalCommand = '';
p.passiveTerminalCursorPos = 0;

    // === RUINS RAIN SYSTEM RESET ===
    ruinsRainActive = false;
    ruinsRainAngle = 0;
    raindrops = [];
    floorSplashes = [];
    rainAmbiencePlayed = false;  // ← add this line
if (rainAmbienceTimer) {
    rainAmbienceTimer = null;
}
if (rainNoiseSource) {
    rainNoiseSource.stop();
    rainNoiseSource = null;
}
// Restore a random immunity on restart
const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];
p.auraMax = 0; // Explicitly reset aura max
p.auraShield = 0; // Explicitly reset aura shield
p.lastAuraRefillMove = 0; // Reset aura refill tracking
p.auraMoveCounter = 0; // Reset aura move counter
    p.perfectlyCutDiamonds = 0;
    // Reset soul items
    p.soulStones = 0;
    p.soulOrbs = 0;
    p.soulStormCharges = 256;
  
farmSpot = null;  
p.farmLocked = false;
p.farmLockedFloor = 0;
p.farmLockedSats = 0;

p.hasAcrobaticsBuff = false;

frostNovaProjectiles = [];
wispFireBoltProjectiles = [];
wispLightningProjectiles = [];
wispEarthquakeProjectiles = [];
entangleAnimations = [];

window.spokenUniques = new Set();
window.breakReminderSpoken = false;

    sandwormBurrowPaused = false; // pause burrow timer in special areas

catPos = null;
catVisible = false;
sandworm = null;
desertStreakHasSandworm = false;

    lastMessageTime = 0;  
    redMazeSavedMuteState = null; 
    // Reset shrine tracking
    p.shrineCharges = 0;
    p.shrineUsedThisFloor = false;
    currentTheme = 'dungeon';            // default theme
    p.maxHP = 36;                       // default max HP
    document.documentElement.style.setProperty('--text-color', '#ff8c00'); // orange
    wave = 1;
    document.getElementById('wave').textContent = wave;
    p.hp = 36;    
    p.potions = 0;
    p.pickaxes = 0;
    diamonds = 0;
    p.hasArmor = true;
    p.armorImmunity = null; // Reset armor immunity on restart
    soulResonance = 0;
    resonanceTriggeredThisRun = false; // Reset for new run
    wardenUses = 0;  // reset echo warden tracker
    wardenRollPending = false;
    wardenFlashStart = 0; // Clear flash on restart
    previousHP = 36;
    hpOverfillFlashStart = 0;
    p.runes = [];
    runeDrops = runeDrops.filter(r => !r.specific);			// maybe
    for (let y = 0; y < H; y++) {					// \
        for (let x = 0; x < W; x++) {					//  \
            if (map[y][x] === 9) {					//   \
                map[y][x] = 0; // Clear specific rune tiles		//    \
            }								//     \
        }								//      \
    }									//       overkill
    
    p.x = 2;
    p.y = 2;
    p.atk = 2;
enemies = [];
    wisps = []; // Clear wisp on restart
    deadWispCorpse = null; // Clear corpse too
enemyBgFrameTimes.clear(); // Clear bg animation tracking
    map = [];
    rooms = [];
    exit = null;
    gameOver = false;
    gameOverSoundPlayed = false;
    autoSubmitTriggered = false;
enemiesSpawnedThisFloor = 0;
        window.hugeShrimpSpawnedThisFloor = false; // reset for new floor
uniqueMonstersSpawnedThisFloor = 0; // Reset unique monster spawn counter
whalesSpawnedThisFloor = 0;
scrollDroppedThisFloor = false;
initialSpawnDoneThisFloor = false;
initialWaveSpawned = false;
waveActive = false;
    nextApiCallTime = null;
    whaleHashIds = ['Whale Transactions:'];
    battleLog = [];
    killsLog = [];
    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    satoshiDrops = [];
    scrollDrops = [];
    portals = [];
    swordDir = 'right';
    swordActive = false;
    swordStart = 0;
    fogMap = [];
    scoreSubmitted = false;
    gameOverBPressed = false;
    hasPlayedOnce = true;  // allow the "Enter" key to start the next game
    projectiles = []; // Add this line to reset projectiles array on restart
    populateNameList();
 
    currentThemeBlock = null;  // 'hell_normal' or 'hell_snowy' for the current 3-floor block

    currentWeapon = 'sword';
    
// Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

localStorage.setItem('musicMuted', 'true');
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }


    /* ------------------------------------------------------------------
       3. Reset UI elements
       ------------------------------------------------------------------ */
    const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
    whaleHashIdsDiv.innerHTML = ''; // clear
    const newDiv = document.createElement('div');
    newDiv.innerHTML = whaleHashIds.join('<br>');
    whaleHashIdsDiv.appendChild(newDiv);
    const whaleLog = document.getElementById('whale-log');
    whaleLog.scrollTop = whaleLog.scrollHeight;

    document.getElementById('battle-events').value = '';
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    document.getElementById('health').textContent = p.hp;
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('sats').textContent = '0';
    window.currentFloorText = `Floor ${floor}`;
    window.lastUniqueSetTime = 0;
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('submit-score').style.display = 'none';
    document.getElementById('view-leaderboard').style.display = 'none';
    document.getElementById('restart-game').style.display = 'none';
    document.getElementById('username-input').value = '';
    document.getElementById('leaderboard-output').textContent = '';
    document.getElementById('leaderboard-output').style.display = 'none';
    document.getElementById('submit-score').disabled = false;
    document.getElementById('submit-score').style.background = '#ff8c00';
    document.getElementById('splash-screen').style.display = 'block';
    window.currentBounty = null; // Reset bounty on restart
    window.seenBountyTypes = []; // optional – for "cousin" tracking
    //window.location.reload(); // Nuke: Full page reload to clear all events/sprites/memory (nah ..)

    /* ------------------------------------------------------------------
       4. Re-initialize button variables and touch listeners
       ------------------------------------------------------------------ */
    // Re-initialize button variables properly
    dpadButtons = document.querySelectorAll('#dpad button');
    actionsButtons = document.querySelectorAll('#actions button');
    
    // Cleanup old listeners first
    cleanupEventListeners();
    
    // Re-initialize touch controls
    initTouchControls(); // Re-initialize touch controls
    
    /* ------------------------------------------------------------------
       5. Reset audio & gamepad polling
       ------------------------------------------------------------------ */
    if (apiTimeoutId) clearTimeout(apiTimeoutId);
    if (movementTimer) clearInterval(movementTimer);
    movementTimer = null;
    gamepadMoveDir = null;
    gamepadLastMoveTime = 0;
    lastButtonsState = [];
    if (gamepadIndex !== null) {
        // Check for gamepad at restart
        if (navigator.getGamepads) {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepadIndex = i;
                    console.log('Gamepad detected at restart:', gamepads[i].id);
                    break;
                }
            }
        }
        gamepadPollingActive = true;
        if (!movementTimer) {
            movementTimer = setInterval(() => {
                if (!splashActive && !gameOver && gamepadMoveDir) {
                    const now = Date.now();
                    if (now - gamepadLastMoveTime >= 200) {
                        move(gamepadMoveDir);
                        gamepadLastMoveTime = now;
                    }
                }
            }, 50);
        }
        requestAnimationFrame(updateGamepad);
    }

    /* ------------------------------------------------------------------
       6. Reset visual state
       ------------------------------------------------------------------ */
    resetSplashScreen();
    initMap();
    updatePlayerState();
    updateSatsDisplay();
    needsRedraw = true;
    inputBlocked = false;
}

function dropSoulStone(x, y) {
    let placed = false;
    if (map[y][x] === 0) {
        map[y][x] = 20; // Soul stone tile
        placed = true;
    } else {
        const dirs = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
        for (let d of dirs) {
            let nx = x + d.dx, ny = y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                map[ny][nx] = 20; // Soul stone tile
                placed = true;
                break;
            }
        }
    }
    if (placed) {
        logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Soul Stone!`);
        playWebAudioSound(sounds.pickup);
    }
}

function selectSkillTreeOption() {
    if (pendingSkillTreeLevel === 3 && !playerClass) {
        playerClass = skillTreeSelectedOption === 0 ? 'druid' : 'degen';
        logBattleEvent(`Class chosen: ${playerClass.charAt(0).toUpperCase() + playerClass.slice(1)}`);
        if (playerClass === 'degen') {
            p.farmLocked = false; // unlock farm
            p.coolROI = (p.coolROI || 0) + 1;
        } else if (playerClass === 'druid') {
            // shrine +1 handled below
        }
    }

    // Apply level-specific perks
    if (playerClass === 'druid') {
    if (pendingSkillTreeLevel === 20) ensnareActive = true;
        if (pendingSkillTreeLevel === 40) p.blockChance = 0.20;
        if (pendingSkillTreeLevel === 50 && !p.farmLocked) {
            p.farmLocked = false;
            p.coolROI = (p.coolROI || 0) + 1;
        }
    } else if (playerClass === 'degen') {
        if ([10,20,30,40].includes(pendingSkillTreeLevel)) {
            p.coolROI = (p.coolROI || 0) + 1;
        }
        if (pendingSkillTreeLevel === 50) p.soulChargeEveryTwoMoves = true;
    }

    closeSkillTree(); // existing call
    pendingSkillTreeLevel = null; // ← add this line to clear flag
}

function closeSkillTree() {
    const overlay = document.getElementById('skill-tree-overlay');
    overlay.classList.remove('visible');
    setTimeout(() => {
        overlay.style.display = 'none';
        skillTreeActive = false;
        pendingSkillTreeLevel = null;
        inputBlocked = false;
        needsRedraw = true;
    }, 400); // match transition duration
}

function draw() {
    // Add frame rate limiting - cap to maximum 50ms updates (20 FPS)
    const now = performance.now();
    if (now - lastDrawTime < 50) {
        needsRedraw = true;
        return;
    }
    lastDrawTime = now;
    

    
    if (!map?.[0] || !p || !enemies || !rooms?.length || !fogMap?.[0]) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms, 'fogMap=', fogMap);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);

// ───── 2× ZOOM – JET FUEL ORBIT CAMERA (ignores player janks, silky momentum) ─────
if (zoomEnabled && !splashActive && !gameOver) {
    c.save();
    c.imageSmoothingEnabled = false;

    c.translate(160, 160);
    c.scale(2, 2);

    // Base target: player center
    const baseX = -(p.currentX + S / 2);
    const baseY = -(p.currentY + S / 2);

// CARDINAL-LOCKED CAMERA – locks to player's exact movement axis (no jitter)
const buffer = 16;           // Natural lag-behind feel
const deadzone = 6;          // Ignore tiny offsets
const accel = 0.22;          // Acceleration toward target
const dampMoving = 0.85;     // Damping while moving
const dampStopped = 0.78;    // Stronger damping when stopped

// Buffered prediction – center of player + axis-locked lookahead (no cross-axis bleed)
const playerCenterX = p.currentX + S / 2;
const playerCenterY = p.currentY + S / 2;

// Determine player's current movement axis (horizontal or vertical)
const absDeltaX = Math.abs(p.deltaX);
const absDeltaY = Math.abs(p.deltaY);
const playerIsHorizontal = absDeltaX > absDeltaY && absDeltaX > 0;
const playerIsVertical   = absDeltaY > absDeltaX && absDeltaY > 0;

const predX = playerCenterX + (playerIsHorizontal ? p.deltaX * buffer / 2 : 0);
const predY = playerCenterY + (playerIsVertical   ? p.deltaY * buffer / 2 : 0);

// Offset from current camera center
let offsetX = predX - (camera.x + 160);
let offsetY = predY - (camera.y + 160);

// Pixel-perfect snap for vertical movement (fixes forward/down shake)
if (playerIsVertical) {
    offsetY = Math.round(offsetY);
}

// Force lock to player's axis (zero the opposite component)
if (playerIsHorizontal) {
    offsetY = 0;
    camera.velocityY = 0;        // Immediately kill any lingering vertical velocity
} else if (playerIsVertical) {
    offsetX = 0;
    camera.velocityX = 0;        // Immediately kill any lingering horizontal velocity
}

let dist = Math.sqrt(offsetX*offsetX + offsetY*offsetY);

if (dist > deadzone) {
    const nx = offsetX / dist || 0;
    const ny = offsetY / dist || 0;

    camera.velocityX += nx * accel;
    camera.velocityY += ny * accel;
}

// Apply damping
if (p.moving) {
    camera.velocityX *= dampMoving;
    camera.velocityY *= dampMoving;
} else {
    camera.velocityX *= dampStopped;
    camera.velocityY *= dampStopped;
}

// Final apply
camera.x += camera.velocityX;
camera.y += camera.velocityY;

    // Apply velocity as smooth offset (orbits/coasts)
    let targetX = baseX + camera.velocityX;
    let targetY = baseY + camera.velocityY;

// Smoothly lerp to base position + gentle velocity offset
camera.x += (targetX + camera.velocityX - camera.x) * 0.22;
camera.y += (targetY + camera.velocityY - camera.y) * 0.22;

    c.translate(Math.floor(camera.x + 0.5), Math.floor(camera.y + 0.5));
}
    
    // Warden entry flash:
// ——— ECHO WARDEN FLASH: Divine ἀρχάγγελος ———
if (wardenFlashStart > 0) {
    const elapsed = Date.now() - wardenFlashStart;
    const duration = 5000; // total flash duration

    if (elapsed < duration) {
        // Smooth pulse: 0 → 1 → 0
        const progress = elapsed / duration;
        const intensity = Math.sin(progress * Math.PI); // 0 to 1 to 0

        // Black flash (cover everything)
        c.fillStyle = `rgba(0, 0, 0, ${intensity})`; // pure black pulse
        c.fillRect(0, 0, W * S, H * S);
    } else {
        // Flash ended → hide Warden completely (remove from map)
        if (echoWardenPos) {
            map[echoWardenPos.y][echoWardenPos.x] = 0; // clear tile
            echoWardenPos = null;
            logBattleEvent("Echo Warden returns to the void...");
        }
        wardenFlashStart = 0;
    }
}

    if (gameOver) {
        const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
        gameOverCanvas.clearRect(0, 0, 320, 320);
        gameOverCanvas.fillStyle = '#000';
        gameOverCanvas.fillRect(0, 0, 320, 320);
        const scale = window.innerWidth <= 700 ? 1.5 : 2;
        const gw = 128 * scale, gh = 32 * scale;
        const offsetY = (Math.sin(Date.now() / 500) * 10);
        gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh) / 2 + offsetY, gw, gh);
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('submit-score').style.display = 'block';
        document.getElementById('view-leaderboard').style.display = 'block';
        document.getElementById('restart-game').style.display = 'block';
        return;
    }
    if (splashActive) { needsRedraw = false; return; }

    // Show/hide XP bar
    const xpContainer = document.getElementById('xp-bar-container');
    if (xpContainer) {
        xpContainer.style.display = (splashActive || gameOver) ? 'none' : 'block';
    }

    // Safety: stop rain visuals/sound if not in ruins
    if (currentTheme !== 'ruins') {
        if (ruinsRainActive) ruinsRainActive = false;
        if (raindrops.length) raindrops = [];
        if (floorSplashes.length) floorSplashes = [];
if (rainAmbienceTimer) {
    rainAmbienceTimer = null;
}
if (rainNoiseSource) {
    rainNoiseSource.stop();
    rainNoiseSource = null;
}
    }

    const radius = 4;
// ───── WALLS ONLY (with Snowy Hell tint) ─────
for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] === 1) { // walls only
            if (currentTheme === 'hell' && !snowyHellActive) {
                // Per-tile random cycle speed 600–2400ms (position-seeded for determinism + variety)
                const seed = (x * 31 + y * 37) & 0xFFFF; // simple hash for good spread
                const speed = 600 + (seed % 1801); // 600 to 2400ms range
                const tileFrame = Math.floor(Date.now() / speed);
                const phaseOffset = tileVariantMap[y][x]; // pre-randomized 0-3 phase
                const animIndex = (tileFrame + phaseOffset) % assets.themes.hell.walls.length;
                c.drawImage(assets.themes.hell.walls[animIndex], x * S, y * S, S, S);
            } else {
                const variant = tileVariantMap[y][x];
                if (variant >= 0 && assets.themes[currentTheme]?.walls) {
                    const walls = assets.themes[currentTheme].walls;
                    c.drawImage(walls[variant], x * S, y * S, S, S);
                } else if (currentTheme === 'hell' && snowyHellActive) {
                    c.save();
                    c.drawImage(assets.themes.hell.wall, x * S, y * S, S, S);
                    c.globalCompositeOperation = 'source-atop';
                    c.fillStyle = 'rgba(190,240,255,0.85)'; // icy tint
                    c.fillRect(x * S, y * S, S, S);
                    c.restore();
                } else {
                    c.drawImage(assets.themes[currentTheme].wall, x * S, y * S, S, S);
                }
            }

            // Red Maze tint (unchanged)
            if (redMazeActive && currentTheme === 'dungeon') {
                c.save();
                c.globalCompositeOperation = 'source-atop';
                c.fillStyle = 'rgba(200, 0, 0, 0.4)';
                c.fillRect(x * S, y * S, S, S);
                c.restore();
            }
        }
}
// Save floor state before entering hideout (moved here to run once per draw)
if (!inHideout) {
previousFloorState = {
    map: map.map(row => [...row]),
    enemies: enemies.map(e => ({ ...e, type: { ...e.type } })),
    rooms: rooms.map(r => ({ ...r })),
    exit: exit ? { ...exit } : null,
    satoshiDrops: [...satoshiDrops],
    runeDrops: [...runeDrops],
    scrollDrops: [...scrollDrops],
    portals: portals.map(p => ({ ...p })),
    fogMap: fogMap.map(row => [...row]),  // ← Add this line
    floor: floor,
    wave: wave,
    enemiesSpawnedThisFloor: enemiesSpawnedThisFloor,
    whalesSpawnedThisFloor: whalesSpawnedThisFloor,
    initialSpawnDoneThisFloor: initialSpawnDoneThisFloor,
    initialWaveSpawned: initialWaveSpawned,
    waveActive: waveActive,
    currentTheme: currentTheme
};
}

// Draw floors, items, stairs, and runes
for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
    const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
    const isVisible = fogMap[y][x] === 1 || dist <= radius || map[y][x] === 1;
    if (isVisible && map[y][x] !== 1) {

        // Pre-randomized variant floor (stable per floor – no dizziness)
        const variant = tileVariantMap[y][x];
        if (variant >= 0 && assets.themes[currentTheme]?.floors) {
            const floors = assets.themes[currentTheme].floors;
            c.drawImage(floors[variant], x * S, y * S, S, S);
        } else if (currentTheme === 'hell' && snowyHellActive) {
            c.drawImage(assets.themes.hell.snowy_floor, x * S, y * S, S, S);
        } else {
            c.drawImage(assets.themes[currentTheme].floor, x * S, y * S, S, S);
        }

        if (redMazeActive && redMaze && redMaze.x === x && redMaze.y === y) {
const now = performance.now();
if (now - assets.red_maze.lastFrameTime >= assets.red_maze.frameDuration) {
    assets.red_maze.frameIndex = (assets.red_maze.frameIndex + 1) % 3;
    assets.red_maze.lastFrameTime = now;
}
c.drawImage(
    assets.red_maze[assets.red_maze.frameIndex],
    redMaze.x * S, redMaze.y * S, S, S
);
        }


    // ── Draw unique monster spell effects – breathing only, floor stays static ──
    const now = Date.now();
    const FADE_DURATION = 1000; // ms – length of the fade‑out
    const BREATH_PERIOD = 3000; // ms – breathing loop length

    dangerousAreas.forEach(area => {
        // only draw the tile we are currently processing
        if (area.x !== x || area.y !== y) return;

        // ---------- pick the correct spell image ----------
        let img;
        switch (area.spellType) {
            case SPELL_TYPES.POISON_CLOUD: img = assets.um_poisonCloud; break;
            case SPELL_TYPES.FROST_NOVA: img = assets.um_frostNova; break;
            case SPELL_TYPES.LIGHTNING_STORM: img = assets.um_lightningStorm; break;
            case SPELL_TYPES.FIRE_WALL: img = assets.um_fireWall; break;
            default: return;
        }
        if (!img?.complete) return;

        // ---------- draw the static floor ----------
        const floorImg = (currentTheme === 'hell' && snowyHellActive)
            ? assets.themes.hell.snowy_floor
            : assets.themes[currentTheme].floor;
        c.drawImage(floorImg, x * S, y * S, S, S);

        // ---------- breathing opacity ----------
        const phase = ((now - area.startTime) % BREATH_PERIOD) / BREATH_PERIOD;
        const sinVal = Math.sin(phase * Math.PI * 2);
        const minAlpha = 0.25;
        const maxAlpha = 0.90;
        const breathAlpha = minAlpha + (maxAlpha - minAlpha) * (sinVal * 0.5 + 0.5);

        // ---------- fade‑out after monster death ----------
        let fadeAlpha = 1;
        if (area.deathTime) {
            const elapsed = now - area.deathTime;
            fadeAlpha = Math.max(0, 1 - elapsed / FADE_DURATION); // linear fade
        }

        const finalAlpha = breathAlpha * fadeAlpha;

        // Skip drawing if fully invisible (syncs with cleanup)
        if (finalAlpha < 0.01) return;

        // ---------- draw the spell overlay (no rotation) ----------
        c.save();
        c.translate(x * S, y * S); // static position
        c.globalAlpha = finalAlpha;
        c.drawImage(img, 0, 0, S, S);
        c.restore();
    });


    // Cleanup spell areas: remove when alpha drops below threshold
    dangerousAreas = dangerousAreas.filter(area => {
        // Compute current alpha (mirrors draw logic exactly)
        const age = now - area.startTime;
        let baseAlpha = 1.0;
        if (age < 800) baseAlpha *= age / 800; // fade-in

        let fadeAlpha = 1;
        if (area.deathTime) {
            const elapsed = now - area.deathTime;
            fadeAlpha = Math.max(0, 1 - elapsed / FADE_DURATION);
        }

        const phase = (age % BREATH_PERIOD) / BREATH_PERIOD;
        const sinVal = Math.sin(phase * Math.PI * 2);
        const breathAlpha = 0.25 + 0.65 * (sinVal * 0.5 + 0.5);

        const currentAlpha = baseAlpha * fadeAlpha * breathAlpha;

        // Remove if too faint (syncs perfectly with visual disappearance)
        if (currentAlpha < 0.01) return false;

        return true;
    });
       
        if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
        if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
        if (map[y][x] === 4) c.drawImage(assets.pickaxe, x * S, y * S, S, S);
        if (map[y][x] === 5) c.drawImage(assets.armor, x * S, y * S, S, S);
        if (map[y][x] === 6 && currentTheme !== 'dungeon') c.drawImage(assets.themes[currentTheme].special, x * S, y * S, S, S);
        if (map[y][x] === 7) c.drawImage(assets.gnome, x * S, y * S, S, S);
        if (map[y][x] === 8) c.drawImage(assets.runes.on_floor, x * S, y * S, S, S);
        if (map[y][x] === 9) {
            const rune = runeDrops.find(r => r.x === x && r.y === y && r.specific);
            if (rune && assets.runes[rune.letter]) {
                c.globalAlpha = 0.9; // Apply 10% transparency
                c.drawImage(assets.runes[rune.letter], x * S, y * S, S, S);
                c.globalAlpha = 1; // Restore full opacity
            }
        }
        if (map[y][x] === 10) { // diamond tile
            c.drawImage(assets.diamond, x * S, y * S, S, S);
        }
        if (map[y][x] === 11) { // scroll tile
            c.drawImage(assets.scroll, x * S, y * S, S, S);
        }
        if (map[y][x] === 12) { // portal tile
            const portal = portals.find(p => p.x === x && p.y === y);
            if (portal) {
                const now = performance.now();
                if (now - portal.lastFrameTime >= portal.frameDuration) {
                    portal.frameIndex = (portal.frameIndex + 1) % assets.town_portal.length;
                    portal.lastFrameTime = now;
                    needsRedraw = true; // Ensure redraw for animation
                }
                c.drawImage(assets.town_portal[portal.frameIndex], x * S, y * S, S, S);
            }
        }
if (map[y][x] === 25) { // Puzzle portal tile
    const portal = portals.find(p => p.x === x && p.y === y && p.type === 'puzzle');
    if (portal) {
        const now = performance.now();
        if (now - portal.lastFrameTime >= portal.frameDuration) {
            portal.frameIndex = (portal.frameIndex + 1) % assets.puzzlePortal.length;
            portal.lastFrameTime = now;
            needsRedraw = true;
        }
        c.drawImage(assets.puzzlePortal[portal.frameIndex], x * S, y * S, S, S);
    }
}
        if (map[y][x] === 13) { // Diamond wall
            c.drawImage(assets.themes.hideout.diamond_wall, x * S, y * S, S, S);
        }
        if (map[y][x] === 14) { // Jeweller
            c.drawImage(assets.jeweller, x * S, y * S, S, S);
        }
        if (map[y][x] === 15) { // Blacksmith
            c.drawImage(assets.blacksmith, x * S, y * S, S, S);
        }
        if (map[y][x] === 16) { // Waypoint
            c.drawImage(assets.waypoint, x * S, y * S, S, S);
        }
        if (map[y][x] === 17) { // Rune Whisperer
            c.drawImage(assets.rune_whisperer, x * S, y * S, S, S);
        }
        if (map[y][x] === 18) { // Hooded Heirloom
            c.drawImage(assets.hooded_heirloom, x * S, y * S, S, S);
        }
        if (map[y][x] === 19) { // Soul Stash
            c.drawImage(assets.soul_stash, x * S, y * S, S, S);
        }
        if (map[y][x] === 20) { // Soul Stone
            c.drawImage(assets.soul_stone, x * S, y * S, S, S);
        }
        if (map[y][x] === 21) { // Soul Orb Statue
            c.drawImage(assets.soul_orb_statue, x * S, y * S, S, S);
        }
        if (map[y][x] === 22) { // Shrine
            c.drawImage(assets.shrine, x * S, y * S, S, S);
        }
        if (map[y][x] === 23) { // Cursed Ring
            c.drawImage(assets.cursed_ring, x * S, y * S, S, S);
        }
        if (map[y][x] === 29) { // Swap tile
            c.drawImage(assets.swap, x * S, y * S, S, S);
        }
        if (map[y][x] === 30) {
            c.drawImage(assets.coolROI, x * S, y * S, S, S);
        }
        if (map[y][x] === 31) {
            c.drawImage(assets.smelter, x * S, y * S, S, S);
        }        
	if (map[y][x] === 32) {
            c.drawImage(assets.billboard, x * S, y * S, S, S);
	}        
        if (map[y][x] === 33) {
            c.drawImage(assets.elixir, x * S, y * S, S, S);
        }
	if (map[y][x] === 34) {
	    c.drawImage(assets.info_sign, x * S, y * S, S, S);
	}
        if (map[y][x] === 35) {
            c.drawImage(assets.jester_shrine, x * S, y * S, S, S);
        }
        // New tile ID for passive sign
        if (map[y][x] === 36) c.drawImage(assets.passive_sign, x * S, y * S, S, S);

if (map[y][x] === GEM_TILES.ruby) {
    c.drawImage(assets.ruby, x * S, y * S, S, S);
}
if (map[y][x] === GEM_TILES.sapphire) {
    c.drawImage(assets.sapphire, x * S, y * S, S, S);
}
if (map[y][x] === GEM_TILES.emerald) {
    c.drawImage(assets.emerald, x * S, y * S, S, S);
}
if (map[y][x] === GEM_TILES.citrine) {
    c.drawImage(assets.citrine, x * S, y * S, S, S);
}

// ───── PUZZLE ROOM – FINAL FIXES: FLOOR REVEAL + BOULDER TRAILS + ZOOM-CENTERED REVEAL ─────
if (inPuzzleRoom && puzzleStaticCanvas) {
    c.clearRect(0, 0, 320, 320);
    c.drawImage(puzzleStaticCanvas, 0, 0);

    // DYNAMIC FLOOR REVEAL: one-frame flash when boulder sinks or moves
    highlightTiles.forEach(t => {
        if (Date.now() - t.highlightStart < 500) {
            c.fillStyle = t.color || 'rgba(100,100,100,0.7)';
            c.fillRect(t.x * S, t.y * S, S, S);
        }
    });

    // Boulders
    puzzleBoulders.forEach(b => c.drawImage(assets.boulder, b.x * S, b.y * S, S, S));

    // Heart Key (pulsing)
    puzzleHeartFramers.forEach((h, i) => {
        const pulse = 0.9 + 0.1 * Math.sin(performance.now() / 250 + i * 0.3);
        c.globalAlpha = pulse;
        c.drawImage(assets.heartFramer, h.x * S, h.y * S, S, S);
    });
    c.globalAlpha = 1;

    // Chest
    if (puzzleChest) {
        const img = puzzleHeartFramers.length === 0 ? assets.chestOpen : assets.chestClosed;
        c.drawImage(img, puzzleChest.x * S, puzzleChest.y * S, S, S);
    }
}
                
// keep a flag that tells the main render loop “the warden is done”
let wardenFinished = false;

if (map[y][x] === 24 && echoWardenPos && echoWardenPos.x === x && echoWardenPos.y === y) {
    const age = Date.now() - echoWardenPos.spawnTime;
    const spawnDuration = 1200;
    const holdDuration   = 1800;
    const fadeOutDuration = 1500;

    // -------------------------------------------------
    // 1️⃣  End‑of‑life handling – *do not* touch the map yet
    // -------------------------------------------------
    if (age >= spawnDuration + holdDuration + fadeOutDuration) {
        wardenFinished = true;          // mark it for later cleanup
        echoWardenPos = null;
        // still draw the last (fully transparent) frame so the
        // background tile isn’t swapped out mid‑frame
    } else {
        // -------------------------------------------------
        // 2️⃣  Normal drawing logic (unchanged)
        // -------------------------------------------------
        let alpha = 1.0;
        let scale = 1.0;

        if (age < spawnDuration) {
            const t = age / spawnDuration;
            alpha = t * t;               // ease‑in
            scale = 0.2 + 0.8 * t;
        } else if (age < spawnDuration + holdDuration) {
            alpha = 1.0;
            scale = 1.0;
        } else {
            const fadeT = (age - spawnDuration - holdDuration) / fadeOutDuration;
            alpha = 1.0 - fadeT;
            scale = 1.0;
        }

        const drawX = echoWardenPos.moving ? echoWardenPos.currentX : x * S;
        const drawY = echoWardenPos.moving ? echoWardenPos.currentY : y * S;

        c.save();
        c.globalAlpha = alpha;
        c.translate(drawX + S / 2, drawY + S / 2);
        c.scale(scale, scale);
        c.translate(-S / 2, -S / 2);
        c.drawImage(assets.echo_warden, 0, 0, S, S);
        c.restore();
    }
}

// -------------------------------------------------
// 3️⃣  After the whole frame has been rendered, clean up
// -------------------------------------------------
if (wardenFinished) {
    // now it’s safe to replace the tile – the frame that showed the
    // fully‑transparent warden has already been presented.
    map[y][x] = 0;
    wardenFinished = false;
}

// Black cat — MATRIX GLITCH (mega digital rain + distortion)
if (catPos && catPos.x === x && catPos.y === y) {
    const now = performance.now();
    const glitchTime = now * 0.01;
    
    c.save();
    
    // 1. BASE CAT with green glow + flicker
    const flicker = 0.6 + 0.4 * Math.sin(glitchTime * 17);
    c.globalAlpha = flicker;
    c.shadowColor = 'lime';
    c.shadowBlur = 4 + Math.sin(glitchTime * 9) * 2;
    c.drawImage(assets.cat, x * S, y * S, S, S);
    c.shadowBlur = 0;
    
    // 2. VERTICAL SCANLINES (Matrix TV static)
    for (let i = 0; i < 4; i++) {
        const scanX = x * S + (i * 4) + (Math.sin(now * 0.02 + i) * 2);
        c.strokeStyle = `rgba(0,255,0,${0.3 * flicker})`;
        c.lineWidth = 1;
        c.beginPath();
        c.moveTo(scanX, y * S);
        c.lineTo(scanX, y * S + S);
        c.stroke();
    }
    
    // 3. PIXEL SHIFT DISTORTION (left/right shake)
    const shiftX = Math.sin(glitchTime * 23) * 1;
    c.globalAlpha = 0.4 * flicker;
    c.drawImage(assets.cat, (x * S) + shiftX, y * S, S, S);
    
    // 4. MATRIX RAIN — 6 falling chars behind cat
    c.font = '8px VT323';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    const chars = '01ABTC₿';
    for (let i = 0; i < 6; i++) {
        const rainY = (y * S + S/2) + (i * 3) - (now * 0.03 * (i + 1));
        const rainX = (x * S + S/2) + (Math.sin(now * 0.05 + i) * 3);
        const char = chars[Math.floor(now * 0.1 + i) % chars.length];
        c.globalAlpha = 0.7 * (1 - i/6) * flicker;
        c.fillStyle = 'lime';
        c.fillText(char, rainX, rainY);
    }
    
    c.restore();
    needsRedraw = true;
}
        
        // Draw stairs after portals to ensure proper visibility
        if (exit && exit.x === x && exit.y === y) {
            c.drawImage(assets.stairs, x * S, y * S, S, S);
        }
    }
}

///////////
// NOTICE: DRAW ORDER IS A THING! ;)
/////////

// Draw flash effect for diamond hand AOE damage
highlightTiles.forEach(tile => {
    const elapsed = performance.now() - tile.highlightStart;
    if (elapsed < 400 && tile.x >= 0 && tile.x < W && tile.y >= 0 && tile.y < H && map[tile.y][tile.x] !== 1) {
        const dist = Math.sqrt((tile.x - p.x) ** 2 + (tile.y - p.y) ** 2);
        const isVisible = fogMap[tile.y][tile.x] === 1 || dist <= radius;
        if (isVisible) {
            c.save();
            if (tile.color === 'circle-white') {
                const expand = 1 + (elapsed / 200);
                c.globalAlpha = 0.8 * (1 - elapsed / 400); // match new duration
                c.fillStyle = 'rgba(255,255,255,0.9)';
                c.beginPath();
                c.arc(tile.x * S + S/2, tile.y * S + S/2, S * expand / 2, 0, Math.PI * 2);
                c.fill();
            } else if (tile.color === 'circle-cyan') {
                const expand = 1 + (elapsed / 200);
                c.globalAlpha = 0.8 * (1 - elapsed / 400);
                c.fillStyle = 'rgba(0,232,216,0.9)';
                c.beginPath();
                c.arc(tile.x * S + S/2, tile.y * S + S/2, S * expand / 2, 0, Math.PI * 2);
                c.fill();
            } else {
                c.fillStyle = tile.color || 'rgba(247, 147, 26, 0.5)';
                c.fillRect(tile.x * S, tile.y * S, S, S);
            }
            c.restore();
        }
    }
});

// Draw fading dead wisp corpse
if (deadWispCorpse) {
    const elapsed = Date.now() - deadWispCorpse.fadeStart;
    const fadeAlpha = Math.max(0, 1 - (elapsed / 5000)); // Fade over 5s
    if (fadeAlpha > 0) {
        const frames = assets.wispFrames[deadWispCorpse.type];
        const frame = frames[deadWispCorpse.frameIndex];
        if (frame && frame.complete) {
            c.save();
            c.globalAlpha = fadeAlpha * 0.75;
            c.drawImage(frame, deadWispCorpse.x * S, deadWispCorpse.y * S, S, S);
            c.restore();
        }
    } else {
        deadWispCorpse = null;
    }
}

// In the draw function, after drawing items but before drawing player:
// Draw shrines with fog handling
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
        const isVisible = fogMap[y][x] === 1 || dist <= radius;
        
        if (map[y][x] === 22 && isVisible) { // Shrine tile
            c.drawImage(assets.shrine, x * S, y * S, S, S);
            needsRedraw = true; // Add this to ensure proper redraw after shrine drawing
        }
    }
}

// Ruins rain floor splashes – only in ruins theme + larger/more visible ripples
if (currentTheme === 'ruins') {
    floorSplashes.forEach(s => {
        const age = Date.now() - s.start;
        if (age < 450) {  // slightly longer lifetime for better visibility
            const alpha = (1 - age / 450) * 0.68;
            const sx = s.tileX * S + (S / 2) + (Math.random() - 0.5) * 5;  // more jitter
            const sy = s.tileY * S + S - 5 + Math.sin(age / 50) * 1.5;     // deeper wave

            c.save();
            c.globalAlpha = alpha;
            c.fillStyle = '#A8D0FF';
            c.fillRect(sx - 2, sy, 4, 1.5);         // ← width halved (8 → 4)
            c.globalAlpha = alpha * 0.65;
            c.fillRect(sx - 1, sy + 1.5, 2, 0.75);  // ← width halved (4 → 2)
            c.restore();
        }
    });

    // Clean up old splashes
    floorSplashes = floorSplashes.filter(s => Date.now() - s.start < 450);
}


// Bitcoin orange-ish splat from a vaporised shrimp – bright 16×16 px square
// Duration: 4 s (unchanged)
const splatDuration = 4000;

shrimpBloodDrips = shrimpBloodDrips.filter(drip => {
    const age = performance.now() - drip.startTime;
    if (age > splatDuration) return false;

    const progress = age / splatDuration;          // 0 → 1
    const maxSize = 16;                            // final side length
    const curSize = maxSize * progress;            // grow from 0 to 16 px

    // Tile centre (pixel coordinates)
    const tileX = drip.x * S;
    const tileY = drip.y * S;
    const cx    = tileX + S / 2;
    const cy    = tileY + S / 2;

    const half = curSize / 2;
    const left = cx - half;
    const top  = cy - half;

    // ---- Opacity (half the previous transparency) ----
    // Centre now almost fully opaque (≈0.95) and the whole splat fades more slowly.
    const grad = c.createRadialGradient(cx, cy, 0, cx, cy, half);
    grad.addColorStop(0, 'rgba(255,150,0,1)');   // bitcoin orange
    grad.addColorStop(1, 'rgba(255,140,0,0.1)');      // almost fully transparent at edge

    c.save();
    // Global fade reduced to half of the previous value
    c.globalAlpha = 1 * (1 - progress);
    c.fillStyle = grad;
    c.fillRect(left, top, curSize, curSize);
    c.restore();

    return true;
});


    // Draw projectiles – enemy bits use bit_spear.png, player sword uses shoot_sword.png
    projectiles.forEach(proj => {
        if (proj.x >= 0 && proj.x < W && proj.y >= 0 && proj.y < H &&
            (proj.x !== p.x || proj.y !== p.y)) {
            c.save();

                        const drawX = proj.currentX !== undefined ? proj.currentX : proj.x * S;
            const drawY = proj.currentY !== undefined ? proj.currentY : proj.y * S;
            c.translate(drawX + S / 2, drawY + S / 2);

            let angle = 0;
            if (proj.dirX !== undefined) {
                // Enemy bit spear – pure cardinal
                if (proj.dirX > 0) angle = 0;          // right →
                else if (proj.dirX < 0) angle = Math.PI; // left ←
                else if (proj.dirY > 0) angle = Math.PI / 2;   // down ↓
                else if (proj.dirY < 0) angle = -Math.PI / 2;  // up ↑
            } else if (proj.dir) {
                // Legacy player sword projectile
                if (proj.dir === 'right') angle = 0;
                if (proj.dir === 'left')  angle = Math.PI;
                if (proj.dir === 'down')  angle = Math.PI / 2;
                if (proj.dir === 'up')    angle = -Math.PI / 2;
            }
            c.rotate(angle);

            // Choose the correct sprite
            if (proj.value !== undefined) {
                // enemy bit projectile
                c.drawImage(assets.bit_spear, -S / 2, -S / 2, S, S);
            } else {
                // player's shooting sword
                c.drawImage(assets.shoot_sword, -S / 2, -S / 2, S, S);
            }

            c.restore();
        }
    });
        
// Draw player
// Add this to the existing draw function for player rendering
    if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
    const now = performance.now();

    // 200 ms full cycle → 2 frames (0 → 1 → 0)
    let frameIndex = 0;
    if (p.moving) {
        const elapsed = now - p.moveStartTime;
        const progress = Math.min(elapsed / p.moveDuration, 1); // 0‑1
        // sinusoidal ease‑in/out gives a smooth half‑step motion
        const eased = 0.5 + 0.5 * Math.sin(Math.PI * progress - Math.PI / 2);
        frameIndex = Math.floor(eased * 2); // 0 or 1
    }
    p.anim.frameIndex = frameIndex; // keep state consistent
        
let drawX = p.currentX;
let drawY = p.currentY;
        
        const direction = p.anim.direction;
        const baseDirection = direction === 'left' ? 'right' : direction;
let frameKey;
if (playerClass === 'druid') {
    frameKey = p.hasDiamondArmor ? `druid_diamond_armor_${baseDirection}` : 
               (p.hasArmor ? `druid_armor_${baseDirection}` : `druid_${baseDirection}`);
} else {
    frameKey = p.hasDiamondArmor ? `diamond_armor_${baseDirection}` : 
               (p.hasArmor ? `armor_${baseDirection}` : baseDirection);
}

// Error handling for Druid frames
['druid_front', 'druid_back', 'druid_right', 'druid_armor_front', 'druid_armor_back', 'druid_armor_right', 
 'druid_diamond_armor_front', 'druid_diamond_armor_back', 'druid_diamond_armor_right'].forEach(key => {
    p.anim.frames[key].forEach((frame, i) => {
        frame.onerror = () => console.error(`Failed to load ${key}[${i}]: ${frame.src}`);
    });
});

if (p.isFalling) {
    frameKey = 'fall';
}
// SAFE FRAME ACCESS – prevents crash on missing/invalid frames
let safeFrameIndex = (p.anim.frameIndex || 0) % 2;  // Clamp 0-1
let safeFrames = p.anim.frames[frameKey];
if (!safeFrames || safeFrames.length <= safeFrameIndex || !safeFrames[safeFrameIndex]) {
    // Fallback: frame 0 of primary direction, or front[0]
    safeFrameIndex = 0;
    safeFrames = p.anim.frames[baseDirection] || p.anim.frames.front;
}
const frame = safeFrames[safeFrameIndex];
        c.save();
                
        if (direction === 'left') {
            c.translate(drawX + S, drawY);
            c.scale(-1, 1);
            
            c.drawImage(frame, 0, 0, S, S);
        } else {
            c.drawImage(frame, drawX, drawY, S, S);
        }
        c.restore();

// Aura hit flash: Red eerie for Maze Aura, Indigo-purple for regular Cursed Aura
if ((p.hasCursedRing || redMazeAuraGiven) && auraHitStartTime > 0) {
    const elapsed = Date.now() - auraHitStartTime;
    if (elapsed < auraFlashDuration) {
        const flashAlpha = 0.6 * (1 - (elapsed / auraFlashDuration));
        auraTempCtx.clearRect(0, 0, W * S, H * S);
        
        // Red eerie flash for Maze Aura, regular purple for Cursed Aura
        auraTempCtx.fillStyle = redMazeAuraGiven 
            ? `rgba(200, 0, 0, ${flashAlpha})`     // Deep red
            : `rgba(75, 0, 130, ${flashAlpha})`;  // Indigo-purple
        
        auraTempCtx.beginPath();
        const centerX = p.currentX + S / 2;
        const centerY = p.currentY + S / 2;
        const radius = S * (elapsed / auraFlashDuration) + S / 2;
        auraTempCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        auraTempCtx.fill();
        c.drawImage(auraTempCanvas, 0, 0);
    } else {
        auraHitStartTime = 0;
    }
}
    }
// Draw sword or pickaxe-sword or diamond hand (PURE RENDERING — no state changes!)
if (swordActive && Date.now() - swordStart < 200) {
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;

    if (sx >= 0 && sx < W && sy >= 0 && sy < H && Math.sqrt((sx - p.x)**2 + (sy - p.y)**2) <= radius) {
        c.save();
        c.translate(sx * S + S / 2, sy * S + S / 2);
        if (swordDir === 'up') c.rotate(-Math.PI / 2);
        if (swordDir === 'down') c.rotate(Math.PI / 2);
        if (swordDir === 'left') c.rotate(Math.PI);

        // Only draw — decide sprite based on current state (no p.atk mutation here)
        if (p.pickaxes > 0 && usePickaxeSword) {
            c.drawImage(assets.pickaxe_sword, -S / 2, -S / 2, S, S);
        } else if (p.hasDiamondHand) {
            c.drawImage(assets.diamond_hand, -S / 2, -S / 2, S, S);
        } else if (p.soulStormCharges >= 8) {
            c.drawImage(assets.soul_sword, -S / 2, -S / 2, S, S);
        } else {
            c.drawImage(assets.sword, -S / 2, -S / 2, S, S);
        }

        c.restore();
    }
}

// SATOSHI'S SCOURGE — TRUE 360° MACE SPIN (mace orbits)
if (p.scourgeSpin && Date.now() - p.scourgeSpin.start < 520) {
    c.imageSmoothingEnabled = false;

    const elapsed = Date.now() - p.scourgeSpin.start;
    const angle = (elapsed / 520) * Math.PI * 2;
    const radius = S * 1.4;
    const cx = p.currentX + S/2;
    const cy = p.currentY + S/2;

    // 1. MACE HEAD — orbits and points outward
    const mx = cx + Math.cos(angle) * radius;
    const my = cy + Math.sin(angle) * radius;

    c.save();
    c.translate(mx, my);
    c.rotate(angle + Math.PI/2);  // +90° so right-pointing sprite faces away
    c.drawImage(assets.satoshi_scourge, -S/2, -S/2, S, S);
    c.restore();

    // 2. Crisp trail (4 ghosts)
    for (let i = 1; i <= 4; i++) {
        const trailAngle = angle - i * 0.35;
        const tx = cx + Math.cos(trailAngle) * radius;
        const ty = cy + Math.sin(trailAngle) * radius;
        c.save();
        c.globalAlpha = 0.8 / i;
        c.translate(tx, ty);
        c.rotate(trailAngle + Math.PI/2);
        c.drawImage(assets.satoshi_scourge, -S/2, -S/2, S, S);
        c.restore();
    }

    needsRedraw = true;
} else if (p.scourgeSpin) {
    p.scourgeSpin = null;
}
    
// Add rune tile indicator when player is on a rune tile
if (currentRuneTile && map[p.y][p.x] === 9) {
    const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
    if (rune) {
        const floorIndicator = document.getElementById('floor-indicator');
        if (!floorIndicator.textContent.startsWith("Rune:")) {
            floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
        }
    }
}
    
// Draw gradient column overlay for RIP blast
if (ripBlastActive && Date.now() - ripBlastStartTime < 3000) {
    if (columnProgress === 0) {
        initGradientOverlay(); // Initialize overlay on first draw
    }
    c.save();
    c.globalCompositeOperation = 'screen'; // Subtle glow for visibility
    const elapsed = Date.now() - ripBlastStartTime;
    columnProgress = elapsed / 2000; // 0 to 1 over 2 seconds
    const columnWidth = 20; // Width of each column in pixels
    const numColumns = Math.ceil(W * S / columnWidth) + 1; // Cover entire width
    for (let i = 0; i < numColumns; i++) {
        const x = i * columnWidth + columnProgress * W * S; // Sweep left to right
        if (x > W * S) continue; // Skip columns off-screen
        const gradient = c.createLinearGradient(x, 0, x + columnWidth, 0);
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0)'); // Transparent edge
        gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.4)'); // Smudged orange center
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)'); // Transparent edge
        c.fillStyle = gradient;
        c.fillRect(x, 0, columnWidth, H * S); // Draw full-height column
    }
    c.restore();
    needsRedraw = true; // Ensure continuous redraw during effect
} else if (ripBlastActive) {
    ripBlastActive = false; // End effect after 3 seconds
    columnProgress = 0;
    if (enemies.length === 0 && !exit) {
        if (placeStairs()) {
            wave++;
            if (wisps.length > 0) wispSpeak('victory'); // happy jingle
            waveActive = false;
            document.getElementById('wave').textContent = wave;
            logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);

            // Reveal entire floor when wave cleared (player sees stairs + map)
            fogMap = Array(H).fill().map(() => Array(W).fill(1));
            needsRedraw = true;
        } else {
            logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
        }
    }
    needsRedraw = true;
}

// Draw wisp companion (always, no dist gate + debug)
wisps.forEach(wisp => {
    if (wisp.x >= 0 && wisp.x < W && wisp.y >= 0 && wisp.y < H) {
        const dist = Math.sqrt((wisp.x - p.x) ** 2 + (wisp.y - p.y) ** 2);
        const alpha = 1.0; // Force full vis for debug (revert to fade later)
    
        // Auto-sync if too far
        if (dist > 6) {
            wisp.x = p.x; wisp.y = p.y;
            wisp.currentX = p.x * S; wisp.currentY = p.y * S;
            //console.log('Wisp synced'); // Debug: Check console
        }
    
        const now = performance.now();
        const bobOffset = Math.floor(Math.sin(now / 400) * 2 + 1); // Snaps to 0,1,2px (prominent, pixel-perfect)
        let drawY = wisp.currentY + bobOffset;
    
        c.save();
        c.globalAlpha = alpha;
   
        // Trail (keep for path vis)
        if (wisp.lastPos) {
            c.strokeStyle = `rgba(255,255,255,${0.3 * alpha})`;
            c.lineWidth = 2;
            c.beginPath();
            c.moveTo(wisp.lastPos.x, wisp.lastPos.y);
            c.lineTo(wisp.currentX + S/2, drawY + S/2);
            c.stroke();
        }
        wisp.lastPos = {x: wisp.currentX + S/2, y: drawY + S/2};
   
        const frames = assets.wispFrames[wisp.type.name];
        const frame = frames[wisp.anim.frameIndex];
        if (frame.complete) {
            c.drawImage(frame, wisp.currentX, drawY, S, S);
        }
   
        c.restore();
    }
});

// Draw fog overlay — SKIP IN PUZZLE ROOMS (mobile performance fix!)
if (!inPuzzleRoom) {
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] !== 1 && !fogMap[y][x]) {
                c.fillStyle = 'rgba(0,0,0,0.7)';
                c.fillRect(x * S, y * S, S, S);
            }
        }
    }
}
       
/**
 * Makes pure‑red pixels transparent (α = 0).  
 * Works for desert and ruins – the same color is used for the “eyes” in those PNGs.
 */
function punchHoleThroughRed(imageData) {
    const d = imageData.data;
    for (let i = 0; i < d.length; i += 4) {
        // Check for pure red or near-red with wider tolerance
        if (
            d[i] >= 200 && d[i] <= 255 && // Red component (wider range)
            d[i+1] <= 50 && // Green component (wider range)
            d[i+2] <= 50 // Blue component (wider range)
        ) {
            //console.log(`Found near-red pixel at index ${i}: R=${d[i]}, G=${d[i+1]}, B=${d[i+2]}, A=${d[i+3]}`);
            d[i+3] = 1; // Mark eye pixels with a unique alpha (1) to identify them later
        }
    }
}

// (removed old pulseAlpha calc - now using PNG frames)

const tempCanvas = document.createElement('canvas');
tempCanvas.width = S;
tempCanvas.height = S;
const tempCtx = tempCanvas.getContext('2d');

// Draw enemies with theme-based color overlays, preserving transparent backgrounds
enemies.forEach(e => {
    if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
        const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
        const isVisible = fogMap[e.y][e.x] === 1 || dist <= radius;
        
        // Check if this enemy is a unique monster
        const isUniqueMonster = e.uniqueName !== undefined;
// Invisible in fog for Cursed Trader OR Jester
if ((e.type.name === 'Cursed Trader' || e.type.name === 'Jester') && fogMap[e.y][e.x] === 0) {
    return; // Skip drawing
}
        
        // Draw sword for Cursed Trader if attacking
        if (e.swordActive && Date.now() - e.swordStart < 200 && e.type.name === 'Cursed Trader') {
            let sx = e.x, sy = e.y;
            if (e.swordDir === 'up') sy--;
            if (e.swordDir === 'down') sy++;
            if (e.swordDir === 'left') sx--;
            if (e.swordDir === 'right') sx++;
            if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
                c.save();
                c.translate(sx * S + S / 2, sy * S + S / 2);
                if (e.swordDir === 'up') c.rotate(-Math.PI / 2);
                if (e.swordDir === 'down') c.rotate(Math.PI / 2);
                if (e.swordDir === 'left') c.rotate(Math.PI);
                c.drawImage(assets.sword, -S / 2, -S / 2, S, S);
                c.restore();
            }
        }
        
        c.save();
        const doPixelEffect = (frameCount % 1 === 0); 

        if (isVisible) {
            // Red pulsing bg circles — skip for huge shrimp (safe across variable names)
            const currentEnemy = e || hit || enemy || dead || null;
            if (currentEnemy && !currentEnemy.isHuge) {
                const bgStartTime = enemyBgFrameTimes.get(currentEnemy) || performance.now();
                enemyBgFrameTimes.set(currentEnemy, bgStartTime);
                const now = performance.now();
                const frameIndex = Math.floor((now - bgStartTime) / 200) % 3;
                const bgImg = assets.enemyBg[frameIndex];
                if (bgImg.complete) {
                    c.drawImage(bgImg, currentEnemy.currentX, currentEnemy.currentY, S, S);
                }
            }
        }

        enemyTempCtx.clearRect(0, 0, S, S);

        // Handle animation timing
        if (e.type.anim && e.anim) {
            const now = performance.now();
            const numFrames = (e.type.name === 'Shrimp' && currentTheme === 'hell' && e.type.anim.hellFrames) 
                ? e.type.anim.hellFrames.length 
                : e.type.anim.frames.length;
            if (now - e.anim.lastFrameTime >= 200) {
                e.anim.frameIndex = (e.anim.frameIndex + 1) % numFrames;
                e.anim.lastFrameTime = now;
            }
        }

            // Select frame — use themed assets when visible, dungeon black in fog
            // Default to dungeon black enemies
            let frames = e.type.anim.frames;

            if (isVisible) {
                // Special case: Hell Shrimp always uses hellFrames in hell theme
                if (e.type.name === 'Shrimp' && currentTheme === 'hell' && e.type.anim.hellFrames) {
                    frames = e.type.anim.hellFrames;
                }
                // Other enemies: use theme-specific frames if available
                else if (currentTheme === 'paradise' && e.type.anim.paradiseFrames) {
                    frames = e.type.anim.paradiseFrames;
                } else if (currentTheme === 'ruins' && e.type.anim.ruinsFrames) {
                    frames = e.type.anim.ruinsFrames;
                } else if (currentTheme === 'desert' && e.type.anim.desertFrames) {
                    frames = e.type.anim.desertFrames;
                } else if (currentTheme === 'hell' && e.type.anim.hellFrames) {
                    frames = e.type.anim.hellFrames;
                }
            }

            img = frames[e.anim.frameIndex];
            // Fallback to dungeon frame if themed image not loaded yet
            if (!img.complete || img.naturalWidth === 0) {
                img = e.type.anim.frames[e.anim.frameIndex];
            }

        // Draw base sprite
        enemyTempCtx.imageSmoothingEnabled = false;
        enemyTempCtx.drawImage(img, 0, 0, S, S);

        // Apply unique monster poison green + red eyes overlay (safe across e/hit/enemy/dead)
        const currentEnemy = e || hit || enemy || dead;
        if (currentEnemy && currentEnemy.uniqueName && currentEnemy.type.name !== 'Cursed Trader' && currentEnemy.type.name !== 'Jester' && !currentEnemy.isHuge && isVisible) {
            const imageData = enemyTempCtx.getImageData(0, 0, S, S);
            const data = imageData.data;

            punchHoleThroughRed(imageData);

            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] === 1) { // Eye pixel
                    data[i] = 255;
                    data[i + 1] = 0;
                    data[i + 2] = 0;
                    data[i + 3] = 255;
                } else if (data[i + 3] > 0) { // Body pixel
                    data[i] = 0;
                    data[i + 1] = 255;
                    data[i + 2] = 0;
                    data[i + 3] = Math.round(0.95 * 255);
                }
            }
            enemyTempCtx.putImageData(imageData, 0, 0);
        }

// Frozen overlay — ONLY for wisp freeze (not Ensnare)
if (currentEnemy.frozen && !currentEnemy.frozenByEnsnare && isVisible) {
    const typeName = currentEnemy.type.name.toLowerCase();
    const frozenFrames = assets[`frozen_${typeName}`];

    // Use only the first frame if it exists and is loaded
    if (frozenFrames && frozenFrames[0].complete) {
        enemyTempCtx.clearRect(0, 0, S, S);
        enemyTempCtx.drawImage(frozenFrames[0], 0, 0, S, S);
    }
}

        // Pulsating red soulstorm circle under enraged huge shrimp
        if (e.isHuge && e.ragePulseStart) {
            const pulseTime = (performance.now() - e.ragePulseStart) / 400;
            const pulseAlpha = 0.4 + 0.3 * Math.sin(pulseTime * Math.PI);
            const radius = S * (1 + 0.3 * Math.sin(pulseTime * Math.PI)); // gently breathing size
            c.save();
            c.globalAlpha = pulseAlpha;
            c.fillStyle = 'rgba(255, 0, 0, 0.7)';
            c.beginPath();
            c.arc(e.currentX + S, e.currentY + S, radius, 0, Math.PI * 2);
            c.fill();
            c.restore();
        }
        
                        // Draw the processed sprite to the main canvas
                        if (e.isHuge) {
                            c.drawImage(enemyTempCanvas, e.currentX - S/2, e.currentY - S/2, S*2, S*2); // 32x32 centered
                        } else {
                            c.drawImage(enemyTempCanvas, e.currentX, e.currentY, S, S);                            
                        }

                        // DRAMATIC WALL‑CRUSH DEATH — show even if already dead
                        if (!e.isHuge && e.crushedToWall) {
                            const crushTime = performance.now() - e.crushedToWall.startTime;
                            if (crushTime < 600) { // 600 ms death animation
                                const progress = crushTime / 600;
                                const crushX = e.x * S + (e.crushedToWall.targetX - e.x) * S * progress;
                                const crushY = e.y * S + (e.crushedToWall.targetY - e.y) * S * progress;

                                // Slide to wall
                                c.save();
                                c.translate(crushX, crushY);
                                c.globalAlpha = 1 - progress; // fade out
                                c.scale(1 + progress * 0.5, 1 + progress * 0.5); // explode scale
                                c.drawImage(enemyTempCanvas, -S/2, -S/2, S, S);
                                c.restore();

                            } else {
                                // Animation done → clean up and let normal death removal handle it
                                delete e.crushedToWall;
                                if (e.hp <= 0) {
                                    enemies = enemies.filter(en => en !== e);
                                }
                            }
                        }

// Huge shrimp death explosion – Bitcoin orange-ish splash
if (e.isHuge && e.hp <= 0 && e.deathTime) {
    const deathTime = performance.now() - e.deathTime;
    if (deathTime < 400) {                     // 400 ms total
        const progress = deathTime / 400;

        // Shrimp sprite fades and expands
        c.save();
        c.globalAlpha = 1 - progress;
        c.translate(e.currentX + S, e.currentY + S);
        c.scale(1 + progress * 2, 1 + progress * 2);
        c.drawImage(enemyTempCanvas, -S, -S, S * 2, S * 2);
        c.restore();

        // ----- Blood splash -----
        const splashRadius = S * 2 * progress;          // grows with progress
        c.save();
        // Fade out as it expands
        c.globalAlpha = 0.8 * (1 - progress);

        c.fillStyle = 'rgba(255, 140, 0, 0.9)';            // Bitcoin orange-ish
        c.beginPath();
        c.arc(e.currentX + S, e.currentY + S, splashRadius, 0, Math.PI * 2);
        c.fill();
        c.restore();

        needsRedraw = true;
    } else {
        delete e.deathTime; // cleanup after animation finishes
    }
}

                        // SCOURGE HIT FLASH (bright orange-red)
                        if (e.scourgeHit && Date.now() - e.scourgeHit < 200) {
                            c.save();
                            c.fillStyle = 'rgba(255,100,0,0.7)';
                            c.fillRect(e.currentX, e.currentY, S, S);
                            c.restore();
                        }

                        // Draw bit shield flash when active (transparent-ish blue circle)
                        if (e.shieldFlash && e.shieldFlash.active) {
                            const elapsed = Date.now() - e.shieldFlash.startTime;
                            if (elapsed < 300) { // flash for 300ms
                                const alpha = 0.6 * (1 - elapsed / 300);
                                c.fillStyle = `rgba(0, 200, 255, ${alpha})`; // bright cyan
                                c.beginPath();
                                c.arc(e.currentX + S/2, e.currentY + S/2, S/2 + 4, 0, Math.PI * 2);
                                c.fill();
                                needsRedraw = true;
                            } else {
                                e.shieldFlash.active = false;
                            }
                        }

c.restore();

// Wisp hit flash on enemies (inside loop)
        if (e.wispHitFlash && Date.now() - e.wispHitFlash.time < 200) {
            c.save();
            let flashColor = 'rgba(0, 0, 0, 0)'; // Default no color (freeze)
            switch (e.wispHitFlash.type) {
                case 'earth': flashColor = 'rgba(180, 92, 13, 0.6)'; // Brown quake
                    break;
                case 'chain': flashColor = 'rgba(252, 194, 12, 0.5)'; // Yellow lightning
                    break;
                case 'fire': flashColor = 'rgba(239, 28, 36, 0.55)'; // Red fire bolt
                    break;
                // cold/freeze stays colorless
            }
            c.fillStyle = flashColor;
            c.fillRect(e.currentX, e.currentY, S, S);
            c.restore();
            if (Date.now() - e.wispHitFlash.time > 200) delete e.wispHitFlash;
        }
    }

// Draw drifting Frost Nova
frostNovaProjectiles.forEach(nova => {
    const frame = assets.frostNova[nova.frameIndex];
    if (frame && frame.complete) {
        c.drawImage(frame, nova.currentX, nova.currentY, S, S);
    }
});

    // Draw wisp attack projectiles (on top of enemies)
const drawAttackProjectiles = (projectiles, framesArray) => {
    projectiles.forEach(proj => {
        const frame = framesArray[proj.frameIndex];
        if (frame && frame.complete) {
            c.drawImage(frame, proj.currentX, proj.currentY, S, S);
        }
    });
};

    drawAttackProjectiles(wispFireBoltProjectiles, assets.wispFireBolt);
    drawAttackProjectiles(wispLightningProjectiles, assets.wispLightning);
    drawAttackProjectiles(wispEarthquakeProjectiles, assets.wispEarthquake);
   
// Draw entangle overlay ON TOP of enemies
entangleAnimations.forEach(ent => {
    if (assets.entangleFrames[ent.frameIndex].complete) {
        c.save();
        c.globalAlpha = 0.9;
        c.drawImage(assets.entangleFrames[ent.frameIndex], ent.x * S, ent.y * S, S, S);
        c.restore();
    }
});
        
}); // END OF DRAWING OF ENEMIES ETC ..

// Draw sandworm on top — hide completely in puzzle room or hideout
if (sandworm && !inPuzzleRoom && !inHideout) {
    const dist = Math.sqrt((sandworm.x - p.x)**2 + (sandworm.y - p.y)**2);
    const isVisible = fogMap[sandworm.y][sandworm.x] === 1 || dist <= radius;
    
    if (isVisible) {
        const now = performance.now();
        if (now - assets.sandworm.lastFrameTime >= assets.sandworm.frameDuration) {
            assets.sandworm.frameIndex = (assets.sandworm.frameIndex + 1) % 3;
            assets.sandworm.lastFrameTime = now;
        }
        c.drawImage(
            assets.sandworm[assets.sandworm.frameIndex],
            sandworm.currentX, sandworm.currentY, S, S
        );
    }
}

    document.getElementById('potions').textContent = p.potions;
    document.getElementById('health').textContent = Math.max(0, p.hp);

// (deleted: moved to updatePlayerState() for centralized death check)
    document.getElementById('pickaxes').textContent = p.pickaxes;
    
// Consolidated name display – clears Cursed Trader and uniques properly
let nameToShow = null;
let isHarbinger = false;

// Visible unique blockchain monsters (exclude Cursed Trader)
const visibleUniques = enemies.filter(e => e.uniqueName && e.type.name !== 'Cursed Trader' && e.type.name !== 'Jester' && !e.isHuge && fogMap[e.y][e.x] === 1);
if (visibleUniques.length > 0) {
    nameToShow = visibleUniques[0].uniqueName;
    // Trigger wisp TTS when first seeing a unique monster (only if wisp is alive)
    if (wisps.length > 0) {
        const uniqueKey = visibleUniques[0].uniqueName;
        if (!window.spokenUniques) window.spokenUniques = new Set();
        if (!window.spokenUniques.has(uniqueKey)) {
            window.spokenUniques.add(uniqueKey);
           
            // Map unique type to talk line index, starting from 0
            const typeMap = {
                'Shrimp': 6, // "HA HA. Shwrimp!"
                'Crab': 4, // "Watch out"
                'Squid': 4, // "Watch out"
                'Dolphin': 4, // "Watch out"
                'Shark': 2, // "Nooo. -Shark"
                'Whale': 1 // "BITCoOIN,"
            };
            const lineIndex = typeMap[visibleUniques[0].type.name] || Math.floor(Math.random() * talkLines.length);
            
            // Delay the speak call slightly to ensure AudioContext is ready
            setTimeout(() => {
                talkSpeak(lineIndex);
            }, 200); // 200ms delay - adjust if needed
        }
    }
}

// Visible Cursed Trader
const visibleTrader = enemies.find(e => e.type.name === 'Cursed Trader' && fogMap[e.y][e.x] === 1);
if (visibleTrader) {
    nameToShow = 'Cursed Trader';   
}

// Harbinger message for uniques in fog
if (!nameToShow) {
    const fogUniques = enemies.filter(e => e.uniqueName && e.type.name !== 'Jester' && fogMap[e.y][e.x] === 0);
    if (fogUniques.length > 0) {
        nameToShow = "A harbinger of doom is near.";
        isHarbinger = true;
    }
}

const floorIndicator = document.getElementById('floor-indicator');
const cachedText = window.currentFloorText || `Floor ${floor}`;
const debounceMs = isHarbinger ? 2000 : 1000;

if (nameToShow && nameToShow !== cachedText && (now - (window.lastUniqueSetTime || 0) > debounceMs) && !floorIndicator.textContent.startsWith("Runeword")) {
    floorIndicator.textContent = nameToShow;
    window.currentFloorText = nameToShow;
    window.lastUniqueSetTime = now;
    activeUniqueMonsterName = nameToShow;

    setTimeout(() => {
        if (activeUniqueMonsterName === nameToShow) {
            activeUniqueMonsterName = null;
            floorIndicator.textContent = `Floor ${floor}`;
            window.currentFloorText = `Floor ${floor}`;
        }
    }, 5000);
} else if (!nameToShow && cachedText !== `Floor ${floor}` && !floorIndicator.textContent.startsWith("Runeword")) {
    floorIndicator.textContent = `Floor ${floor}`;
    window.currentFloorText = `Floor ${floor}`;
    activeUniqueMonsterName = null;
}

    updateAndDrawMatrix();  // ← PERFECT SPOT! Magical flames + red balls


// ───── SNOW (snowy hell – zoom-aware, no snapping) ─────
if (snowyHellActive && snowflakes.length) {
    const SCREEN_W = zoomEnabled ? 640 : 320;
    const SCREEN_H = zoomEnabled ? 640 : 320;
    const SCALE = zoomEnabled ? 2 : 1;

    c.fillStyle = 'rgba(255,255,255,0.9)';
    snowflakes.forEach(f => {
        f.y += f.speed * SCALE;
        f.x += Math.sin(performance.now() / 1000 + f.sway) * 0.3 * SCALE;
        if (f.y > SCREEN_H) {
            f.y = -f.size * SCALE;
            f.x = Math.random() * SCREEN_W;
        }
        if (f.x < -10) f.x = SCREEN_W - 1;
        if (f.x > SCREEN_W + 10) f.x = 0;
        c.fillRect(f.x, f.y, f.size * SCALE, f.size * SCALE);
    });
}

// ───── RAIN (rainy RUINS ) ─────
if (ruinsRainActive && currentTheme === 'ruins' && raindrops.length) {
    // Sharp, short diagonal rain spikes (drawn first)
    c.strokeStyle = 'rgba(140, 170, 240, 0.95)';
    c.lineWidth = 0.7;
    c.lineCap = 'round';

    raindrops.forEach(d => {
        d.y += d.speed * 2;
        d.x += d.speed * 0.5 * Math.sin(ruinsRainAngle);

        if (d.y > 340) {
            d.y = -15;
            d.x = Math.random() * 340 - 10;

            // Splash spawning (safe version from earlier)
            if (Math.random() < 0.4) {
                let attempts = 0;
                let tileX, tileY;
                do {
                    tileX = Math.floor(p.x + (Math.random() - 0.5) * 8);
                    tileY = Math.floor(p.y + (Math.random() - 0.5) * 8);
                    attempts++;
                } while (
                    attempts < 20 &&
                    (tileX < 0 || tileX >= W || tileY < 0 || tileY >= H ||
                     !map[tileY] || map[tileY][tileX] !== 0)
                );

                if (tileY >= 0 && tileY < H && map[tileY] && map[tileY][tileX] === 0) {
                    floorSplashes.push({ tileX, tileY, start: Date.now() });
                }
            }
        }

        const length = 2 + Math.random() * 2;
        c.beginPath();
        c.moveTo(d.x, d.y);
        c.lineTo(d.x + length * Math.sin(ruinsRainAngle), d.y + length);
        c.stroke();
    });

    // Wet floor tint — drawn LAST so it doesn't interfere with portals/stairs
    c.fillStyle = 'rgba(0, 0, 50, 0.22)';
    c.fillRect(0, 0, 320, 320);
}

// ───── RESTORE ONLY IF WE ZOOMED ─────
if (zoomEnabled && !splashActive && !gameOver) {

// Bitcoin orange stairs arrow (world‑plane, floats above player)
if (exit) {
    const now   = performance.now();
    const angle = Math.atan2(exit.y - p.y, exit.x - p.x);
    const pulse = 1 + 0.15 * Math.sin(now / 600);
    const bob   = 0.08 * Math.sin(now / 300);

    const arrowX = p.currentX + S / 2;
    const arrowY = p.currentY - S * 1.5 + bob * S;

    c.save();
    c.translate(arrowX, arrowY);
    c.rotate(angle);
    c.scale(pulse, pulse);

    // ---- RETRO PIXEL ARROW (mid size) ----
    c.font = 'bold 14px "Courier New", monospace';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    c.fillStyle   = '#F7931A';
    c.strokeStyle = '#FF4400';
    c.lineWidth   = 1.5;
    c.shadowColor = '#F7931A';
    c.shadowBlur  = 6;

    // Size choice: 9 px total height (≈ 75 % of original)
    const size      = 9;   // overall height
    const tipHeight = 3;   // tip length (half of total height)
    // shaft height is implicit: size - tipHeight

    c.beginPath();
    // tip
    c.moveTo( tipHeight, -size/2 );
    c.lineTo( size,      0 );
    c.lineTo( tipHeight,  size/2 );
    // shaft
    c.lineTo( tipHeight,  size/4 );
    c.lineTo( 0,          size/4 );
    c.lineTo( 0,         -size/4 );
    c.lineTo( tipHeight, -size/4 );
    c.closePath();

    c.stroke();   // outline
    c.fill();     // fill

    c.restore();
}

    c.restore();
}

    // Top-right armor icon
    const armorIcon = document.getElementById('armor-icon-container');
    let currentArmorImg = null;
    if (redMazeAuraGiven) currentArmorImg = assets.inv_maze_aura;
    else if (p.hasCursedRing) currentArmorImg = assets.inv_cursed_aura;
    else if (p.hasDiamondArmor) currentArmorImg = assets.inv_diamond_armor;
    else if (p.hasArmor) currentArmorImg = assets.inv_leather;
    else currentArmorImg = assets.inv_cloth;

    if (currentArmorImg && currentArmorImg.complete) {
        armorIcon.innerHTML = '';
        const img = currentArmorImg.cloneNode();
        img.style.width = '48px';
        img.style.height = '48px';
        img.style.imageRendering = 'pixelated'; // Crisp pixels, no smoothing
        // Center if asset has transparency around a central design
        img.style.display = 'block';
        img.style.margin = 'auto';
        armorIcon.appendChild(img);
    }

    // Jester's Acrobatics buff icon (left of armor)
    if (p.hasAcrobaticsBuff) {
        const acrobaticsContainer = document.getElementById('acrobatics-icon-container') || (() => {
            const div = document.createElement('div');
            div.id = 'acrobatics-icon-container';
            div.style.cssText = 'position:absolute;top:0px;right:42px;width:48px;height:48px;z-index:20;pointer-events:none;';
            document.getElementById('top-right-ui').insertBefore(div, document.getElementById('armor-icon-container'));
            return div;
        })();
        acrobaticsContainer.innerHTML = '';
        const img = assets.jester_acrobatics.cloneNode();
        img.style.width = '48px';
        img.style.height = '48px';
        img.style.imageRendering = 'pixelated';
        acrobaticsContainer.appendChild(img);
    } else {
        const container = document.getElementById('acrobatics-icon-container');
        if (container) container.innerHTML = '';
    }

    // GUI for health and soul charges – crisp & screen-space ready (2x on zoom)
    if (assets.guiHP?.complete && assets.guiHPglobe?.complete &&
        assets.guiSC?.complete && assets.guiSCglobe?.complete) {

        c.imageSmoothingEnabled = false;

        const scale = zoomEnabled ? 2 : 1;
        const padding = 0 * scale;
        const bgY = (320 - 37 * scale); // bottom-aligned
        const hpBgX = padding;
        // SC background: compensate for canvas scaling from top-left (extra shift left by full canvas width)
        const scBgX = zoomEnabled 
            ? (320 * scale - 45 * scale - padding) - (320 * (scale - 1)) 
            : (320 - 45 - padding);

        // Draw backgrounds (scaled)
        c.drawImage(assets.guiHP, hpBgX, bgY, 46 * scale, 37 * scale);
        c.drawImage(assets.guiSC, scBgX, bgY, 45 * scale, 37 * scale);

        // Globe size & positioning
        const globeW = 31 * scale;
        const globeH = 30 * scale;
        const hpOffsetX = Math.floor((46 * scale - globeW) - 2 * scale);
        const scOffsetX = Math.floor((45 * scale - globeW) / 7);
        const globeOffsetY = Math.floor((37 * scale - globeH) / 4);

        const hpGlobeX = Math.floor(hpBgX + hpOffsetX);
        const scGlobeX = Math.floor(scBgX + scOffsetX);
        const globeY = Math.floor(bgY + globeOffsetY);

        // HP globe fill
        const hpPercent = Math.max(0, Math.min(1, p.hp / 36));
        const hpFillH = Math.floor(globeH * hpPercent + 0.0001);

        c.save();
        c.beginPath();
        c.rect(hpGlobeX, globeY + globeH - hpFillH, globeW, hpFillH);
        c.clip();
        c.drawImage(assets.guiHPglobe, hpGlobeX, globeY, globeW, globeH);
        c.restore();
        
        // Overlay current HP as text centered on HP globe
        c.imageSmoothingEnabled = false; // Ensure no blur on text
        c.font = (11 * scale) + 'px VT323'; // Scale font with zoom
        c.fillStyle = '#000000';
        c.textAlign = 'center';
        c.textBaseline = 'middle';
        c.fillText(p.hp.toString(), hpGlobeX + globeW / 2, globeY + globeH / 2 + 1 * scale); // Slight Y nudge for better centering


        // Soul Charges globe fill
        const scPercent = Math.max(0, Math.min(1, p.soulStormCharges / 256));
        const scFillH = Math.floor(globeH * scPercent + 0.0001);

        c.save();
        c.beginPath();
        c.rect(scGlobeX, globeY + globeH - scFillH, globeW, scFillH);
        c.clip();
        c.drawImage(assets.guiSCglobe, scGlobeX, globeY, globeW, globeH);
        c.restore();

        // HP overfill flash (scaled)
        if (hpOverfillFlashStart > 0) {
            const elapsed = Date.now() - hpOverfillFlashStart;
            if (elapsed < 300) {
                const flashAlpha = 0.75 * (1 - elapsed / 300);
                c.save();
                c.fillStyle = `rgba(255, 100, 0, ${flashAlpha})`;
                c.beginPath();
                c.arc(
                    hpGlobeX + globeW / 2,
                    globeY + globeH / 2,
                    Math.min(globeW, globeH) / 2 + 3 * scale,
                    0, Math.PI * 2
                );
                c.fill();
                c.restore();
            } else {
                hpOverfillFlashStart = 0;
            }
        }
    }

    // Low-health warning – full screen pulsing border (drawn on top of GUI, works in both zoom/non-zoom)
    if ((p.hp <= 4 || (p.hp > 4 && p.hp < 9)) && !gameOver && !splashActive) {
        const pulse = Math.sin(Date.now() / 100);
        const alpha = 0.5 + 0.1 * pulse;
        const color = p.hp <= 4 ? `rgba(255, 0, 0, ${alpha})` : `rgba(255, 165, 0, ${alpha})`;

        c.strokeStyle = color;
        c.lineWidth = 8;
        c.beginPath();
        c.rect(0, 0, 320, 320); // full logical canvas border
        c.stroke();
    }

// ───── ZELDA-ISH RADAR MINIMAP – TOP-LEFT BELOW FLOOR TEXT (PERFECTION) ─────
if (minimapVisible && zoomEnabled) {
    const MINI_W = 64;
    const MINI_H = 64;
    const MINI_S = MINI_W / W;  // 3.2px per tile

    // Position: top-left, just below "Floor X" text
    const PADDING = 8;
    const X = PADDING;
    const Y = 38;  // 38px down = just below floor text (perfect on all screens)

    c.save();
    c.translate(X, Y);

    // Dark semi-transparent background
    c.fillStyle = 'rgba(27, 22, 16, 0.5)';
    c.fillRect(0, 0, MINI_W, MINI_H);

    // ALL enemies (true radar)
    enemies.forEach(e => {
        const mx = e.x * MINI_S;
        const my = e.y * MINI_S;
        c.fillStyle = '#F7931A';
        c.fillRect(mx + 0.5, my + 0.5, MINI_S * 0.8, MINI_S * 0.8); // same size as player
    });

// Red Maze boss eye on minimap (bright orange square like enemies)
if (redMazeActive && redMaze) {
    const mx = redMaze.x * MINI_S;
    const my = redMaze.y * MINI_S;
    c.fillStyle = '#FF0000'; // red boss marker
    c.fillRect(mx + 0.5, my + 0.5, MINI_S * 0.8, MINI_S * 0.8);
}

    // Player (white dot)
    const px = p.x * MINI_S + 0.5;
    const py = p.y * MINI_S + 0.5;
    c.fillStyle = '#FFFFFF';
    c.fillRect(px - 1, py - 1, MINI_S * 0.8, MINI_S * 0.8);

    c.restore();
}

    // THIS IS THE MAIN DRAW, MADE TO CREATE EFFECTS BEFORE "needsRedraw = false"
    needsRedraw = false;
    frameCount++;
}

// GOLDEN : 2 PART 1
let rafId = null;
let lastTimestamp = 0;          // ← keep the previous RAF time

const startGameLoop = () => {
    // GOLDEN : 2 PART 2
    // Reset the timing source so the first delta after resume is tiny
    lastTimestamp = performance.now();
    if (rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(gameLoop);
};

function gameLoop(timestamp) {
    // GOLDEN : 3
    // If this is the very first frame after a resume, ignore the huge delta
    if (lastTimestamp === 0) lastTimestamp = timestamp;
    const delta = timestamp - lastTimestamp;
    lastTimestamp = timestamp;
    
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state');
        initMap();
        needsRedraw = true;
    }

    // Detect HP damage while overfilled (>36) for globe flash
    if (p.hp < previousHP && p.hp > 36) {
        hpOverfillFlashStart = Date.now();
    }
    previousHP = p.hp;
    
if (gameOver) {
    musicManager.mute(true);
    musicManager.play(currentTheme);
    if (!gameOverSoundPlayed) {
        sounds.gameover.play().catch(e => console.error('Gameover sound error:', e));
        gameOverSoundPlayed = true;
    }
    document.getElementById('health').textContent = 0;
    // Reset text color to Bitcoin orange for game-over screen
    document.documentElement.style.setProperty('--text-color', '#ff8c00');
    document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #leaderboard-output, #username-input, #sats-calc').forEach(el => {
        el.style.color = '#ff8c00';
    });
    
    // Add gamepad control blocking logic
    if (gamepadIndex !== null && !inputBlocked) {
        inputBlocked = true;
        // Block controls for 1 second (1000ms)
        setTimeout(() => {
            inputBlocked = false;
        }, 1000);
    }
    
// Auto-submit score with random name from names array only if gamepad is connected
   if (!scoreSubmitted && gamepadIndex !== null && !autoSubmitTriggered) {
       autoSubmitTriggered = true;
       // Do NOT auto-submit anymore - user must press B button to submit
   }
    needsRedraw = true;
}
    
updateProjectiles();

// Sandworm burrow
if (sandworm && !sandwormBurrowPaused && performance.now() > sandworm.nextBurrowTime) {
    // Pick random floor tile
    let attempts = 50;
    let nx, ny;
    do {
        nx = Math.floor(Math.random() * W);
        ny = Math.floor(Math.random() * H);
    } while (attempts-- > 0 && map[ny][nx] !== 0);

    if (attempts > 0) {
        sandworm.x = nx;
        sandworm.y = ny;
        sandworm.currentX = nx * S;
        sandworm.currentY = ny * S;
    }
    sandworm.nextBurrowTime = performance.now() + 3000 + Math.random() * 4000;
    needsRedraw = true;
}

// Update frost nova projectiles
frostNovaProjectiles = frostNovaProjectiles.filter(nova => {
    const elapsed = performance.now() - nova.startTime;
    const duration = 800; // 800ms drift
    if (elapsed >= duration) return false; // remove when done

    const progress = elapsed / duration;
    nova.currentX = nova.x * S + progress * (nova.targetX - nova.x * S);
    nova.currentY = nova.y * S + progress * (nova.targetY - nova.y * S);
    nova.frameIndex = Math.floor(elapsed / 200) % 3; // 200ms per frame
    return true;
});

// Update wisp attack projectiles (fire, lightning, earthquake)
const updateAttackProjectiles = (projectiles) => {
    return projectiles.filter(proj => {
        const elapsed = performance.now() - proj.startTime;
        const duration = 600;
        if (elapsed >= duration) return false;

        const progress = elapsed / duration;
        proj.currentX = proj.x * S + progress * (proj.targetX - proj.x * S);
        proj.currentY = proj.y * S + progress * (proj.targetY - proj.y * S);

        // Cycle through 3 frames (150ms per frame)
        proj.frameIndex = Math.floor(elapsed / 150) % 3;

        return true;
    });
};

wispFireBoltProjectiles = updateAttackProjectiles(wispFireBoltProjectiles);
wispLightningProjectiles = updateAttackProjectiles(wispLightningProjectiles);
wispEarthquakeProjectiles = updateAttackProjectiles(wispEarthquakeProjectiles);

// Update entangle animations
entangleAnimations = entangleAnimations.filter(ent => {
    const elapsed = performance.now() - ent.startTime;
    const frameTime = 200; // 200ms per frame
    ent.frameIndex = Math.min(2, Math.floor(elapsed / frameTime)); // 0→1→2, stop at 3rd frame
    return elapsed < 600; // keep for 600ms total
});

updateRedMaze();

    // Unique monster harasses player who stands still inside its spell
    const playerOnSpell = dangerousAreas.some(area => area.x === p.x && area.y === p.y);
    if (playerOnSpell) {
        if (spellHarassTimer === 0) {
            spellHarassTimer = performance.now() + 2000 + Math.random() * 2000; // first harass in 2–4s
        }
        if (performance.now() >= spellHarassTimer) {
            const caster = enemies.find(e => 
                e.uniqueName && e.spell && dangerousAreas.some(a => a.spellType === e.spell && a.x === p.x && a.y === p.y)
            );
            if (caster) {
                applySpellDamage(p.x, p.y); // harass = damage
                logBattleEvent(`Floor ${floor} - ${caster.uniqueName} surges through the ${caster.spell}!`);
                moveEnemies(); // normal AI moves everyone naturally
                needsRedraw = true;
            }
            spellHarassTimer = performance.now() + 2000 + Math.random() * 2000; // next pulse every 2–4s
        }
    } else {
        spellHarassTimer = 0; // reset when player leaves spell
    }

// Simple delta updates (run every frame for smooth movement)
if (p.moving) {
    const elapsed = performance.now() - p.moveStartTime;
    const progress = Math.min(elapsed / p.moveDuration, 1); // 0 to 1 over duration
    const eased = 0.5 + 0.5 * Math.sin(Math.PI * progress - Math.PI / 2); // Smooth ease-in-out
    p.currentX = p.startX * S + eased * (p.x * S - p.startX * S);
    p.currentY = p.startY * S + eased * (p.y * S - p.startY * S);
    p.currentX = Math.floor(p.currentX); // Pixel-snap
    p.currentY = Math.floor(p.currentY);
    if (progress >= 1) {
        p.moving = false;
        p.anim.frameIndex = 0; // Reset to idle frame on stop
        p.currentX = p.x * S;
        p.currentY = p.y * S;
    }
    needsRedraw = true;
}
enemies.forEach(e => {
    if (e.moving) {
        e.currentX += e.deltaX;
        e.currentY += e.deltaY;
        e.stepsLeft--;
        if (e.stepsLeft <= 0) {
            e.moving = false;
            e.currentX = e.x * S;
            e.currentY = e.y * S;
        }
        needsRedraw = true;
    }
});

        // Warden interpolation (smooth pixel steps)
        if (echoWardenPos && echoWardenPos.moving) {
            echoWardenPos.currentX += echoWardenPos.deltaX;
            echoWardenPos.currentY += echoWardenPos.deltaY;
            echoWardenPos.stepsLeft--;

            if (echoWardenPos.stepsLeft <= 0) {
                echoWardenPos.moving = false;
                echoWardenPos.currentX = echoWardenPos.x * S;
                echoWardenPos.currentY = echoWardenPos.y * S;
            }
            needsRedraw = true;
        }

// Interp wisp movement
wisps.forEach(wisp => {
    if (wisp.moving) {
        wisp.currentX += wisp.deltaX;
        wisp.currentY += wisp.deltaY;
        wisp.stepsLeft--;
        if (wisp.stepsLeft <= 0) {
            wisp.moving = false;
            wisp.currentX = wisp.x * S;
            wisp.currentY = wisp.y * S;
        }
        needsRedraw = true;
    }
});

// Frame animation (only when moving) - throttled
const now = performance.now();
if (p.moving && now - p.anim.lastFrameTime >= 50) {
    p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
    p.anim.lastFrameTime = now;
}
    
    // Check for invisible health warning animation (activated at above 8 HP)
    const showInvisibleHealthWarning = p.hp > 8; // Trigger animation at higher threshold
    
    // Throttle draw to 20 FPS, but keep updates smooth
    if ((needsRedraw || p.hp <= 8 || showInvisibleHealthWarning) && !splashActive) {
        draw();
    }
    

    // GOLDEN : 4
    rafId = requestAnimationFrame(gameLoop);
}

// Main global keydown listener (handles movement, attack, potion, etc.)
document.addEventListener('keydown', e => {

// 1.) this code block makes the a and d key to work as aspected inside the passive tree terminal (combined)
// Allow 'a' and 'd' (and all keys) when typing in soul or passive terminal input
    if ((p.inPassiveTerminal && p.passiveTerminalActive && e.target.matches('#passive-input'))) {
        // Let the input field handle the key normally (typing 'a', 'd', etc.)
        return;
    }

// 2.) this code block makes the a and d key to work as aspected inside the passive tree terminal (combined)
// BLOCK attack/potion ONLY when a terminal is open but input is NOT focused
    if ((p.inPassiveTerminal && p.passiveTerminalActive)) {
        if (e.key === 'a' || e.key === 'd') {
            e.preventDefault();
            e.stopPropagation();
            return; // No attack/potion sound/action
        }
    }

    // Soul terminal input handling (when focused)
    if (p.inSoulTerminal && p.soulTerminalActive) {
        handleTerminalInput(e);
        return;
    }

    // Passive terminal input handling (when focused)
    if (p.inPassiveTerminal && p.passiveTerminalActive) {
        handlePassiveInput(e);
        return;
    }

    // Soul terminal blurred input fallback
    if (p.inSoulTerminal && p.soulTerminalActive && !e.target.matches('#soul-terminal-input')) {
        if (e.key.length === 1 && e.key !== 'Enter') {
            handleBlurredTerminalInput(e.key);
        }
        return;
    }

    // Passive terminal blurred input fallback (add this too)
    if (p.inPassiveTerminal && p.passiveTerminalActive && !e.target.matches('#passive-input')) {
        if (e.key.length === 1 && e.key !== 'Enter') {
            handleBlurredPassiveInput(e.key);
        }
        return;
    }

    // Normal game controls (only reach here if no terminal is open)
    if (gameOver || splashActive) return;

    if (skillTreeActive) {
        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            if (pendingSkillTreeLevel === 3 && !playerClass && !window.skillTreeInputBlocked) {
                skillTreeSelectedOption = (e.key === 'ArrowLeft') ? 0 : 1;
                updateClassHighlight();
                needsRedraw = true;
            }
        }
        if (e.key === 'Enter' || e.key === ' ') {
            selectSkillTreeOption();
        }
        e.preventDefault();
        return;
    }

    // Enter key special cases
    if (e.key === 'Enter') {
        // Username input on game over
        if (document.activeElement && document.activeElement.id === 'username-input') {
            return; // Let input handler deal with it
        }
        // Splash screen start
        if (splashActive) {
            if (!hasPlayedOnce) return; // Block initial splash
            const startButton = document.getElementById('start-button');
            startButton.style.background = '#00b7ef';
            setTimeout(() => startButton.style.background = '#00e8d8', 200);
            currentTheme = 'dungeon';
            if (currentSplashImage !== 'splash.png') {
                currentSplashImage = 'splash.png';
                splashCanvas.clearRect(0, 0, 320, 320);
                splashImg.src = currentSplashImage;
                splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
            }
            fadeSplash();
            setTimeout(() => {
                if (!gameOver && !splashActive) {
                    fetchTxs();
                    lastUpdate = Date.now();
                    console.log('Initial fetchTxs via Enter');
                }
            }, 2000);
            return;
        }
        // Game over restart
        if (gameOver && hasPlayedOnce) {
            restart();
            return;
        }
    }

    // Movement keys
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keyStates[e.key] = true;
    }

    // Attack / Potion (only if not blocked by terminal)
    else if (e.key === 'a') {
        attack();
    }
    else if (e.key === 'd') {
        usePotion();
    }

    // Start keyboard polling if needed
    if (!keyboardMovementTimer) {
        keyboardMovementTimer = setInterval(() => {
            if (!splashActive && !gameOver) {
                let newMoveDir = null;
                if (keyStates.ArrowUp) newMoveDir = 'up';
                else if (keyStates.ArrowDown) newMoveDir = 'down';
                else if (keyStates.ArrowLeft) newMoveDir = 'left';
                else if (keyStates.ArrowRight) newMoveDir = 'right';

                if (newMoveDir) {
                    const now = Date.now();
                    if (!currentMoveDir || newMoveDir !== currentMoveDir || now - lastMoveTime >= 200) {
                        move(newMoveDir);
                        lastMoveTime = now;
                        currentMoveDir = newMoveDir;
                    }
                } else if (currentMoveDir) {
                    currentMoveDir = null;
                    lastMoveTime = 0;
                }
            }
        }, 50);
    }
});

// Keyup: reset states
document.addEventListener('keyup', e => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        keyStates[e.key] = false;
    }
});

// Soul terminal input (focused)
document.getElementById('soul-terminal-input')?.addEventListener('keydown', function(e) {
    if (p.inSoulTerminal && p.soulTerminalActive) {
        if (e.key === 'Enter') e.preventDefault();
        handleTerminalInput(e);
        if (e.key === 'Enter') {
            const command = this.value;
            processSoulCommand(command);
            this.value = '';
            this.focus();
        }
    }
});

// Soul terminal blurred input
document.addEventListener('keydown', e => {
    if (p.inSoulTerminal && p.soulTerminalActive && !e.target.matches('#soul-terminal-input')) {
        if (e.key.length === 1 && e.key !== 'Enter') {
            handleBlurredTerminalInput(e.key);
        }
    }
});

// Add a global animation update for continuous animation when player moves or health changes
function animateHealthWarning() {
    // This function will be called periodically to trigger invisible animations
    if (p.hp > 8 && !gameOver && !splashActive) {
        needsRedraw = true;
    }
}

// Set up interval for invisible health warning animation updates
setInterval(animateHealthWarning, 100); // Update every 100ms when health is above threshold

document.getElementById('game-over').addEventListener('click', (event) => {
    if (
        gameOver &&
        !document.getElementById('username-input').contains(event.target) &&
        !document.getElementById('submit-score').contains(event.target) &&
        !document.getElementById('view-leaderboard').contains(event.target) &&
        !document.getElementById('restart-game').contains(event.target) &&
        !document.getElementById('leaderboard-output').contains(event.target)
    ) {
    }
});

        initMap();
        updateSatsDisplay();
        populateNameList();
        requestAnimationFrame(gameLoop);
        
// Removed redundant D-pad touch event listeners; handled in initTouchControls

//////////////////////
// Gamepad support //
////////////////////
let gamepadIndex = null; // Track connected gamepad
let lastButtonsState = []; // Track previous button states
let lastAxesState = { axis0: 0, axis1: 0 }; // Track previous D-pad axis states
let lastStartPressTime = 0; // Debounce Start button
const DEBOUNCE_MS = 200; // Debounce interval
const GAMEPAD_POLL_INTERVAL = 50; // Poll rate in ms
let lastGamepadPollTime = 0; // Throttle polling
let movementTimer = null; // Timer for continuous movement
let currentMoveDir = null; // Track current movement direction
let lastMoveTime = 0; // Track last move to enforce 200ms interval
let gamepadMoveDir = null; // Track gamepad movement direction
let gamepadLastMoveTime = 0; // Track last gamepad move to enforce 200ms interval
let gamepadPollingActive = false; // Track if gamepad polling is enabled
let hasPlayedOnce = false; // Track if player has played at least one game


const keyStates = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false
};
let keyboardMovementTimer = null;

// Simplified gamepad axis handling class without excessive profiling
class GamepadAxes {
    constructor(gamepad) {
        this.gamepad = gamepad;
        this.axis0 = 0;
        this.axis1 = 0;
    }
    
    // Update axes with current state
    update() {
        if (this.gamepad.axes.length >= 2) {
            this.axis0 = this.gamepad.axes[0];
            this.axis1 = this.gamepad.axes[1];
        }
    }
    
    // Get direction based on buttons or axes
    getDirection() {
        let newMoveDir = null;
        const deadZone = 0.2;
        
        // First check if we have a valid gamepad
        if (!this.gamepad) return null;
        
        // Check button-based D-pad (indices 12-15 for standard mapping)
        if (this.gamepad.buttons.length >= 16) {
            const upBtn = this.gamepad.buttons[12];
            const downBtn = this.gamepad.buttons[13];
            const leftBtn = this.gamepad.buttons[14];
            const rightBtn = this.gamepad.buttons[15];
            
            // Check each button individually
            if (leftBtn.pressed) {
                newMoveDir = 'left';
            } else if (rightBtn.pressed) {
                newMoveDir = 'right';
            } else if (upBtn.pressed) {
                newMoveDir = 'up';
            } else if (downBtn.pressed) {
                newMoveDir = 'down';
            }
        }
        
        // If no button direction, check axes 0 and 1
        if (!newMoveDir) {
            if (Math.abs(this.axis0) > deadZone) {
                newMoveDir = this.axis0 > 0 ? 'right' : 'left';
            } else if (Math.abs(this.axis1) > deadZone) {
                newMoveDir = this.axis1 > 0 ? 'down' : 'up';
            }
        }
        
        return newMoveDir;
    }
    
    // Check if D-pad is active (button-based or axis-based)
    isDpadActive() {
        const deadZone = 0.2;
        
        // Check button-based D-pad
        if (this.gamepad.buttons.length >= 16) {
            const upBtn = this.gamepad.buttons[12];
            const downBtn = this.gamepad.buttons[13];
            const leftBtn = this.gamepad.buttons[14];
            const rightBtn = this.gamepad.buttons[15];
            
            if (upBtn.pressed || downBtn.pressed || leftBtn.pressed || rightBtn.pressed) {
                return true;
            }
        }
        
        // Check axis-based D-pad
        return Math.abs(this.axis0) > deadZone || Math.abs(this.axis1) > deadZone;
    }
}

// Global instance for current gamepad axes
let currentAxes = null;

// Start game function for splash screen
function startGame() {
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪'; // Update mute button UI based on saved state
    if (!splashActive) {
        return;
    }
    
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }
    
    const startButton = document.getElementById('start-button');
    startButton.style.background = '#00b7ef'; // Mimic hover
    setTimeout(() => {
        startButton.style.background = '#00e8d8'; // Revert
    }, 200);
    
    // Check for gamepad at game start
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                console.log('Gamepad detected at game start:', gamepads[i].id);
                break;
            }
        }
    }
    
    // Resume AudioContext
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
        }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    preloadSounds(); // Preload sounds after user interaction
    
    currentTheme = 'dungeon'; // Force default theme on game start
    // Set mute state based on saved preference
    musicManager.mute(musicMuted);
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪'; // Update mute button UI
    musicManager.current = null; // Reset MusicManager state
    musicManager.audios[currentTheme].pause(); // Ensure audio is stopped
    musicManager.audios[currentTheme].currentTime = 0; // Reset to start of track
    
    if (musicManager.audios[currentTheme].readyState >= 2) { // Check if audio is loaded
        console.log('Playing music from start:', currentTheme); // Debug log
        musicManager.play(currentTheme); // Play the music immediately
    } else {
        console.log('Audio not ready, waiting for', currentTheme); // Debug log
        musicManager.audios[currentTheme].load(); // Force reload
        musicManager.audios[currentTheme].oncanplaythrough = () => {
            console.log('Audio ready, playing from start:', currentTheme); // Debug log
            musicManager.audios[currentTheme].currentTime = 0; // Reset to start of track
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
        };
    }
    
    fadeSplash();
    
    // Start gamepad polling if gamepad is connected
    if (gamepadIndex !== null) {
        gamepadPollingActive = true;
        updateGamepad();
    }
    
    hasPlayedOnce = true; // Mark that the player has started a game
    
    // Ensure fetchTxs is triggered after splash fade
    setTimeout(() => {
        if (!gameOver && !splashActive && floor > 0) {
            console.log('Post-splash fetchTxs triggered: floor=', floor, 'wave=', wave);
            fetchTxs();
        } else {
            console.log('Post-splash fetchTxs skipped: gameOver=', gameOver, 'splashActive=', splashActive, 'floor=', floor);
        }
    }, 2000); // Match original start-button delay
}

window.addEventListener("gamepadconnected", (e) => {
    // Only connect if no gamepad is currently connected or if it's a different gamepad
    if (gamepadIndex === null) {
        gamepadIndex = e.gamepad.index;
        lastButtonsState = new Array(e.gamepad.buttons.length).fill(false);
        lastGamepadPollTime = performance.now();
        console.log('Gamepad connected:', e.gamepad.id);
        
        if (!splashActive) {
            gamepadPollingActive = true;
            if (!movementTimer) {
                movementTimer = setInterval(() => {
                    if (!splashActive && !gameOver && gamepadMoveDir) {
                        const now = Date.now();
                        if (now - gamepadLastMoveTime >= 200) {
                            move(gamepadMoveDir);
                            gamepadLastMoveTime = now;
                        }
                    }
                }, 50);
            }
            updateGamepad();
        }
    } else {
        console.log('Gamepad connected but already tracking:', e.gamepad.id);
    }
});

window.addEventListener("gamepaddisconnected", (e) => {
    // Only handle disconnection if this is the same gamepad we were tracking
    if (gamepadIndex === e.gamepad.index) {
        gamepadIndex = null;
        lastButtonsState = [];
        gamepadPollingActive = false;
        
        // Clear movement timer if active
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
        }
        
        // Reset gamepad movement tracking
        gamepadMoveDir = null;
        gamepadLastMoveTime = 0;
        
        console.log('Gamepad disconnected:', e.gamepad.id);
    }
});

// Modify the updateGamepad function to handle start button press for pausing
function updateGamepad(timestamp) {
    if (gamepadIndex === null) {
        // Try to find a connected gamepad
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                gamepadPollingActive = true;
                break;
            }
        }
        if (gamepadIndex === null) {
            return; // No gamepad found, stop polling
        }
    }

    if (!gamepadPollingActive) {
        const gamepad = navigator.getGamepads()[gamepadIndex];
        if (gamepad && gamepad.buttons[3].pressed && !lastButtonsState[3] && splashActive) {
            const nowTime = Date.now();
            if (nowTime - lastStartPressTime > DEBOUNCE_MS) {
                startGame();
                lastStartPressTime = nowTime;
                gamepadPollingActive = true;
                if (!movementTimer) {
                    movementTimer = setInterval(() => {
                        if (!splashActive && !gameOver && gamepadMoveDir) {
                            const now = Date.now();
                            if (now - gamepadLastMoveTime >= 200) {
                                move(gamepadMoveDir);
                                gamepadLastMoveTime = now;
                            }
                        }
                    }, 50);
                }
            }
            lastButtonsState[3] = gamepad.buttons[3].pressed;
        }
        requestAnimationFrame(updateGamepad);
        return;
    }

    const now = performance.now();
    if (now - lastGamepadPollTime < GAMEPAD_POLL_INTERVAL) {
        requestAnimationFrame(updateGamepad);
        return;
    }
    lastGamepadPollTime = now;
    const gamepad = navigator.getGamepads()[gamepadIndex];
    if (!gamepad) {
        gamepadIndex = null;
        gamepadPollingActive = false;
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            currentMoveDir = null;
            lastMoveTime = 0;
        }
        return;
    }

    // Update axes with new state
    currentAxes = new GamepadAxes(gamepad);
    currentAxes.update();

    // Check for actual gamepad input (buttons or axes)
    const buttons = gamepad.buttons;
    const hasInput = buttons.some(b => b.pressed) || currentAxes.isDpadActive();

// Close the soul terminal or the passive tree terminal with the start button (generic gamepad)    
if (!splashActive && !gameOver && inputBlocked) {
    const buttons = gamepad.buttons;
    const nowTime = Date.now();
    if (buttons[3].pressed && !lastButtonsState[3] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        if (p.inSoulTerminal && p.soulTerminalActive) {
            closeSoulTerminal();
        }
        else if (p.inPassiveTerminal && p.passiveTerminalActive) {
            closePassiveTerminal();  // ← only this name
        }
        lastStartPressTime = nowTime;
    }
    lastButtonsState[3] = buttons[3].pressed;
    requestAnimationFrame(updateGamepad);
    return;
}

    // Handle buttons (A=0, B=1, Select=2, Start=3)
    const nowTime = Date.now();

    // A Button (0) - usePotion
    if (buttons[0].pressed && !lastButtonsState[0] && !splashActive && !gameOver) {
        usePotion();
        lastMoveTime = nowTime; // Update lastMoveTime to maintain consistency with other actions
    }

// B Button (1) - attack, skill tree confirm, or game over actions
if (buttons[1].pressed && !lastButtonsState[1]) {
    // Skill tree confirm
    if (skillTreeActive && !window.skillTreeInputBlocked) {
        selectSkillTreeOption();
    }
    // Normal gameplay attack
    else if (!splashActive && !gameOver) {
        attack();
        lastMoveTime = nowTime;
    }
    // Game over actions
    else if (gameOver && gamepadIndex !== null && !inputBlocked) {
        if (!gameOverBPressed) {
            if (!scoreSubmitted && floor >= 3) {
                submitScoreWithRandomName();
            } else if (floor < 3) {
                document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
                document.getElementById('leaderboard-output').style.display = 'block';
            }
            gameOverBPressed = true;
        } else {
            restart();
        }
    }
}

    // Select Button (2) - toggleMute
    if (buttons[2].pressed && !lastButtonsState[2] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        toggleMute();
        lastStartPressTime = nowTime; // Reuse lastStartPressTime for debouncing
    }

// Start Button (3) - startGame, restart, or exit soul terminal
if (buttons[3].pressed && !lastButtonsState[3] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
    if (p.inSoulTerminal && p.soulTerminalActive) {
        // Exit soul terminal
        closeSoulTerminal();
    } else if (splashActive) {
        startGame();
    } else if (gameOver) {
        restart();
    } else {
        // Existing else logic (if any)
    }
    lastStartPressTime = nowTime;
}

    // Update button states
    lastButtonsState = buttons.map(b => b.pressed);

    // Update movement direction using the new axes class
    if (!splashActive && !gameOver) {
    
            // Skill tree left/right navigation for gamepad D-pad / analog
            if (skillTreeActive && pendingSkillTreeLevel === 3 && !playerClass && !window.skillTreeInputBlocked) {
                const dir = currentAxes.getDirection();
                if (dir === 'left') skillTreeSelectedOption = 0;
                else if (dir === 'right') skillTreeSelectedOption = 1;
                if (dir === 'left' || dir === 'right') {
                    updateClassHighlight();
                    needsRedraw = true;
                }
            }
    
        let newMoveDir = currentAxes.getDirection();
        gamepadMoveDir = newMoveDir; // Always update gamepadMoveDir
        
        // Rely on movementTimer for continuous movement
        if (newMoveDir && !movementTimer) {
            movementTimer = setInterval(() => {
                if (!splashActive && !gameOver && gamepadMoveDir) {
                    const now = Date.now();
                    if (now - gamepadLastMoveTime >= 200) {
                        move(gamepadMoveDir);
                        gamepadLastMoveTime = now;
                    }
                }
            }, 50);
        } else if (!newMoveDir && movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            gamepadLastMoveTime = 0;
        }
    }

    // Continue polling
    requestAnimationFrame(updateGamepad);
}

// Initialize touch controls after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the global button variables
    dpadButtons = document.querySelectorAll('#dpad button');
    actionsButtons = document.querySelectorAll('#actions button');
    
    setTimeout(() => {
        initTouchControls();
    }, 100);
    
    // Add event listener for soul terminal input
    const soulTerminalInput = document.getElementById('soul-terminal-input');
    if (soulTerminalInput) {
        soulTerminalInput.addEventListener('keydown', function(e) {
            if (p.inSoulTerminal && p.soulTerminalActive) {
                handleTerminalInput(e);
                
                // Handle Enter key for terminal input
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const command = this.value;
                    processSoulCommand(command);
                    this.value = '';
                    this.focus();
                }
            }
        });
    }
});

// Add this to prevent context menu issues
document.addEventListener('contextmenu', function(e) {
    // Only prevent context menu for elements that might cause issues
    if (e.target.closest('#game-container, #dpad, #actions') || 
        e.target.id === 'game' || 
        e.target.id === 'battle-events') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, { passive: false });

// Function to submit score with random name
function submitScoreWithRandomName() {
    if (gameOver && !scoreSubmitted && gamepadIndex !== null) {
        // Select a random name from the names array
        const randomName = names[Math.floor(Math.random() * names.length)];
        document.getElementById('username-input').value = randomName;
        
        // Submit the score
        submitScore();
    }
}

function displayUniqueMonsterName() {
    if (!activeUniqueMonsterName) return;
    
    // Check if any visible unique monsters are present
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0) {
        // Clear previous display
        activeUniqueMonsterName = null;
        return;
    }
    
    // Check if unique monster is in fog of war but still has a name to show
    const uniqueMonsterInFog = enemies.find(e => e.uniqueName && fogMap[e.y][e.x] === 0);
    
    if (uniqueMonsterInFog && !activeUniqueMonsterName) {
        activeUniqueMonsterName = uniqueMonsterInFog.uniqueName;
        logBattleEvent(`A harbinger of doom is near.`);
        
// Clear only when enemy is killed or when leaving the area
// No auto-clear timeout needed anymore
    }
}

// Screensaver: black background, slow drifting orange ball (#f7931a) with white "₿" and soft glows.
// Smooth fade-out/fade-in, minimal breathing and drift.

let screensaverActive = false;
let screensaverCanvas = null;
let screensaverCtx = null;
let screensaverInitialized = false;
let screensaverLoopId = null;

(function ensureScreensaverOverlay() {
  if (!document.getElementById('screensaver-overlay')) {
    const newOverlay = document.createElement('div');
    newOverlay.id = 'screensaver-overlay';
    newOverlay.style.display = 'none';
    newOverlay.style.position = 'fixed';
    newOverlay.style.left = '0';
    newOverlay.style.top = '0';
    newOverlay.style.width = '100%';
    newOverlay.style.height = '100%';
    newOverlay.style.zIndex = '9999';
    newOverlay.innerHTML = '<canvas id="screensaver-canvas"></canvas>';
    document.body.appendChild(newOverlay);
  }
})();

function initScreensaver() {
  if (screensaverInitialized) return true;
  screensaverCanvas = document.getElementById('screensaver-canvas');
  if (!screensaverCanvas) return false;
  screensaverCanvas.style.display = 'block';
  screensaverCanvas.style.width = '100%';
  screensaverCanvas.style.height = '100%';
  screensaverCtx = screensaverCanvas.getContext('2d');
  if (!screensaverCtx) return false;

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    if (screensaverCanvas.width !== w || screensaverCanvas.height !== h) {
      screensaverCanvas.width = w;
      screensaverCanvas.height = h;
    }
  }
  resize();
  window.addEventListener('resize', resize);

  screensaverInitialized = true;
  return true;
}

function activateScreensaver() {
  if (!initScreensaver()) return;
  const overlay = document.getElementById('screensaver-overlay');
  if (!overlay) return;
  overlay.style.display = 'block';
  screensaverActive = true;
  if (!screensaverLoopId) screensaverLoopId = requestAnimationFrame(drawScreensaver);
}

function exitScreensaver() {
  const overlay = document.getElementById('screensaver-overlay');
  if (overlay) overlay.style.display = 'none';
  screensaverActive = false;
  if (screensaverLoopId) {
    cancelAnimationFrame(screensaverLoopId);
    screensaverLoopId = null;
  }
  if (screensaverCanvas) {
    screensaverCtx.clearRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);
  }
  startTime = 0;
}

// Visual settings
const ORANGE_HEX = '#f7931a';
const ORANGE_RGB = { r: 247, g: 147, b: 26 }; // for rgba usage
const BASE_RADIUS_RATIO = 0.10;
const SLOW_BREATHE_AMPL = 0.02;
const BREATHE_PERIOD = 10.0;
const DRIFT_PERIOD_Y = 20.0;
const DRIFT_AMPL_Y = 0.05;
const DRIFT_PERIOD_X = 26.0;
const DRIFT_AMPL_X = 0.07;

const VISIBLE_INTERVAL = 9.0;
const HIDE_DURATION = 3.5;
const FADE_DURATION = 1.0;

let startTime = 0;

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function alphaForTime(tSec) {
  const cycleLen = VISIBLE_INTERVAL + FADE_DURATION + HIDE_DURATION + FADE_DURATION;
  const p = tSec % cycleLen;
  if (p < VISIBLE_INTERVAL) return 1;
  let q = p - VISIBLE_INTERVAL;
  if (q < FADE_DURATION) return 1 - easeInOutCubic(q / FADE_DURATION);
  q -= FADE_DURATION;
  if (q < HIDE_DURATION) return 0;
  q -= HIDE_DURATION;
  if (q < FADE_DURATION) return easeInOutCubic(q / FADE_DURATION);
  return 1;
}

function drawScreensaver(timestamp) {
  if (!screensaverActive || !screensaverCtx) {
    screensaverLoopId = null;
    return;
  }
  if (!startTime) startTime = timestamp || performance.now();
  const now = timestamp || performance.now();
  const tSec = (now - startTime) / 1000;

  // Clear
  screensaverCtx.fillStyle = 'black';
  screensaverCtx.fillRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);

  const alpha = alphaForTime(tSec);
  if (alpha <= 0) {
    // Fully clean up during long invisible periods – prevents memory leak
    screensaverCtx.fillStyle = 'black';
    screensaverCtx.fillRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);
    if (screensaverLoopId) {
      cancelAnimationFrame(screensaverLoopId);
      screensaverLoopId = null;
    }
    // Restart the loop only after the hide duration ends
    setTimeout(() => {
      if (screensaverActive) {
        startTime = performance.now(); // reset cycle timer
        screensaverLoopId = requestAnimationFrame(drawScreensaver);
      }
    }, HIDE_DURATION * 1000);
    return;
  }

  const w = screensaverCanvas.width;
  const h = screensaverCanvas.height;
  const minWH = Math.min(w, h);

  const baseRadius = minWH * BASE_RADIUS_RATIO;
  const breathe = 1 + SLOW_BREATHE_AMPL * Math.sin((2 * Math.PI * tSec) / BREATHE_PERIOD);
  const radius = baseRadius * breathe;

  const offsetY = DRIFT_AMPL_Y * h * Math.sin((2 * Math.PI * tSec) / DRIFT_PERIOD_Y);
  const offsetX = DRIFT_AMPL_X * w * Math.sin((2 * Math.PI * tSec) / DRIFT_PERIOD_X + 0.9);

  const cx = w / 2 + offsetX;
  const cy = h / 2 + offsetY;

  // Orange glow (soft, larger than before)
  const glowRadius = radius * 2.8;
  const glowAlpha = 0.22 * alpha;
  const grad = screensaverCtx.createRadialGradient(cx, cy, radius * 0.25, cx, cy, glowRadius);
  grad.addColorStop(0, `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${(glowAlpha).toFixed(3)})`);
  grad.addColorStop(0.45, `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${(glowAlpha * 0.55).toFixed(3)})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  screensaverCtx.fillStyle = grad;
  screensaverCtx.beginPath();
  screensaverCtx.arc(cx, cy, glowRadius, 0, Math.PI * 2);
  screensaverCtx.fill();

  // Main steady circle
  const mainAlpha = 0.75 * alpha;
  screensaverCtx.fillStyle = `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${mainAlpha.toFixed(3)})`;
  screensaverCtx.beginPath();
  screensaverCtx.arc(cx, cy, radius, 0, Math.PI * 2);
  screensaverCtx.fill();

  // White ₿ with soft white halo
  const fontSize = Math.max(12, Math.round(radius * 1.05));
  screensaverCtx.save();
  // white halo using shadow
  screensaverCtx.globalAlpha = alpha;
  screensaverCtx.shadowColor = 'rgba(255,255,255,0.75)';
  screensaverCtx.shadowBlur = Math.max(6, radius * 0.22);
  screensaverCtx.fillStyle = '#ffffff';
  screensaverCtx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`;
  screensaverCtx.textAlign = 'center';
  screensaverCtx.textBaseline = 'middle';
  screensaverCtx.fillText('₿', cx, cy + (fontSize * 0.02));
  screensaverCtx.restore();

  screensaverLoopId = requestAnimationFrame(drawScreensaver);
}

/* Input handlers to exit screensaver (kept minimal) */
let screensaverMovementTimeout = null;
let lastMovementTime = 0;
const DEBOUNCE_DELAY = 50;

function handleMovement() {
  const now = Date.now();
  if (!screensaverActive) return;
  if (now - lastMovementTime > DEBOUNCE_DELAY) {
    lastMovementTime = now;
    if (screensaverMovementTimeout) {
      clearTimeout(screensaverMovementTimeout);
      screensaverMovementTimeout = null;
    }
    screensaverMovementTimeout = setTimeout(() => {
      // Make screensaver exit behave like gamepad select button
      const muteButton = document.getElementById('mute');
      if (muteButton.textContent === '☀') { // Screensaver active state
        exitScreensaver();
        musicMuted = false;
        musicManager.mute(false);
        muteButton.textContent = '♪';
        if (!splashActive) {
          musicManager.current = null; // Reset MusicManager state
          musicManager.play(currentTheme);
        }
        localStorage.setItem('musicMuted', 'false');
      } else {
        exitScreensaver();
      }
    }, DEBOUNCE_DELAY * 2);
  }
}

document.addEventListener('pointerdown', function (e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  handleMovement();
}, { passive: true });

document.addEventListener('touchstart', function (e) {
  if (e.touches && e.touches.length > 1) return;
  handleMovement();
}, { passive: true });

document.addEventListener('mousedown', function (e) {
  if (e.button !== 0) return;
  handleMovement();
}, { passive: true });

document.addEventListener('keydown', function (e) {
  if (['a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Enter'].includes(e.key)) {
    handleMovement();
  }
});
// Prevent battle-log focus from gamepad/shoulder buttons
document.getElementById('battle-events').addEventListener('focus', function() {
    this.blur();
});

// GOLDEN : 1
/* ----------------------- */
/* Visibility handling –  */
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        // Pause loop when tab hidden/sleep
        if (rafId) {
            cancelAnimationFrame(rafId);
            rafId = null;
            console.log('Game paused (tab hidden)');
        }
    } else {
        // Resume + force redraw when back
        startGameLoop();                     // ← resets lastTimestamp
        // Firefox Android canvas redraw hack
        canvas.style.transform = 'translateZ(0)';
        setTimeout(() => {
            canvas.style.transform = 'none';
            needsRedraw = true;
            console.log('Game resumed + canvas forced redraw');
        }, 100);
    }
});

    </script>
</body>
</html>
