<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self' https://noexxibndcooqjquhqzk.supabase.co https://mempool.space; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 0vh; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: pan-x pan-y; /* Prevents pinch-to-zoom */
            -webkit-user-select: none; /* Prevents selection */
            -webkit-touch-callout: none; /* Disables iOS callouts */
        }
        /* Existing styles remain unchanged */
        #console { 
            background: #111;
            border: 4px solid #ff8c00;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            max-width: 800px;
            width: 100%;
            box-sizing: border-box;
        }
        #whale-log { 
            width: 618px; 
            height: 24px; 
            overflow-y: auto;
            scroll-behavior: smooth; 
            background: #111; 
            color: #ff8c00; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: #ff8c00; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
        #battle-log { 
            width: 620px;
            margin-left: 20px; 
            background: transparent; 
            color: #ff8c00; 
            padding: 16px; 
            border: none; 
            font-size: 16px;
            z-index: 10;
            margin-top: -240px;
        }
#battle-log textarea {
    background: transparent;
    color: #ff8c00;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    resize: none;
    width: 100%;
    height: 200px;
    padding: 0;
    overflow-y: auto;
    scroll-behavior: smooth;
    z-index: 10;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.2s ease;
    transform: translateX(-100%);
    opacity: 0;
    /* Hide scrollbar */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}
#battle-log textarea::-webkit-scrollbar {
    display: none; /* Chrome, Safari, WebKit */
}
        #inventory { 
            position: absolute;
            top: 10px;
            right: -24px;
            background: transparent;
            color: #ff8c00;
            border: none;
            padding: 8px;
            z-index: 10;
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.5;
            width: 160px;
        }
        #floor-indicator { 
            position: absolute; 
            top: 11px; 
            left: 10px; 
            background: transparent; 
            color: #ff8c00; 
            padding: 8px; 
            z-index: 10; 
            font-family: 'VT323', monospace;
            font-size: 24px; 
        }
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
            grid-area: t;
            z-index: 40;
            border-radius: 5%;
        }
        #left { 
            grid-area: l;
            z-index: 40;
            border-radius: 5%;
        }
        #right { 
            grid-area: r;
            z-index: 40; 
            border-radius: 5%;
        }
        #down { 
            grid-area: b;
            z-index: 40;
            border-radius: 5%;
        }
        #actions { 
            display: flex; 
            gap: 5px; 
            align-items: center; 
        }
        button { 
            background-color: transparent;
            border: 1px solid #ff8c00;
            color: #ff8c00;
            padding: 8px; 
            border: 0px solid #000; 
            cursor: pointer; 
            font-size: 14px; 
            width: 40px; 
            height: 40px;
            box-sizing: border-box; 
        }
        button:hover {
            background: rgba(224, 123, 0, 0.5);
        }
        #mute {
            padding: 0px;
            border-radius: 25%;
            height: 20px;
            width: 30px;
            background: #fff;
            color: #000;
            margin-right: 50px;
            z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #attack, #potion {
            margin-right: 20px;
            background: #ff8c00;
            color: #fff;
            height: 50px;
            width: 50px; 
            border-radius: 50%;
        }
        #attack:hover, #potion:hover {
            background: #e07b00;
        }
        #start-button {
            position: absolute;
            top: 75%;
            left: 50%;
            width: 120px;
            height: 50px;
            transform: translate(-50%, -50%);
            background: #00e8d8;
            color: #fff;
            border: none;
            padding: 0px 20px;
            font-family: 'VT323', monospace;
            font-size: 42px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 40;
        }
        #start-button:hover {
            background: #00b7ef;
        }
#dpad button:active, #dpad button.pressed {
    background: rgba(224, 123, 0, 0.7); /* Slightly darker than hover */
}

#submit-score, #view-leaderboard, #restart-game {
    background: #ff8c00;
    color: #fff;
    border: none;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 18px;
    cursor: pointer;
    border-radius: 5px;
    width: 120px; /* Keep for view-leaderboard and restart-game */
    height: 40px;
    z-index: 40;
}
#submit-score {
    width: 220px; /* Almost doubled from 120px */
}

#submit-score:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
}

#leaderboard-output {
    position: absolute;
    top: 0px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #ff8c00;
    border: 2px solid #ff8c00;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    width: 640px;
    max-width: 100%;
    text-align: left;
    white-space: pre;
    line-height: 1.2;
    box-sizing: border-box;
    word-break: break-word; /* Handle long text */
}
    
/* Phones (320px–767px) */
@media only screen and (min-width: 320px) and (max-width: 767px) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 9px;
    }
    #whale-hash-ids {
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 9px;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: 8px;
        height: 110px;
        font-size: 10px; /* Match font-size for consistency */
    }
    #inventory {
        width: 100px;
        font-size: 12px;
        line-height: 1.5;
        margin-right: 2px;
    }
    #floor-indicator {
        font-size: 10px;
    }
    button {
        width: 55px;
        height: 55px;
        font-size: 12px;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 40px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: -10px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 0px;
        margin-left: -15px;
        margin-top: 60px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 0px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 0px;
                margin-left: 20px;
        background: #ff8c00;
        height: 35px;
        width: 35px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }
    
    #submit-score, #view-leaderboard, #restart-game {
        width: 80px; /* Keep for view-leaderboard and restart-game */
        height: 30px;
        font-size: 16px;
    }
    #submit-score {
        width: 160px; /* Doubled from 80px */
    }
#username-input {
    width: 150px;
    font-size: 14px;
}
    #leaderboard-output {
        top: -12px;
        width: 100%;
        max-width: 640px;
        font-size: 12px;
        max-height: 160px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}

/* Tablets (768px–1024px, high pixel ratio) */
@media only screen and (min-width: 768px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
        max-width: 640px;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 1.2rem;
    }
    #whale-hash-ids {
        font-size: 1.2rem;
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 1.2rem;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: -60px;
        height: 146px;
        font-size: 1.2rem;
    }
    #inventory {
        width: 170px;
        font-size: 1.4rem;
        line-height: 1.5;
        margin-right: 20px;
    }
    #floor-indicator {
        font-size: 1.6rem;
    }
    button {
        width: 65px;
        height: 65px;
        font-size: 1.2rem;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 120px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: 20px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 24px;
        width: 24px;
        background: #fff;
        color: #000;
        margin-right: 80px;
        margin-left: -15px;
        margin-top: 45px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 5px;
        background: #ff8c00;
        height: 65px;
        width: 65px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 5px;
        margin-left: 20px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }

    #submit-score, #view-leaderboard, #restart-game {
        width: 100px; /* Keep for view-leaderboard and restart-game */
        height: 48px;
        font-size: 18px;
    }
    #submit-score {
        width: 200px; /* Doubled from 100px */
    }
#username-input {
    width: 180px;
    font-size: 16px;
}
    #leaderboard-output {
        top: 0px;
        width: 100%;
        max-width: 640px;
        font-size: 14px;
        max-height: 200px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}
    </style>
</head>
<body>
    <div id="console">
        <div id="whale-log">
            <div id="whale-hash-ids">Whale Transactions:</div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
    		<canvas id="splash-canvas" width="320" height="320"></canvas>
    	    <button id="start-button">START</button>
	    </div>
<div id="game-over">
    <pre id="leaderboard-output"></pre>
    <canvas id="game-over-canvas" width="320" height="320"></canvas>
    <div style="position: absolute; top: 60%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px;"> <!-- Increased gap from 10px to 15px -->
        <input id="username-input" type="text" placeholder="Enter Username" maxlength="20" style="background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 8px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; width: 200px;">
        <button id="submit-score" onclick="submitScore()">Submit Score</button>
        <button id="view-leaderboard" onclick="fetchLeaderboard()">Leaderboard</button>
        <button id="restart-game" onclick="restart()">Restart</button>
    </div>
</div>
            <div id="floor-indicator">Floor 1</div>
<div id="inventory">
    Wave: <span id="wave">0</span><br>
    <br>
    Health: <span id="health">24</span><br>
    Potions: <span id="potions">0</span><br>
    Pickaxes: <span id="pickaxes">0</span><br> <!-- New pickaxe display -->
    Bag: <span id="sats">0</span><br>
</div>
        </div>
<div id="battle-log">
    <textarea id="battle-events" readonly>Battle Log:</textarea>
</div>
        <div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">↑</button>
                <button id="left" onclick="move('left')">←</button>
                <button id="right" onclick="move('right')">→</button>
                <button id="down" onclick="move('down')">↓</button>
            </div>
            <div id="actions">
                <button id="mute" onclick="toggleMute()">♪</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>

const SUPABASE_URL = 'https://noexxibndcooqjquhqzk.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5vZXh4aWJuZGNvb3FqcXVocXprIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkyNzY3NDgsImV4cCI6MjA2NDg1Mjc0OH0.LvN81angnwKM5IS1lCrr-dUESgeJfvO6VjkC0lMB0y4';
const headers = {
    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
    'apikey': SUPABASE_ANON_KEY,
    'Content-Type': 'application/json',
    'Prefer': 'return=representation'
};

async function submitScore() {
    if (!gameOver) return; // Only allow submission on game-over
    if (scoreSubmitted) {
        document.getElementById('leaderboard-output').textContent = 'Score already submitted for this game!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: already submitted');
        return;
    }
    if (floor < 3) {
        document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: floor=', floor, '< 3');
        return;
    }
    const username = document.getElementById('username-input').value.trim();
    if (!username) {
        document.getElementById('leaderboard-output').textContent = 'Please enter a username!';
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
    }
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ username, score: totalSats, floor })
        });
        const text = await response.text();
        console.log(`POST Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : {};
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok) {
            scoreSubmitted = true; // Mark score as submitted
            document.getElementById('submit-score').disabled = true; // Disable button
            document.getElementById('submit-score').style.background = '#666'; // Gray out button
            document.getElementById('leaderboard-output').textContent = `Score submitted: ${username}, ${totalSats} sats (Floor ${floor})`;
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
            if (response.status === 400 && text.includes('new row violates row-level security policy')) {
                document.getElementById('leaderboard-output').textContent = 'Submission blocked: Must reach at least Floor 3!';
            }
        }
        document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

async function fetchLeaderboard() {
    try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?select=username,score,floor&order=score.desc&limit=10`, {
            method: 'GET',
            headers
        });
        const text = await response.text();
        console.log(`GET Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : [];
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok && Array.isArray(data)) {
            // Format leaderboard with wider space-based alignment
            const maxUsernameLength = 20; // Increased from 15
            const scoreWidth = 20; // Increased from 15
            const numberWidth = 12; // Increased from 8
            const floorWidth = 8; // Increased from 5
            const header = `Rank  Username               Score               Floor`;
            const rows = data.map((entry, index) => {
                const rank = (index + 1).toString().padStart(2, '0'); // e.g., "01", "10"
                const username = entry.username.length > maxUsernameLength
                    ? entry.username.substring(0, maxUsernameLength - 2) + '..' // Truncate long names
                    : entry.username.padEnd(maxUsernameLength); // Pad short names
                // Convert score to BTC if >= 1e8, otherwise display as sats
                const scoreValue = entry.score;
                let numberPart, unitPart;
                if (scoreValue >= 1e8) {
                    numberPart = (scoreValue / 1e8).toFixed(1); // e.g., "1.0"
                    unitPart = 'BTC';
                } else {
                    numberPart = scoreValue.toString(); // e.g., "2349"
                    unitPart = 'sats';
                }
                const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
                const score = scoreDisplay.padStart(scoreWidth); // Right-align score
                const floor = entry.floor.toString().padStart(floorWidth); // Right-align floor
                return `${rank}    ${username}  ${score}  ${floor}`;
            });
            const leaderboardText = `${header}\n${rows.join('\n') || 'No entries yet!'}`;
            document.getElementById('leaderboard-output').textContent = leaderboardText;
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
        }
        document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        console.error('Fetch leaderboard error:', error);
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

document.getElementById('username-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameOver) {
        e.preventDefault(); // Prevent any default behavior
        submitScore(); // Trigger score submission
    }
});

// Prevent pinch-to-zoom and double-tap zoom
document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Blocked multi-touchstart');
    }
}, { passive: false });
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Blocked multi-touchmove or pinch');
    }
}, { passive: false });
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked gesturestart');
}, { passive: false });
document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked gesturechange');
}, { passive: false });
document.addEventListener('gestureend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked gestureend');
}, { passive: false });
document.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked dblclick');
}, { passive: false });

// Block canvas touch interference
const canvas = document.getElementById('game');
canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Canvas blocked multi-touchstart');
    } else if (!e.target.closest('#dpad, #actions')) {
        e.preventDefault();
        console.log(`Canvas single-touchstart blocked at ${e.touches[0].clientX}, ${e.touches[0].clientY}`);
    }
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Canvas blocked multi-touchmove or pinch');
    }
}, { passive: false });

// Touch handlers for #dpad buttons
document.querySelectorAll('#dpad button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
        console.log(`Touchstart on ${button.id}, relying on onclick`);
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed'); // Remove visual feedback
        console.log(`Touchend on ${button.id}`);
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default click behavior after onclick
        console.log(`Click processed on ${button.id}`);
    }, { passive: false });
});

// Touch handlers for #actions buttons
document.querySelectorAll('#actions button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
        if (button.id === 'mute') toggleMute();
        else if (button.id === 'attack') attack();
        else if (button.id === 'potion') usePotion();
        console.log(`Touchstart triggered on ${button.id}`);
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed'); // Remove visual feedback
        console.log(`Touchend on ${button.id}`);
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default click behavior
        console.log(`Click processed on ${button.id}`);
    }, { passive: false });
});
        

const c = canvas.getContext('2d');
const W = 20, H = 20, S = 16;
        
let map = [], 
    p = {
        x: 2,
        y: 2,
        hp: 24,
        potions: 0,
        atk: 2,
        pickaxes: 0,
        hasArmor: false,
        anim: {
            frames: {
                front: [new Image(), new Image()],
                back: [new Image(), new Image()],
                right: [new Image(), new Image()],
                armor_front: [new Image(), new Image()],
                armor_back: [new Image(), new Image()],
                armor_right: [new Image(), new Image()]
            },
            direction: 'front',
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 200
        }
    }, 
    enemies = [], 
    rooms = [];
// Load animation frames
p.anim.frames.front[0].src = 'player-front1.png';
p.anim.frames.front[1].src = 'player-front2.png';
p.anim.frames.back[0].src = 'player-back1.png';
p.anim.frames.back[1].src = 'player-back2.png';
p.anim.frames.right[0].src = 'player-right1.png';
p.anim.frames.right[1].src = 'player-right2.png';
p.anim.frames.armor_front[0].src = 'player_armor-front1.png';
p.anim.frames.armor_front[1].src = 'player_armor-front2.png';
p.anim.frames.armor_back[0].src = 'player_armor-back1.png';
p.anim.frames.armor_back[1].src = 'player_armor-back2.png';
p.anim.frames.armor_right[0].src = 'player_armor-right1.png';
p.anim.frames.armor_right[1].src = 'player_armor-right2.png';

let floor = 1, wave = 0, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
let scoreSubmitted = false; // Tracks if score has been submitted
let whaleHashIds = ['Whale Transactions:'], battleLog = [], killsLog = [];
let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let satoshiDrops = [];
let splashActive = true;
let waveActive = false;
let musicMuted = false;        
let swordDir = 'right', swordActive = false, swordStart = 0;
let gameOverSoundPlayed = false;
let fogMap = [];
let battleLogTimeout = null;
        const types = [
            {name: 'Shrimp', min: 0, max: 0.01, img: new Image(), hp: 1, atk: 1, reward: 0, move: 1},
            {name: 'Crab', min: 0.01, max: 0.1, img: new Image(), hp: 2, atk: 2, reward: 0, move: 1},
            {name: 'Squid', min: 0.1, max: 1, img: new Image(), hp: 3, atk: 2, reward: 0, move: 2},
            {name: 'Dolphin', min: 1, max: 10, img: new Image(), hp: 4, atk: 3, reward: 0, move: 2},
            {name: 'Shark', min: 10, max: 100, img: new Image(), hp: 5, atk: 5, reward: 0, move: 2},
            {name: 'Whale', min: 100, max: Infinity, img: new Image(), hp: 6, atk: 4, reward: 0, move: 2}
        ];
const assets = {
    floor: new Image(),
    wall: new Image(),
    potion: new Image(),
    player: new Image(),
    stairs: new Image(),
    bitcoin: new Image(),
    gameOver: new Image(),
    sword: new Image(),
    pickaxe: new Image(), // New pickaxe asset
    armor: new Image(),   // New armor asset
    player_armor: new Image(), // New armored player sprite
    pickaxe_sword: new Image() // New pickaxe-sword asset
};
        types[0].img.src = 'shrimp.png';
        types[1].img.src = 'crab.png';
        types[2].img.src = 'squid.png';
        types[3].img.src = 'dolphin.png';
        types[4].img.src = 'shark.png';
        types[5].img.src = 'whale.png';
        assets.floor.src = 'floor.png';
        assets.wall.src = 'wall.png';
        assets.potion.src = 'potion.png';
	assets.player.src = 'player.png'; // Ensure player.png is set as default
	assets.pickaxe.src = 'pickaxe.png';
	assets.armor.src = 'armor.png';
	assets.player_armor.src = 'player_armor.png';
        assets.stairs.src = 'stairs.png'; 
        assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png'; assets.sword.src = 'sword.png';
        assets.pickaxe_sword.src = 'pickaxe-sword.png'; // New asset source
        Object.values(assets).forEach(asset => {
    asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
});
        types.forEach(t => { t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`); });

const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();
const sounds = {
    attack: new Audio('attack.wav'),
    potion: new Audio('potion.wav'),
    hit: { buffer: null, url: 'hit.wav', isPlaying: false, duration: 720 },
    pickup: { buffer: null, url: 'pickup.wav', isPlaying: false, duration: 950 },
    music: new Audio('music.mp3'),
    gameover: new Audio('gameover.wav'),
    stairs: new Audio('stairs.wav'),
    secret: new Audio('secret.wav') // New secret sound for wall-breaking
};

sounds.music.loop = true;

// Load Web Audio buffers
function loadSoundBuffer(url, key) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(data => audioContext.decodeAudioData(data))
        .then(buffer => {
            sounds[key].buffer = buffer;
            console.log(`Loaded Web Audio buffer for ${key}: ${url}`);
        })
        .catch(e => console.error(`Failed to load Web Audio buffer for ${key}: ${url}`, e));
}
loadSoundBuffer('hit.wav', 'hit');
loadSoundBuffer('pickup.wav', 'pickup');

Object.values(sounds).forEach(s => {
    if (s instanceof Audio) {
        s.volume = 1.0;
        s.onerror = () => console.error(`Failed to load sound: ${s.src}`);
    }
});

function preloadSounds() {
    Object.entries(sounds).forEach(([key, sound]) => {
        if (key === 'music' || key === 'hit' || key === 'pickup') return; // Skip music and Web Audio sounds
        if (Array.isArray(sound)) {
            sound.forEach((instance, idx) => {
                instance.volume = 0; // Mute for preloading
                instance.play().then(() => {
                    instance.pause();
                    instance.currentTime = 0;
                    instance.volume = 1.0;
                    console.log(`Preloaded sound instance ${idx}: ${instance.src}, volume=${instance.volume}`);
                }).catch(e => console.error(`Preload sound error for ${instance.src} instance ${idx}:`, e));
            });
        } else {
            sound.volume = 0;
            sound.play().then(() => {
                sound.pause();
                sound.currentTime = 0;
                sound.volume = 1.0;
                console.log(`Preloaded sound: ${sound.src}, volume=${sound.volume}`);
            }).catch(e => console.error(`Preload sound error for ${sound.src}:`, e));
        }
    });
}

function playWebAudioSound(soundObj) {
    if (!soundObj.buffer) {
        console.warn(`Buffer not loaded for ${soundObj.url}`);
        return;
    }
    if (soundObj.isPlaying) {
        console.log(`Skipping playback of ${soundObj.url}: already playing`);
        return;
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            console.log('AudioContext resumed');
        }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    soundObj.isPlaying = true; // Set flag
    const source = audioContext.createBufferSource();
    source.buffer = soundObj.buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 1.0; // Max volume
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
    console.log(`Playing Web Audio sound: ${soundObj.url}, volume=${gainNode.gain.value}`);
    source.onended = () => {
        soundObj.isPlaying = false; // Clear flag
        console.log(`Web Audio sound ended: ${soundObj.url}`);
    };
    // Fallback timeout to clear flag if onended fails
    setTimeout(() => {
        if (soundObj.isPlaying) {
            soundObj.isPlaying = false;
            console.log(`Cleared isPlaying flag for ${soundObj.url} via timeout`);
        }
    }, soundObj.duration);
}

const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
const splashImg = new Image();
splashImg.src = 'splash.png';
splashImg.onload = () => {
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    console.log('Splash started: active=', splashActive, 'bg=#F7931A');
};

function fadeSplash() {
    setTimeout(() => {
        const imgData = splashCanvas.getImageData(0, 0, 320, 320);
        const pixels = imgData.data;
        const totalPixels = 320 * 320;
        const fadePerFrame = totalPixels / 20;
        let fadedPixels = 0;
        const fadeInterval = setInterval(() => {
            for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                const px = Math.floor(Math.random() * totalPixels) * 4;
                pixels[px + 3] = 0;
                fadedPixels++;
            }
            splashCanvas.putImageData(imgData, 0, 0);
            if (fadedPixels >= totalPixels) {
                clearInterval(fadeInterval);
                splashActive = false;
                document.getElementById('splash-screen').style.display = 'none'; // Hide instead of remove
                console.log('Splash ended: active=', splashActive);
            }
        }, 75);
    }, 25);
}

function resetSplashScreen() {
    splashActive = true;
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block'; // Show splash screen
    // Redraw splash image
    splashCanvas.clearRect(0, 0, 320, 320);
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    console.log('Splash screen reset: active=', splashActive);
}

document.getElementById('start-button').addEventListener('click', () => {
    if (splashActive) {
        console.log('START button clicked: splashActive=', splashActive, 'musicMuted=', musicMuted, 'wave=', wave);
        preloadSounds();
        // Preload player animation frames
        const imagesToLoad = [
            p.anim.frames.front[0], p.anim.frames.front[1],
            p.anim.frames.back[0], p.anim.frames.back[1],
            p.anim.frames.right[0], p.anim.frames.right[1],
            p.anim.frames.armor_front[0], p.anim.frames.armor_front[1],
            p.anim.frames.armor_back[0], p.anim.frames.armor_back[1],
            p.anim.frames.armor_right[0], p.anim.frames.armor_right[1]
        ];
        let loadedCount = 0;
        imagesToLoad.forEach(img => {
            if (img.complete) {
                loadedCount++;
                if (loadedCount === imagesToLoad.length) {
                    console.log('All player animation frames loaded');
                }
            } else {
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === imagesToLoad.length) {
                        console.log('All player animation frames loaded');
                    }
                };
                img.onerror = () => console.error(`Failed to load image: ${img.src}`);
            }
        });
        if (!musicMuted) {
            sounds.music.pause();
            sounds.music.currentTime = 0;
            sounds.music.play().then(() => {
                console.log('Music started successfully');
            }).catch(e => console.error('Music play failed on START:', e));
        }
        fadeSplash();
        setTimeout(() => {
            if (!gameOver && !splashActive) {
                fetchTxs();
                lastUpdate = Date.now();
                console.log('Initial fetchTxs triggered after splash, wave=', wave);
            }
        }, 2000);
    }
});

function toggleMute() {
    musicMuted = !musicMuted;
    sounds.music.muted = musicMuted;
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪';
    if (!musicMuted && !splashActive) {
        sounds.music.currentTime = 0; // Start from beginning
        sounds.music.play().catch(e => console.error('Music play failed on unmute:', e));
    }
}

        function logWhaleHashId(txid) {
            whaleHashIds.push(`Floor ${floor} - <a href="https://www.blockchain.com/explorer/transactions/btc/${txid}" target="_blank">${txid}</a>`);
            document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
            const whaleLog = document.getElementById('whale-log');
            whaleLog.scrollTop = whaleLog.scrollHeight;
            console.log('Whale Hash ID:', txid);
        }

function logBattleEvent(event) {
    if (gameOver) return;
    const battleEvents = document.getElementById('battle-events');
    // Handle kills display (static, no fading)
    if (event.startsWith('Kills:') || event.match(/^(Shrimp|Crab|Squid|Dolphin|Shark|Whale):/) || event === '') {
        // Clear killsLog if starting a new kills block
        if (event === 'Kills:') {
            killsLog = [event];
        } else {
            killsLog.push(event);
        }
        if (exit && enemies.length === 0) {
            // Show exactly 8 kills lines
            battleEvents.value = killsLog.join('\n');
            battleEvents.scrollTop = battleEvents.scrollHeight;
            // Keep visible without fade-out
            battleEvents.style.transform = 'translateX(0)';
            battleEvents.style.opacity = '1';
            if (battleLogTimeout) {
                clearTimeout(battleLogTimeout);
                battleLogTimeout = null;
            }
            console.log('Kills display updated: persistent, lines=', killsLog.length, killsLog);
            return;
        }
    }
    // Keep last 3 messages for regular events (reverse waterfall)
    battleLog.push(event);
    battleLog = battleLog.slice(-3); // Keep last 3 events
    battleEvents.value = battleLog.join('\n');
    battleEvents.scrollTop = battleEvents.scrollHeight;
    // Clear any existing timeout
    if (battleLogTimeout) {
        clearTimeout(battleLogTimeout);
    }
    // Slide in and fade in
    battleEvents.style.transform = 'translateX(0)';
    battleEvents.style.opacity = '1';
    // Schedule slide out after 3 seconds for non-kills events
    battleLogTimeout = setTimeout(() => {
        battleEvents.style.transform = 'translateX(-100%)';
        battleEvents.style.opacity = '0';
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(battleEvents);
            if (computedStyle.opacity === '0') {
                battleLog = [];
                battleEvents.value = '';
                console.log('Battle log cleared after fade-out');
                // Restore kills display if still valid
                if (exit && enemies.length === 0) {
                    killsLog = [
                        'Kills:',
                        `Shrimp: ${kills.Shrimp}`,
                        `Crab: ${kills.Crab}`,
                        `Squid: ${kills.Squid}`,
                        `Dolphin: ${kills.Dolphin}`,
                        `Shark: ${kills.Shark}`,
                        `Whale: ${kills.Whale}`,
                        '' // Empty line for 8 lines total
                    ];
                    battleEvents.value = killsLog.join('\n');
                    battleEvents.style.transform = 'translateX(0)';
                    battleEvents.style.opacity = '1';
                    battleEvents.scrollTop = battleEvents.scrollHeight;
                    console.log('Kills display restored after fade-out, lines=', killsLog.length, killsLog);
                }
            }
        }, 300); // Wait for transition (0.3s)
        battleLogTimeout = null;
    }, 3000);
}

function updateSatsDisplay() {
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    document.getElementById('sats').textContent = totalSats < 1e8 ? `${totalSats} sats` : `${(totalSats / 1e8).toFixed(1)} BTC`;
    // Trigger kills display only when exit exists and no enemies remain
    if (exit && enemies.length === 0) {
        logBattleEvent(`Kills:`);
        const enemyTypes = ['Shrimp', 'Crab', 'Squid', 'Dolphin', 'Shark', 'Whale'];
        for (const type of enemyTypes) {
            if (kills[type] > 0) {
                logBattleEvent(`${type}: ${kills[type]}`);
            }
        }
    }
}

function spawnItemWithChance(itemType, chance, maxItems, proximityRange, excludePlayer = true) {
    if (Math.random() > chance) {
        console.log(`No ${itemType} spawned: chance=${chance}`);
        return [];
    }
    let itemPositions = [];
    let selectedRooms = rooms.sort(() => 0.5 - Math.random()).slice(0, Math.min(rooms.length, maxItems));
    for (let r of selectedRooms) {
        let x, y, attempts = 100;
        while (attempts > 0 && itemPositions.length < maxItems) {
            x = r.x + Math.floor(Math.random() * r.w);
            y = r.y + Math.floor(Math.random() * r.h);
            if (
                map[y][x] === 0 &&
                (!excludePlayer || (x !== p.x || y !== p.y)) &&
                !itemPositions.some(p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange) &&
                !satoshiDrops.some(d => d.x === x && d.y === y)
            ) {
                itemPositions.push({ x, y });
                map[y][x] = itemType; // Set map tile to itemType (e.g., 4 for pickaxe, 5 for armor)
                console.log(`${itemType} placed at (${x}, ${y})`);
                break;
            }
            attempts--;
        }
        if (attempts === 0) {
            console.warn(`${itemType} placement failed in room:`, r);
        }
    }
    return itemPositions;
}

function initMap() {
    try {
        map = Array(H).fill().map(() => Array(W).fill(1));
        fogMap = Array(H).fill().map(() => Array(W).fill(0));
        rooms = [];
        satoshiDrops = [];
        
        // Generate rooms (existing code unchanged)
        let maxAttempts = 100;
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        maxAttempts = 50;
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap();
        }
        
        // Connect rooms with corridors (existing code unchanged)
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r2.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }
        
        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;
        
        // Place player
        p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
        if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) { p.x = x; p.y = y; break; }
        }
        
        // Mark initial player area as explored
        updateFogMap(p.x, p.y);
        

        // Place potions (existing code)
        let potionPositions = [];
        let selectedRooms = rooms.sort(() => 0.5 - Math.random()).slice(0, Math.min(3, rooms.length));
        let proximityRange = 5;
        for (let r of selectedRooms) {
            let x, y, attempts = 100;
            while (attempts > 0 && potionPositions.length < 3) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);
                if (map[y][x] === 0 && (x !== p.x || y !== p.y) && !potionPositions.some(p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange)) {
                    map[y][x] = 2;
                    potionPositions.push({x, y});
                    if (potionPositions.length === 3) break;
                }
                attempts--;
            }
            if (attempts === 0 && potionPositions.length < 3) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;
                continue;
            }
        }

        // Place pickaxe (4, 1/3, 1, 5 = chance to drop a pickaxe, 1 out of 3)
        let pickaxePositions = spawnItemWithChance(4, 1/3, 1, 5);
        
        console.log('Rooms generated:', rooms.length, 'Potions placed:', potionPositions, 'Pickaxes placed:', pickaxePositions);
        exit = null;
        initialWaveSpawned = false;
        needsRedraw = true;
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

function createSecretRoom(wx, wy, px, py, dir) {
    // Create a 3x3 room based on player's facing direction
    const roomSize = 3;
    let rx, ry;
    // Position room based on direction
    switch (dir) {
        case 'up':
            rx = wx;
            ry = wy - roomSize;
            break;
        case 'down':
            rx = wx;
            ry = wy + 1;
            break;
        case 'left':
            rx = wx - roomSize;
            ry = wy;
            break;
        case 'right':
            rx = wx + 1;
            ry = wy;
            break;
        default:
            console.error(`Invalid direction: ${dir}`);
            p.pickaxes++;
            logBattleEvent(`Floor ${floor} - Secret Room Failed: Invalid direction`);
            return;
    }
    // Check if room fits within map bounds
    if (rx < 1 || rx + roomSize > W - 1 || ry < 1 || ry + roomSize > H - 1) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): out of bounds`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Check if the 3x3 area is all walls
    let allWalls = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (map[y][x] !== 1) {
                allWalls = false;
                break;
            }
        }
        if (!allWalls) break;
    }
    if (!allWalls) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): not a 3x3 wall block`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No 3x3 wall block for secret room! Pickaxe refunded`);
        return;
    }
    // Validate room placement
    let valid = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (
                [2, 3, 4, 5].includes(map[y][x]) || // Items
                (x === px && y === py) || // Player
                enemies.some(e => e.x === x && e.y === y) // Enemies
            ) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
    }
    // Allow overlap with one room (e.g., corridor)
    let overlapCount = 0;
    rooms.forEach(r => {
        if (!(rx >= r.x + r.w || rx + roomSize <= r.x || ry >= r.y + r.h || ry + roomSize <= r.y)) {
            overlapCount++;
        }
    });
    if (overlapCount > 1) valid = false;
    if (!valid) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): invalid placement (items, player, or overlap)`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Carve out the room
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            map[y][x] = 0;
        }
    }
    // Clear the broken wall
    map[wy][wx] = 0;
    // Punch a non-directional hole (clear one adjacent tile)
    const adjacent = [
        { x: wx - 1, y: wy }, // Left
        { x: wx + 1, y: wy }, // Right
        { x: wx, y: wy - 1 }, // Up
        { x: wx, y: wy + 1 }  // Down
    ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] !== 0);
    if (adjacent.length > 0) {
        const hole = adjacent[Math.floor(Math.random() * adjacent.length)];
        map[hole.y][hole.x] = 0;
        console.log(`Punched hole at (${hole.x}, ${hole.y}) for access`);
    }
    // Carve a corridor to a nearby floor tile
    let floorTiles = [];
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 0 && !(x === px && y === py) && !(x === wx && y === wy)) {
                floorTiles.push({ x, y });
            }
        }
    }
    if (floorTiles.length > 0) {
        floorTiles.sort((a, b) => {
            const distA = Math.abs(a.x - wx) + Math.abs(a.y - wy);
            const distB = Math.abs(b.x - wx) + Math.abs(b.y - wy);
            return distA - distB;
        });
        const target = floorTiles[0];
        let x = wx, y = wy;
        while (x !== target.x || y !== target.y) {
            if (Math.abs(target.x - x) > Math.abs(target.y - y)) {
                x += target.x > x ? 1 : -1;
            } else {
                y += target.y > y ? 1 : -1;
            }
            if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 0) {
                map[y][x] = 0;
            }
        }
        console.log(`Carved corridor from (${wx}, ${wy}) to (${target.x}, ${target.y})`);
    } else {
        console.warn(`No floor tile found to connect secret room at (${wx}, ${wy})`);
    }
    // Place armor in the center
    const armorX = rx + 1;
    const armorY = ry + 1;
    map[armorY][armorX] = 5;
    rooms.push({ x: rx, y: ry, w: roomSize, h: roomSize });
    // Show "Found Secret!" in Whale alert area and log success
    const floorIndicator = document.getElementById('floor-indicator');
    floorIndicator.textContent = `Found Secret!`;
    logBattleEvent(`Floor ${floor} - Secret Room Created!`);
    setTimeout(() => {
        floorIndicator.textContent = `Floor ${floor}`;
    }, 5000);
    updateFogMap(px, py);
    console.log(`Secret room (3x3) created at (${rx}, ${ry}), armor at (${armorX}, ${armorY}), entry at (${wx}, ${wy}), dir=${dir}`);
    needsRedraw = true;
}

function updatePlayerState() {
    if (p.hp <= 24 && p.hasArmor) {
        p.hasArmor = false;
        logBattleEvent(`Floor ${floor} - Armor boost lost!`);
        console.log(`Armor boost lost: p.hp=${p.hp}, p.hasArmor=${p.hasArmor}`);
    }
    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = true;
}

function updateFogMap(px, py) {
    const radius = 4; // Visibility radius
    const currentRoom = rooms.find(r => px >= r.x && px < r.x + r.w && py >= r.y && py < r.y + r.h);

    // Enhanced Bresenham's line algorithm with corner checking
    function hasLineOfSight(x0, y0, x1, y1) {
        let x = x0, y = y0;
        const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
            // Check current tile and adjacent tiles to block diagonal slips
            if (x >= 0 && x < W && y >= 0 && y < H) {
                if (map[y][x] === 1) return false; // Hit a wall
                // Check adjacent tiles to prevent corner penetration
                if (dx === dy) { // 45-degree line, check orthogonally adjacent tiles
                    if (sx === 1 && sy === 1) { // Moving SE
                        if (y - 1 >= 0 && map[y - 1][x] === 1) return false; // Wall above
                        if (x - 1 >= 0 && map[y][x - 1] === 1) return false; // Wall left
                    } else if (sx === 1 && sy === -1) { // Moving NE
                        if (y + 1 < H && map[y + 1][x] === 1) return false; // Wall below
                        if (x - 1 >= 0 && map[y][x - 1] === 1) return false; // Wall left
                    } else if (sx === -1 && sy === 1) { // Moving SW
                        if (y - 1 >= 0 && map[y - 1][x] === 1) return false; // Wall above
                        if (x + 1 < W && map[y][x + 1] === 1) return false; // Wall right
                    } else if (sx === -1 && sy === -1) { // Moving NW
                        if (y + 1 < H && map[y + 1][x] === 1) return false; // Wall below
                        if (x + 1 < W && map[y][x + 1] === 1) return false; // Wall right
                    }
                }
            } else {
                return false; // Out of bounds
            }
            if (x === x1 && y === y1) return true; // Reached target
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x += sx; }
            if (e2 < dx) { err += dx; y += sy; }
        }
    }

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (dist <= radius) {
                // Check if tile is in the same room or has line-of-sight
                const tileRoom = rooms.find(r => x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h);
                const inSameRoom = currentRoom && tileRoom && currentRoom === tileRoom;
                const hasLOS = hasLineOfSight(px, py, x, y);
                if (inSameRoom || hasLOS) {
                    fogMap[y][x] = 1; // Mark as explored
                }
            }
        }
    }
}

let enemiesSpawnedThisFloor = 0;
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 20000; // 20 seconds

async function fetchTxs() {
    if (gameOver || splashActive || floor === 0) {
        console.log(`Skipping fetchTxs: gameOver=${gameOver}, splashActive=${splashActive}, floor=${floor}`);
        return;
    }
    const now = Date.now();
    if (nextApiCallTime && now < nextApiCallTime) {
        console.log(`Skipping API call, next call in ${(nextApiCallTime - now) / 1000} seconds`);
        return;
    }
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }
    try {
        console.log(`fetchTxs: floor=${floor}, wave=${wave}, enemiesSpawnedThisFloor=${enemiesSpawnedThisFloor}, initialSpawnDoneThisFloor=${initialSpawnDoneThisFloor}, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
        if (initialSpawnDoneThisFloor) {
            console.log(`Initial spawn done for floor ${floor}, checking for Whales or new wave`);
        } else {
            console.log(`Spawning enemies for floor ${floor}, ${enemiesSpawnedThisFloor}/10 spawned`);
        }
        await new Promise(resolve => setTimeout(resolve, 25));
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        console.log('Mempool response:', res.data);
        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }
        let enemyCount = 0;
        const processedTxids = new Set();
        // Changed to console.warn for visibility
        console.warn(`[WHALE ATTEMPT] Checking ${res.data.length} transactions for Whale spawns (> 100 BTC)`);
        for (const tx of res.data.slice(0, 10)) {
            if (processedTxids.has(tx.txid)) continue;
            processedTxids.add(tx.txid);
            let value = 0;
            let address = 'Invalid address';
            try {
                await new Promise(resolve => setTimeout(resolve, 25));
                const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
                if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                    value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                    address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
                } else {
                    console.log(`Invalid tx data from api/tx/${tx.txid}:`, txRes.data);
                    continue;
                }
            } catch (e) {
                console.log(`Skipping tx ${tx.txid} due to fetch error:`, e.message);
                continue;
            }
            if (value <= 0) {
                console.log(`Skipping tx ${tx.txid}: Zero/negative value`, value);
                continue;
            }
            const btc = value / 1e8;
            const type = types.find(t => btc > t.min && btc <= t.max);
            console.log(`Tx ${tx.txid}: BTC=${btc.toFixed(8)}, Type=${type ? type.name : 'None'}, Value=${value}`);
            if (!type) {
                console.log(`No type for BTC: ${btc}, Tx: ${tx.txid}`);
                continue;
            }

            // Handle initial spawn (up to 10 enemies, including Whales)
            if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10) {
                if (type.name !== 'Whale' && exit) {
                    console.log(`Exit exists at (${exit.x}, ${exit.y}), skipping non-Whale spawn for tx ${tx.txid}`);
                    continue;
                }
                console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`);
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                } while (map[y][x] !== 0 || (x === p.x && y === p.y) || enemies.some(e => e.x === x && e.y === y));
                enemies.push({ x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) });
                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
                enemiesSpawnedThisFloor++;
                enemyCount++;
                if (type.name === 'Whale') {
                    console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                    logWhaleHashId(tx.txid);
                    document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                    setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
                }
                if (enemiesSpawnedThisFloor >= 10) {
                    initialSpawnDoneThisFloor = true;
                }
            } else if (type.name === 'Whale') {
                console.log(`[WHALE SPAWN ATTEMPT] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}`);
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                } while (map[y][x] !== 0 || (x === p.x && y === p.y) || enemies.some(e => e.x === x && e.y === y));
                enemies.push({ x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) });
                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
                console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                logWhaleHashId(tx.txid);
                document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
                enemyCount++;
            }
        }
        if (enemiesSpawnedThisFloor > 0 && enemiesSpawnedThisFloor < 10 && !initialSpawnDoneThisFloor) {
            console.warn(`Only spawned ${enemiesSpawnedThisFloor} enemies due to insufficient valid blockchain data`);
        }
        if (enemyCount > 0 && enemies.length > 0 && !exit) {
            if (!waveActive) {
                wave++;
                initialWaveSpawned = true;
                waveActive = true;
                document.getElementById('wave').textContent = wave;
                logBattleEvent(`Floor ${floor} - Wave ${wave} Started!`);
                console.log(`New wave started: wave=${wave}, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
            } else {
                console.log(`Additional enemies added to wave ${wave}, enemies=${enemies.length}, waveActive=${waveActive}`);
            }
            needsRedraw = true;
        } else {
            console.log(`No enemies spawned, wave=${wave}, scheduling retry in ${API_INTERVAL / 1000}s`);
        }
    } catch (e) {
        console.error('fetchTxs Error:', e, e.stack);
    } finally {
        nextApiCallTime = now + API_INTERVAL;
        apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    }
}

function move(dir) {
    if (gameOver || splashActive) return;
    swordDir = dir;
    let nx = p.x, ny = p.y;
    let newDirection = p.anim.direction; // Default to current direction
    if (dir === 'up') {
        ny--;
        newDirection = 'back';
    }
    if (dir === 'down') {
        ny++;
        newDirection = 'front';
    }
    if (dir === 'left') {
        nx--;
        newDirection = 'left';
    }
    if (dir === 'right') {
        nx++;
        newDirection = 'right';
    }
    // Update direction even if move is blocked
    p.anim.direction = newDirection;
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        return;
    }
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        p.x = nx;
        p.y = ny;
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2; // Cycle frames
        p.anim.lastFrameTime = performance.now(); // Update frame time
        if (map[ny][nx] === 2) { 
            p.potions++; 
            map[ny][nx] = 0; 
            playWebAudioSound(sounds.pickup);
        }
        if (map[ny][nx] === 3) {
            const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
            if (drop) {
                satsEarned[drop.type] += drop.sats;
                map[ny][nx] = 0;
                satoshiDrops = satoshiDrops.filter(d => d !== drop);
                playWebAudioSound(sounds.pickup);
                updateSatsDisplay();
            }
        }
        if (map[ny][nx] === 4) {
            p.pickaxes++;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Pickaxe Found!`);
        }
        if (map[ny][nx] === 5) {
            if (p.hp >= 24) {
                p.hp += 12;
            } else {
                p.hp = 24 + 12;
            }
            p.hasArmor = true;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Armor Found: HP set to ${p.hp}`);
            updatePlayerState();
        }
        if (exit && p.x === exit.x && p.y === exit.y) {
            sounds.stairs.play().catch(e => console.error('Stairs sound error:', e));
            enemiesSpawnedThisFloor = 0;
            initialSpawnDoneThisFloor = false;
            enemies = [];
            floor++;
            initialWaveSpawned = false;
            waveActive = false;
            exit = null;
            killsLog = [];
            document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
            document.getElementById('wave').textContent = wave;
            console.log(`Moved to floor ${floor}, wave=${wave}, reset enemy spawns, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}`);
            initMap();
            nextApiCallTime = null;
            const battleEvents = document.getElementById('battle-events');
            battleEvents.value = '';
            battleEvents.style.transform = 'translateX(-100%)';
            battleEvents.style.opacity = '0';
            setTimeout(() => {
                if (!gameOver && !splashActive && floor > 0) {
                    fetchTxs();
                    console.log(`Triggered fetchTxs for wave ${wave} on floor ${floor}`);
                }
            }, 1000);
        }
        updateFogMap(p.x, p.y);
    }
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

function moveEnemies() {
    if (gameOver || splashActive) return;
    enemies.forEach(e => {
        let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
        if (dist <= 5) {
            let moves = e.type.move, steps = 0;
            while (steps < moves) {
                let nx = e.x, ny = e.y;
                if (e.type.name === 'Crab') {
                    nx += dx > 0 ? 1 : -1;
                } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
                    if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                    else ny += dy > 0 ? 1 : -1;
                } else {
                    if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                    else ny += dy > 0 ? 1 : -1;
                }
                if (
                    nx >= 0 && nx < W && ny >= 0 && ny < H && 
                    map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) && 
                    !enemies.some(en => en.x === nx && en.y === ny && en !== e)
                ) {
                    e.x = nx; e.y = ny;
                } else break;
                steps++;
                dx = p.x - e.x; dy = p.y - e.y;
            }
            if (
                (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark') ?
                (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
            ) {
                p.hp -= e.type.atk;
                logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${e.type.atk} DMG`);
                playWebAudioSound(sounds.hit);
                if (p.hp <= 0) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    gameOver = true;
                    console.log(`Game Over: p.hp=${p.hp}`);
                }
                updatePlayerState(); // Check HP and armor state after damage
            }
        }
    });
    if (enemies.length === 0 && !exit && waveActive) {
        let r = rooms[Math.floor(Math.random() * rooms.length)];
        let x, y;
        do { x = r.x + Math.floor(Math.random() * r.w); y = r.y + Math.floor(Math.random() * r.h); }
        while (map[y][x] !== 0 || (x === p.x && y === p.y));
        exit = {x, y};
        console.log(`Stairs spawned at (${x}, ${y}) on floor ${floor}, wave=${wave}`);
        updateSatsDisplay();
        needsRedraw = true;
    }
    if (enemies.length === 0 && waveActive) {
        waveActive = false;
        logBattleEvent(`Floor ${floor} - Wave ${wave} Completed!`);
        initialWaveSpawned = false;
        console.log(`Wave ${wave} completed, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
        needsRedraw = true;
    }
    needsRedraw = true;
}

let usePickaxeSword = false; // Global flag for draw

function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    // Update player direction to match swordDir
    let newDirection = p.anim.direction;
    if (swordDir === 'up') newDirection = 'back';
    if (swordDir === 'down') newDirection = 'front';
    if (swordDir === 'left') newDirection = 'left';
    if (swordDir === 'right') newDirection = 'right';
    p.anim.direction = newDirection;
    const initialPickaxes = p.pickaxes; // Store initial pickaxe count
    usePickaxeSword = initialPickaxes > 0; // Set flag for animation
    let hit = enemies.find(e => {
        let sx = p.x, sy = p.y;
        if (swordDir === 'up') sy--;
        if (swordDir === 'down') sy++;
        if (swordDir === 'left') sx--;
        if (swordDir === 'right') sx++;
        return e.x === sx && e.y === sy;
    });
    if (hit) {
        hit.hp -= p.atk;
        if (hit.hp <= 0) {
            kills[hit.type.name]++;
            let dropPlaced = false;
            if (map[hit.y][hit.x] === 0) {
                map[hit.y][hit.x] = 3;
                satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                dropPlaced = true;
            } else {
                const adjacent = [
                    {x: hit.x, y: hit.y - 1},
                    {x: hit.x, y: hit.y + 1},
                    {x: hit.x - 1, y: hit.y},
                    {x: hit.x + 1, y: hit.y}
                ];
                for (const pos of adjacent) {
                    const nx = pos.x, ny = pos.y;
                    if (
                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                        map[ny][nx] === 0 &&
                        !enemies.some(e => e.x === nx && e.y === ny)
                    ) {
                        map[ny][nx] = 3;
                        satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                        dropPlaced = true;
                        console.log(`Placed satoshi drop at adjacent tile (${nx}, ${ny})`);
                        break;
                    }
                }
            }
            if (!dropPlaced) {
                console.log(`No empty adjacent tile found for satoshi drop at (${hit.x}, ${hit.y})`);
            }
            enemies = enemies.filter(e => e !== hit);
            if (exit && enemies.length === 0) {
                updateSatsDisplay(); // Update only when all enemies are cleared
            }
        }
    } else if (initialPickaxes > 0) {
        // Check for wall hit
        let sx = p.x, sy = p.y;
        if (swordDir === 'up') sy--;
        if (swordDir === 'down') sy++;
        if (swordDir === 'left') sx--;
        if (swordDir === 'right') sx++;
        if (sx >= 0 && sx < W && sy >= 0 && sy < H && map[sy][sx] === 1) {
            usePickaxeSword = true; // Ensure pickaxe-sword animation
            p.pickaxes--; // Consume pickaxe
            sounds.secret.play().catch(e => console.error('Secret sound error:', e));
            logBattleEvent(`Floor ${floor} - Wall Broken!`);
            createSecretRoom(sx, sy, p.x, p.y, swordDir);
        } else {
            usePickaxeSword = true; // Show pickaxe-sword for air swings
        }
    }
    moveEnemies();
    needsRedraw = true;
    setTimeout(() => {
        swordActive = false;
        usePickaxeSword = false; // Clear flag after animation
        needsRedraw = true;
    }, 200);
}

function usePotion() {
    if (gameOver || splashActive || p.potions <= 0) return;
    if (p.hp >= 24) {
        logBattleEvent(`Floor ${floor} - Potion Returned: HP already at ${p.hp}!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Refund potion by not decrementing p.potions
    }
    p.potions--;
    const oldHP = p.hp;
    p.hp = Math.min(24, p.hp + 12);
    logBattleEvent(`Floor ${floor} - Potion Used: +${p.hp - oldHP} HP (now ${p.hp})`);
    sounds.potion.play().catch(e => console.error('Potion sound error:', e));
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

function restart() {
    console.log('Restarting game');
    floor = 1;
    wave = 1;
    p.hp = 24;
    p.potions = 0;
    p.pickaxes = 0;
    p.hasArmor = false;
    p.x = 2;
    p.y = 2;
    p.atk = 2;
    enemies = [];
    map = [];
    rooms = [];
    exit = null;
    gameOver = false;
    gameOverSoundPlayed = false;
    enemiesSpawnedThisFloor = 0;
    initialSpawnDoneThisFloor = false;
    initialWaveSpawned = false;
    waveActive = false;
    nextApiCallTime = null;
    whaleHashIds = ['Whale Transactions:'];
    battleLog = [];
    killsLog = [];
    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    satoshiDrops = [];
    swordDir = 'right';
    swordActive = false;
    swordStart = 0;
    fogMap = [];
    scoreSubmitted = false; // Reset submission flag

    document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
    document.getElementById('battle-events').value = '';
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    document.getElementById('health').textContent = p.hp;
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('sats').textContent = '0';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('submit-score').style.display = 'none';
    document.getElementById('view-leaderboard').style.display = 'none';
    document.getElementById('restart-game').style.display = 'none';
    document.getElementById('username-input').value = '';
    document.getElementById('leaderboard-output').textContent = '';
    document.getElementById('leaderboard-output').style.display = 'none';
    document.getElementById('submit-score').disabled = false; // Re-enable button
    document.getElementById('submit-score').style.background = '#ff8c00'; // Restore button color
    document.getElementById('splash-screen').style.display = 'block';
    const battleEvents = document.getElementById('battle-events');
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
    splashActive = true;

    sounds.music.pause();
    sounds.music.currentTime = 0;

    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }

    resetSplashScreen();
    initMap();
    updateSatsDisplay();
    needsRedraw = true;
    console.log('Restart complete, floor=', floor, 'wave=', wave, 'splashActive=', splashActive, 'enemies=', enemies.length, 'exit=', exit, 'gameOver=', gameOver, 'scoreSubmitted=', scoreSubmitted);
}

function draw() {
    if (!map?.[0] || !p || !enemies || !rooms?.length || !fogMap?.[0]) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms, 'fogMap=', fogMap);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);
if (gameOver) {
    const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
    gameOverCanvas.clearRect(0, 0, 320, 320);
    gameOverCanvas.fillStyle = '#000';
    gameOverCanvas.fillRect(0, 0, 320, 320);
    const scale = window.innerWidth <= 700 ? 1.5 : 2;
    const gw = 128 * scale, gh = 32 * scale;
    const offsetY = (Math.sin(Date.now() / 500) * 10);
    gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh) / 2 + offsetY, gw, gh);
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('submit-score').style.display = 'block';
    document.getElementById('view-leaderboard').style.display = 'block';
    document.getElementById('restart-game').style.display = 'block';
    return;
}
    if (splashActive) { needsRedraw = false; return; }

    const radius = 4;
    // Draw walls first
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] === 1) c.drawImage(assets.wall, x * S, y * S, S, S);
    }
    // Draw floors, items, and stairs
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
        const isVisible = fogMap[y][x] === 1 || dist <= radius || map[y][x] === 1;
        if (isVisible && map[y][x] !== 1) {
            c.drawImage(assets.floor, x * S, y * S, S, S);
            if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
            if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
            if (map[y][x] === 4) c.drawImage(assets.pickaxe, x * S, y * S, S, S);
            if (map[y][x] === 5) c.drawImage(assets.armor, x * S, y * S, S, S);
            if (exit && exit.x === x && exit.y === y) c.drawImage(assets.stairs, x * S, y * S, S, S);
        }
    }
// Draw player
if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
    const now = performance.now();
    if (now - p.anim.lastFrameTime >= p.anim.frameDuration) {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2; // Cycle frames
        p.anim.lastFrameTime = now;
    }
    const direction = p.anim.direction;
    const baseDirection = direction === 'left' ? 'right' : direction; // Use right frames for left
    const frameKey = p.hasArmor ? `armor_${baseDirection}` : baseDirection;
    const frame = p.anim.frames[frameKey][p.anim.frameIndex];
    c.save();
    if (direction === 'left') {
        c.translate((p.x + 1) * S, p.y * S);
        c.scale(-1, 1); // Mirror horizontally
        c.drawImage(frame, 0, 0, S, S);
    } else {
        c.drawImage(frame, p.x * S, p.y * S, S, S);
    }
    c.restore();
}
    // Draw sword or pickaxe-sword
    if (swordActive && Date.now() - swordStart < 200) {
        let sx = p.x, sy = p.y;
        if (swordDir === 'up') sy--;
        if (swordDir === 'down') sy++;
        if (swordDir === 'left') sx--;
        if (swordDir === 'right') sx++;
        if (sx >= 0 && sx < W && sy >= 0 && sy < H && Math.sqrt((sx - p.x) ** 2 + (sy - p.y) ** 2) <= radius) {
            c.save();
            c.translate(sx * S + S / 2, sy * S + S / 2);
            if (swordDir === 'up') c.rotate(-Math.PI / 2);
            if (swordDir === 'down') c.rotate(Math.PI / 2);
            if (swordDir === 'left') c.rotate(Math.PI);
            c.drawImage(usePickaxeSword ? assets.pickaxe_sword : assets.sword, -S / 2, -S / 2, S, S);
            c.restore();
        }
    }
    // Draw fog overlay
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] !== 1 && !fogMap[y][x]) {
            c.fillStyle = 'rgba(0, 0, 0, 0.7)';
            c.fillRect(x * S, y * S, S, S);
        }
    }
    // Draw enemies
    enemies.forEach(e => {
        if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
            c.drawImage(e.type.img, e.x * S, e.y * S, S, S);
        }
    });
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = false;
}

function gameLoop(timestamp) {
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state');
        initMap();
        needsRedraw = true;
    }
    if (gameOver) {
        sounds.music.pause();
        sounds.music.currentTime = 0;
        if (!gameOverSoundPlayed) {
            sounds.gameover.play().catch(e => console.error('Gameover sound error:', e));
            gameOverSoundPlayed = true; // Mark sound as played
        }
        document.getElementById('health').textContent = 0;
        needsRedraw = true;
    }
    if (needsRedraw && !splashActive) draw();
    if (p.hp <= 0 && !gameOver) {
        p.hp = 0;
        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
        gameOver = true;
    }
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if (splashActive && e.key === 'Enter') {
        console.log('Enter key pressed on splash: splashActive=', splashActive, 'musicMuted=', musicMuted);
        const startButton = document.getElementById('start-button');
        startButton.style.background = '#00b7ef'; // Mimic :hover color
        setTimeout(() => {
            startButton.style.background = '#00e8d8'; // Revert to original color
        }, 200); // Short duration to simulate tap
        preloadSounds(); // Initialize all sounds except music
        if (!musicMuted) {
            sounds.music.pause(); // Ensure clean state
            sounds.music.currentTime = 0;
            sounds.music.play().then(() => {
                console.log('Music started successfully on Enter');
            }).catch(e => console.error('Music play failed on Enter:', e));
        }
        fadeSplash();
        return; // Prevent other key actions during splash
    }
    if (gameOver || splashActive) return;
    if (e.key === 'ArrowUp') move('up');
    if (e.key === 'ArrowDown') move('down');
    if (e.key === 'ArrowLeft') move('left');
    if (e.key === 'ArrowRight') move('right');
    if (e.key === 'a') attack();
    if (e.key === 'd') usePotion();
});

document.getElementById('game-over').addEventListener('click', (event) => {
    if (
        gameOver &&
        !document.getElementById('username-input').contains(event.target) &&
        !document.getElementById('submit-score').contains(event.target) &&
        !document.getElementById('view-leaderboard').contains(event.target) &&
        !document.getElementById('restart-game').contains(event.target) &&
        !document.getElementById('leaderboard-output').contains(event.target)
    ) {
        // No action on canvas click; restart only via button
    }
});

        initMap();
        updateSatsDisplay();
        requestAnimationFrame(gameLoop);
        
document.querySelectorAll('#dpad button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        button.classList.add('pressed'); // Add visual feedback
        button.click(); // Trigger onclick
    }, { passive: false });
    button.addEventListener('touchend', () => {
        button.classList.remove('pressed'); // Remove visual feedback
    });
});

// go to game-over screen at startup (DEBUG)
//function initGameOver() {
//    gameOver = true;
//    floor = 3;
//    satsEarned = {Shrimp: 2349, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
//    kills = {Shrimp: 1, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
//    document.getElementById('game-over').style.display = 'block';
//    document.getElementById('submit-score').style.display = 'block';
//    document.getElementById('view-leaderboard').style.display = 'block';
//    document.getElementById('restart-game').style.display = 'block';
//    updateSatsDisplay();
//    needsRedraw = true;
//    console.log('Initialized to game-over: gameOver=', gameOver, 'floor=', floor);
//}
//initGameOver();
//requestAnimationFrame(gameLoop);

    </script>
</body>
</html>



