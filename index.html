<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 100vh; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
        }
        #console { 
	background: #111;
  	border: 4px solid #ff8c00;
  	padding: 4px;
  	display: flex;
  	flex-direction: column;
  	align-items: center;
  	gap: 4px;
  	max-width: 800px;
  	width: 100%;
  	box-sizing: border-box;
        }
        #whale-log { 
            width: 618px; 
            max-height: 24px; 
            overflow-y: auto; 
            background: #111; 
            color: #ff8c00; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: #ff8c00; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
        #battle-log { 
            width: 620px; 
            background: transparent; 
            color: #ff8c00; 
            padding: 8px; 
            border: none; 
            font-size: 14px;
            z-index: 10;
            margin-top: -240px; 
        }
        #battle-log textarea { 
            background: transparent; 
            color: #ff8c00; 
            border: none; 
            font-family: 'VT323', monospace; 
            font-size: 14px; 
            resize: none; 
            width: 100%; 
            height: 200px; 
            padding: 0; 
            overflow-y: auto; 
            scroll-behavior: smooth;
            z-index: 10;            
            pointer-events: none; 
        }
        #inventory { 
            position: absolute; 
            top: 10px; 
            right: -24px; 
            background: transparent; 
            color: #ff8c00;
            border: none;  
            padding: 8px; 
            z-index: 10; 
            font-family: 'VT323', monospace; 
            font-size: 20px; 
            line-height: 1.5; 
            width: 160px; 
        }
        #floor-indicator { 
            position: absolute; 
            top: 11px; 
            left: 10px; 
            background: transparent; 
            color: #ff8c00; 
            padding: 8px; 
            z-index: 10; 
            font-family: 'VT323', monospace;
            font-size: 24px; 
        }
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
        grid-area: t;
        z-index: 10;
        }
        #left { grid-area: l;
        z-index: 10;
        }
        #right { grid-area: r;
        z-index: 10; 
        }
        #down { grid-area: b;
        z-index: 10;
        }
        #actions { display: flex; gap: 5px; align-items: center; }
        button { 
            background-color: transparent;
            border: 1px solid #ff8c00;
            color: #ff8c00;
            padding: 8px; 
            border: 0px solid #000; 
            cursor: pointer; 
            font-size: 14px; 
            width: 40px; 
            height: 40px;
            box-sizing: border-box; 
        }
        button:hover {
        background: #e07b00;
        }
        
        #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 30px;
        background: #fff;
        color: #000;
        margin-right: 50px;
        z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        
        #attack, #potion {
        margin-right: 20px;
        background: #ff8c00;
        color: #fff;
        height: 50px;
        width: 50px; 
        border-radius: 50%;
        }
        #attack:hover, #attack:hover, #potion:hover {
            background: #e07b00;
        }
	#download-stats {
        position: absolute;
    	bottom: 10px;
    	left: 50%;
    	transform: translateX(-50%);
   	margin-top: 20;
    	padding: 0px;
    	width: 80px;
    	background: #ff8c00;
    	color: #111;
    	font-family: 'VT323', monospace;
    	font-size: 16px;
    	border: none;
    	cursor: pointer;
    	border-radius: 5%;
    	z-index: 40;
	}
        @media only screen and (min-width: 320px) and (max-width: 1024px) {
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            #console { padding: 5px; overflow: hidden;}
            canvas, #splash-screen, #game-container, #game-over { 
                width: 100%; 
                max-width: 270px; 
                height: auto; 
                aspect-ratio: 1/1; 
            }
            #whale-log { 
                width: 100%; 
                max-width: 270px; 
                font-size: 12px; 
            }
            #whale-hash-ids { 
                max-width: 460px; 
            }
            #battle-log { 
                width: 100%; 
                max-width: 480px; 
                font-size: 12px; 
            }
            #battle-log textarea { 
                width: 100%; 
                height: 50px; 
                font-size: 12px; 
            }
            #inventory { 
                width: 100px; 
                font-size: 10px; 
                line-height: 1.4;
                margin-right: -10px; 
            }
            #floor-indicator { font-size: 10px; }
            button { 
            width: 50px;
            height: 50px;
            font-size: 12px;
            border-radius: 50%;
            margin-top: 0px;
            }
            button:hover {
            background: #e07b00;
            }
        #mute {
        padding: 2px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 30px;
        margin-left: -290px;
        margin-top: 120px;
        z-index: 30;
        }
        #attack, #potion {
        padding: 0px;
        margin-right: 20px;
        background: #ff8c00;
        height: 30px;
        width: 30px; 
        border-radius: 50%;
        margin-right: 15px;
        margin-top: 120px;
        z-index: 30;
        }
        #up {
	grid-area: t;
    	margin-top: 120px;
    	margin-left: 197px;
    	z-index: 30;
   	border-radius: 0%;
        }
        #left {
	grid-area: t;
    	margin-top: 166px;
    	margin-left: 152px;
    	z-index: 30;
    	border-radius: 0%;
        }
        #right {
	grid-area: t;
   	margin-top: 166px;
    	margin-right: -15px;
    	margin-left: 243px;
    	border-radius: 0%;
        }
        #down {
	grid-area: t;
    	margin-top: 212px;
   	 margin-left: 197px;
    	z-index: 30;
    	border-radius: 0%;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #download-stats {
	position: absolute;
    	bottom: 140px;
    	left: 50%;
    	transform: translateX(-50%);
    	margin-top: -10;
    	padding: 0px;
    	width: 80px;
    	height: 20px;
    	background: #ff8c00;
    	color: #fff;
    	font-family: 'VT323', monospace;
    	font-size: 16px;
    	border: none;
    	cursor: pointer;
    	border-radius: 5%;
   	z-index: 40;    
	}
            #controller { padding: 5px; }
        }
    </style>
</head>
<body>
    <div id="console">
        <div id="whale-log">
            <div id="whale-hash-ids">Whale Transactions:</div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
                <canvas id="splash-canvas" width="320" height="320"></canvas>
            </div>
            <div id="game-over">
                <canvas id="game-over-canvas" width="320" height="320"></canvas>
                <button id="download-stats">screenshot</button>
            </div>
            <div id="floor-indicator">Floor 1</div>
            <div id="inventory">
                Wave: <span id="wave">0</span><br>
                <br>
                Health: <span id="health">24</span><br>
                Potions: <span id="potions">0</span><br>
                Bag: <span id="sats">0</span><br>
                <br>
                Kills:<br>
                <span id="sats-breakdown">
                    Shrimp: 0<br>Crab: 0<br>Squid: 0<br>Dolphin: 0<br>Shark: 0<br>Whale: 0
                </span><br>
            </div>
        </div>
        <div id="battle-log">
            <textarea id="battle-events" readonly>Battle Log:</textarea>
        </div>
        <div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">‚Üë</button>
                <button id="left" onclick="move('left')">‚Üê</button>
                <button id="right" onclick="move('right')">‚Üí</button>
                <button id="down" onclick="move('down')">‚Üì</button>
            </div>
            <div id="actions">
                <button id="mute" onclick="toggleMute()">‚ô™</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        const canvas = document.getElementById('game');
        const c = canvas.getContext('2d');
        const W = 20, H = 20, S = 16;
        let map = [], p = {x: 2, y: 2, hp: 24, potions: 0, atk: 2}, enemies = [], rooms = [];
        let floor = 1, wave = 0, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
        let whaleHashIds = ['Whale Hash IDs:'], battleLog = ['Battle Log:'];
        let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
        let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
        let satoshiDrops = [];
        let retryDelay = 5000;
        let splashActive = true
        let waveActive = false;
        let musicMuted = false;        
        let swordDir = 'right', swordActive = false, swordStart = 0;
        const types = [
            {name: 'Shrimp', min: 0, max: 0.01, img: new Image(), hp: 1, atk: 1, reward: 0, move: 1},
            {name: 'Crab', min: 0.01, max: 0.1, img: new Image(), hp: 2, atk: 2, reward: 0, move: 1},
            {name: 'Squid', min: 0.1, max: 1, img: new Image(), hp: 3, atk: 2, reward: 0, move: 2},
            {name: 'Dolphin', min: 1, max: 10, img: new Image(), hp: 4, atk: 3, reward: 0, move: 2},
            {name: 'Shark', min: 10, max: 100, img: new Image(), hp: 5, atk: 5, reward: 0, move: 2},
            {name: 'Whale', min: 100, max: Infinity, img: new Image(), hp: 6, atk: 4, reward: 0, move: 2}
        ];
        const assets = {
            floor: new Image(), wall: new Image(), potion: new Image(), player: new Image(), 
            stairs: new Image(), bitcoin: new Image(), gameOver: new Image(), playAgain: new Image(),
            sword: new Image()
        };
        types[0].img.src = 'shrimp.png'; types[1].img.src = 'crab.png'; types[2].img.src = 'squid.png';
        types[3].img.src = 'dolphin.png'; types[4].img.src = 'shark.png'; types[5].img.src = 'whale.png';
        assets.floor.src = 'floor.png'; assets.wall.src = 'wall.png'; assets.potion.src = 'potion.png';
        assets.player.src = 'player.png'; assets.stairs.src = 'stairs.png'; assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png'; assets.playAgain.src = 'playagain.png'; assets.sword.src = 'sword.png';
        Object.values(assets).forEach(asset => { asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`); });
        types.forEach(t => { t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`); });

        const sounds = {
            attack: new Audio('attack.wav'), potion: new Audio('potion.wav'), hit: new Audio('hit.wav'),
            pickup: new Audio('pickup.wav'), music: new Audio('music.ogg')
        };
        sounds.music.loop = true;
        Object.values(sounds).forEach(s => { s.onerror = () => console.error(`Failed to load sound: ${s.src}`); });

        const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
        const splashImg = new Image();
        splashImg.src = 'splash.png';
        splashImg.onload = () => {
            splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
            fadeSplash();
            console.log('Splash started: active=', splashActive, 'bg=#F7931A');
        };

        function fadeSplash() {
            setTimeout(() => {
                const imgData = splashCanvas.getImageData(0, 0, 320, 320);
                const pixels = imgData.data;
                const totalPixels = 320 * 320;
                const fadePerFrame = totalPixels / 20;
                let fadedPixels = 0;
                const fadeInterval = setInterval(() => {
                    for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                        const px = Math.floor(Math.random() * totalPixels) * 4;
                        pixels[px + 3] = 0;
                        fadedPixels++;
                    }
                    splashCanvas.putImageData(imgData, 0, 0);
                    if (fadedPixels >= totalPixels) {
                        clearInterval(fadeInterval);
                        splashActive = false;
                        document.getElementById('splash-screen').remove();
                        sounds.music.play();
                        console.log('Splash ended: active=', splashActive);
                    }
                }, 100);
            }, 3000);
        }

        function toggleMute() {
            musicMuted = !musicMuted;
            sounds.music.muted = musicMuted;
            document.getElementById('mute').textContent = musicMuted ? 'üõá' : '‚ô™';
        }

        function logWhaleHashId(txid) {
            whaleHashIds.push(`Floor ${floor} - <a href="https://www.blockchain.com/explorer/transactions/btc/${txid}" target="_blank">${txid}</a>`);
            document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
            const whaleLog = document.getElementById('whale-log');
            whaleLog.scrollTop = whaleLog.scrollHeight;
            console.log('Whale Hash ID:', txid);
        }

        function logBattleEvent(event) {
            if (gameOver) return;
            battleLog.push(event);
            const textarea = document.getElementById('battle-events');
            textarea.value = battleLog.join('\n');
            textarea.scrollTop = textarea.scrollHeight;
        }

        function updateSatsDisplay() {
            const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
            document.getElementById('sats').textContent = totalSats < 1e8 ? `${totalSats} sats` : `${(totalSats / 1e8).toFixed(1)} BTC`;
            document.getElementById('sats-breakdown').innerHTML = 
                `Shrimp: ${kills.Shrimp}<br>Crab: ${kills.Crab}<br>Squid: ${kills.Squid}<br>` +
                `Dolphin: ${kills.Dolphin}<br>Shark: ${kills.Shark}<br>Whale: ${kills.Whale}`;
        }

function initMap() {
    try {
        map = Array(H).fill().map(() => Array(W).fill(1));
        rooms = [];
        satoshiDrops = [];
        
        // Generate at least 3 rooms, up to 5
        let maxAttempts = 100; // Prevent infinite loops
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4); // Room width: 4-7
            let rh = 4 + Math.floor(Math.random() * 4); // Room height: 4-7
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            
            // Check for overlap with existing rooms
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        
        // Try to add up to 2 more rooms (optional, max 5 total)
        maxAttempts = 50; // Limit attempts for additional rooms
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap(); // Recursively retry if we didn't get enough rooms
        }
        
        // Connect rooms with corridors
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r2.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }
        
        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;
        
        // Place player
        p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
        if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) { p.x = x; p.y = y; break; }
        }
        
        // Place potions
        let potionPositions = [];
        let selectedRooms = rooms.sort(() => 0.5 - Math.random()).slice(0, Math.min(3, rooms.length));
        let proximityRange = 5; // Initial proximity range
        for (let r of selectedRooms) {
            let x, y, attempts = 100;
            while (attempts > 0 && potionPositions.length < 3) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);
                if (map[y][x] === 0 && (x !== p.x || y !== p.y) && !potionPositions.some(p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange)) {
                    map[y][x] = 2;
                    potionPositions.push({x, y});
                    if (potionPositions.length === 3) {
                        break;
                    }
                }
                attempts--;
            }
            if (attempts === 0 && potionPositions.length < 3) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;
                continue;
            }
        }
        
        console.log('Rooms generated:', rooms.length, 'Potions placed:', potionPositions);
        exit = null;
        initialWaveSpawned = false;
        needsRedraw = true;
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

let enemiesSpawnedThisFloor = 0;
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 20000; // 20 seconds

async function fetchTxs() {
    if (gameOver) return;

    const now = Date.now();
    if (nextApiCallTime && now < nextApiCallTime) {
        console.log(`Skipping API call, next call in ${(nextApiCallTime - now) / 1000} seconds`);
        return;
    }

    // Clear any existing timeout to prevent stacking
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }

    try {
        // Skip non-Whale spawns if initial spawn is done
        if (initialSpawnDoneThisFloor) {
            console.log(`Initial spawn done for floor ${floor}, only checking for Whales`);
        } else {
            console.log(`Spawning non-Whales for floor ${floor}, ${enemiesSpawnedThisFloor}/10 spawned`);
        }

        // Fetch recent transactions
        await new Promise(resolve => setTimeout(resolve, 25));
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        console.log('Mempool response:', res.data);

        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }

        let enemyCount = 0;
        const processedTxids = new Set(); // Track processed transactions

        // Single loop for both initial spawn and Whale spawn
        for (const tx of res.data.slice(0, 10)) { // Process up to 10 transactions
            if (processedTxids.has(tx.txid)) continue; // Skip already processed transactions
            processedTxids.add(tx.txid);

            let value = 0;
            let address = 'Invalid address';
            console.log(`Fetching tx details for ${tx.txid}`);
            try {
                await new Promise(resolve => setTimeout(resolve, 25));
                const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
                if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                    value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                    address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
                } else {
                    console.log(`Invalid tx data from api/tx/${tx.txid}:`, txRes.data);
                    continue;
                }
            } catch (e) {
                console.error(`Failed to fetch tx ${tx.txid}:`, e);
                continue;
            }

            if (value <= 0) {
                console.log(`Skipping tx ${tx.txid}: Zero/negative value`, value);
                continue;
            }

            const btc = value / 1e8;
            const type = types.find(t => btc > t.min && btc <= t.max);
            console.log(`Tx ${tx.txid}: BTC=${btc.toFixed(8)}, Type=${type ? type.name : 'None'}, Value=${value}`);

            if (!type) {
                console.log(`No type for BTC: ${btc}, Tx: ${tx.txid}`);
                continue;
            }

            // Handle initial spawn (10 non-Whale enemies)
            if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10) {
                if (type.name === 'Whale') {
                    console.log(`Skipping Whale for initial spawn: ${tx.txid}`);
                    continue;
                }

                console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`);

                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                } while (map[y][x] !== 0 || (x === p.x && y === p.y) || enemies.some(e => e.x === x && e.y === y));

                enemies.push({ x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) });

                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);

                enemiesSpawnedThisFloor++;
                enemyCount++;
                
                // Set flag immediately when 10 enemies are spawned
                if (enemiesSpawnedThisFloor >= 10) {
                    initialSpawnDoneThisFloor = true;
                }
                
                continue; // Move to next transaction
            }

            // Handle Whale spawns (no enemy cap)
            if (type.name !== 'Whale') {
                console.log(`Skipping non-Whale tx: ${tx.txid}, Type: ${type.name}`);
                continue;
            }

            console.log(`Parsed Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value=${value}`);

            const r = rooms[Math.floor(Math.random() * rooms.length)];
            let x, y;
            do {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);
            } while (map[y][x] !== 0 || (x === p.x && y === p.y) || enemies.some(e => e.x === x && e.y === y));

            enemies.push({ x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) });

            const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
            logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);

            console.log(`Whale tx:`, tx, `Hash ID: ${tx.txid}`);
            logWhaleHashId(tx.txid);
            document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
            setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
        }

        // Warn if some enemies spawned but not enough
        if (enemiesSpawnedThisFloor > 0 && enemiesSpawnedThisFloor < 10 && !initialSpawnDoneThisFloor) {
            console.warn(`Only spawned ${enemiesSpawnedThisFloor} non-Whale enemies due to insufficient valid blockchain data`);
        }

        if (enemies.length === 0 && initialSpawnDoneThisFloor) {
            console.warn(`No valid Whale transactions spawned enemies, scheduling retry in ${API_INTERVAL / 1000}s`);
        } else {
            initialWaveSpawned = true;
            waveActive = enemies.length > 0;
            document.getElementById('wave').textContent = wave;
            needsRedraw = true;
        }
    } catch (e) {
        console.error('fetchTxs Error:', e, e.stack);
    } finally {
        // Schedule next call (only one timer)
        nextApiCallTime = now + API_INTERVAL;
        apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    }
}

        function move(dir) {
            if (gameOver || splashActive) return;
            swordDir = dir;
            let nx = p.x, ny = p.y;
            if (dir === 'up') ny--;
            if (dir === 'down') ny++;
            if (dir === 'left') nx--;
            if (dir === 'right') nx++;
            if (!map[ny] || map[ny][nx] === undefined) {
                console.error('Invalid map access: nx=', nx, 'ny=', ny);
                initMap();
                needsRedraw = true;
                return;
            }

            // Check if the target position is occupied by an enemy
            if (enemies.some(e => e.x === nx && e.y === ny)) {
                // If the target position is occupied, do not move the player
                return;
            }

            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
                p.x = nx; p.y = ny;
                if (map[ny][nx] === 2) { 
                    p.potions++; 
                    map[ny][nx] = 0; 
                    sounds.pickup.play().catch(e => console.error('Pickup sound error:', e)); 
                }
                if (map[ny][nx] === 3) {
                    const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
                    if (drop) {
                        satsEarned[drop.type] += drop.sats;
                        map[ny][nx] = 0;
                        satoshiDrops = satoshiDrops.filter(d => d !== drop);
                        sounds.pickup.play().catch(e => console.error('Pickup sound error:', e));
                        updateSatsDisplay();
                    }
                }
// Reset the enemiesSpawnedThisFloor counter when the player moves to the next floor
if (exit && p.x === exit.x && p.y === exit.y) {
// In your floor transition function (e.g., when entering stairs)
    enemiesSpawnedThisFloor = 0;
    initialSpawnDoneThisFloor = false;
    enemies = [];
    floor++;
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    initMap();
    initialWaveSpawned = false;
    waveActive = false;
    wave = 1;
    console.log(`Moved to floor ${floor}, reset enemy spawns`);
    nextApiCallTime = null;
    fetchTxs();

}
            }
            moveEnemies();
            needsRedraw = true;
        }

        function moveEnemies() {
            if (gameOver || splashActive) return;
            enemies.forEach(e => {
                let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
                if (dist <= 5) {
                    let moves = e.type.move, steps = 0;
                    while (steps < moves) {
                        let nx = e.x, ny = e.y;
                        if (e.type.name === 'Crab') {
                            nx += dx > 0 ? 1 : -1;
                        } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
                            if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                            else ny += dy > 0 ? 1 : -1;
                        } else {
                            if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                            else ny += dy > 0 ? 1 : -1;
                        }
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H && 
                            map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) && 
                            !enemies.some(en => en.x === nx && en.y === ny && en !== e)
                        ) {
                            e.x = nx; e.y = ny;
                        } else break;
                        steps++;
                        dx = p.x - e.x; dy = p.y - e.y;
                    }
                    if (
                        (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark') ?
                        (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                        Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
                    ) {
                        p.hp -= e.type.atk;
                        logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${e.type.atk} DMG`);
                        sounds.hit.play().catch(e => console.error('Hit sound error:', e));
                        if (p.hp <= 0) {
                            p.hp = 0;
                            logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                            gameOver = true;
                            console.log(`Game Over: p.hp=${p.hp}`);
                        }
                    }
                }
            });
            if (enemies.length === 0) waveActive = false;
            if (enemies.length === 0 && !exit && initialWaveSpawned) {
                let r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y;
                do { x = r.x + Math.floor(Math.random() * r.w); y = r.y + Math.floor(Math.random() * r.h); }
                while (map[y][x] !== 0 || (x === p.x && y === p.y));
                exit = {x, y};
            }
            needsRedraw = true;
        }

function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    let hit = enemies.find(e => {
        let sx = p.x, sy = p.y;
        if (swordDir === 'up') sy--;
        if (swordDir === 'down') sy++;
        if (swordDir === 'left') sx--;
        if (swordDir === 'right') sx++;
        return e.x === sx && e.y === sy;
    });
    if (hit) {
        hit.hp -= p.atk;
        sounds.hit.play().catch(e => console.error('Hit sound error:', e));
        if (hit.hp <= 0) {
            kills[hit.type.name]++;
            // Check if the tile is empty or find an adjacent empty tile
            let dropPlaced = false;
            if (map[hit.y][hit.x] === 0) {
                // Place drop on the enemy's tile if it's empty
                map[hit.y][hit.x] = 3;
                satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                dropPlaced = true;
            } else {
                // Try adjacent tiles (up, down, left, right)
                const adjacent = [
                    {x: hit.x, y: hit.y - 1}, // Up
                    {x: hit.x, y: hit.y + 1}, // Down
                    {x: hit.x - 1, y: hit.y}, // Left
                    {x: hit.x + 1, y: hit.y}  // Right
                ];
                for (const pos of adjacent) {
                    const nx = pos.x, ny = pos.y;
                    if (
                        nx >= 0 && nx < W && ny >= 0 && ny < H && // Within bounds
                        map[ny][nx] === 0 && // Empty tile
                        !enemies.some(e => e.x === nx && e.y === ny) // Not occupied by enemy
                    ) {
                        map[ny][nx] = 3;
                        satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                        dropPlaced = true;
                        console.log(`Placed satoshi drop at adjacent tile (${nx}, ${ny})`);
                        break;
                    }
                }
            }
            if (!dropPlaced) {
                console.log(`No empty adjacent tile found for satoshi drop at (${hit.x}, ${hit.y})`);
            }
            enemies = enemies.filter(e => e !== hit);
            updateSatsDisplay();
        }
    }
    moveEnemies();
    needsRedraw = true;
    setTimeout(() => { swordActive = false; needsRedraw = true; }, 200);
}

        function usePotion() {
            if (gameOver || splashActive || p.potions <= 0) return;
            p.potions--;
            p.hp = Math.min(24, p.hp + 12);
            logBattleEvent(`Floor ${floor} - Potion Used: +12 HP`);
            sounds.potion.play().catch(e => console.error('Potion sound error:', e));
            moveEnemies();
            needsRedraw = true;
        }

        function restart() {
            floor = 1; wave = 0; p.hp = 24; p.potions = 0; p.x = 2; p.y = 2;
            enemies = [];
            exit = null;
            gameOver = false;
            enemiesSpawnedThisFloor = 0;
            initialSpawnDoneThisFloor = false;
            nextApiCallTime = null;
            waveActive = false;
            whaleHashIds = ['Whale Hash IDs:']; battleLog = ['Battle Log:'];
            satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
            kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
            satoshiDrops = []; retryDelay = 5000; swordDir = 'right';
            document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
            document.getElementById('battle-events').value = battleLog.join('\n');
            document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('download-stats').style.display = 'none';
            updateSatsDisplay();
            initMap();
            fetchTxs();
            if (!musicMuted) sounds.music.play().catch(e => console.error('Music play failed:', e));
            needsRedraw = true;
        }

function downloadStats() {
    const gameOverCanvas = document.getElementById('game-over-canvas');
    const link = document.createElement('a');
    link.href = gameOverCanvas.toDataURL('image/png');
    link.download = `BTC_Dungeon_Floor_${floor}_Stats.png`;
    link.click();
}

function draw() {
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);
    if (gameOver) {
        const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
        // Ensure opaque black background
        gameOverCanvas.clearRect(0, 0, 320, 320); // Clear any previous content
        gameOverCanvas.fillStyle = '#000'; // Solid black
        gameOverCanvas.fillRect(0, 0, 320, 320); // Fill entire canvas
        const scale = window.innerWidth <= 700 ? 1.5 : 2;
        const gw = 128 * scale, gh = 32 * scale, pw = 96 * scale, ph = 32 * scale;
        const offsetY = (Math.sin(Date.now() / 500) * 10);
        // Draw images and text
        gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh - ph - 50) / 2, gw, gh);
        //gameOverCanvas.drawImage(assets.playAgain, (320 - pw) / 2, (320 + gh - ph + 50) / 2 + offsetY, pw, ph); // disabled for now
        // Draw stats
        gameOverCanvas.fillStyle = '#ff8c00';
        gameOverCanvas.font = '18px "VT323"';
        gameOverCanvas.textAlign = 'center';
        gameOverCanvas.fillText(`Floor Reached: ${floor}`, 160, 220);
        const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
        gameOverCanvas.fillText(`Sats: ${totalSats < 1e8 ? totalSats : (totalSats / 1e8).toFixed(6) + ' BTC'}`, 160, 240);

        document.getElementById('game-over').style.display = 'block';
        document.getElementById('download-stats').style.display = 'block';
        //needsRedraw = true; // Keep redrawing for animation // disabled for now
        return;
    }
            if (splashActive) { needsRedraw = false; return; }
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
                if (map[y][x] !== 1) c.drawImage(assets.floor, x * S, y * S, S, S);
            }
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
                if (map[y][x] === 1) c.drawImage(assets.wall, x * S, y * S, S, S);
            }
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
                if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
                if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
            }
            if (exit) c.drawImage(assets.stairs, exit.x * S, exit.y * S, S, S);
            if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
                c.drawImage(assets.player, p.x * S, p.y * S, S, S);
            }
            enemies.forEach(e => {
                if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
                    c.drawImage(e.type.img, e.x * S, e.y * S, S, S);
                }
            });
            if (swordActive && Date.now() - swordStart < 200) {
                let sx = p.x, sy = p.y;
                if (swordDir === 'up') sy--;
                if (swordDir === 'down') sy++;
                if (swordDir === 'left') sx--;
                if (swordDir === 'right') sx++;
                if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
                    c.save();
                    c.translate(sx * S + S / 2, sy * S + S / 2);
                    if (swordDir === 'up') c.rotate(-Math.PI / 2);
                    if (swordDir === 'down') c.rotate(Math.PI / 2);
                    if (swordDir === 'left') c.rotate(Math.PI);
                    c.drawImage(assets.sword, -S / 2, -S / 2, S, S);
                    c.restore();
                }
            }
            document.getElementById('potions').textContent = p.potions;
            document.getElementById('health').textContent = Math.max(0, p.hp);
            needsRedraw = false;
        }

        function gameLoop(timestamp) {
            if (!map?.[0] || !p || !enemies || !rooms?.length) {
                console.error('Invalid state');
                initMap();
                needsRedraw = true;
            }
            if (!gameOver && !splashActive && timestamp - lastUpdate >= 60000) {
                fetchTxs();
                lastUpdate = timestamp;
            }
            if (!gameOver && !splashActive) {
                    sounds.music.play();
            } else {
                sounds.music.pause();
                sounds.music.currentTime = 0;
                document.getElementById('health').textContent = 0;
                needsRedraw = true;
            }            
            if (needsRedraw && !splashActive) draw();
            if (p.hp <= 0 && !gameOver) {
                p.hp = 0;
                logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                gameOver = true;
            }
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', e => {
            if (gameOver || splashActive) return;
            if (e.key === 'ArrowUp') move('up');
            if (e.key === 'ArrowDown') move('down');
            if (e.key === 'ArrowLeft') move('left');
            if (e.key === 'ArrowRight') move('right');
            if (e.key === 'a') attack();
            if (e.key === 'd') usePotion();
        });

        canvas.addEventListener('click', () => {
            if (gameOver && !document.getElementById('download-stats').contains(event.target)) restart();
        });
        document.getElementById('game-over').addEventListener('click', (event) => {
            if (gameOver && !document.getElementById('download-stats').contains(event.target)) {
                restart();
                }
        });
        document.getElementById('download-stats').addEventListener('click', downloadStats);


        initMap();
        fetchTxs();
        updateSatsDisplay();
        requestAnimationFrame(gameLoop);

// go to game-over screen at startup (DEBUG)
//function initGameOver() {
//    gameOver = true;
//    floor = 1; // Default floor for display
//    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
//    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
//    document.getElementById('game-over').style.display = 'block';
//    document.getElementById('download-stats').style.display = 'block';
//    updateSatsDisplay();
//    needsRedraw = true;
//    console.log('Initialized to game-over: gameOver=', gameOver);
//}
//
//initGameOver();
//requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
