<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self' https://noexxibndcooqjquhqzk.supabase.co/functions/v1/leaderboard https://mempool.space; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 10px; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: pan-x pan-y; /* Prevents pinch-to-zoom */
            -webkit-user-select: none; /* Prevents selection */
            -webkit-touch-callout: none; /* Disables iOS callouts */
        }
        /* Existing styles remain unchanged */
        #console { 
            background: #111;
            border: 4px solid #ff8c00;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            max-width: 800px;
            width: 100%;
            box-sizing: border-box;
        }
#whale-log { 
            width: 618px; 
            height: 24px; 
            overflow-y: auto;
            scroll-behavior: smooth; 
            background: #111; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator {color: var(--text-color, #ff8c00) !important;
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
#battle-log {
    width: 620px;
    margin-left: 20px; 
    background: transparent; 
    color: var(--text-color, #ff8c00) !important; 
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
    padding: 16px; 
    border: none; 
    font-size: 16px;
    z-index: 10;
    margin-top: -240px;
}

/* Soul Terminal Overlay */
#soul-terminal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 1000;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: 'VT323', monospace;
    color: #ff8c00;
}

#soul-terminal {
    width: 90%;
    max-width: 800px;
    height: 80%;
    background: rgba(17, 17, 17, 0.95);
    border: 4px solid #ff8c00;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#soul-terminal-header {
    color: #ff8c00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 24px;
    margin-bottom: 15px;
    text-align: center;
    padding-bottom: 10px;
    border-bottom: 2px solid #ff8c00;
}

#soul-terminal-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 10px;
    background: #111;
    border: 2px solid #ff8c00;
    margin-bottom: 15px;
    font-size: 16px;
    line-height: 1.4;
}

#soul-terminal-input-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

#soul-terminal-prompt {
    color: #ff8c00;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    font-size: 16px;
    white-space: nowrap;
}

#soul-terminal-input {
    flex-grow: 1;
    background: #ff8c00;
    color: #000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    font-weight: 900;
    outline: none;
    padding: 5px;
}

#soul-terminal-input:focus {
    outline: 1px solid #ff8c00;
    background: #ff8c00;
    color: #000;
}
/ Add this for the blur behavior /
#soul-terminal-input:not(:focus) {
    background: #ff8c00;
    color: #000;
}
#battle-log textarea {
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    resize: none;
    width: 100%;
    height: 200px;
    padding: 0;
    overflow-y: auto;
    scroll-behavior: smooth;
    z-index: 10;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.2s ease;
    transform: translateX(-100%);
    opacity: 0;
    /* Hide scrollbar */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}
#battle-log textarea:focus {
    outline: none !important;
}
#inventory { 
    position: absolute;
    top: 10px;
    right: -12px;
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    padding: 8px;
    z-index: 10;
    font-family: 'VT323', monospace;
    font-size: 20px;
    line-height: 1.5;
    width: 160px;
}
#inventory sup {
    vertical-align: super;
    font-size: 0.6em; /* Matches ™ size */
    text-shadow: none; /* Remove shadow for clarity */
}
/* Tighten line-height for Safari */
@media not all and (min-resolution: 0.001dpcm) { /* Targets Safari */
    #inventory {
        line-height: 1.0; /* Reduce line-height by ~50% */
    }
}
	#floor-indicator { 
    	    position: absolute; 
    	    top: 11px; 
	    left: 10px; 
	    background: transparent; 
	    color: var(--text-color, #ff8c00) !important; 
	    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
	    padding: 8px; 
	    z-index: 10; 
	    font-family: 'VT323', monospace;
	    font-size: clamp(21px, 5.33vw, 32px);
	    line-height: 1.2; / Prevents squishing /
	}
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
            grid-area: t;
            z-index: 40;
            border-radius: 5%;
        }
        #left { 
            grid-area: l;
            z-index: 40;
            border-radius: 5%;
        }
        #right { 
            grid-area: r;
            z-index: 40; 
            border-radius: 5%;
        }
        #down { 
            grid-area: b;
            z-index: 40;
            border-radius: 5%;
        }
        #actions { 
            display: flex; 
            gap: 5px; 
            align-items: center; 
        }
button {
    background-color: transparent;
    border: 1px solid #ff8c00;
    color: #ff8c00;
    padding: 8px;
    border: 0px solid #000;
    cursor: pointer;
    font-size: 14px;
    width: 40px;
    height: 40px;
    box-sizing: border-box;
    transition: none; /* Prevent any transitions */
}
button:hover {
    background: rgba(224, 123, 0, 0.5);
    transition: background 0.1s ease; /* Smooth hover effect */
}
        #mute {
            padding: 0px;
            border-radius: 25%;
            height: 20px;
            width: 30px;
            background: #fff;
            color: #000;
            margin-right: 50px;
            z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #attack, #potion {
            margin-right: 20px;
            background: #ff8c00;
            color: #fff;
            height: 50px;
            width: 50px; 
            border-radius: 50%;
        }
        #attack:hover, #potion:hover {
            background: #e07b00;
        }
        #start-button {
            position: absolute;
            top: 75%;
            left: 50%;
            width: 120px;
            height: 50px;
            transform: translate(-50%, -50%);
            background: #00e8d8;
            color: #fff;
            border: none;
            padding: 0px 20px;
            font-family: 'VT323', monospace;
            font-size: 42px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 40;
        }
        #start-button:hover {
            background: #00b7ef;
        }
#dpad button {
    -webkit-tap-highlight-color: transparent; /* Remove browser default highlight */
    touch-action: none; /* Prevent browser touch interference */
    user-select: none; /* Prevent text selection */
    background: transparent; /* Default background */
    transition: background 0.1s ease-out; /* Brief flash for press */
}

#dpad button:active {
    background: rgba(224, 123, 0, 0.7); /* Orange flash on press */
}
#dpad button.pressed {
    background: rgba(224, 123, 0, 0.2); /* Subtle feedback for held state */
}

#submit-score, #view-leaderboard, #restart-game {
    background: #ff8c00;
    color: #fff;
    border: none;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 18px;
    cursor: pointer;
    border-radius: 5px;
    width: 120px; /* Keep for view-leaderboard and restart-game */
    height: 40px;
    z-index: 40;
}
#submit-score {
    width: 220px; /* Almost doubled from 120px */
}

#submit-score:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
}

#leaderboard-output {
    position: absolute;
    top: 0px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #ff8c00;
    border: 2px solid #ff8c00;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    width: 640px;
    max-width: 100%;
    text-align: left;
    white-space: pre;
    line-height: 1.2;
    box-sizing: border-box;
    word-break: break-word; /* Handle long text */
}

#sats-calc {
    display: block;          /* line‑break */
    color: var(--text-color);   /* inherits the theme colour */
}

    /* Windows 95 Screensaver Styles */
#screensaver-overlay { position: fixed; inset: 0; z-index: 99999; background: black; display: none; }   
#screensaver-canvas { position: absolute; top:0; left:0; width:100%; height:100%; display:block; }
    
.star {
    position: absolute;
    background-color: #ff8c00; /* Windows 95 orange */
    border-radius: 50%;
    box-shadow: 0 0 10px #ff8c00, 0 0 20px #ff8c00;
    /* Add these new properties for better visual effect */
    filter: blur(0.5px);
    animation: pulse 2s infinite alternate;
}

@keyframes pulse {
    0% { opacity: 0.7; }
    100% { opacity: 1; }
}
    
/* Phones (320px–767px) */
@media only screen and (min-width: 320px) and (max-width: 767px) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 9px;
    }
    #whale-hash-ids {
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 9px;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: 8px;
        height: 110px;
        font-size: 10px; /* Match font-size for consistency */
    }
    #inventory {
        width: 100px;
        font-size: 12px;
        line-height: 1.5;
        margin-right: 2px;
    }
    #floor-indicator {
        font-size: clamp(16px, 4.67vw, 24px);
    }
    button {
        width: 55px;
        height: 55px;
        font-size: 12px;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 40px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: -10px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 0px;
        margin-left: -15px;
        margin-top: 60px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 0px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 0px;
                margin-left: 20px;
        background: #ff8c00;
        height: 35px;
        width: 35px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }
    
    #submit-score, #view-leaderboard, #restart-game {
        width: 80px; /* Keep for view-leaderboard and restart-game */
        height: 30px;
        font-size: 16px;
    }
    #submit-score {
        width: 160px; /* Doubled from 80px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 14px;
}
    #leaderboard-output {
        top: -12px;
        width: 100%;
        max-width: 640px;
        font-size: 12px;
        max-height: 160px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}

/* Tablets (768px–1024px, high pixel ratio) */
@media only screen and (min-width: 768px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
        max-width: 640px;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 1.2rem;
    }
    #whale-hash-ids {
        font-size: 1.2rem;
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 1.2rem;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: -60px;
        height: 156px;
        font-size: 1.2rem;
    }
    #inventory {
        width: 170px;
        font-size: 1.4rem;
        line-height: 1.5;
        margin-right: 20px;
    }
    #floor-indicator {
        font-size: clamp(24px, 4.67vw, 37px);
    }
    button {
        width: 65px;
        height: 65px;
        font-size: 1.2rem;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 120px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: 20px;
        margin-top: -50px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 24px;
        width: 24px;
        background: #fff;
        color: #000;
        margin-right: 80px;
        margin-left: -15px;
        margin-top: 45px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 5px;
        background: #ff8c00;
        height: 65px;
        width: 65px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 5px;
        margin-left: 20px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }

    #submit-score, #view-leaderboard, #restart-game {
        width: 100px; /* Keep for view-leaderboard and restart-game */
        height: 48px;
        font-size: 18px;
    }
    #submit-score {
        width: 200px; /* Doubled from 100px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 16px;
}
    #leaderboard-output {
        top: 0px;
        width: 100%;
        max-width: 640px;
        font-size: 14px;
        max-height: 200px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}
</style>
</head>
<body>
    <div id="console">
        <div id="whale-log">
            <div id="whale-hash-ids">Whale Transactions:</div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
    		<canvas id="splash-canvas" width="320" height="320"></canvas>
    	    <button id="start-button">START</button>
    	    <div id="info-icon" onclick="showInfo()" style="position: absolute; top: 50px; right: 20px; width: 30px; height: 30px; background: #00e8d8; color: #fff; border: 3px solid #ff8c00; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-family: 'VT323', monospace; font-size: 24px; cursor: pointer; z-index: 50;">i</div>
    	    <!-- Add info message display -->
<div id="info-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 20px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; display: none; z-index: 60; max-width: 80vw; border-radius: 5px;">
    Hey listen! ;)<br><br>
    If you are using a Gamepad, connect it after you have pressed the START button on the screen.
</div>
	    </div>
<div id="game-over">
    <pre id="leaderboard-output"></pre>
    <canvas id="game-over-canvas" width="320" height="320"></canvas>
    <div style="position: absolute; top: 60%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px;"> <!-- Increased gap from 10px to 15px -->
        <input id="username-input" type="text" placeholder="Enter Username" maxlength="20" list="name-list" style="background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 8px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; width: 200px;">
<datalist id="name-list"></datalist>
        <button id="submit-score" onclick="submitScore()">Submit Score</button>
        <button id="view-leaderboard" onclick="fetchLeaderboard()">Leaderboard</button>
        <button id="restart-game" onclick="restart()">Restart</button>
    </div>
</div>
            <div id="floor-indicator">Floor 1</div>
<div id="inventory" style="-webkit-nbsp-mode: normal;">
    <span id="wave" style="display: none;">1</span>
    Health: <span id="health">24</span><br>
    Armor: <span id="armorStatus">Leather</span><br>
    Potions: <span id="potions">0</span><br>
    <span id="pickaxes" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    Floor x Bag: <span id="sats" style="display: none;">0</span>
    <span id="sats-calc" class="calc"></span>
    <span id="diamonds" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    <span id="perfectlyCutDiamonds" style="display: none;">0</span><br> <!-- moved to soul terminal -->
    <span id="runes" style="display: none;">None</span><br> <!-- moved to soul terminal -->
    <span id="resonance" style="display: none;">0%</span><br>
</div>
        </div>
<div id="battle-log">
    <textarea id="battle-events" readonly tabindex="-1">Battle Log:</textarea>
</div>

<!-- Soul Terminal Overlay -->
<div id="soul-terminal-overlay">
    <div id="soul-terminal">
        <div id="soul-terminal-header">BTC-DUNGEON</div>
        <div id="soul-terminal-content"></div>
        <div id="soul-terminal-input-container">
            <span id="soul-terminal-prompt">soul@terminal:~$ </span>
            <input type="text" id="soul-terminal-input" autocomplete="off" spellcheck="false">
        </div>
    </div>
</div>
<div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">↑</button>
                <button id="left" onclick="move('left')">←</button>
                <button id="right" onclick="move('right')">→</button>
                <button id="down" onclick="move('down')">↓</button>
            </div>
<div id="actions">
                <button id="mute" onclick="toggleMute()">♪</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.10.0/dist/axios.min.js"></script>
    <script>

const names = [
    "Alan-Soul",
    "Alex-Cipher",
    "Amanda-Quest",
    "Amy-Crypt",
    "Andrea-Haze",
    "Andrew-Fury",
    "Angela-Shade",
    "Ann-Shadow",
    "Anthony-Smog",
    "Arthur-Sky",
    "Ashley-Guild",
    "Azeroth-Blade",
    "Barbara-Storm",
    "Benjamin-Bolt",
    "Blaise-Crypt",
    "Brian-Block",
    "Brother-Void",
    "Bruce-Ice",
    "Carl-Fissure",
    "Catherine-Dark",
    "Charles-Claw",
    "Cheryl-Vine",
    "Christina-Spark",
    "Christopher-Blade",
    "Cindy-Breath",
    "Craig-Mark",
    "Crystal-Gale",
    "Cynthia-Frost",
    "Daniel-Hex",
    "David-Rune",
    "Deborah-Spear",
    "Dennis-Pulse",
    "Diane-Blood",
    "Donald-Ward",
    "Donna-Slash",
    "Edward-Blaze",
    "Elizabeth-Fog",
    "Emily-Dusk",
    "Eric-Iron",
    "Eugene-Dream",
    "Father-Rune",
    "Frank-Tide",
    "Gary-Grip",
    "George-Drift",
    "Gerden-Skull",
    "Gregory-Doom",
    "Heather-Knight",
    "Helen-Fire",
    "Howard-Wild",
    "James-Miner",
    "Jane-Trace",
    "Janet-Spine",
    "Jason-Void",
    "Jeffrey-Glare",
    "Jennifer-Vault",
    "Jeremy-Rage",
    "Jessica-Hash",
    "Joan-Tempest",
    "John-Flame",
    "Jonathan-Mist",
    "Joseph-Nexus",
    "Joshua-Coin",
    "Judith-Shock",
    "Julie-Fade",
    "Karen-Fell",
    "Kathleen-Howl",
    "Kelly-Wind",
    "Kenneth-Glow",
    "Kevin-Wisp",
    "Kimberly-Grim",
    "Kristin-Curse",
    "Larry-Vortex",
    "Laura-Veil",
    "Lauren-Bane",
    "Linda-Dawn",
    "Lisa-Torch",
    "Lori-Swarm",
    "Maria-Crag",
    "Mark-Wraith",
    "Mary-Raven",
    "Matt-Dread",
    "Matthew-Shard",
    "Megan-Sword",
    "Melissa-Cipher",
    "Michael-Chain",
    "Michelle-Viper",
    "Mother-Wraith",
    "Nancy-Byte",
    "Nathan-Bind",
    "Nicole-Rift",
    "Pamela-Node",
    "Patrich-Hex",
    "Patrick-Maze",
    "Paul-Hawk",
    "Philip-Wave",
    "Ponyo-Shard",
    "Rachel-Fang",
    "Randy-Clash",
    "Rebecca-Dust",
    "Richard-Lore",
    "Robert-Skull",
    "Roger-Light",
    "Ronald-Guard",
    "Ruth-Vow",
    "Ryan-Crow",
    "Sarah-Ledger",
    "Satoshi-Chain",
    "Scott-Ghost",
    "Sharon-Chill",
    "Shawn-Trail",
    "Sister-Gloom",
    "Solan-Fury",
    "Stephanie-Talon",
    "Steve-Burst",
    "Steven-Pool",
    "Susan-Thorn",
    "Terry-Edge",
    "Theresa-Stone",
    "Thomas-Gloom",
    "Tiffany-Flux",
    "Timothy-Night",
    "Tina-Fall",
    "Todd-Rush",
    "Tony-Realm",
    "Tracy-Wolf",
    "Victoria-Seer",
    "Walter-Hunt",
    "William-Dagger"
];

const uniqueMonsterNames = {
    'Shrimp': ['Fire-Shrimp', 'Gray-Shrimp', 'Gut-Shrimp', 'Sharp-Shrimp', 'Sin-Shrimp', 'Blaze-Shrimp', 'Spirit-Shrimp', 'Steel-Shrimp', 'Storm-Shrimp', 'Viper-Shrimp'],
    'Crab': ['Blade-Crab', 'Death-Crab', 'Gloom-Crab', 'Mind-Crab', 'Ooze-Crab', 'Pit-Crab', 'Rust-Crab', 'Vile-Crab', 'Wind-Crab', 'Thunder-Crab'],
    'Squid': ['Chaos-Squid', 'Cold-Squid', 'Dire-Squid', 'Dragon-Squid', 'Gore-Squid', 'Mold-Squid', 'Puke-Squid', 'Soul-Squid', 'Warp-Squid', 'Frost-Squid'],
    'Dolphin': ['Black-Dolphin', 'Blight-Dolphin', 'Demon-Dolphin', 'Dread-Dolphin', 'Flesh-Dolphin', 'Night-Dolphin', 'Seethe-Dolphin', 'Snot-Dolphin', 'Wrath-Dolphin', 'Venom-Dolphin'],
    'Shark': ['Bile-Shark', 'Bone-Shark', 'Doom-Shark', 'Grief-Shark', 'Moon-Shark', 'Plague-Shark', 'Pox-Shark', 'Shadow-Shark', 'Sharp-Shark', 'Bolt-Shark'],
    'Whale': ['Ash-Whale', 'Bane-Whale', 'Blood-Whale', 'Fester-Whale', 'Foul-Whale', 'Haze-Whale', 'Rot-Whale', 'Spine-Whale', 'Star-Whale', 'Inferno-Whale']
};

// Show info message
function showInfo() {
    const infoMessage = document.getElementById('info-message');
    infoMessage.style.display = 'block';
    
    // Switch to info.png
    currentSplashImage = 'info.png';
    splashCanvas.clearRect(0, 0, 320, 320);
    splashImg.src = currentSplashImage;
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    
    setTimeout(() => {
        infoMessage.style.display = 'none';
    }, 5000); // Auto-hide after 5 seconds
}

function populateNameList() {
    const datalist = document.getElementById('name-list');
    datalist.innerHTML = ''; // Clear existing options
    names.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        datalist.appendChild(option);
    });
}

function levenshtein(a, b) {
    const matrix = Array(b.length + 1).fill().map(() => Array(a.length + 1).fill(0));
    for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
    for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
            matrix[j][i] = Math.min(
                matrix[j-1][i] + 1,
                matrix[j][i-1] + 1,
                matrix[j-1][i-1] + (a[i-1].toLowerCase() === b[j-1].toLowerCase() ? 0 : 1)
            );
        }
    }
    return matrix[b.length][a.length];
}

// Enhanced name matching function
function findClosestName(input, nameList) {
    const inputLower = input.toLowerCase();
    
    // First, try exact prefix match (case-insensitive)
    const exactPrefixMatch = nameList.find(name => 
        name.toLowerCase().startsWith(inputLower)
    );
    if (exactPrefixMatch) return exactPrefixMatch;
    
    // Then, try partial match (substring anywhere in the name)
    const partialMatch = nameList.find(name => 
        name.toLowerCase().includes(inputLower)
    );
    if (partialMatch) return partialMatch;
    
    // If no prefix or partial match, use Levenshtein distance
    let minDistance = Infinity;
    let closestName = input; // Default to input if no close match
    
    for (const name of nameList) {
        const distance = levenshtein(inputLower, name.toLowerCase());
        if (distance < minDistance) {
            minDistance = distance;
            closestName = name;
        }
    }
    
    // Only use Levenshtein match if distance is reasonably small
    // Adjust threshold as needed - 3 seems good for most cases
    if (minDistance <= 3) {
        return closestName;
    }
    
    return input; // Return original if no good match found
}

/**
 * Calculates the score that will be sent to the leaderboard.
 *  • `floor` is the current floor number.
 *  • The multiplier is `floor / 100`.
 *  • The extra amount is `floor / 100` of the raw satoshis.
 *
 * Example: floor = 45, raw = 14000 BTC
 *   multiplier = 45 / 100 = 0.45
 *   extra      = 14000 * 0.45 = 6300
 *   finalScore = 14000 + 6300 = 20300
 */
function getScoreWithMultiplier(rawScore, currentFloor) {
    const multiplier = currentFloor / 100;          // 0.45 for floor 45
    const added = Math.floor(rawScore * multiplier);
    return rawScore + added;                       // 20300 in the example
}

// Modified submitScore function with nearest name matching and random fallback
async function submitScore() {
    if (!gameOver) return;
    if (scoreSubmitted) {
        document.getElementById('leaderboard-output').textContent = 'Score already submitted for this game!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: already submitted');
        return;
    }
    if (floor < 3) {
        document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: floor=', floor, '< 3');
        return;
    }
    let username = document.getElementById('username-input').value.trim();
    if (!username) {
        // Select random name if input is empty
        username = names[Math.floor(Math.random() * names.length)];
        console.log(`Empty username, selected random name: '${username}'`);
    } else if (!names.includes(username)) {
        // Find the closest matching name using enhanced algorithm
        const closestName = findClosestName(username, names);
        
        // Check if we found a match and it's different from input
        if (closestName !== username && closestName.toLowerCase() !== username.toLowerCase()) {
            console.log(`Username '${username}' matched to '${closestName}'`);
            username = closestName;
        } else {
            // Select random name if no good match found
            username = names[Math.floor(Math.random() * names.length)];
            console.log(`Username '${username}' not matched, selected random name: '${username}'`);
        }
    }
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    // NEW: calculate the leaderboard score with the floor multiplier
    const leaderboardScore = getScoreWithMultiplier(totalSats, floor);
    try {
    const response = await fetch(`${API_URL}?action=submit`, {
        method: 'POST',
        headers,
        // send the multiplied score
        body: JSON.stringify({ username, score: leaderboardScore, floor })
    });
      if (response.status === 429) {
        console.error('Rate limit exceeded for submitting scores');
        return;
      }
      if (!response.ok) {
        console.error(`POST Status: ${response.status}, Response: ${await response.text()}`);
        return;
      }
        const text = await response.text();
        console.log(`POST Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : {};
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok) {
            scoreSubmitted = true;
            document.getElementById('submit-score').disabled = true;
            document.getElementById('submit-score').style.background = '#666';
            document.getElementById('leaderboard-output').textContent = `Score submitted: ${username}, ${leaderboardScore} sats (Floor ${floor})`;
            document.getElementById('leaderboard-output').style.display = 'block';
            
            await fetchLeaderboard(username, leaderboardScore, floor);
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
            if (response.status === 400 && text.includes('new row violates row-level security policy')) {
                document.getElementById('leaderboard-output').textContent = 'Submission blocked: Must reach at least Floor 3!';
            }
            document.getElementById('leaderboard-output').style.display = 'block';
        }
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

// Generate or retrieve session ID
  function generateSessionId() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  const sessionId = localStorage.getItem('sessionId') || generateSessionId();
  localStorage.setItem('sessionId', sessionId);

const API_URL = 'https://noexxibndcooqjquhqzk.supabase.co/functions/v1/leaderboard';
  const headers = {
    'Content-Type': 'application/json',
    'X-Session-ID': sessionId
  };


async function fetchLeaderboard(submittedUsername = null, submittedScore = null, submittedFloor = null) {
    try {
      const leaderboardResponse = await fetch(`${API_URL}?action=fetch&limit=10`, {
        method: 'GET',
        headers
      });
      if (leaderboardResponse.status === 429) {
        console.error('Rate limit exceeded for fetching leaderboard');
        document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching leaderboard';
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
      }
      if (!leaderboardResponse.ok) {
        const errorText = await leaderboardResponse.text();
        console.error(`GET Status: ${leaderboardResponse.status}, Response: ${errorText}`);
        document.getElementById('leaderboard-output').textContent = `Error: ${leaderboardResponse.status} ${errorText}`;
        document.getElementById('leaderboard-output').style.display = 'block';
        return;
      }
      const text = await leaderboardResponse.text();
      console.log(`GET Status: ${leaderboardResponse.status}, Response: ${text}`);
      let data;
      try {
        data = text ? JSON.parse(text) : [];
      } catch (e) {
        data = { raw: text };
      }
      if (leaderboardResponse.ok && Array.isArray(data)) {
    // Cache the raw data
    localStorage.setItem('leaderboardData', JSON.stringify(data));
    cachedLeaderboard = data;
        let playerInTop10 = submittedUsername ? data.some(entry => entry.username === submittedUsername && entry.score === submittedScore && entry.floor === submittedFloor) : false;
        let playerEntry = null;
        let playerRank = null;

        // Fetch player's score and rank if not in top 10 and floor >= 3
        if (submittedUsername && !playerInTop10 && submittedFloor >= 3) {
          try {
            const playerResponse = await fetch(
              `${API_URL}?action=fetchPlayer&username=${encodeURIComponent(submittedUsername)}&score=${submittedScore}&floor=${submittedFloor}`,
              { method: 'GET', headers }
            );
            if (playerResponse.status === 429) {
              console.error('Rate limit exceeded for fetching player');
              document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching player';
              document.getElementById('leaderboard-output').style.display = 'block';
              return;
            }
            if (!playerResponse.ok) {
              console.error(`GET Status: ${playerResponse.status}, Response: ${await playerResponse.text()}`);
              return;
            }
            const playerData = await playerResponse.json();
            if (playerResponse.ok && playerData.length > 0) {
              playerEntry = playerData[0];
              const rankResponse = await fetch(`${API_URL}?action=fetchRank&score=${submittedScore}`, {
                method: 'GET',
                headers
              });
              if (rankResponse.status === 429) {
                console.error('Rate limit exceeded for fetching rank');
                document.getElementById('leaderboard-output').textContent = 'Rate limit exceeded for fetching rank';
                document.getElementById('leaderboard-output').style.display = 'block';
                return;
              }
              if (!rankResponse.ok) {
                console.error(`GET Status: ${rankResponse.status}, Response: ${await rankResponse.text()}`);
                return;
              }
              const rankData = await rankResponse.json();
              if (rankResponse.ok) {
                playerRank = rankData.length + 1;
              }
            }
          } catch (e) {
            console.error('Error fetching player score or rank:', e);
          }
        }

        // Format leaderboard
        const maxUsernameLength = 20;
        const scoreWidth = 14;
        const numberWidth = 10;
        const floorWidth = 6;
        const header = `Rank  Username               Score         Floor`;
        let rows = data.map((entry, index) => {
          const rank = (index + 1).toString().padStart(2, '0');
          const username = entry.username.length > maxUsernameLength
            ? entry.username.substring(0, maxUsernameLength - 2) + '..'
            : entry.username.padEnd(maxUsernameLength);
          const scoreValue = entry.score;
          let numberPart, unitPart;
          if (scoreValue >= 1e8) {
            numberPart = (scoreValue / 1e8).toFixed(1);
            unitPart = 'BTC';
          } else {
            numberPart = scoreValue.toString();
            unitPart = 'sats';
          }
          const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
          const score = scoreDisplay.padEnd(scoreWidth);
          const floor = entry.floor.toString().padStart(floorWidth);
          return `${rank}    ${username}${score}${floor}`;
        });

        // Replace or append player's entry with actual rank if not in top 10
        if (playerEntry && !playerInTop10 && playerRank) {
          const username = playerEntry.username.length > maxUsernameLength
            ? playerEntry.username.substring(0, maxUsernameLength - 2) + '..'
            : playerEntry.username.padEnd(maxUsernameLength);
          const scoreValue = playerEntry.score;
          let numberPart, unitPart;
          if (scoreValue >= 1e8) {
            numberPart = (scoreValue / 1e8).toFixed(1);
            unitPart = 'BTC';
          } else {
            numberPart = scoreValue.toString();
            unitPart = 'sats';
          }
          const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
          const score = scoreDisplay.padEnd(scoreWidth);
          const floor = playerEntry.floor.toString().padStart(floorWidth);
          const playerRow = `${playerRank.toString().padStart(2, '0')}    ${username}${score}${floor}`;
          if (rows.length >= 10) {
            rows[9] = playerRow; // Replace 10th entry
          } else {
            rows.push(playerRow); // Append if fewer than 10 entries
          }
        }

        const leaderboardText = `${header}\n${rows.join('\n') || 'No entries yet!'}`;
        document.getElementById('leaderboard-output').textContent = leaderboardText;
      } else {
        document.getElementById('leaderboard-output').textContent = `Error: ${leaderboardResponse.status} ${JSON.stringify(data, null, 2)}`;
      }
      document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
      document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
      console.error('Fetch leaderboard error:', error);
      document.getElementById('leaderboard-output').style.display = 'block';
    }
  }

// Get player's estimated rank/score for cached leaderboard
function getPlayerEstimatedRank(cachedData, playerSats, playerFloor) {
    const playerScore = getScoreWithMultiplier(playerSats, playerFloor);
    let rank = 1;
    for (const entry of cachedData) {
        const entryScore = getScoreWithMultiplier(entry.score, entry.floor); // Recompute for fairness
        if (playerScore > entryScore) break;
        rank++;
    }
    return { score: playerScore, rank, floor: playerFloor };
}

document.getElementById('username-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameOver) {
        e.preventDefault(); // Prevent any default behavior
        e.stopPropagation(); // Stop event propagation to prevent restart
        submitScore(); // Trigger score submission
    }
});

// Also add blur handler to prevent touch keyboard from triggering restart
document.getElementById('username-input').addEventListener('blur', function() {
    // Allow a short delay before re-enabling game controls
    setTimeout(() => {
        // Re-enable game controls if needed
    }, 100);
});

// Prevent pinch-to-zoom and double-tap zoom
document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gestureend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });

const canvas = document.getElementById('game');
let touchMoveInterval = null; // Global variable for continuous touch movement
let touchTimeout = null; // Global variable for touch timeout
let dpadButtons = document.querySelectorAll('#dpad button');
let actionsButtons = document.querySelectorAll('#actions button');

// Touch handlers for #actions buttons
document.querySelectorAll('#actions button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.add('pressed');
        if (button.id === 'mute') toggleMute();
        else if (button.id === 'attack') attack();
        else if (button.id === 'potion') usePotion();
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed');
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault();
    }, { passive: false });
});

const c = canvas.getContext('2d');
const W = 20, H = 20, S = 16;
let currentTheme = 'dungeon'; // Default theme
const themes = ['dungeon', 'desert', 'paradise', 'hell', 'ruins'];
let initialWaveSpawned = false; // Track if initial wave has spawned

function selectNewTheme(current) {
    const available = themes.filter(t => t !== current);
    return available[Math.floor(Math.random() * available.length)];
}

function patchStaticCanvas(x, y) {
    if (!puzzleStaticCtx) return;
    puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, x * S, y * S, S, S);
}

let isFetchingTxs = false; // Track if fetchTxs is currently running
let savedPauseState = null; // remembers pause button state before screensaver
let currentRuneTile = null; // Track current rune tile position
let highlightTiles = [];
let activatedRunewords = [];
let lastDrawTime = null;
let frameCount = 0;  // Add this line
let borderLastUpdate = null;
let activeUniqueMonsterName = null;
let enemyBgFrameTimes = new Map(); // Track per-enemy bg animation start time
let shrinePositions = [];
let auraHitStartTime = 0; // New: Track aura hit flash start
let auraFlashDuration = 300; // New: Flash duration in ms

let puzzlePreviousTheme = null;  // remembers theme before entering puzzle portal
let currentThemeBlock = null;  // 'hell_normal' or 'hell_snowy' for the current 3-floor block
let puzzleCurrentLayout = null;  // ← ADD THIS

let spearHitShakeStart = 0;     // ← ADD THIS LINE
let spearHitShakeIntensity = 0;

// ─────── ZOOM SYSTEM ───────
let zoomEnabled = false; // Default: no zoom
let minimapVisible = false;

// Respect saved user preference first
if (localStorage.getItem('zoomEnabled') === 'true') {
    zoomEnabled = true;
} else if (localStorage.getItem('zoomEnabled') === 'false') {
    zoomEnabled = false;
}
// Auto-enable zoom ONLY on phones (small screens + touch), if no preference saved
else if (window.innerWidth <= 767 && (navigator.maxTouchPoints > 0 || 'ontouchstart' in window)) {
    zoomEnabled = true;
}

// Final sync
minimapVisible = zoomEnabled;

let camera = { x: 0, y: 0 };
let stairsArrow = null;           // {dx,dy} when stairs are off-screen

camera.velocityX = 0;
camera.velocityY = 0;
camera.lastDeltaX = 0;
camera.lastDeltaY = 0;

let puzzleStaticCanvas = null;
let puzzleStaticCtx = null;

let map = [],
p = {
x: 2,
y: 2,
currentX: 32,  // S * x
currentY: 32,  // S * y
moving: false,
stepsLeft: 0,
deltaX: 0,
deltaY: 0,
targetTileX: 0,
targetTileY: 0,
hp: 36,
maxHP: 36,  // Initialize maxHP to match starting hp
potions: 0,
atk: 2,
pickaxes: 0,
hasArmor: true,
hasDiamondArmor: false, // Track diamond armor
perfectlyCutDiamonds: 0, // Track perfectly cut diamonds
runes: [], // Array to store collected rune letters (e.g., ['a','b','c'])
runewords: [], // Array to store activated runewords (e.g., ['btc', 'hodl'])
immortal: false, // Flag for HODL runeword immortality
ripBlast: false, // Flag for RIP runeword blast
isFalling: false, // Flag to track if the player is currently animating
anim: {
    frames: {
        front: [new Image(), new Image()],
        back: [new Image(), new Image()],
        right: [new Image(), new Image()],
        armor_front: [new Image(), new Image()],
        armor_back: [new Image(), new Image()],
        armor_right: [new Image(), new Image()],
        diamond_armor_front: [new Image(), new Image()],
        diamond_armor_back: [new Image(), new Image()],
        diamond_armor_right: [new Image(), new Image()],
        fall: [new Image(), new Image(), new Image()],
    },
    direction: 'front',
    frameIndex: 0,
    lastFrameTime: 0,
    frameDuration: 400  // Doubled for half speed
},
// Add shrine charge tracking
shrineCharges: 0,
maxShrineCharges: 24,
shrineUsedThisFloor: false, // Track if shrine was used on this floor

// Add soul system properties
soulStones: 0,
soulShards: 0,
soulOrbs: 0,
soulStormCharges: 256, // Track how many charges we have (max 256)
soulStormCharges: 256,
currentWeapon: 'sword', // 'sword | soul_sword | satoshi_scourge | etc ..
echoWardenBlessingGiven: false,

farmLocked: false,
farmLockedFloor: 0,
farmLockedSats: 0,

inSoulTerminal: false, // Track if player is in soul terminal
soulTerminalCommand: '', // Current command input
soulTerminalCursorPos: 0, // Cursor position in command
soulTerminalActive: false, // Whether soul terminal is currently open
// Add diamond hand properties
hasDiamondHand: false, // Track if player has diamond hand
moveCounter: 0,
auraMoveCounter: 0,
lastAuraRefillMove: 0,  // New: Track last refill to throttle
// Add elemental immunity
elementImmunity: null, // Store the player's elemental immunity
armorImmunity: null, // Store armor's elemental immunity
},
    enemies = [], 
    rooms = [];
    dangerousAreas = []; // Track dangerous spell areas
    diamonds = 0;          // total diamonds collected in the current run
    let themeTimeoutId = null;   // <‑‑ new
    
// Load animation frames
p.anim.frames.front[0].src = 'player-front1.png';
p.anim.frames.front[1].src = 'player-front2.png';
p.anim.frames.back[0].src = 'player-back1.png';
p.anim.frames.back[1].src = 'player-back2.png';
p.anim.frames.right[0].src = 'player-right1.png';
p.anim.frames.right[1].src = 'player-right2.png';
p.anim.frames.armor_front[0].src = 'player_armor-front1.png';
p.anim.frames.armor_front[1].src = 'player_armor-front2.png';
p.anim.frames.armor_back[0].src = 'player_armor-back1.png';
p.anim.frames.armor_back[1].src = 'player_armor-back2.png';
p.anim.frames.armor_right[0].src = 'player_armor-right1.png';
p.anim.frames.armor_right[1].src = 'player_armor-right2.png';

// player is affected during theme "Ruins"
p.anim.frames.fall[0].src = 'player_fall1.png';
p.anim.frames.fall[1].src = 'player_fall2.png';
p.anim.frames.fall[2].src = 'player_fall3.png';
p.anim.frames.fall.forEach((frame, i) => {
    frame.onerror = () => console.error(`Failed to load fall frame ${i}: ${frame.src}`);
});

let floor = 1, wave = 1, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
let previousFloorState = null; // Store state before entering hideout
let inHideout = false; // Track if player is in hideout
let jewellerPos = null; // Track jeweller position
let blacksmithPos = null; // Track blacksmith position
let waypointPos = null; // Track waypoint position
let scoreSubmitted = false; // Tracks if score has been submitted
let gameOverBPressed = false;
let cachedLeaderboard = null; // Store fetched leaderboard
let whaleHashIds = ['Whale Transactions:'], battleLog = [], killsLog = [];
let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let soulResonance = 0; // 0-100%, +1 per floor, maxed triggers resurrection
let resonanceTriggeredThisRun = false; // One-time per run
let wardenFlashStart = 0; // Timestamp for 500ms invert flash
let wisps = []; // Array for active wisps (max 1)
let wispPromptTimeout = null; // Timer for floor text prompt
let deadWispCorpse = null; // {x, y, frameIndex, fadeStart: timestamp}
let staticWispDangerSpoken = false;
let wispIsSpeaking = false;
let spellPulseTimer = 0;        // ← add this line
let spellHarassTimer = 0;   // ← add this line
let spellPulseInterval = 0;     // ← and this one
let echoWardenPos = null; // Track warden position for draw
let satoshiDrops = [];
let runeDrops = []; // Array to store rune drops with positions and letters
let scrollDrops = []; // Array to store scroll drops with positions
let portals = []; // Array to store active portal positions and animation state
let splashActive = true;
let waveActive = false;
let musicMuted = localStorage.getItem('musicMuted') === 'true';
      
let swordDir = 'right', swordActive = false, swordStart = 0;
let gameOverSoundPlayed = false;
let fogMap = [];
let battleLogTimeout = null;
let projectiles = [];
let snowflakes = [];
let snowyHellActive = false;        // master switch
let snowyHellToggleFloor = 0;       // for slow random toggles
let autoSubmitTriggered = false;
let inputBlocked = false;
let soulStashPos = null; // Position of soul stash on current floor

let catPos = null; // {x, y}
let catVisible = false; // Fade in/out
let catAnimStart = 0; // Timestamp for fade cycle

let soulTerminalActive = false; // Whether soul terminal is currently open
let soulTerminalCommand = ''; // Current command input
let soulTerminalCursorPos = 0; // Cursor position in command

// Puzzle Room System (v2 — proper L2 style)
let inPuzzleRoom = false;
let puzzleHazards = [];      // {x,y,type} — lava, water, quicksand
let puzzleArrows = [];       // {x,y,dir} — 'up','down','left','right'
let puzzleBoulders = [];     // {x,y}
let puzzleHeartFramers = []; // array of {x,y} — collect ALL to open chest
let puzzleChest = null;      // {x,y}

let farmSpot = null;

let puzzleReturnPos = null;
let puzzleTheme = 'hell';    // hell, desert, paradise

const specialSoundsPlayedThisFloor = {
    lava: false,
    quicksand: false,
    pond: false,
    rune: false,
    hole: false
};

class EnemyType {
    constructor(name, min, max, hp, atk, move, reward = 0) {
        this.name = name;
        this.min = min;
        this.max = max;
        this.hp = hp;
        this.atk = atk;
        this.move = move;
        this.reward = reward;
        this.anim = {
            frames: [new Image(), new Image(), new Image()],
            hellFrames: [new Image(), new Image(), new Image()],
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 400  // Doubled for half speed
        };
    }
}

// Spell types for unique monsters
const SPELL_TYPES = {
    FIRE_WALL: 'Fire Wall',
    LIGHTNING_STORM: 'Lightning Storm',
    FROST_NOVA: 'Frost Nova',
    POISON_CLOUD: 'Poison Cloud'
};

const types = [
    new EnemyType('Shrimp', 0, 0.01, 2, 1, 1),
    new EnemyType('Crab', 0.01, 0.1, 3, 2, 1),
    new EnemyType('Squid', 0.1, 1, 4, 2, 2),
    new EnemyType('Dolphin', 1, 10, 4, 3, 2),
    new EnemyType('Shark', 10, 100, 5, 5, 2),
    new EnemyType('Whale', 100, Infinity, 6, 4, 2)
];

// Wisp types (companion spells)
const WISP_TYPES = [
    { name: 'cold', damage: 0, range: 3, aoe: 'medium', effect: 'freeze' }, // Freeze AOE, no dmg
    { name: 'fire', damage: 3, range: 2, aoe: 'single', effect: 'damage' }, // Strong single
    { name: 'chain', damage: 1, range: 3, aoe: 'large', effect: 'chain' }, // Weak large AOE
    { name: 'earth', damage: 2, range: 2, aoe: 'small', effect: 'quake' } // Strong small AOE
];
    // Add Cursed Trader as special enemy (not in types for tx spawning)
    const cursedTraderType = new EnemyType('Cursed Trader', 0, 0, 12, 2, 1); // Custom: 12 HP, 2 DMG, 1 move
    cursedTraderType.anim.frames[0].src = 'cursedtrader_1.png';
    cursedTraderType.anim.frames[1].src = 'cursedtrader_2.png';
    cursedTraderType.anim.frames[2].src = 'cursedtrader_3.png';
    cursedTraderType.anim.frameDuration = 400;
    cursedTraderType.reward = 0; // No sats reward

const assets = {
    themes: {
        dungeon: { floor: new Image(), wall: new Image() },
        desert: { floor: new Image(), wall: new Image(), special: new Image() },
        paradise: { floor: new Image(), wall: new Image(), special: new Image() },
        hell: { floor: new Image(), wall: new Image(), special: new Image() },
        ruins: { floor: new Image(), wall: new Image(), special: new Image() },
        hideout: { floor: new Image(), wall: new Image(), diamond_wall: new Image() }
    },
    potion: new Image(),
    player: new Image(),
    stairs: new Image(),
    bitcoin: new Image(),
    gameOver: new Image(),
    sword: new Image(),
    pickaxe: new Image(),
    armor: new Image(),
    player_armor: new Image(),
    player_diamond_armor: new Image(),
    pickaxe_sword: new Image(),
    shoot_sword: new Image(),
    gnome: new Image(),
    jeweller: new Image(),
    blacksmith: new Image(),
    waypoint: new Image(),
    rune_whisperer: new Image(),
    runes: {
        on_floor: new Image(),
        a: new Image(), b: new Image(), c: new Image(), d: new Image(), e: new Image(),
        f: new Image(), g: new Image(), h: new Image(), i: new Image(), k: new Image(),
        l: new Image(), m: new Image(), n: new Image(), o: new Image(), p: new Image(),
        q: new Image(), r: new Image(), s: new Image(), t: new Image(), u: new Image(),
        v: new Image(), y: new Image(), z: new Image(), æ: new Image(), ø: new Image()
    },
    diamond: new Image(),
    scroll: new Image(),
    town_portal: [new Image(), new Image(), new Image()],
    soul_stash: new Image(),
    soul_stone: new Image(),
    hooded_heirloom: new Image(),
    soul_orb_statue: new Image(),
    shrine: new Image()
};

// Initialize sprite frames for all enemy types
for (let i = 0; i < types.length; i++) {
    const type = types[i];
    if (type.name === 'Shrimp') {
        // Hell Shrimp has special frames that need to be loaded
        assets.themes.hell.special.onerror = () => console.error(`Failed to load hell special asset: ${assets.themes.hell.special.src}`);
    }
}

// Load sprite frames for each enemy type
types.forEach((type, index) => {
    // Set up default animation frames
    type.anim.frames[0].src = `${type.name.toLowerCase()}_1.png`;
    type.anim.frames[1].src = `${type.name.toLowerCase()}_2.png`;
    type.anim.frames[2].src = `${type.name.toLowerCase()}_3.png`;
    
    // Special handling for Hell Shrimp
    if (type.name === 'Shrimp') {
        type.anim.hellFrames[0].src = 'hell_shrimp_1.png';
        type.anim.hellFrames[1].src = 'hell_shrimp_2.png';
        type.anim.hellFrames[2].src = 'hell_shrimp_3.png';
        type.anim.hellFrames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load Hell Shrimp frame ${i}: ${frame.src}`);
        });
    }
});

Object.values(assets).forEach(asset => {
        if (asset instanceof Image) {
            asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
        } else if (typeof asset === 'object') {
            Object.values(asset).forEach(subAsset => {
                subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
            });
        }
    });
    
// Handle error for enemy sprite frames
types.forEach(t => {
    t.anim.frames.forEach((frame, i) => {
        frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
    });
    // Also handle Hell Shrimp frames if they exist
    if (t.anim.hellFrames) {
        t.anim.hellFrames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load Hell sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});
        assets.themes.dungeon.floor.src = 'floor.png';
        assets.themes.dungeon.wall.src = 'wall.png';
        assets.themes.desert.floor.src = 'sand_floor.png';
        assets.themes.desert.wall.src = 'sand_wall.png';
        assets.themes.desert.special.src = 'quicksand.png';
        assets.themes.paradise.floor.src = 'paradise_floor.png';
        assets.themes.paradise.wall.src = 'paradise_wall.png';
        assets.themes.paradise.special.src = 'pond.png';
        // Normal hell
        assets.themes.hell.floor.src = 'hell_floor.png';
        assets.themes.hell.wall.src = 'hell_wall.png';
        assets.themes.hell.special.src = 'lava.png';
        // Snowy hell overrides (used when snowyHellActive = true)
        assets.themes.hell.snowy_floor = new Image();
        assets.themes.hell.snowy_wall = new Image();
        assets.themes.hell.snowy_floor.src = 'hell_floor_snow.png';
        assets.themes.hell.snowy_wall.src = 'hell_wall.png';     // reuse base texture
        assets.themes.ruins.floor.src = 'ring_floor.png';
        assets.themes.ruins.wall.src = 'ring_wall.png';
        assets.themes.ruins.special.src = 'ring_hole.png';
        assets.potion.src = 'potion.png';
        assets.gnome.src = 'gnome.png';
	assets.player.src = 'player.png';
	assets.pickaxe.src = 'pickaxe.png';
	assets.armor.src = 'armor.png';
	assets.player_armor.src = 'player_armor.png';
        assets.stairs.src = 'stairs.png'; 
        assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png';
        assets.sword.src = 'sword.png';
        assets.diamond_hand = new Image(); // Add diamond hand asset
        assets.diamond_hand.src = 'diamond_hand.png';
        assets.pickaxe_sword.src = 'pickaxe-sword.png';
        assets.shoot_sword.src = 'shoot_sword.png';        
        assets.bit_spear = new Image();
        assets.bit_spear.src = 'bit_spear.png';       
        assets.soul_sword = new Image();
        assets.soul_sword.src = 'soul_sword.png';      
        assets.runes.on_floor.src = 'rune_on_floor.png';
	assets.runes.a.src = 'rune-a.png';
	assets.runes.b.src = 'rune-b.png';
	assets.runes.c.src = 'rune-c.png';
	assets.runes.d.src = 'rune-d.png';
	assets.runes.e.src = 'rune-e.png';
	assets.runes.f.src = 'rune-f.png';
	assets.runes.g.src = 'rune-g.png';
	assets.runes.h.src = 'rune-h.png';
	assets.runes.i.src = 'rune-i.png';
	assets.runes.k.src = 'rune-k.png';
	assets.runes.l.src = 'rune-l.png';
	assets.runes.m.src = 'rune-m.png';
	assets.runes.n.src = 'rune-n.png';
	assets.runes.o.src = 'rune-o.png';
	assets.runes.p.src = 'rune-p.png';
	assets.runes.q.src = 'rune-q.png';
	assets.runes.r.src = 'rune-r.png';
	assets.runes.s.src = 'rune-s.png';
	assets.runes.t.src = 'rune-t.png';
	assets.runes.u.src = 'rune-u.png';
	assets.runes.v.src = 'rune-v.png';
	assets.runes.y.src = 'rune-y.png';
	assets.runes.z.src = 'rune-z.png';
	assets.runes.æ.src = 'rune-æ.png';
	assets.runes.ø.src = 'rune-ø.png';
	
	assets.diamond.src = 'diamond.png';
	assets.scroll.src = 'scroll.png';
	assets.town_portal[0].src = 'town_portal_1.png';
	assets.town_portal[1].src = 'town_portal_2.png';
	assets.town_portal[2].src = 'town_portal_3.png';
	assets.themes.hideout.floor.src = 'town_floor.png';
	assets.themes.hideout.wall.src = 'town_wall.png';
	assets.themes.hideout.diamond_wall.src = 'diamond_wall.png';
	assets.soul_orb_statue.src = 'soul_orb_statue.png';
	assets.shrine.src = 'shrine.png';

// Puzzle room assets
assets.puzzlePortal = [new Image(), new Image(), new Image()];
assets.puzzlePortal[0].src = 'puzzle_portal_1.png';
assets.puzzlePortal[1].src = 'puzzle_portal_2.png';
assets.puzzlePortal[2].src = 'puzzle_portal_3.png';
assets.boulder = new Image();
assets.boulder.src = 'boulder.png';
assets.heartFramer = new Image();
assets.heartFramer.src = 'heart_framer.png';
assets.chestClosed = new Image();
assets.chestClosed.src = 'chest_closed.png';
assets.chestOpen = new Image();
assets.chestOpen.src = 'chest_open.png';

assets.arrow_up    = new Image(); assets.arrow_up.src    = 'arrow_up.png';
assets.arrow_right = new Image(); assets.arrow_right.src = 'arrow_right.png';
assets.arrow_down  = new Image(); assets.arrow_down.src  = 'arrow_down.png';
assets.arrow_left  = new Image(); assets.arrow_left.src  = 'arrow_left.png';
	
	assets.jeweller.src = 'jeweller.png';
	assets.blacksmith.src = 'blacksmith.png';
	assets.waypoint.src = 'waypoint.png';
	assets.rune_whisperer.src = 'rune_whisperer.png';
	assets.player_diamond_armor.src = 'player_diamond_armor.png';
	assets.soul_stash.src = 'soul_stash.png';
	assets.soul_stone.src = 'soul_stone.png';
	assets.hooded_heirloom.src = 'hooded_heirloom.png';
assets.cursed_ring = new Image(),
assets.cursed_ring.src = 'cursed_ring.png';

assets.farmSpot1 = new Image();
assets.farmSpot1.src = 'farmSpot1.png';
assets.farmSpot2 = new Image();
assets.farmSpot2.src = 'farmSpot2.png';
assets.farmSpot1.onerror = () => console.error('Failed to load farmSpot1.png');
assets.farmSpot2.onerror = () => console.error('Failed to load farmSpot2.png');

assets.echo_warden = new Image();
assets.echo_warden.src = 'ἀρχάγγελος.png';
assets.echo_warden.onerror = () => console.error('Failed to load echo_warden.png');

// Wisp animation frames
assets.wispFrames = [
    new Image(), new Image(), new Image()
];
assets.wispFrames[0].src = 'wisp1.png';
assets.wispFrames[1].src = 'wisp2.png';
assets.wispFrames[2].src = 'wisp3.png';
assets.wispFrames.forEach((frame, i) => {
    frame.onerror = () => console.error(`Failed to load wisp frame ${i}: wisp${i+1}.png`);
});

// Enemy background circles (16x16px animated)
assets.enemyBg = [new Image(), new Image(), new Image()];
assets.enemyBg[0].src = 'red-bg1.png';
assets.enemyBg[1].src = 'red-bg2.png';
assets.enemyBg[2].src = 'red-bg3.png';
	p.anim.frames.diamond_armor_front = [new Image(), new Image()];
	p.anim.frames.diamond_armor_front[0].src = 'player_diamond_armor-front1.png';
	p.anim.frames.diamond_armor_front[1].src = 'player_diamond_armor-front2.png';
	p.anim.frames.diamond_armor_back = [new Image(), new Image()];
	p.anim.frames.diamond_armor_back[0].src = 'player_diamond_armor-back1.png';
	p.anim.frames.diamond_armor_back[1].src = 'player_diamond_armor-back2.png';
	p.anim.frames.diamond_armor_right = [new Image(), new Image()];
	p.anim.frames.diamond_armor_right[0].src = 'player_diamond_armor-right1.png';
	p.anim.frames.diamond_armor_right[1].src = 'player_diamond_armor-right2.png';

assets.satoshi_scourge = new Image();
assets.satoshi_scourge.src = 'satoshi_scourge.png';
assets.satoshi_scourge.onerror = () => console.error('Failed to load satoshi_scourge.png');

assets.cat = new Image();
assets.cat.src = 'black_cat.png';
assets.cat.onerror = () => console.error('Failed to load black_cat.png');
	
Object.values(assets.runes).forEach(rune => {
    rune.onerror = () => console.error(`Failed to load rune asset: ${rune.src}`);
});
Object.values(assets).forEach(asset => {
    if (asset instanceof Image) {
        asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
    } else if (typeof asset === 'object') {
        Object.values(asset).forEach(subAsset => {
            subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
        });
    }
});
types.forEach(t => {
    if (t.img) {
        t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`);
    } else if (t.anim) {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});

function placeStairs() {
    if (inHideout) {
        console.warn('Attempted to place stairs in hideout – forbidden');
        return false;
    }
    if (exit) {
        logBattleEvent(`Floor ${floor} - Stairs placement skipped: exit already exists at (${exit.x}, ${exit.y})`);
        return true;
    }
    let x, y, placed = false;
    // Try room-based placement first
    if (rooms && rooms.length > 0) {
        let r = rooms[Math.floor(Math.random() * rooms.length)];
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = r.x + Math.floor(Math.random() * r.w);
            y = r.y + Math.floor(Math.random() * r.h);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    // Fallback to any valid floor tile
    if (!placed) {
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = Math.floor(Math.random() * W);
            y = Math.floor(Math.random() * H);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    if (placed) {
        exit = {x, y};
        updateSatsDisplay();
        logBattleEvent(`Floor ${floor} - Stairs appeared!`);
        needsRedraw = true;
        return true;
    } else {
        logBattleEvent(`Floor ${floor} - Failed to place stairs: no valid position found!`);
        console.warn(`Stairs placement failed: rooms=${rooms.length}, map valid=${map.every(row => row.length === W)}`);
        needsRedraw = true;
        return false;
    }
}

const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioContext = null;
function getAudioContext() {
    if (!audioContext) {
        audioContext = new AudioContext();
    }
    return audioContext;
}
audioContext = getAudioContext();

const sounds = {
    attack: new Audio('attack.wav'),
    potion: new Audio('potion.wav'),
    hit: { buffer: null, url: 'hit.wav', isPlaying: false, duration: 720 },
    pickup: { buffer: null, url: 'pickup.wav', isPlaying: false, duration: 950 },
    dungeon: new Audio('dungeon.mp3'),
desert: new Audio('desert.mp3'),
hell: new Audio('hell.mp3'),
paradise: new Audio('paradise.mp3'),
ruins: new Audio('ruins.mp3'),
hideout: new Audio('hideout.mp3'),
    gameover: new Audio('gameover.wav'),
    stairs: new Audio('stairs.wav'),
    secret: new Audio('secret.wav'),
    shoot_sword: new Audio('shoot_sword.wav'),
    heads: { buffer: null, url: 'heads.wav', isPlaying: false, duration: 650 },
    tails: { buffer: null, url: 'tails.wav', isPlaying: false, duration: 950 },
    lava: { buffer: null, url: 'lava.wav', isPlaying: false, duration: 900 },
    quicksand: { buffer: null, url: 'quicksand.wav', isPlaying: false, duration: 250 },
    pond: { buffer: null, url: 'pond.wav', isPlaying: false, duration: 500 },
    rune: { buffer: null, url: 'rune.wav', isPlaying: false, duration: 2000 },
    rune_drop: { buffer: null, url: 'rune_drop.wav', isPlaying: false, duration: 1000 },
    hole: { buffer: null, url: 'hole.wav', isPlaying: false, duration: 745 },
    town_portal: { buffer: null, url: 'town_portal.wav', isPlaying: false, duration: 535 },
    buzz: { buffer: null, url: 'buzz.wav', isPlaying: false, duration: 1000 },
    unique_monster: { buffer: null, url: 'unique_monster.wav', isPlaying: false, duration: 1400 }
};

// Volume control
let soundVolume = localStorage.getItem('soundVolume') || 1.0;
let musicVolume = localStorage.getItem('musicVolume') || 1.0;

function setSoundVolume(volume) {
    soundVolume = Math.max(0, Math.min(1, volume));
    localStorage.setItem('soundVolume', soundVolume);
    
    // Update all sound volumes
    Object.entries(sounds).forEach(([key, sound]) => {
        // Skip music tracks which are handled by musicManager
        if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout') {
            return; // Skip music tracks
        }
        if (sound.buffer) {
            // Web Audio sounds need to be handled via gain nodes - we'll handle this in playWebAudioSound
            return;
        }
        if (sound instanceof Audio) {
            sound.volume = soundVolume;
        }
    });
}

function setMusicVolume(volume) {
    musicVolume = Math.max(0, Math.min(1, volume));
    localStorage.setItem('musicVolume', musicVolume);
    
    // Update music manager volume
    if (musicManager) {
        musicManager.volume = musicVolume;
        if (musicManager.current && musicManager.audios[musicManager.current]) {
            const currentAudio = musicManager.audios[musicManager.current];
            currentAudio.volume = musicManager.muted ? 0 : musicVolume;
        }
    }
}

// Load Web Audio buffers
function loadSoundBuffer(url, key) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(data => audioContext.decodeAudioData(data))
        .then(buffer => {
            sounds[key].buffer = buffer;
                    })
        .catch(e => console.error(`Failed to load Web Audio buffer for ${key}: ${url}`, e));
}
loadSoundBuffer('hit.wav', 'hit');
loadSoundBuffer('pickup.wav', 'pickup');
loadSoundBuffer('heads.wav', 'heads');
loadSoundBuffer('tails.wav', 'tails');
loadSoundBuffer('lava.wav', 'lava');
loadSoundBuffer('quicksand.wav', 'quicksand');
loadSoundBuffer('pond.wav', 'pond');
loadSoundBuffer('rune.wav', 'rune');
loadSoundBuffer('rune_drop.wav', 'rune_drop');
loadSoundBuffer('hole.wav', 'hole');
loadSoundBuffer('town_portal.wav', 'town_portal');
loadSoundBuffer('buzz.wav', 'buzz');
loadSoundBuffer('unique_monster.wav', 'unique_monster');

class MusicManager {
  constructor() {
    this.audios = {
      dungeon: sounds.dungeon,
      desert: sounds.desert,
      hell: sounds.hell,
      paradise: sounds.paradise,
      ruins: sounds.ruins,
      hideout: sounds.hideout
    };
    this.current = null;
    this.muted = false;
    this.volume = 1.0;
    Object.values(this.audios).forEach(audio => {
      audio.loop = true;
      audio.onerror = () => console.error(`Failed to load music: ${audio.src}`);
      audio.volume = musicVolume; // Set initial volume from global
    });
  }
  play(theme) {
    if (!this.audios[theme]) return;
    const audio = this.audios[theme];
    if (this.current === theme) {
      if (!this.muted) {
        audio.play().catch(e => console.error('Music play failed:', e));
      }
      return;
    }
    if (this.current) {
      this.fadeOut(this.audios[this.current]);
    }
audio.volume = this.muted ? 0 : musicVolume; // Set initial volume based on muted state
audio.muted = this.muted;
audio.play().catch(e => console.error('Music play failed:', e));
if (!this.muted) {
  this.fadeIn(audio); // Ensure fadeIn is called only if not muted
}
    this.current = theme;
  }
  fadeOut(audio) {
    let vol = audio.volume;
    const interval = setInterval(() => {
      vol = Math.max(0, vol - 0.1);
      audio.volume = vol;
      if (vol <= 0) {
        clearInterval(interval);
        audio.pause();
        audio.currentTime = 0;
      }
    }, 100);
  }
  fadeIn(audio) {
    let vol = 0;
    const interval = setInterval(() => {
      vol = Math.min(this.volume, vol + 0.1);
      audio.volume = vol;
      if (vol >= this.volume) {
        clearInterval(interval);
      }
    }, 100);
  }
  mute(muted) {
    this.muted = muted;
    if (this.current) {
      this.audios[this.current].muted = muted;
      this.audios[this.current].volume = muted ? 0 : musicVolume;
    }
  }
}
const musicManager = new MusicManager();

Object.values(sounds).forEach(s => {
    if (s instanceof Audio) {
        s.volume = 1.0;
        s.onerror = () => console.error(`Failed to load sound: ${s.src}`);
    }
});

function isIOSorSafari() {
    const ua = navigator.userAgent;
    return /iPad|iPhone|iPod/.test(ua) || /Safari/.test(ua);
}

function preloadSounds() {
    // Save current volume before setting to 0
    const savedSoundVolume = soundVolume;
    
    if (isIOSorSafari()) {
        // iOS/Safari: Preload by setting src without playing
        Object.entries(sounds).forEach(([key, sound]) => {
            if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop' || key === 'hole' || key === 'town_portal' || key === 'buzz' || key === 'unique_monster') return; // Skip music and Web Audio sounds
            if (Array.isArray(sound)) {
                sound.forEach((instance, idx) => {
                    // Create a new Audio object to trigger caching
                    const tempAudio = new Audio(instance.src);
                    tempAudio.volume = 0; // Set volume to 0 during preload
                });
            } else if (sound instanceof Audio && sound.src) {
                // Create a new Audio object to trigger caching
                const tempAudio = new Audio(sound.src);
                tempAudio.volume = 0;
            }
        });
} else {
    // Non-iOS: Existing preload logic
    Object.entries(sounds).forEach(([key, sound]) => {
        if (key === 'dungeon' || key === 'desert' || key === 'hell' || key === 'paradise' || key === 'ruins' || key === 'hideout' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop' || key === 'hole' || key === 'town_portal' || key === 'buzz' || key === 'unique_monster') return; // Skip music and Web Audio sounds
        if (Array.isArray(sound)) {
            sound.forEach((instance, idx) => {
                if (instance instanceof Audio && instance.src) {
                    instance.volume = 0; // Set volume to 0 during preload
                    instance.play().then(() => {
                        instance.pause();
                        instance.currentTime = 0;
                        instance.volume = 0; // Keep at 0 during preload
                    }).catch(e => console.error(`Preload sound error for ${instance.src}:`, e));
                }
            });
        } else if (sound instanceof Audio && sound.src) {
            sound.volume = 0; // Set volume to 0 during preload
            sound.play().then(() => {
                sound.pause();
                sound.currentTime = 0;
                sound.volume = 0; // Keep at 0 during preload
            }).catch(e => console.error(`Preload sound error for ${sound.src}:`, e));
        }
    });
}
    
    // Restore original volume after preloading is complete
    setTimeout(() => {
        setSoundVolume(savedSoundVolume);
    }, 100);
}

function playWebAudioSound(soundObj) {
    if (!soundObj.buffer) {
        console.warn(`Buffer not loaded for ${soundObj.url}`);
        return;
    }
    if (soundObj.isPlaying) {
                return;
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
                    }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    soundObj.isPlaying = true; // Set flag
    const source = audioContext.createBufferSource();
    source.buffer = soundObj.buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = soundVolume; // Use global sound volume setting
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
        source.onended = () => {
        soundObj.isPlaying = false; // Clear flag
            };
    // Fallback timeout to clear flag if onended fails
    setTimeout(() => {
        if (soundObj.isPlaying) {
            soundObj.isPlaying = false;
                    }
    }, soundObj.duration);
}

// Ultra low-fi 8-bit / C64 style wisp voice + music ducking
function wispSpeak(type) {
    if (musicMuted || !audioContext || wispIsSpeaking) return;

    wispIsSpeaking = true;
    const originalVolume = musicManager.volume;

    // Gently duck the music (feels like Navi!)
    if (musicManager.current) {
        musicManager.audios[musicManager.current].volume = originalVolume * 0.25;
    }

    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.type = 'square';
    osc.connect(gain);
    gain.connect(audioContext.destination);
    gain.gain.setValueAtTime(0.180, audioContext.currentTime); // 50% louder (0.09 × 2)

    let duration = 0.38;
    if (type === 'danger') {
        const notes = [220, 277.18, 329.63, 440];
        let t = audioContext.currentTime;
        notes.forEach((f, i) => {
            osc.frequency.setValueAtTime(f * (1 + i*0.05), t);
            t += 0.09;
        });
    } else if (type === 'victory') {
        duration = 0.85; // longer to fit the laugh
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.18, audioContext.currentTime);

        // Laughing pattern: "plooiiihhhiihiihhiung" in pure 8-bit fairy voice
        let t = audioContext.currentTime;

        // ploooooiii (long rising glide)
        osc.frequency.setValueAtTime(880, t);           // A5 start
        osc.frequency.exponentialRampToValueAtTime(1760, t + 0.28); // fast rise to A6

        // hhhiihiihhi (quick giggling ups and downs)
        t += 0.30;
        const giggle = [1760, 1396.96, 1760, 1396.96, 1760, 1567.98];
        giggle.forEach((f, i) => {
            osc.frequency.setValueAtTime(f, t + i*0.07);
        });

        // final "ung" (soft drop)
        osc.frequency.exponentialRampToValueAtTime(880, t + 0.50);
    }

    // start/stop once – works for both danger and victory
    osc.start();
    osc.stop(audioContext.currentTime + duration);
    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

    // Restore music after the voice finishes
    osc.onended = () => {
        // Only restore music immediately for victory jingle
        if (type === 'victory') {
            if (musicManager.current && !musicMuted) {
                musicManager.audios[musicManager.current].volume = originalVolume;
            }
        }
        // For danger: music stays ducked until player heals above 8 HP
        wispIsSpeaking = false;
    };
}

function playPigSnort() {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const duration = 0.45;
    const sampleRate = ctx.sampleRate;

    const buffer = ctx.createBuffer(1, duration * sampleRate, sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < data.length; i++) {
        const t = i / sampleRate;

        // Base low growl with wobble
        const freq1 = 110 + 20 * Math.sin(2 * Math.PI * 1.5 * t);
        let wave = Math.sin(2 * Math.PI * freq1 * t);

        // Higher piggy harmonic
        const freq2 = 320 + 50 * Math.sin(2 * Math.PI * 2 * t);
        wave += 0.4 * Math.sin(2 * Math.PI * freq2 * t);

        // Add some roughness/noise
        wave += 0.2 * (Math.random() - 0.5);

        // Punchy envelope: fast attack, long decay
        const envelope = Math.exp(-4 * t) * (1 - Math.exp(-15 * t));
        data[i] = wave * envelope;
    }

    const source = ctx.createBufferSource();
    source.buffer = buffer;

    // ---- RESPECT SOUL TERMINAL SOUND VOLUME ----
    const gainNode = ctx.createGain();
    gainNode.gain.value = soundVolume;  // uses the global soundVolume set by terminal
    source.connect(gainNode);
    gainNode.connect(ctx.destination);

    source.start(0);
}

/* ---------- AUDIO ---------- */
function playScourgeSpin() {
    if (musicMuted || soundVolume === 0) return;

    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const now = ctx.currentTime;

    // Master gain – louder epic
    const master = ctx.createGain();
    master.gain.value = 0.9 * soundVolume;
    master.connect(ctx.destination);

    // 1. Angelic WHOOSH sweep
    const whoosh = ctx.createOscillator();
    whoosh.type = 'triangle';
    whoosh.frequency.setValueAtTime(300, now);
    whoosh.frequency.exponentialRampToValueAtTime(30, now + 0.5);

    const whooshFilter = ctx.createBiquadFilter();
    whooshFilter.type = 'highpass';
    whooshFilter.frequency.setValueAtTime(200, now);
    whooshFilter.frequency.exponentialRampToValueAtTime(800, now + 0.5);

    const whooshGain = ctx.createGain();
    whooshGain.gain.setValueAtTime(0, now);
    whooshGain.gain.linearRampToValueAtTime(1.2, now + 0.03);
    whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);

    whoosh.connect(whooshFilter).connect(whooshGain).connect(master);
    whoosh.start(now);
    whoosh.stop(now + 0.55);

    // 2. Four heavy THUNK impacts (cleaner)
    for (let i = 0; i < 4; i++) {
        const t = now + i * 0.09;

        // Deep punch – sine
        const thud = ctx.createOscillator();
        thud.type = 'sine';
        thud.frequency.setValueAtTime(120, t);
        thud.frequency.exponentialRampToValueAtTime(40, t + 0.15);

        const thudGain = ctx.createGain();
        thudGain.gain.setValueAtTime(1.0, t);
        thudGain.gain.exponentialRampToValueAtTime(0.01, t + 0.18);

        thud.connect(thudGain).connect(master);
        thud.start(t);
        thud.stop(t + 0.18);

        // Metallic CLANG – layered
        const clang = ctx.createOscillator();
        clang.type = 'square';
        clang.frequency.setValueAtTime(380 + i * 90, t);
        clang.frequency.exponentialRampToValueAtTime(120, t + 0.08);

        const clang2 = ctx.createOscillator();
        clang2.type = 'square';
        clang2.frequency.setValueAtTime((380 + i * 90) * 1.5 + 5, t);
        clang2.frequency.exponentialRampToValueAtTime(180, t + 0.08);

        const clangGain = ctx.createGain();
        clangGain.gain.setValueAtTime(0.45, t);
        clangGain.gain.exponentialRampToValueAtTime(0.02, t + 0.12);

        const clangFilter = ctx.createBiquadFilter();
        clangFilter.type = 'bandpass';
        clangFilter.frequency.value = 900;
        clangFilter.Q.value = 10;

        clang.connect(clangFilter);
        clang2.connect(clangFilter);
        clangFilter.connect(clangGain).connect(master);

        clang.start(t);
        clang2.start(t);
        clang.stop(t + 0.12);
        clang2.stop(t + 0.12);
    }

    // Longer, smoother reverb tail
    const convolver = ctx.createConvolver();
    const impulse = ctx.createBuffer(2, ctx.sampleRate * 0.4, ctx.sampleRate);
    const left = impulse.getChannelData(0);
    const right = impulse.getChannelData(1);
    for (let i = 0; i < impulse.length; i++) {
        const decay = Math.exp(-i / (ctx.sampleRate * 0.3));
        left[i] = (Math.random() * 2 - 1) * decay;
        right[i] = (Math.random() * 2 - 1) * decay;
    }
    convolver.buffer = impulse;
    master.connect(convolver).connect(ctx.destination);
}

// CAT TRACKER v16
function playCatPurr() {
  if (typeof musicMuted !== 'undefined' && musicMuted) return;
  if (typeof soundVolume === 'undefined') soundVolume = 1;
  if (soundVolume === 0) return;
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const now = ctx.currentTime;
  const osc = ctx.createOscillator(); osc.type = 'sawtooth';
  const filter = ctx.createBiquadFilter(); filter.type = 'lowpass';
  filter.frequency.setValueAtTime(3000, now);
  filter.frequency.exponentialRampToValueAtTime(1500, now + 1.0);
  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0.001, now);
  gain.gain.linearRampToValueAtTime(0.7 * soundVolume, now + 0.08);

  let t = now;

  osc.frequency.setValueAtTime(20 + (Math.random()*20-10), t);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.130);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.430);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.52);
  t += 0.4056;
  osc.frequency.setValueAtTime(20 + (Math.random()*20-10), t);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.130);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.430);
  osc.frequency.exponentialRampToValueAtTime(20, t + 0.52);
  t += 0.4056;
  gain.gain.setValueAtTime(0.7 * soundVolume, t - 0.25);
  gain.gain.exponentialRampToValueAtTime(0.001, t);
  osc.connect(filter).connect(gain).connect(ctx.destination);
  osc.start(now); osc.stop(t + 0.3);
}

const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
let currentSplashImage = 'splash.png';
const splashImg = new Image();
splashImg.src = currentSplashImage;
splashImg.onload = () => {
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
};

function fadeSplash() {
    setTimeout(() => {
        const imgData = splashCanvas.getImageData(0, 0, 320, 320);
        const pixels = imgData.data;
        const totalPixels = 320 * 320;
        const fadePerFrame = totalPixels / 20;
        let fadedPixels = 0;
        const fadeInterval = setInterval(() => {
            for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                const px = Math.floor(Math.random() * totalPixels) * 4;
                pixels[px + 3] = 0;
                fadedPixels++;
            }
            splashCanvas.putImageData(imgData, 0, 0);
            if (fadedPixels >= totalPixels) {
                clearInterval(fadeInterval);
                splashActive = false;
                document.getElementById('splash-screen').style.display = 'none'; // Hide instead of remove
                            }
        }, 75);
    }, 25);
}

function resetSplashScreen() {
    splashActive = true;
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block'; // Show splash screen
    // Redraw splash image
    splashCanvas.clearRect(0, 0, 320, 320);
    splashImg.src = currentSplashImage;
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
}

document.getElementById('start-button').addEventListener('click', () => {
    currentTheme = 'dungeon'; // Force default theme on game start
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }

    // Assign random elemental immunity
    const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
    p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];

wakeLock = null;

// Function to request wake lock
async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake lock activated');
      wakeLock.addEventListener('release', () => {
        console.log('Wake lock released');
      });
    } else {
      console.warn('Wake Lock API not supported in this browser. Adjust OS power settings manually.');
      alert('Wake Lock not supported. To prevent sleep, disable screen timeout in your OS settings or play a silent audio loop.');
    }
  } catch (err) {
    console.error('Wake lock error:', err);
  }
}

// Re-request wake lock if visibility changes (e.g., tab switch)
document.addEventListener('visibilitychange', async () => {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    await requestWakeLock();
  }
});

if (splashActive) {
        preloadSounds();
        // Ensure AudioContext is resumed for iOS
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                // Reset music manager state and play music after AudioContext is resumed
                musicManager.current = null;
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
            }).catch(e => console.error('Failed to resume AudioContext:', e));
        } else {
            // Reset music manager state on restart
            musicManager.current = null;
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
        }
            // Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

        musicManager.mute(musicMuted); // Ensure proper mute state
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }
    
// Set music volume to 0 when restarting
setSoundVolume(0);
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);
fadeSplash();
setTimeout(() => {
    if (!gameOver && !splashActive) {
        requestWakeLock();  // ← Add this to request wake lock on game start
        fetchTxs();
        lastUpdate = Date.now();
        console.log('Initial fetchTxs triggered after splash, wave=', wave);
        
        // First-time leaderboard cache (only once per browser session)
        if (!localStorage.getItem('leaderboardCached')) {
            fetchLeaderboard().then(() => {
                localStorage.setItem('leaderboardCached', 'true');
                cachedLeaderboard = JSON.parse(localStorage.getItem('leaderboardData') || '[]');
                console.log('Leaderboard cached on first start');
            }).catch(err => console.error('Cache fetch failed:', err));
        } else {
            cachedLeaderboard = JSON.parse(localStorage.getItem('leaderboardData') || '[]');
        }
    }
}, 2000);
    }
    
    // Set music volume to max when starting
if (musicManager.current) {
    const currentAudio = musicManager.audios[musicManager.current];
    if (currentAudio) {
        currentAudio.currentTime = 0;
        currentAudio.volume = 1;
    }
}
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);
});

function toggleMute() {
    const muteButton = document.getElementById('mute');
    const currentState = muteButton.textContent;
    
    // Cycle through the three states: ♪ → X → ☀ → ♪
    if (currentState === '♪') {
        // First state: Music on → Mute music
        musicMuted = true;
        musicManager.mute(true);
        muteButton.textContent = 'X';
        localStorage.setItem('musicMuted', 'true');
} else if (currentState === 'X') {
        // Second state: Music muted → Activate screensaver
        musicMuted = true;
        musicManager.mute(true);
        muteButton.textContent = '☀';
        if (!splashActive) {
            musicManager.current = null; // Reset MusicManager state
            musicManager.play(currentTheme);
        }
        // Activate screensaver when moving to ☀ state
        activateScreensaver();
    } else if (currentState === '☀') {
        // Third state: Screensaver active → Return to music
        // Reset screensaver and return to normal state
        exitScreensaver();
        musicMuted = false;
        musicManager.mute(false);
        muteButton.textContent = '♪';
        if (!splashActive) {
            musicManager.current = null; // Reset MusicManager state
            musicManager.play(currentTheme);
        }
        localStorage.setItem('musicMuted', 'false');
    }
}

function logWhaleHashId(txid) {
    const newEntry = `Floor ${floor} - <a href="https://mempool.space/tx/${txid}" target="_blank">${txid}</a>`;
    whaleHashIds.push(newEntry);
    if (whaleHashIds.length > 50) {
        whaleHashIds = ['Whale Transactions:', ...whaleHashIds.slice(-49)];
        const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
        while (whaleHashIdsDiv.children.length > 49) {
            whaleHashIdsDiv.removeChild(whaleHashIdsDiv.firstChild);
        }
    }
    const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
    const newDiv = document.createElement('div');
    newDiv.innerHTML = newEntry;
    whaleHashIdsDiv.appendChild(newDiv);
    const whaleLog = document.getElementById('whale-log');
    whaleLog.scrollTop = whaleLog.scrollHeight;
    console.log('Whale Hash ID:', txid);
}

function logBattleEvent(event) {
    if (gameOver) return;
    const battleEvents = document.getElementById('battle-events');
    if (event.startsWith('Kills:') || event.match(/^(Shrimp|Crab|Squid|Dolphin|Shark|Whale):/) || event === '') {
        if (event === 'Kills:') {
            killsLog = [event];
        } else {
            killsLog.push(event);
            if (killsLog.length > 10) {
                killsLog = killsLog.slice(-10); // Cap at 10 entries
            }
        }
        if (exit && enemies.length === 0) {
            // Show exactly 8 kills lines
            battleEvents.value = killsLog.join('\n');
            battleEvents.scrollTop = battleEvents.scrollHeight;
            // Keep visible without fade-out
            battleEvents.style.transform = 'translateX(0)';
            battleEvents.style.opacity = '1';
            if (battleLogTimeout) {
                clearTimeout(battleLogTimeout);
                battleLogTimeout = null;
            }
                        return;
        }
    }
    // Keep last 3 messages for regular events (reverse waterfall)
    battleLog.push(event);
    battleLog = battleLog.slice(-3); // Keep last 3 events
    battleEvents.value = battleLog.join('\n');
    battleEvents.scrollTop = battleEvents.scrollHeight;
    // Clear any existing timeout
    if (battleLogTimeout) {
        clearTimeout(battleLogTimeout);
    }
    // Slide in and fade in
    battleEvents.style.transform = 'translateX(0)';
    battleEvents.style.opacity = '1';
    // Schedule slide out after 3 seconds for non-kills events
    battleLogTimeout = setTimeout(() => {
        battleEvents.style.transform = 'translateX(-100%)';
        battleEvents.style.opacity = '0';
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(battleEvents);
            if (computedStyle.opacity === '0') {
                battleLog = [];
                battleEvents.value = '';
                                // Restore kills display if still valid
                if (exit && enemies.length === 0) {
                    killsLog = [
                        'Kills:',
                        `Shrimp: ${kills.Shrimp}`,
                        `Crab: ${kills.Crab}`,
                        `Squid: ${kills.Squid}`,
                        `Dolphin: ${kills.Dolphin}`,
                        `Shark: ${kills.Shark}`,
                        `Whale: ${kills.Whale}`,
                        '' // Empty line for 8 lines total
                    ];
                    battleEvents.value = killsLog.join('\n');
                    battleEvents.style.transform = 'translateX(0)';
                    battleEvents.style.opacity = '1';
                    battleEvents.scrollTop = battleEvents.scrollHeight;
                                    }
            }
        }, 300); // Wait for transition (0.3s)
        battleLogTimeout = null;
    }, 3000);
}

function updateSatsDisplay() {
    const raw = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
    const mult = getScoreWithMultiplier(raw , floor);

    // Main value (sats or BTC)
    const satsElem   = document.getElementById('sats');
    satsElem.textContent =
        raw < 1e8 ? `${raw} sats` : `${(raw / 1e8).toFixed(1)} BTC`;

    // The calculation – shown on its own line
    const calcElem = document.getElementById('sats-calc');
    calcElem.textContent = `${floor / 100}: ${mult < 1e8 ? `${mult} sats` : `${(mult / 1e8).toFixed(1)} BTC`}`;

    // Trigger kills display only when exit exists and no enemies remain
    if (exit && enemies.length === 0) {
        logBattleEvent(`Kills:`);
        for (const type of types) {
            if (kills[type.name] > 0) {
                logBattleEvent(`${type.name}: ${kills[type.name]}`);
            }
        }
    }
}

function spawnItemWithChance(item, chance, maxItems, proximityRange, avoidPlayer) {
    let positions = [];
    let attempts = 0;
    const maxAttempts = 100;

    while (positions.length < maxItems && attempts < maxAttempts) {
        if (Math.random() < chance) {
            let x = Math.floor(Math.random() * W);
            let y = Math.floor(Math.random() * H);
            let valid = map[y][x] === 0;

            if (avoidPlayer) {
                valid = valid && Math.abs(x - p.x) >= 3 && Math.abs(y - p.y) >= 3; // Ensure 5x5 clear area
            }

            if (valid) {
                let isNearOtherItem = false;
                for (let pos of positions) {
                    if (Math.abs(x - pos[0]) <= 2 && Math.abs(y - pos[1]) <= 2) {
                        isNearOtherItem = true;
                        break;
                    }
                }
                if (!isNearOtherItem) {
                    positions.push([x, y]);
                    if (item !== -1) {
                        map[y][x] = item;
                    }
                }
            }
        }
        attempts++;
    }

    return positions;
}

function playUniqueMonsterSound(uniqueName) {
    // Check if we have a unique monster sound file
    if (isIOSorSafari()) {
        // iOS/Safari version - use existing audio handling
        const audio = sounds.unique_monster;
        if (audio && audio.src) {
            audio.currentTime = 0;
            audio.play().catch(e => console.error('Unique monster sound error:', e));
        }
    } else {
        // Non-iOS version - use Web Audio
        playWebAudioSound(sounds.unique_monster);
    }
}

function updateSnowState() {
    if (currentTheme === 'hell' && currentThemeBlock === 'hell_snowy') {
        snowyHellActive = true;
        // make sure we have snowflakes if they got cleared
        if (snowflakes.length === 0) {
            for (let i = 0; i < 120; i++) {
                snowflakes.push({
                    x: Math.random() * 320,
                    y: Math.random() * 320 - 100,
                    speed: 0.2 + Math.random() * 0.4,
                    size: 1 + Math.random() * 2,
                    sway: Math.random() * 2
                });
            }
        }
    } else {
        snowyHellActive = false;
        snowflakes = []; // instantly stop snow
    }
}

function initMap() {
    try {
        if (inHideout) {
            currentTheme = 'hideout';
            updateSnowState();
            document.documentElement.style.setProperty('--text-color', '#ff8c00');
            document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                el.style.color = '#ff8c00';
            });
            enemies = [];
            enemiesSpawnedThisFloor = 0;
            whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
            initialSpawnDoneThisFloor = false;
            initialWaveSpawned = false;
            map = Array(H).fill().map(() => Array(W).fill(1));
            fogMap = Array(H).fill().map(() => Array(W).fill(0));
            rooms = [];
            satoshiDrops = [];
            runeDrops = runeDrops.filter(r => !r.specific);
            scrollDrops = [];
            portals = [];
            dangerousAreas = []; // Clear dangerous areas
            currentRuneTile = null;
            jewellerPos = null;
            blacksmithPos = null;
            waypointPos = null;
            exit = null; // Prevent stairs and related enemy spawning
            echoWardenPos = null; // Clear warden on new floor
            wardenFlashStart = 0; // Clear flash on new floor
                for (let yy = 0; yy < H; yy++) {
                    for (let xx = 0; xx < W; xx++) {
                        if (map[yy][xx] === 24) map[yy][xx] = 0; // Clear warden tile
                    }
                }

            dpadButtons = document.querySelectorAll('#dpad button');
            actionsButtons = document.querySelectorAll('#actions button');

            rooms = [];
            const roomSize = 7;
            const gap = 2;

            const mainRoomX = Math.floor((W - roomSize) / 2);
            const mainRoomY = Math.floor((H - roomSize) / 2);
            rooms.push({ x: mainRoomX, y: mainRoomY, w: roomSize, h: roomSize });
            for (let y = mainRoomY; y < mainRoomY + roomSize; y++) {
                for (let x = mainRoomX; x < mainRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            const leftRoomX = mainRoomX - roomSize - gap;
            const leftRoomY = mainRoomY;
            rooms.push({ x: leftRoomX, y: leftRoomY, w: roomSize, h: roomSize });
            for (let y = leftRoomY; y < leftRoomY + roomSize; y++) {
                for (let x = leftRoomX; x < leftRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            const rightRoomX = mainRoomX + roomSize + gap;
            const rightRoomY = mainRoomY;
            rooms.push({ x: rightRoomX, y: rightRoomY, w: roomSize, h: roomSize });
            for (let y = rightRoomY; y < rightRoomY + roomSize; y++) {
                for (let x = rightRoomX; x < rightRoomX + roomSize; x++) {
                    map[y][x] = 0;
                }
            }

            for (let x = leftRoomX + roomSize; x < mainRoomX; x++) {
                map[mainRoomY + 3][x] = 0;
            }
            for (let x = mainRoomX + roomSize; x < rightRoomX; x++) {
                map[mainRoomY + 3][x] = 0;
            }

            jewellerPos = { x: mainRoomX + 3, y: mainRoomY + 3 };
            const diamondWallTiles = [
                {x: mainRoomX + 2, y: mainRoomY + 2}, {x: mainRoomX + 3, y: mainRoomY + 2}, {x: mainRoomX + 4, y: mainRoomY + 2},
                {x: mainRoomX + 2, y: mainRoomY + 3}, {x: mainRoomX + 4, y: mainRoomY + 3},
                {x: mainRoomX + 2, y: mainRoomY + 4}, {x: mainRoomX + 4, y: mainRoomY + 4}
            ];
            diamondWallTiles.forEach(pos => {
                if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H) {
                    map[pos.y][pos.x] = 13;
                }
            });
            map[jewellerPos.y][jewellerPos.x] = 14;

            // Place blacksmith at a fixed position in the left room
            const blacksmithX = leftRoomX + 4;
            const blacksmithY = leftRoomY + 3;
            if (map[blacksmithY][blacksmithX] === 0) {
                map[blacksmithY][blacksmithX] = 15; // Blacksmith
                blacksmithPos = { x: blacksmithX, y: blacksmithY };
            } else {
                console.warn('Failed to place blacksmith: tile occupied at', blacksmithX, blacksmithY);
            }

            // Place waypoint at a fixed position in the right room
            const waypointX = rightRoomX + 3;
            const waypointY = rightRoomY + 3;
            if (map[waypointY][waypointX] === 0) {
                map[waypointY][waypointX] = 16; // Waypoint
                waypointPos = { x: waypointX, y: waypointY };
            } else {
                console.warn('Failed to place waypoint: tile occupied at', waypointX, waypointY);
            }
            
            // Place rune whisperer at a fixed position in the right room
            const runeWhispererX = rightRoomX + 1;
            const runeWhispererY = rightRoomY + 5;
            if (map[runeWhispererY][runeWhispererX] === 0) {
                map[runeWhispererY][runeWhispererX] = 17; // Rune Whisperer
                runeWhispererPos = { x: runeWhispererX, y: runeWhispererY };
            } else {
                console.warn('Failed to place rune whisperer: tile occupied at', runeWhispererX, runeWhispererY);
            }

            // Place hooded heirloom (4 tiles north of rune whisperer)
            const heirloomX = runeWhispererX;
            const heirloomY = runeWhispererY - 4;
            if (map[heirloomY][heirloomX] === 0) {
                map[heirloomY][heirloomX] = 18; // Hooded Heirloom
            } else {
                console.warn('Failed to place hooded heirloom: tile occupied at', heirloomX, heirloomY);
            }

p.x = mainRoomX + 3;
p.y = mainRoomY + 6;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;
updateFogMap(p.x, p.y);
            needsRedraw = true;
            logBattleEvent(`Hideout - Entered the secret hideout!`);
            document.getElementById('floor-indicator').textContent = `Hideout`;
            return;
        }

// ——— THEME BLOCK CONSISTENCY ———
if (floor % 3 === 0 && floor > 1) {
    const newTheme = selectNewTheme(currentTheme);

    if (newTheme === 'hell') {
        // First time entering a new hell block?
        if (currentThemeBlock !== 'hell_normal' && currentThemeBlock !== 'hell_snowy') {
            // 50% chance to be snowy hell for the ENTIRE 3-floor block
            currentThemeBlock = Math.random() < 0.5 ? 'hell_snowy' : 'hell_normal';
            
            // Apply the decision
            snowyHellActive = (currentThemeBlock === 'hell_snowy');
            
            if (snowyHellActive) {
                // Initialize snowflakes ONCE per block
                snowflakes = [];
                for (let i = 0; i < 120; i++) {
                    snowflakes.push({
                        x: Math.random() * 320,
                        y: Math.random() * 320 - 100,
                        speed: 0.2 + Math.random() * 0.4,
                        size: 1 + Math.random() * 2,
                        sway: Math.random() * 2
                    });
                }
                logBattleEvent(`Floor ${floor} - Hell froze over! Snowy Hell begins…`);
            }
        }
        // Keep using the same hell variant for the whole block
        currentTheme = 'hell';
    } else {
        // Not hell → reset everything
        currentThemeBlock = null;
        snowyHellActive = false;
        snowflakes = [];
        currentTheme = newTheme;
    }
} else {
    // Not a theme-change floor → keep current hell variant (if any)
    if (currentTheme === 'hell' && currentThemeBlock === 'hell_snowy') {
        snowyHellActive = true;
    }
}
updateSnowState(); // make sure snowflakes match
        
        // Update text color based on theme
        let textColor;
        switch (currentTheme) {
            case 'hell':
                textColor = '#00ff00'; // Matrix green for hell
                break;
            case 'desert':
            case 'paradise':
            case 'ruins':
                textColor = '#ff8c00'; // Orange for desert, paradise, and ruins
                break;
            default:
                textColor = '#ff8c00'; // Orange for dungeon
        }
        document.documentElement.style.setProperty('--text-color', textColor);
        // Force re-render of text color
        document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
            el.style.color = textColor;
        });
        // Reset enemy spawning variables
        enemies = [];
        enemiesSpawnedThisFloor = 0;
        whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
        initialSpawnDoneThisFloor = false;
        initialWaveSpawned = false;
        map = Array(H).fill().map(() => Array(W).fill(1));
        fogMap = Array(H).fill().map(() => Array(W).fill(0));
        rooms = [];
        satoshiDrops = [];
        runeDrops = []; // Clear rune drops on map, but keep p.runes, p.runewords, p.immortal
        scrollDrops = []; // Clear scroll drops
        portals = []; // Clear portals
        // Reset rune tracking
        currentRuneTile = null;

        function checkCurrentRuneTile() {
            if (map[p.y][p.x] === 9) {
                const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
                if (rune) {
                    const floorIndicator = document.getElementById('floor-indicator');
                    floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
                    currentRuneTile = { x: p.x, y: p.y };
                    return true;
                }
            }
            return false;
        }

        // Generate rooms
        let maxAttempts = 100;
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        maxAttempts = 50;
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap();
        }

        // Connect rooms with corridors
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r1.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }

        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;

// Place player
p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;
if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
   for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) {
       p.x = x; p.y = y;
       p.currentX = p.x * S; p.currentY = p.y * S;
       p.targetTileX = p.x; p.targetTileY = p.y;
       break;
    }
}
// Mark initial player area as explored
updateFogMap(p.x, p.y);

        // Place special tiles based on theme (pond, quicksand, lava)
        let specialPositions = [];
        if (currentTheme !== 'dungeon') {
            specialPositions = spawnItemWithChance(6, 0.5, 2, 5, true); // 50% chance, max 2 tiles
        }

        // Place Gnome with X% chance, only if no conflict with special tiles
        let gnomePositions = [];
        if (
            currentTheme === 'dungeon' || 
            currentTheme === 'desert' || 
            currentTheme === 'hell' || 
            currentTheme === 'paradise' || 
            specialPositions.length < 2
        ) {
            if (Math.random() < 0.1) { // 10% chance to spawn a gnome
                gnomePositions = spawnItemWithChance(7, 1.0, 1, 5, true);
                if (gnomePositions.length > 0) {
                } else {
                }
            } else {
            }
        } else {
        }

        /* -------------------------------------------------
           Place potions – 2 total, never in the same room
           ------------------------------------------------- */

        let potionPositions = [];                         // all potion coordinates
        let selectedRooms = rooms
            .sort(() => 0.5 - Math.random())              // random order
            .slice(0, Math.min(3, rooms.length));        // look at up to 3 rooms

        let proximityRange = 5;
        let potionsNeeded = 2;                             // how many potions are still missing

        for (let r of selectedRooms) {
            if (potionsNeeded <= 0) break;                // we already have 2

            let x, y, attempts = 100;

            // try to place **one** potion in this room
            while (attempts > 0 && potionsNeeded > 0) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);

                // empty tile, not the player, not too close to another potion
                if (
                    map[y][x] === 0 &&
                    (x !== p.x || y !== p.y) &&
                    !potionPositions.some(
                        p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange
                    )
                ) {
                    map[y][x] = 2;                        // place the potion
                    potionPositions.push({ x, y });
                    potionsNeeded--;                      // one potion placed
                    break;                                // stop – only one per room
                }

                attempts--;
            }

            // If we ran out of attempts in this room, warn and try again with a tighter range
            if (attempts === 0 && potionsNeeded > 0) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;                           // restart attempts for the same room
            }
        }

        // Place pickaxe (chance to drop a pickaxe)
        let pickaxePositions = [];
        if (Math.random() < 0.25) { // 25% chance to spawn a pickaxe
            pickaxePositions = spawnItemWithChance(4, 1.0, 1, 5, true);
            if (pickaxePositions.length > 0) {
            } else {
            }
        }    

// Place soul stash in the same room as player spawn (only on normal floors)
if (!inHideout) {
    const room = rooms[0]; // Player spawns in first room
    let stashX, stashY;
    let attempts = 100;
    
    // First priority: Spawn near player (2 tiles away)
    let foundNearPlayer = false;
    if (p.x >= 0 && p.y >= 0) {
        const possiblePositions = [];
        for (let dx = -2; dx <= 2; dx++) {
            for (let dy = -2; dy <= 2; dy++) {
                if (Math.abs(dx) + Math.abs(dy) === 2) { // Exactly 2 tiles away
                    const x = p.x + dx;
                    const y = p.y + dy;
                    if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] === 0) {
                        possiblePositions.push({x, y});
                    }
                }
            }
        }
        
        if (possiblePositions.length > 0) {
            const randomPos = possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
            stashX = randomPos.x;
            stashY = randomPos.y;
            foundNearPlayer = true;
        }
    }
    
    // If no near player position found, use original logic
    if (!foundNearPlayer) {
        do {
            stashX = room.x + Math.floor(Math.random() * room.w);
            stashY = room.y + Math.floor(Math.random() * room.h);
            attempts--;
        } while ((map[stashY][stashX] !== 0 || 
                 (stashX === p.x && stashY === p.y)) && attempts > 0);
    }
    
    if (attempts > 0 || foundNearPlayer) {
        map[stashY][stashX] = 19; // Soul stash tile
        soulStashPos = {x: stashX, y: stashY};
    } else {
        // Fallback to player position if no room space found
        if (map[p.y][p.x] === 0) {
            map[p.y][p.x] = 19; // Soul stash tile
            soulStashPos = {x: p.x, y: p.y};
        }
    }
}

// After placing soul stash, spawn soul orb statues
if (!inHideout && floor > 1) { // Don't spawn on floor 1 to avoid conflicts
	// Add soul orb statue spawning logic here
	function spawnSoulOrbStatue() {
		if (inHideout) return; // Don't spawn in hideout
		
		// 5% chance to spawn a soul orb statue
		if (Math.random() < 0.05) {
			let attempts = 0;
			const maxAttempts = 50;
			
			do {
				let x = Math.floor(Math.random() * W);
				let y = Math.floor(Math.random() * H);
				
				// Ensure it's a floor tile, not a wall, not occupied by player or items
				if (map[y][x] === 0 && 
					!(x === p.x && y === p.y) &&
					!enemies.some(e => e.x === x && e.y === y) &&
					!satoshiDrops.some(d => d.x === x && d.y === y) &&
					!runeDrops.some(r => r.x === x && r.y === y) &&
					!scrollDrops.some(s => s.x === x && s.y === y) &&
					!portals.some(p => p.x === x && p.y === y) &&
					Math.abs(x - p.x) > 2 && Math.abs(y - p.y) > 2) {
					
					map[y][x] = 21; // Soul orb statue tile
					return {x, y};
				}
				attempts++;
			} while (attempts < maxAttempts);
		}
	}
	spawnSoulOrbStatue();
}

// In the initMap function where items are placed, add shrine placement:
// Place shrine (20% chance, except in hideout), we now give out a shrine in the first floor
if (!inHideout && (floor === 1 || Math.random() < 0.20)) {
    let attempts = 0;
    const maxAttempts = 50;
    
    do {
        let x = Math.floor(Math.random() * W);
        let y = Math.floor(Math.random() * H);
        
        // Ensure it's a floor tile, not a wall, not occupied by player or items
        if (map[y][x] === 0 && 
            !(x === p.x && y === p.y) &&
            !enemies.some(e => e.x === x && e.y === y) &&
            !satoshiDrops.some(d => d.x === x && d.y === y) &&
            !runeDrops.some(r => r.x === x && r.y === y) &&
            !scrollDrops.some(s => s.x === x && s.y === y) &&
            !portals.some(p => p.x === x && p.y === y) &&
            Math.abs(x - p.x) > 2 && Math.abs(y - p.y) > 2) {
            
            map[y][x] = 22; // Shrine tile
            shrinePositions.push({x, y});
            break;
        }
        attempts++;
    } while (attempts < maxAttempts);
}

// 5% chance black cat spawn (once per floor) — NEVER in puzzle rooms
if (!inHideout && !inPuzzleRoom && Math.random() < 0.05) {
    let attempts = 50;
    do {
        const x = Math.floor(Math.random() * W);
        const y = Math.floor(Math.random() * H);
        if (map[y][x] === 0 && 
            !(x === p.x && y === p.y) && 
            Math.abs(x - p.x) > 3 && 
            Math.abs(y - p.y) > 3) {
            map[y][x] = 28; // Cat tile
            catPos = {x, y};
            catVisible = false; // Start invisible, fade in
            catAnimStart = performance.now();
            break;
        }
        attempts--;
    } while (attempts > 0);
}

// Initialize dangerous areas array for spells
dangerousAreas = [];

exit = null;

        initialWaveSpawned = false;
        needsRedraw = true;

        // Spawn Cursed Trader (25% chance from floor 2+)
        if (floor >= 2 && Math.random() < 0.25 && !inHideout) {
            let traderX, traderY, attempts = 50;
            do {
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                traderX = r.x + Math.floor(Math.random() * r.w);
                traderY = r.y + Math.floor(Math.random() * r.h);
                attempts--;
            } while (attempts > 0 && 
                     (map[traderY][traderX] !== 0 || 
                      (traderX === p.x && traderY === p.y) || 
                      enemies.some(e => e.x === traderX && e.y === traderY)));
            
            if (attempts > 0) {
                const newTrader = { 
                    x: traderX, y: traderY,
                    currentX: traderX * S, currentY: traderY * S,
                    moving: false, stepsLeft: 0, deltaX: 0, deltaY: 0,
                    targetTileX: 0, targetTileY: 0,
                    type: cursedTraderType,
                    hp: 12,
                    address: 'Cursed Trader',
                    sats: 0, // No sats
                    uniqueName: 'Cursed Trader', // Treat as unique for fog invisibility
                    swordActive: false, swordDir: 'right', swordStart: 0, // For sword animation
                    anim: { frameIndex: 0, lastFrameTime: performance.now() }
                };
                enemies.push(newTrader);
                logBattleEvent(`Floor ${floor} - Cursed Trader appears!`);
                needsRedraw = true;
            }
        }

        // Check runewords at floor start
        checkRunewordsAtFloorStart();

if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

function createSecretRoom(wx, wy, px, py, dir) {
    // Create a 3x3 room based on player's facing direction
    const roomSize = 3;
    let rx, ry;
    // Position room based on direction
    switch (dir) {
        case 'up':
            rx = wx;
            ry = wy - roomSize;
            break;
        case 'down':
            rx = wx;
            ry = wy + 1;
            break;
        case 'left':
            rx = wx - roomSize;
            ry = wy;
            break;
        case 'right':
            rx = wx + 1;
            ry = wy;
            break;
        default:
            console.error(`Invalid direction: ${dir}`);
            p.pickaxes++;
            logBattleEvent(`Floor ${floor} - Secret Room Failed: Invalid direction`);
            return;
    }
    // Check if room fits within map bounds
    if (rx < 1 || rx + roomSize > W - 1 || ry < 1 || ry + roomSize > H - 1) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): out of bounds`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Check if the 3x3 area is all walls
    let allWalls = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (map[y][x] !== 1) {
                allWalls = false;
                break;
            }
        }
        if (!allWalls) break;
    }
    if (!allWalls) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): not a 3x3 wall block`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No 3x3 wall block for secret room! Pickaxe refunded`);
        return;
    }
    // Validate room placement - allow overlap with existing rooms
    let valid = true;
    let overlappingRooms = 0;

    // Count how many existing rooms this new room overlaps with
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            // Check if any existing room overlaps with this tile
            rooms.forEach(r => {
                if (x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h) {
                    overlappingRooms++;
                }
            });
            
            // Check for conflicts (items, player, enemies)
            if (
                [2, 3, 4, 5].includes(map[y][x]) || // Items
                (x === px && y === py) || // Player
                enemies.some(e => e.x === x && e.y === y) // Enemies
            ) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
    }

    // If we have conflicts, but it's a valid 3x3 wall area, proceed anyway
    // (This allows for rooms that slightly overlap corridors)
    if (!valid && overlappingRooms > 0) {
        // Check specifically if the room can be placed in this location
        let canPlace = true;
        for (let y = ry; y < ry + roomSize; y++) {
            for (let x = rx; x < rx + roomSize; x++) {
                // Allow overlap with items, player, or enemies if they're not in the main area
                if (map[y][x] !== 0 && map[y][x] !== 1) { // Not a floor or wall
                    canPlace = false;
                    break;
                }
            }
            if (!canPlace) break;
        }
        valid = canPlace;
    }

    if (!valid) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): invalid placement (items, player, or overlap)`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Carve out the room
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            map[y][x] = 0;
        }
    }
    // Clear the broken wall
    map[wy][wx] = 0;
// Punch a non-directional hole (clear one adjacent tile)
const adjacent = [
    { x: wx - 1, y: wy }, // Left
    { x: wx + 1, y: wy }, // Right
    { x: wx, y: wy - 1 }, // Up
    { x: wx, y: wy + 1 }  // Down
].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] !== 0);

if (adjacent.length > 0) {
    const hole = adjacent[Math.floor(Math.random() * adjacent.length)];
    map[hole.y][hole.x] = 0;
}

// Carve a corridor to a nearby floor tile
let floorTiles = [];
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        if (map[y][x] === 0 && !(x === px && y === py) && !(x === wx && y === wy)) {
            floorTiles.push({ x, y });
        }
    }
}

if (floorTiles.length > 0) {
    floorTiles.sort((a, b) => {
        const distA = Math.abs(a.x - wx) + Math.abs(a.y - wy);
        const distB = Math.abs(b.x - wx) + Math.abs(b.y - wy);
        return distA - distB;
    });
    const target = floorTiles[0];
    let x = wx, y = wy;
    while (x !== target.x || y !== target.y) {
        if (Math.abs(target.x - x) > Math.abs(target.y - y)) {
            x += target.x > x ? 1 : -1;
        } else {
            y += target.y > y ? 1 : -1;
        }
        if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 0) {
            map[y][x] = 0;
        }
    }
} else {
    console.warn(`No floor tile found to connect secret room at (${wx}, ${wy})`);
}
    // Place armor in the center
    const armorX = rx + 1;
    const armorY = ry + 1;
    map[armorY][armorX] = 5;

    // place a diamond with 50 % chance
    const dirs = [
        {dx: -1, dy: 0},
        {dx:  1, dy: 0},
        {dx:  0, dy: -1},
        {dx:  0, dy:  1}
    ];
    dirs.sort(() => Math.random() - 0.5);
    for (const d of dirs) {
        const nx = armorX + d.dx;
        const ny = armorY + d.dy;
        if (
            nx >= 0 && nx < W &&
            ny >= 0 && ny < H &&
            map[ny][nx] === 0          // only on an empty floor tile
        ) {
            if (Math.random() < 0.25) {   // ← 25 % chance
                map[ny][nx] = 10;          // diamond tile
            }
            break;
        }
    }

// Show "Found Secret!" in Whale alert area and log success
const floorIndicator = document.getElementById('floor-indicator');
floorIndicator.textContent = `Found Secret!`;
logBattleEvent(`Floor ${floor} - Secret Room Created!`);
setTimeout(() => {
    floorIndicator.textContent = `Floor ${floor}`;
}, 5000);
updateFogMap(px, py);
needsRedraw = true;
}

// Modified updatePlayerState to ensure immortality works correctly
function updatePlayerState() {
if (gameOver) return; // Prevent spam calls post-death
if (p.hp <= 36 && p.hasDiamondArmor) {  // Tie to <= 36 HP
    p.hasDiamondArmor = false;
    p.hasArmor = true;
    p.armorImmunity = null; // Reset armor immunity
    p.maxHP = 36;  // Revert to leather max
    logBattleEvent(`Floor ${floor} - Diamond Armor lost! Found Leather Armor beneath.`);
    document.getElementById('armorStatus').textContent = 'Leather';
} else if (p.hp <= 24 && p.hasArmor) {
        p.hasArmor = false;
        p.armorImmunity = null; // Reset armor immunity
        p.maxHP = 24;  // Revert to base max
        // Also remove any cursed ring effects if active (no stacking with resistances)
        if (p.hasCursedRing) {
            p.elementImmunity = null;
        }
        logBattleEvent(`Floor ${floor} - Armor boost lost!`);
        document.getElementById('armorStatus').textContent = 'Cloth'; // Essential line
}

// ——— UI DISPLAY: ARMOR ———
if (p.hasDiamondArmor) {
    document.getElementById('armorStatus').textContent = 'Diamond';
}
else if (p.hasCursedRing) {
    document.getElementById('armorStatus').textContent = 'Cursed Aura';
}
else if (p.hasArmor) {
    document.getElementById('armorStatus').textContent = 'Leather';
}
else {
    document.getElementById('armorStatus').textContent = 'Cloth';
}

    // HODL immortality protection
    if (p.immortal && p.hp <= 0) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
    }

    // Sync wisp HP to half player HP and check for death (all damage types)
    if (wisps.length > 0) {
        const wisp = wisps[0];
        wisp.hp = Math.floor(p.hp / 2);
        wisp.maxHP = Math.floor(p.maxHP / 2);
        if (wisp.hp <= 0) {
            wisps = [];
            logBattleEvent(`Floor ${floor} - Wisp perishes!`);
            sounds.gameover.currentTime = 0;
            sounds.gameover.play().catch(e => console.error('Wisp death sound error:', e));
            deadWispCorpse = {
                x: wisp.x, y: wisp.y,
                frameIndex: wisp.anim.frameIndex,
                fadeStart: Date.now()
            };
        }
    }

    // Wisp low-fi danger voice (8 HP or less)
    if (p.hp <= 8 && wisps.length > 0) {
        staticWispDangerSpoken = false; // reset flag
    }
    if (p.hp <= 8 && wisps.length > 0 && !staticWispDangerSpoken) {
        wispSpeak('danger');
        staticWispDangerSpoken = true; // speak only once per low-HP event
    }

    // Restore music when healing above 8 HP (after danger voice ducked it)
    if (p.hp > 8 && wisps.length > 0) {
        if (musicManager.current && !musicMuted) {
            musicManager.audios[musicManager.current].volume = musicManager.volume;
        }
        staticWispDangerSpoken = false; // reset so it can speak again next time
    }

    // Check if player is on blacksmith tile and can get diamond armor or diamond hand
    if (map[p.y][p.x] === 15 && p.perfectlyCutDiamonds > 0) {
        if (!p.hasDiamondArmor) {
            p.hasDiamondArmor = true;
            p.perfectlyCutDiamonds--;
            p.maxHP = 1000;  // Set diamond max
            p.hp = Math.min(p.hp, p.maxHP);  // Cap at new max
            logBattleEvent(`Floor ${floor} - Diamond Armor acquired from Blacksmith!`);
            document.getElementById('armorStatus').textContent = 'Diamond';
        } else if (!p.hasDiamondHand) {
            p.hasDiamondHand = true;
            p.perfectlyCutDiamonds--;
            p.atk = 3; // Increase attack power for diamond hand
            logBattleEvent(`Floor ${floor} - Diamond Hand acquired from Blacksmith!`);
        }
    }

    // Check if player lost diamond armor and should lose diamond hand
    if (!p.hasDiamondArmor && p.hasDiamondHand) {
        p.hasDiamondHand = false;
        logBattleEvent(`Floor ${floor} - Diamond Hand lost! Back to normal sword.`);
        p.atk = 2; // Reset attack power
    }

    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('diamonds').textContent = diamonds;
    document.getElementById('perfectlyCutDiamonds').textContent = p.perfectlyCutDiamonds;
    document.getElementById('resonance').textContent = `${soulResonance}%`;
    
    // Add soul items to display
    if (p.inSoulTerminal) {
        // In terminal, update both regular and soul inventory
        document.getElementById('runes').textContent = p.runes.join(' ');
    }

    // Regenerate aura shield (1 per "turn" - every 64 moves) - separate from shrine
    if (p.hasCursedRing && p.auraMoveCounter >= 64 && p.auraShield < p.auraMax && p.lastAuraRefillMove !== p.auraMoveCounter) {
        p.auraShield = Math.min(p.auraMax, p.auraShield + 1);
        p.lastAuraRefillMove = p.auraMoveCounter; // Track last refill move to prevent spam
        p.auraMoveCounter = 0;  // Reset aura counter after refill
        logBattleEvent(`Floor ${floor} - Cursed Aura regenerates +1 (now ${p.auraShield}/${p.auraMax})`);
    }

    // Break ring if aura depleted
    if (p.hasCursedRing && p.auraShield <= 0) {
        p.hasCursedRing = false;
        p.auraMax = 0;
        p.auraShield = 0;
        // Keep curseActive true until pond dispel
        // Restore a random immunity
        const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
        p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];
        logBattleEvent(`Floor ${floor} - Cursed Ring shattered! HP unchanged at ${p.hp}/${p.maxHP}. Gained ${p.elementImmunity} immunity.`);
    }

    // Centralized death check (immortal + resonance + normal)
    if (p.hp <= 0 && !gameOver) {
        if (p.immortal) {
            p.hp = 1;
            logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
        } else if (soulResonance >= 100 && !resonanceTriggeredThisRun) {
            // Resonance Surge: One-time resurrection
            resonanceTriggeredThisRun = true;
            soulResonance = 0; // Consume meter
            p.hp = 100;
            p.hasArmor = true; // Leather armor
            p.maxHP = 36; // Leather max
            p.soulStormCharges = 256;
            // Clear all enemies (with drops, like RIP)
            enemies.forEach(enemy => {
                kills[enemy.type.name]++;
                if (enemy.type.name !== 'Cursed Trader' && !enemy.uniqueName) {
                    // Drop sats (simplified)
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 3;
                        satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                    }
                }
                handleUniqueMonsterReward(enemy); // Handle uniques
            });
            enemies = []; // Wipe enemies
        // Place Echo Warden directly on player's death spot
        const wx = p.x;
        const wy = p.y;
        echoWardenPos = {x: wx, y: wy};
        map[wy][wx] = 24; // New tile type for warden
            // Effects
            playWebAudioSound(sounds.rune); // Rune sound
            logBattleEvent(`Floor ${floor} - Resonance Surge! Echo Warden descends—enemies vanquished, HP restored to 100, leather armor granted, soul charges maxed.`);
            updateSatsDisplay();
            needsRedraw = true;
            // Trigger 500ms invert flash on warden entry
            wardenFlashStart = Date.now();
                    gameOver = false; // Force reset if spell/attack overrode
        //console.log('DEBUG: Post-surge force - HP:', p.hp, 'gameOver:', gameOver); // Remove after test
        } else {
            // Normal death
            p.hp = 0;
            diamonds = 0;

            // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
            // NEW: Lose the farm when you die
            if (p.farmLocked) {
                logBattleEvent(`Floor ${floor} - Your farm withered... all planted SATS lost forever.`);
                p.farmLocked = false;
                p.farmLockedFloor = 0;
                p.farmLockedSats = 0;
            }
            // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←

            logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
            gameOver = true; // Centralized set
            updatePlayerState(); // Run death/resonance check
            // 2s input lock
            inputBlocked = true;
            setTimeout(() => { inputBlocked = false; }, 1000);
        }
    }

    needsRedraw = true;
}  // ← Add this closing brace here (end of function)

function updateFogMap(px, py) {
    const radius = 3; // Visibility radius
    
    // Quick optimization: Only process tiles within radius and visible from player
    const start_x = Math.max(0, px - radius);
    const end_x = Math.min(W, px + radius + 1);
    const start_y = Math.max(0, py - radius);
    const end_y = Math.min(H, py + radius + 1);
    
    // Track newly visible Shrimps
    const newlyVisibleShrimps = [];
    for (let y = start_y; y < end_y; y++) {
        for (let x = start_x; x < end_x; x++) {
            const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (dist <= radius) {
                // Simple line-of-sight check for performance
                const hasLOS = true; // Simplified for performance
                if (hasLOS && fogMap[y][x] !== 1) { // Tile was not previously explored
                    fogMap[y][x] = 1; // Mark as explored
                    // Check for Shrimp at this position
                    const shrimp = enemies.find(e => e.x === x && e.y === y && e.type.name === 'Shrimp' && currentTheme === 'hell');
                    if (shrimp) {
                        newlyVisibleShrimps.push(shrimp);
                    }
                }
            }
        }
    }
    // Log evolution for newly visible Shrimps
    if (newlyVisibleShrimps.length > 0) {
        logBattleEvent(`Floor ${floor} - Shrimp evolves to Hell Shrimp!`);
    }
}

let lastKeyMoveTime = 0; // Track last keyboard move time
let pendingKeyDir = null; // Track latest keyboard direction
let isKeyHeld = false; // Track if a key is held
let enemiesSpawnedThisFloor = 0;
let uniqueMonstersSpawnedThisFloor = 0; // Track unique monsters spawned this floor
let scrollDroppedThisFloor = false; // Track if a scroll has dropped on this floor
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 30000; // 30 seconds

function shouldSpawn() {
  // If we are in hideout, or we have just stepped into it, abort.
  return !inHideout;
}

async function fetchTxs() {
    if (gameOver || splashActive || floor === 0 || inHideout || screensaverActive) {
        console.log(`Skipping fetchTxs: gameOver=${gameOver}, splashActive=${splashActive}, floor=${floor}, inHideout=${inHideout}, screensaverActive=${screensaverActive}`);
        return;
    }
    
    // Prevent duplicate calls
    if (isFetchingTxs) {
        console.log('fetchTxs: Already running, skipping');
        return;
    }
    
    isFetchingTxs = true; // Set flag
    
    const now = Date.now();
    // Prevent duplicate calls within API_INTERVAL
    if (nextApiCallTime && now < nextApiCallTime) {
        console.log(`fetchTxs: Already scheduled, skipping`);
        isFetchingTxs = false;
        return;
    }
    
    // Prevent concurrent calls to the same function
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }
    
    try {
        console.log(`fetchTxs: floor=${floor}, wave=${wave}, enemiesSpawnedThisFloor=${enemiesSpawnedThisFloor}, initialSpawnDoneThisFloor=${initialSpawnDoneThisFloor}, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}, enemies=${enemies.length}`);
        await new Promise(resolve => setTimeout(resolve, 25));
        
        // Check if we're still in the right state before making API call
        if (gameOver || splashActive || floor === 0 || inHideout) {
            console.log(`fetchTxs: State changed during API call, aborting`);
            return;
        }
        
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }
        
        // *** NEW *** Abort early if we have stepped into hideout while the request was still processing.
        if (!shouldSpawn()) {
          console.log('Player entered hideout while fetchTxs was in progress. Aborting enemy spawn.');
          return;
        }
        
        let enemyCount = 0;
        const processedTxids = new Set();
        console.warn(`[WHALE ATTEMPT] Checking ${res.data.length} transactions for Whale spawns (> 100 BTC)`);
        
        for (const tx of res.data.slice(0, 10)) {
          // *** NEW *** Stop the loop if hideout has been entered during this loop.
          if (!shouldSpawn()) {
            console.log('Player entered hideout. Stopping spawn loop.');
            break;
          }
          
          if (processedTxids.has(tx.txid)) continue;
          processedTxids.add(tx.txid);
          
          let value = 0;
          let address = 'Invalid address';
          try {
              await new Promise(resolve => setTimeout(resolve, 25));
              const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
              if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                  value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                  address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
              } else {
                  continue;
              }
          } catch (e) {
              continue;
          }
          
          if (value <= 0) {
              continue;
          }
          
          const btc = value / 1e8;
          const type = types.find(t => btc > t.min && btc <= t.max);
          if (!type) {
              continue;
          }

          // Handle initial spawn (up to 10 enemies, including Whales)
          if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10 && enemies.length < 10) {
              if (type.name !== 'Whale' && exit) {
                  continue;
              }
              //console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`);
              console.log('Initial Spawn Tx: Checking 10 transactions for Enemies spawns'); // less bloat means win in the long run
              const r = rooms[Math.floor(Math.random() * rooms.length)];
              let x, y, attempts = 50;
              const auraRadius = 2; // 5x5 grid
              let validPosition = false;
              do {
                  x = r.x + Math.floor(Math.random() * r.w);
                  y = r.y + Math.floor(Math.random() * r.h);
                  validPosition = (
                      map[y][x] === 0 &&
                      !(x === p.x && y === p.y) &&
                      !enemies.some(e => e.x === x && e.y === y) &&
                      Math.abs(x - p.x) > auraRadius &&
                      Math.abs(y - p.y) > auraRadius
                  );
                  attempts--;
              } while (attempts > 0 && !validPosition);
              
              const newEnemy = {
                 x,
                 y,
                  currentX: x * S,
                  currentY: y * S,
                  moving: false,
                  stepsLeft: 0,
                  deltaX: 0,
                  deltaY: 0,
                  targetTileX: 0,
                  targetTileY: 0,
                 type,
                 hp: type.name === 'Shrimp' && currentTheme === 'hell' ? 3 : type.hp,
                 address,
                 sats: Math.round(btc * 1e8),
                 anim: {
                     frameIndex: Math.floor(Math.random() * type.anim.frames.length),
                     lastFrameTime: performance.now()
                 },
                 // Bit ammo (normal enemies always have 2)
                 bits: 2,
                 bitAmmo: 2,
                 lastBitShot: 0,
                 shieldFlash: { active: false, startTime: 0 } // for bit shield visual
              };
    
// I am starting to think 10% chance to spawn an unique monster actually means per regular enemy spawned (10%,10%,10%,10%,10%,10%,10%,10%,10%,10% instead of just 10%)
if (floor > 1 && Math.random() < 0.10) {
    const randomUniqueName = uniqueMonsterNames[type.name][Math.floor(Math.random() * uniqueMonsterNames[type.name].length)];
    // Check if we've already spawned a unique monster of this type on this floor
    const hasUniqueSpawned = enemies.some(e => e.uniqueName && 
        e.uniqueName.includes(type.name) && 
        !e.uniqueName.includes('Shrimp') || // Allow multiple Shrimp types
        (type.name === 'Shrimp' && e.type.name === 'Shrimp'));
    
    if (!hasUniqueSpawned && uniqueMonstersSpawnedThisFloor < 1) {
        const isUnique = true; // ← THIS WAS MISSING
        newEnemy.uniqueName = randomUniqueName;
        // Make unique monster stronger
        newEnemy.atk = type.atk * 2;
        newEnemy.hp = type.hp * 2;
        
        // Assign a spell to this unique monster
        const spell = assignUniqueMonsterSpell(newEnemy);
        
        // Play unique monster sound on first spawn of this type
        playUniqueMonsterSound(randomUniqueName);        
        
        // Harbinger message handled in draw() for fog visibility only
logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${btc.toFixed(2)} BTC`); // Generic spawn log
        uniqueMonstersSpawnedThisFloor++;
        
// Add bit ammo for uniques
        newEnemy.bits = 4;
        newEnemy.bitAmmo = 4;
        newEnemy.lastBitShot = 0;
    } else {
        const isUnique = false; // ← normal enemy
        const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
        logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
// Add bit ammo for normal enemies
        newEnemy.bits = 2;
        newEnemy.bitAmmo = 2;
        newEnemy.lastBitShot = 0;
    }
} else {
    const isUnique = false; // ← normal enemy
    const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
    logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
// Add bit ammo for normal enemies
        newEnemy.bits = 2;
        newEnemy.bitAmmo = 2;
        newEnemy.lastBitShot = 0;
}
          
              if (!validPosition) {
                  // Fallback: try any floor tile in any room
                  for (let r of rooms) {
                      for (let y = r.y; y < r.y + r.h; y++) {
                          for (let x = r.x; x < r.x + r.w; x++) {
                              if (
                                  map[y][x] === 0 &&
                                  !(x === p.x && y === p.y) &&
                                  Math.abs(x - p.x) > auraRadius &&
                                  Math.abs(y - p.y) > auraRadius &&
                                  !enemies.some(e => e.x === x && e.y === y)
                              ) {
                                  newEnemy.x = x;
                                  newEnemy.y = y;
                                  newEnemy.currentX = newEnemy.x * S;
                                  newEnemy.currentY = newEnemy.y * S;
                                  newEnemy.targetTileX = newEnemy.x;
                                  newEnemy.targetTileY = newEnemy.y;
                                  
                                  validPosition = true;
                                  break;
                              }
                          }
                          if (validPosition) break;
                      }
                      if (validPosition) break;
                  }
              }
              
              if (!validPosition) {
                  console.log(`No valid spawn position found for tx ${tx.txid}, skipping`);
                  continue;
              }
              
              // *** NEW *** Check again before pushing the new enemy.
              if (!shouldSpawn()) {
                console.log('Player entered hideout. Skipping enemy spawn.');
                continue;
              }
              
              enemies.push(newEnemy);
              const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
              logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
              enemiesSpawnedThisFloor++;
              enemyCount++;
              
              if (type.name === 'Whale') {
                  console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                  logWhaleHashId(tx.txid);
                  document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                  setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
              }
              
              if (enemiesSpawnedThisFloor >= 10) {
                  initialSpawnDoneThisFloor = true;
              }
          } else if (type.name === 'Whale') {
              console.log(`[WHALE SPAWN ATTEMPT] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}`);
              const r = rooms[Math.floor(Math.random() * rooms.length)];
              let x, y, attempts = 50;
              const auraRadius = 2; // 5x5 grid
              let validPosition = false;
              do {
                  x = r.x + Math.floor(Math.random() * r.w);
                  y = r.y + Math.floor(Math.random() * r.h);
                  validPosition = (
                      map[y][x] === 0 &&
                      !(x === p.x && y === p.y) &&
                      !enemies.some(e => e.x === x && e.y === y) &&
                      Math.abs(x - p.x) > auraRadius &&
                      Math.abs(y - p.y) > auraRadius
                  );
                  attempts--;
              } while (attempts > 0 && !validPosition);
              
              if (!validPosition) {
                  // Fallback: try any floor tile in any room
                  for (let r of rooms) {
                      for (let y = r.y; y < r.y + r.h; y++) {
                          for (let x = r.x; x < r.x + r.w; x++) {
                              if (
                                  map[y][x] === 0 &&
                                  !(x === p.x && y === p.y) &&
                                  Math.abs(x - p.x) > auraRadius &&
                                  Math.abs(y - p.y) > auraRadius &&
                                  !enemies.some(e => e.x === x && e.y === y)
                              ) {
                                  x = x;
                                  y = y;
                                  validPosition = true;
                                  break;
                              }
                          }
                          if (validPosition) break;
                      }
                      if (validPosition) break;
                  }
              }
              
              if (!validPosition) {
                  console.log(`No valid spawn position found for Whale tx ${tx.txid}, skipping`);
                  continue;
              }
              
              if (type.name === 'Whale' && whalesSpawnedThisFloor >= 10) {
                  console.log(`Whale spawn skipped: reached cap of 10 Whales on floor ${floor}`);
                  continue;
              }
              
              const newEnemy = { x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8),
                   anim: {
                       frameIndex: Math.floor(Math.random() * type.anim.frames.length),
                       lastFrameTime: performance.now()
                   },
                   bits: 2,
                   bitAmmo: 2,
                   lastBitShot: 0,
                   shieldFlash: { active: false, startTime: 0 } // for bit shield visual
                 };

              enemies.push(newEnemy);
              
              if (type.name === 'Whale') {
                  whalesSpawnedThisFloor++; // Increment Whale counter
              }
              
              const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
              logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
              console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
              logWhaleHashId(tx.txid);
              document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
              setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
              enemyCount++;
          }
        }
        
        // Apply RIP blast to all on-screen enemies if active
        if (p.ripBlast && enemies.length > 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast annihilates all enemies!`);
            playWebAudioSound(sounds.hit);
            ripBlastActive = true; // Set flag for firestorm effect
            ripBlastStartTime = Date.now();
            enemies.forEach(enemy => {
                enemy.hp = 0; // Instant kill
                handleUniqueMonsterReward(enemy);
                kills[enemy.type.name]++;
if (enemy.type.name === 'Cursed Trader') {
        dropSoulStone(enemy.x, enemy.y);
    }
                logBattleEvent(`Floor ${floor} - ${enemy.type.name} destroyed!`);
let dropPlaced = false;

// Skip bitcoin drop for uniques/Cursed Trader
if (!enemy.uniqueName && enemy.type.name !== 'Cursed Trader') {
    if (map[enemy.y][enemy.x] === 0) {
        map[enemy.y][enemy.x] = 3;
        satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
        dropPlaced = true;
    } else {
        const adjacent = [
            {x: enemy.x, y: enemy.y - 1},
            {x: enemy.x, y: enemy.y + 1},
            {x: enemy.x - 1, y: enemy.y},
            {x: enemy.x + 1, y: enemy.y}
        ];
        for (const pos of adjacent) {
            const nx = pos.x, ny = pos.y;
            if (
                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                map[ny][nx] === 0 &&
                !enemies.some(e => e.x === nx && e.y === ny)
            ) {
                map[ny][nx] = 3;
                satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                dropPlaced = true;
                break;
            }
        }
    }
} else if (enemy.type.name === 'Cursed Trader') {
    // Explicit no-drop for Cursed Trader (prevents visual bitcoin.png glitch)
    dropPlaced = false;
}

                // Cursed Ring drop (50% for Cursed Trader only, even in blast)
                if (enemy.type.name === 'Cursed Trader' && Math.random() < 0.5 && !p.hasCursedRing) {
                    let ringPlaced = false;
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 23; // Cursed ring tile
                        ringPlaced = true;
                    } else {
                        const adjacent = [
                            { x: enemy.x, y: enemy.y - 1 },
                            { x: enemy.x, y: enemy.y + 1 },
                            { x: enemy.x - 1, y: enemy.y },
                            { x: enemy.x + 1, y: enemy.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 23; // Cursed ring tile
                                ringPlaced = true;
                                break;
                            }
                        }
                    }
                    if (ringPlaced) {
                        logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                        playWebAudioSound(sounds.pickup);
                    }
                }
                
                // Rune drop logic (20% for Hell Shrimp, 10% for others)
                if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                        const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 8;
                        runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: enemy.x, y: enemy.y - 1 },
                            { x: enemy.x, y: enemy.y + 1 },
                            { x: enemy.x - 1, y: enemy.y },
                            { x: enemy.x + 1, y: enemy.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8;
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
            });
            
const deadEnemies = enemies.filter(e => e.hp <= 0);
enemies = enemies.filter(e => e.hp > 0);
deadEnemies.forEach(dead => enemyBgFrameTimes.delete(dead)); // Clear bg tracking for dead
            // Delay stairs placement until fire wave animation completes
            if (enemies.length === 0 && !exit && waveActive) {
                // Stairs will be placed in draw() after animation completes
            }
            p.ripBlast = false; // Disable blast after use
            needsRedraw = true;
        } else if (p.ripBlast && enemies.length === 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast activated but no enemies to destroy!`);
            // Delay stairs placement until fire wave animation completes
            p.ripBlast = false; // Consume RIP even if no enemies
            needsRedraw = true;
        }
        
        if (enemyCount > 0 && enemies.length > 0 && !exit) {
            if (!waveActive) {
                initialWaveSpawned = true;
                waveActive = true;
                document.getElementById('wave').textContent = wave;
                logBattleEvent(`Floor ${floor} - Wave ${wave} Started!`);
                console.log(`New wave started: wave=${wave}, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
            } else {
                console.log(`Additional enemies added to wave ${wave}, enemies=${enemies.length}, waveActive=${waveActive}`);
            }
            needsRedraw = true;
        } else {
            console.log(`No enemies spawned, wave=${wave}, scheduling retry in ${API_INTERVAL / 1000}s`);
        }
        
} catch (e) {
    console.error('fetchTxs Error:', e, e.stack);
} finally {
    // Set next API call time after successful execution
    nextApiCallTime = now + API_INTERVAL;
    apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    isFetchingTxs = false; // Clear flag when done
}
}

function isSolid(x, y) {
    return map[y][x] === 1 || map[y][x] === 13; // Standard walls and diamond walls
}

function move(dir) {
    if (gameOver || splashActive || inputBlocked) return;
    
    // Check if player is in hideout and trying to pause from waypoint tile
    if (inHideout && map[p.y][p.x] === 16) {
        // Allow pausing when on waypoint in hideout
        // This is handled by the existing logic but we want to ensure it works properly
    }

    // Save previous position for boulder pushing
    if (!p.previousX) p.previousX = p.x;
    if (!p.previousY) p.previousY = p.y;

    swordDir = dir;
    let nx = p.x, ny = p.y;
    
// === BLOCK MOVEMENT ON HAZARDS IN PUZZLE ROOMS ===
    if (inPuzzleRoom) {
        const hazardTile = map[ny] && map[ny][nx] === 6;
        if (hazardTile) {
            return; // Cannot walk on lava/quicksand/pond
        }
    }
    
    let newDirection = p.anim.direction;

    if (dir === 'up') { ny--; newDirection = 'back'; }
    if (dir === 'down') { ny++; newDirection = 'front'; }
    if (dir === 'left') { nx--; newDirection = 'left'; }
    if (dir === 'right') { nx++; newDirection = 'right'; }

// In the move function, after updating position:
p.moveCounter++;
p.auraMoveCounter++;
if (p.moveCounter >= 2) {
    if (p.shrineCharges > 0) {
        p.hp++;
        p.shrineCharges--;
        // Log only every 8 charges spent to reduce spam
        if ((p.maxShrineCharges - p.shrineCharges) % 8 === 0) {
            logBattleEvent(`Floor ${floor} - Shrine refills health! (${p.shrineCharges}/${p.maxShrineCharges})`);
        }
    }
    p.moveCounter = 0;  // Reset only shrine counter
    updatePlayerState();  // Call every 2 moves (shrine tick) to check aura too
}

    // === VALIDATE MOVE + BOULDER PUSHING (L2 style) ===
    if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
        p.anim.direction = newDirection;
        needsRedraw = true;
        return;
    }

    // Block walls
    if (isSolid(nx, ny)) {
        p.anim.direction = newDirection;
        needsRedraw = true;
        return;
    }

// ———————————————————————————————————————
// PUZZLE ROOM: BOULDER & LAVA LOGIC (FINAL – NO BLACK TILES)
// ———————————————————————————————————————
if (inPuzzleRoom) {
    const targetTile = map[ny][nx];

    // 1. Raw lava (no boulder) → blocked
    if (targetTile === 6 && !puzzleBoulders.some(b => b.x === nx && b.y === ny)) {
        p.anim.direction = newDirection;
        needsRedraw = true;
        return;
    }

    // 2. There is a boulder on the target tile
    if (puzzleBoulders.some(b => b.x === nx && b.y === ny)) {
        const boulder = puzzleBoulders.find(b => b.x === nx && b.y === ny);

        // 2a. Boulder on lava → walkable bridge
        if (puzzleHazards.some(h => h.x === nx && h.y === ny)) {
            // do nothing — player walks on bridge
        }
        // 2b. Boulder is pushable
        else {
            const pushX = nx + (dir === 'right' ? 1 : dir === 'left' ? -1 : 0);
            const pushY = ny + (dir === 'down' ? 1 : dir === 'up' ? -1 : 0);

            // Sacred blocks
            if (puzzleChest && pushX === puzzleChest.x && pushY === puzzleChest.y) return;
            if (puzzleHeartFramers.some(h => h.x === pushX && h.y === pushY)) return;

            if (pushX >= 0 && pushX < W && pushY >= 0 && pushY < H) {
                if (map[pushY][pushX] === 6) {
                    // ——— SINK INTO LAVA ———
                    const oldX = boulder.x;
                    const oldY = boulder.y;

                    // Remove boulder + lava
                    map[oldY][oldX] = 0;
                    map[pushY][pushX] = 0;
                    puzzleBoulders = puzzleBoulders.filter(b => b !== boulder);
                    puzzleHazards = puzzleHazards.filter(h => h.x !== pushX || h.y !== pushY);

                    // Patch BOTH tiles in static canvas → floor
                    patchStaticCanvas(oldX, oldY);
                    patchStaticCanvas(pushX, pushY);

                    // Flash effect
                    highlightTiles.push({x: oldX, y: oldY, highlightStart: Date.now(), color: 'rgba(120,120,120,0.7)'});
                    highlightTiles.push({x: pushX, y: pushY, highlightStart: Date.now(), color: 'rgba(255,100,0,0.9)'});

                    logBattleEvent("Boulder sinks and cools into permanent stone!");
                    playWebAudioSound(sounds.lava);
                }
                else if (map[pushY][pushX] === 0) {
                    // ——— NORMAL PUSH ———
                    const oldX = boulder.x;
                    const oldY = boulder.y;

                    // Patch old position
                    patchStaticCanvas(oldX, oldY);

                    // Move boulder
                    map[oldY][oldX] = 0;
                    map[pushY][pushX] = 26;
                    boulder.x = pushX;
                    boulder.y = pushY;
                }
                else {
                    p.anim.direction = newDirection;
                    needsRedraw = true;
                    return;
                }

                needsRedraw = true;
                return;
            }
        }
    }
}

// Save previous position for next frame's push detection
p.previousX = p.x;
p.previousY = p.y;

    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return; // Don't start animation
    }

    if (enemies.some(e => e.x === nx && e.y === ny)) {
        p.anim.direction = newDirection; // Update direction for rendering
        needsRedraw = true;
        return; // Don't start animation
    }

    // Update direction and position (will be interpolated during draw)
    p.anim.direction = newDirection;
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        // Set target position for animation but don't update immediately
        // Actual position will be updated during interpolation in draw()
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
// Cap animation updates to 10 FPS (100ms - doubled interval)
if (now - p.anim.lastFrameTime >= 50) { // 10 FPS capped
    p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
    p.anim.lastFrameTime = now;
}
} else {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = performance.now();
    }
    }
    
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    
    // Always update direction for rendering, even if blocked by enemy
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        needsRedraw = true; // Ensure redraw to reflect new direction
        return;
    }
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        // Actual position update will happen during interpolation in draw()
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
    // Cap animation updates to 20 FPS (50ms)
    if (now - p.anim.lastFrameTime >= 50) { // 20 FPS capped
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
} else {
            p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
            p.anim.lastFrameTime = performance.now();
        }
    }
    
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    
    // Always update direction for rendering, even if blocked by enemy
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        needsRedraw = true; // Ensure redraw to reflect new direction
        return;
    }
    
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
    
const oldX = p.x;
const oldY = p.y;
p.startX = p.x; // Track actual start for lerp
p.startY = p.y;
p.x = nx;
p.y = ny;

        // ——— SMOOTH WARDEN MIRROR: Interpolates between tiles ———
        if (floor === 1 && echoWardenPos && p.echoWardenBlessingGiven) {
            const oldWX = echoWardenPos.x;
            const oldWY = echoWardenPos.y;

            // Opposite direction
            let newWX = echoWardenPos.x - (nx - oldX);
            let newWY = echoWardenPos.y - (ny - oldY);

            // Clamp bounds
            newWX = Math.max(0, Math.min(W - 1, newWX));
            newWY = Math.max(0, Math.min(H - 1, newWY));

            // Valid target?
            if (map[newWY][newWX] === 0 || (newWX === p.x && newWY === p.y)) {
                // Clear old tile
                map[oldWY][oldWX] = 0;

                // Start smooth move (8 steps, 2px/step like enemies)
                echoWardenPos.targetX = newWX * S;
                echoWardenPos.targetY = newWY * S;
                echoWardenPos.deltaX = (newWX - oldWX) * 2;
                echoWardenPos.deltaY = (newWY - oldWY) * 2;
                echoWardenPos.stepsLeft = 8;
                echoWardenPos.moving = true;
                echoWardenPos.x = newWX;
                echoWardenPos.y = newWY;

                // Set new tile
                map[newWY][newWX] = 24;
            }

            needsRedraw = true;
        }

p.targetTileX = nx;
p.targetTileY = ny;
p.deltaX = (nx - oldX) * 2;
p.deltaY = (ny - oldY) * 2;
p.stepsLeft = 8;
p.moving = true;
p.anim.direction = newDirection;
    p.moveStartTime = performance.now(); // Track start for smooth lerp
    p.moveDuration = 200; // ms per tile (tune for feel)

// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
    // Half speed animation during movement (10 FPS)
    if (now - p.anim.lastFrameTime >= 50) {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
}

        // Apply spell damage when moving onto dangerous areas
        applySpellDamage(p.x, p.y);

        // Standing still on a dangerous tile still hurts!
        if (dangerousAreas.some(area => area.x === p.x && area.y === p.y)) {
            applySpellDamage(p.x, p.y);
        }
        
        if (map[ny][nx] === 2) { 
            p.potions++; 
            map[ny][nx] = 0; 
            playWebAudioSound(sounds.pickup);
        }
        
if (map[ny][nx] === 6 && !inHideout) {
            if (currentTheme === 'paradise') {
    if (p.hasCursedRing || p.curseActive) {
        p.hasCursedRing = false;
        p.curseActive = false;
        p.auraMax = 0;
        p.auraShield = 0;
        p.armorImmunity = null;
        logBattleEvent(`Floor ${floor} - Pond dispels Cursed Aura! Resistances restored.`);
        playWebAudioSound(sounds.pond);
        // Restore a random immunity
        const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
        p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];
    }
    // Only restore HP if we're below the threshold
        if (p.hp < 24) {  // Or use p.hp < 36 if that's your desired cutoff
            const oldHP = p.hp;
            p.hp = 24 + (p.hasArmor ? 12 : 0); // Full health (24 or 36 with armor)
            logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
            playWebAudioSound(sounds.pond);
        }
        // Additional condition for armor users with less than 36 HP
        else if (p.hasArmor && p.hp < 36) {
            const oldHP = p.hp;
            p.hp = 36; // Fill up to 36 HP for armor-wearing players
            logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
            playWebAudioSound(sounds.pond);
        }
    }            
            // If p.hp > 36, do nothing and continue
            
            // Desert – Sludge pit
            if (currentTheme === 'desert') {
                // Check for poison immunity
                if (p.elementImmunity === 'Poison' || p.armorImmunity === 'Poison') {
                    logBattleEvent(`Floor ${floor} - Sludge Pit: Immune to Poison damage!`);
} else {
    const damage = p.hasCursedRing ? 4 : 2;
    p.hp = Math.max(0, p.hp - damage);
    logBattleEvent(`Floor ${floor} - Sludge Pit: -${damage} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hit);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;                // ← reset diamonds
                        updatePlayerState();          // ← update display
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    }
                }
            }

            // Hell – Lava
            if (currentTheme === 'hell') {
                // Check for fire immunity
                if (p.elementImmunity === 'Fire' || p.armorImmunity === 'Fire') {
                    logBattleEvent(`Floor ${floor} - Lava: Immune to Fire damage!`);
} else {
    const damage = p.hasCursedRing ? 16 : 8;
    p.hp = Math.max(0, p.hp - damage);
    logBattleEvent(`Floor ${floor} - Lava: -${damage} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hit);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;
                        updatePlayerState();
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    }
                }
            }

            // Ruins – Falling into a hole
            if (currentTheme === 'ruins') {
                if (p.hp === 1) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Fell into Hole: Hero Fell! Reached Floor ${floor}`);
                    playWebAudioSound(sounds.hole);
                    updatePlayerState(); // Run death/resonance check
                } else {
                    const oldHP = p.hp;
                    p.hp = Math.ceil(p.hp / 2);
                    logBattleEvent(`Floor ${floor} - Fell into Hole: -${oldHP - p.hp} HP (now ${p.hp})`);
                    playWebAudioSound(sounds.hole);
                    if (p.hp <= 0 && p.immortal) {
                        p.hp = 1;
                        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                    } else if (p.hp <= 0) {
                        p.hp = 0;
                        diamonds = 0;
                        updatePlayerState();
                        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    }
                }
            }

            updatePlayerState();
        }
        
if (map[ny][nx] === 7) {
    if (p.curseActive) {
        logBattleEvent(`Floor ${floor} - Gnome refuses: Lingering curse blocks extra life!`);
        playWebAudioSound(sounds.buzz);
        p.potions = 0;
        map[ny][nx] = 0;
        updatePlayerState();
        return;  // Skip coin toss
    }
    const coinToss = Math.random() < 0.5; // 50/50 chance
    if (coinToss) {
        if (p.hasCursedRing) {
            logBattleEvent(`Floor ${floor} - Gnome flips a coin... Heads! But Cursed Aura blocks extra life!`);
            playWebAudioSound(sounds.heads); // Play heads.wav
        } else {
            // Grant max health (original behavior)
            const healthGain = p.potions * 12;
            p.maxHP += healthGain;
            p.hp += healthGain;
            logBattleEvent(`Floor ${floor} - Gnome flips a coin... Heads! Traded ${p.potions} potions for +${healthGain} max HP (new max HP: ${p.hp})`);
            playWebAudioSound(sounds.heads); // Play heads.wav
        }
    } else {
        // Remove excess health and adjust armor
        let currentMaxHP = 24; // Base HP
        let newArmorStatus = 'Cloth';
        if (p.hp > 1000) {
            currentMaxHP = 1000; // Diamond armor max
            newArmorStatus = 'Diamond';
        } else if (p.hp > 36) {
            currentMaxHP = 36; // Leather armor max
            newArmorStatus = 'Leather';
        } else if (p.hp > 24) {
            currentMaxHP = 24; // Cloth max
            newArmorStatus = 'Cloth';
        }
        if (p.hp > currentMaxHP) {
            const healthLost = p.hp - currentMaxHP;
            p.hp = currentMaxHP;
            p.hasDiamondArmor = currentMaxHP >= 1000;
            p.hasArmor = currentMaxHP === 36;
            document.getElementById('armorStatus').textContent = newArmorStatus;
            logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! A mischievous cackle echoes as ${healthLost} excess HP is whisked away! Armor set to ${newArmorStatus} (HP now: ${p.hp})`);
        } else {
            logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! The gnome giggles but finds no excess HP to take! (HP: ${p.hp})`);
        }
        playWebAudioSound(sounds.tails); // Play tails.wav
    }
    p.potions = 0;
    map[ny][nx] = 0;
    updatePlayerState();
}
        
        if (map[ny][nx] === 3) {
            const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
            if (drop) {
                if (satsEarned[drop.type] !== undefined) {
                    satsEarned[drop.type] += drop.sats;
                }
                map[ny][nx] = 0;
                satoshiDrops = satoshiDrops.filter(d => d !== drop);
                playWebAudioSound(sounds.pickup);
                updateSatsDisplay();
            }
        }
        
        if (map[ny][nx] === 4) {
            p.pickaxes++;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Pickaxe Found!`);
        }
        
        if (map[ny][nx] === 5) {
            // Cursed Aura now stacks with armor (no dispel)
            if (p.hp >= 24) {
                p.hp += 12;
            } else {
                p.hp = 24 + 12;
            }
p.hasArmor = true;
const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
let available = elements.filter(el => el !== p.elementImmunity);
if (available.length > 0 && !p.curseActive) {
    p.armorImmunity = available[Math.floor(Math.random() * available.length)];
    logBattleEvent(`Floor ${floor} - Leather Armor grants 100% ${p.armorImmunity} resistance!`);
}
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Armor Found: HP set to ${p.hp}`);
            updatePlayerState();
        }
        
        if (map[ny][nx] === 10) {            // diamond tile
            diamonds++;                      // collect it
            map[ny][nx] = 0;                 // remove from map
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Diamond collected!`);
            updatePlayerState();              // updates inventory display
        }
        
if (map[ny][nx] === 11) { // Scroll pickup → spawn portal nearby
    const scroll = scrollDrops.find(s => s.x === nx && s.y === ny);
    if (scroll) {
        map[ny][nx] = 0;
        scrollDrops = scrollDrops.filter(s => s !== scroll);
        playWebAudioSound(sounds.pickup);

        // ——— WIDE SEARCH: try up to 2 tiles away + diagonals (13 positions) ———
        const candidates = [];
        for (let dy = -2; dy <= 2; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
                if (dx === 0 && dy === 0) continue;               // skip the scroll tile itself
                const px = nx + dx;
                const py = ny + dy;
                if (px >= 0 && px < W && py >= 0 && py < H &&
                    map[py][px] === 0 &&                          // empty floor
                    !enemies.some(e => e.x === px && e.y === py) && // no enemy
                    !(exit && exit.x === px && exit.y === py)       // don’t overwrite stairs
                ) {
                    // give closer tiles higher priority (optional – looks nicer)
                    const distance = Math.abs(dx) + Math.abs(dy);
                    candidates.push({ x: px, y: py, dist: distance });
                }
            }
        }

        // Sort by distance so the portal prefers the closest free spot
        candidates.sort((a, b) => a.dist - b.dist);

        if (candidates.length > 0) {
            const portalPos = candidates[0]; // take the closest valid spot

            if (Math.random() < 0.5) {
                // 50% → Puzzle Portal
                map[portalPos.y][portalPos.x] = 25;
                portals.push({
                    x: portalPos.x,
                    y: portalPos.y,
                    type: 'puzzle',
                    frameIndex: 0,
                    lastFrameTime: performance.now(),
                    frameDuration: 200
                });
                logBattleEvent(`Floor ${floor} - The scroll ignites... a Puzzle Portal opens nearby!`);
                playWebAudioSound(sounds.secret);
            } else {
                // 50% → Town Portal
                map[portalPos.y][portalPos.x] = 12;
                portals.push({
                    x: portalPos.x,
                    y: portalPos.y,
                    frameIndex: 0,
                    lastFrameTime: performance.now(),
                    frameDuration: 400
                });
                logBattleEvent(`Floor ${floor} - The scroll unrolls... a Town Portal appears!`);
                playWebAudioSound(sounds.town_portal);
            }
        } else {
            logBattleEvent(`Floor ${floor} - The scroll crumbles... no space for a portal!`);
        }
    }
}

        // Check for adjacent special tiles (type 6) and play ambient sound once per floor
        if (currentTheme !== 'dungeon') {
            const adjacent = [
                {x: p.x, y: p.y - 1}, // Up
                {x: p.x, y: p.y + 1}, // Down
                {x: p.x - 1, y: p.y}, // Left
                {x: p.x + 1, y: p.y}  // Right
            ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 6);
            if (adjacent.length > 0) {
                let soundKey;
                switch (currentTheme) {
                    case 'hell':
                        soundKey = 'lava';
                        break;
                    case 'desert':
                        soundKey = 'quicksand';
                        break;
                    case 'paradise':
                        soundKey = 'pond';
                        break;
                }
                if (soundKey && !specialSoundsPlayedThisFloor[soundKey]) {
                    playWebAudioSound(sounds[soundKey]);
                    specialSoundsPlayedThisFloor[soundKey] = true;
                    logBattleEvent(`Floor ${floor} - Heard ${soundKey === 'quicksand' ? 'sludge pit' : soundKey} nearby!`);
                }
            }
        }

        // Check for falling animation (only on Ruins theme)
        if (
            currentTheme === 'ruins' &&
            map[ny][nx] === 6 && // Ring hole tile
            !p.isFalling // Not already falling
        ) {
            inputBlocked = true;
            p.isFalling = true;
            const direction = p.anim.direction; // Save current direction for push
            const oldX = p.x;
            const oldY = p.y;

            // Start fall animation - ensure it starts from frame 0
            let frameIndex = 0;
            const fallDuration = 200; // ms per frame
            const totalFrames = 3; // Exactly 3 frames
            const startTime = Date.now();

            function animateFall() {
                const elapsed = Date.now() - startTime;
                frameIndex = Math.min(Math.floor(elapsed / fallDuration), totalFrames - 1);

                // Update animation - cycle through 0,1,2
                p.anim.frameIndex = frameIndex;
                needsRedraw = true;

                if (frameIndex < totalFrames - 1) {
                    requestAnimationFrame(animateFall);
                } else {
                    // Animation complete, now push player one tile away
                    let pushX = oldX;
                    let pushY = oldY;

                    switch (direction) {
                        case 'up': pushY--; break;
                        case 'down': pushY++; break;
                        case 'left': pushX--; break;
                        case 'right': pushX++; break;
                    }

                    // Ensure player lands on a valid floor tile (not wall or hole), preferring same direction
                    pushX = oldX; // Reuse existing pushX
                    pushY = oldY; // Reuse existing pushY
                    let validPosition = false;

                    // Log original position for debugging
                    //console.log(`Original position: (${oldX}, ${oldY}), tile=${oldX >= 0 && oldX < W && oldY >= 0 && oldY < H ? map[oldY][oldX] : 'out of bounds'}`);

                    // Try pushing one tile in the original direction
                    //console.log(`Direction before initial push: ${direction}`);
                    switch (direction) {
                        case 'back': pushY--; break; // Up
                        case 'front': pushY++; break; // Down
                        case 'left': pushX--; break;
                        case 'right': pushX++; break;
                    }

                    //console.log(`Initial push: direction=${direction}, position=(${pushX}, ${pushY}), tile=${pushX >= 0 && pushX < W && pushY >= 0 && pushY < H ? map[pushY][pushX] : 'out of bounds'}`);

                    // Check if initial push position is the hole; if so, player is already on it
                    if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] === 6 // Initial push is the hole
                    ) {
                        // Try one tile before the hole (opposite direction, same side)
                        let backX = oldX;
                        let backY = oldY;
                        switch (direction) {
                            case 'front': backY--; break; // Up (opposite of front)
                            case 'back': backY++; break; // Down (opposite of back)
                            case 'left': backX++; break; // Right (opposite of left)
                            case 'right': backX--; break; // Left (opposite of right)
                        }
                        //console.log(`Back push (opposite direction): position=(${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                        if (
                            backX >= 0 && backX < W &&
                            backY >= 0 && backY < H &&
                            map[backY][backX] !== 1 && // Not a wall
                            map[backY][backX] !== 6 // Not a hole
                        ) {
                            pushX = backX;
                            pushY = backY;
                            validPosition = true;
                            //console.log(`Valid back push position found at (${pushX}, ${pushY})`);
                        } else {
                            //console.log(`Back push invalid at (${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                            // Try adjacent tiles on same side (left/right for front/back, up/down for left/right)
                            const adjacent = [
                                direction === 'front' || direction === 'back' ? { x: oldX - 1, y: oldY } : { x: oldX, y: oldY - 1 }, // Left or up
                                direction === 'front' || direction === 'back' ? { x: oldX + 1, y: oldY } : { x: oldX, y: oldY + 1 }  // Right or down
                            ];
                            for (let i = 0; i < adjacent.length; i++) {
                                const adjX = adjacent[i].x;
                                const adjY = adjacent[i].y;
                                //console.log(`Adjacent push ${i+1}: position=(${adjX}, ${adjY}), tile=${adjX >= 0 && adjX < W && adjY >= 0 && adjY < H ? map[adjY][adjX] : 'out of bounds'}`);
                                if (
                                    adjX >= 0 && adjX < W &&
                                    adjY >= 0 && adjY < H &&
                                    map[adjY][adjX] !== 1 && // Not a wall
                                    map[adjY][adjX] !== 6 // Not a hole
                                ) {
                                    pushX = adjX;
                                    pushY = adjY;
                                    validPosition = true;
                                    //console.log(`Valid adjacent push position found at (${pushX}, ${pushY})`);
                                    break;
                                }
                            }
                        }
                    } else if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] !== 1 && // Not a wall
                        map[pushY][pushX] !== 6 // Not a hole
                    ) {
                        validPosition = true;
                        //console.log(`Valid initial position found at (${pushX}, ${pushY})`);
                    } else if (
                        pushX >= 0 && pushX < W &&
                        pushY >= 0 && pushY < H &&
                        map[pushY][pushX] === 1 // Wall detected
                    ) {
                        // Try one tile before the hole (opposite direction, same side)
                        let backX = oldX;
                        let backY = oldY;
                        switch (direction) {
                            case 'front': backY--; break; // Up
                            case 'back': backY++; break; // Down
                            case 'left': backX++; break; // Right
                            case 'right': backX--; break; // Left
                        }
                        //console.log(`Back push (opposite direction): position=(${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                        if (
                            backX >= 0 && backX < W &&
                            backY >= 0 && backY < H &&
                            map[backY][backX] !== 1 && // Not a wall
                            map[backY][backX] !== 6 // Not a hole
                        ) {
                            pushX = backX;
                            pushY = backY;
                            validPosition = true;
                            //console.log(`Valid back push position found at (${pushX}, ${pushY})`);
                        } else {
                            //console.log(`Back push invalid at (${backX}, ${backY}), tile=${backX >= 0 && backX < W && backY >= 0 && backY < H ? map[backY][backX] : 'out of bounds'}`);
                            // Try adjacent tiles on same side
                            const adjacent = [
                                direction === 'front' || direction === 'back' ? { x: oldX - 1, y: oldY } : { x: oldX, y: oldY - 1 }, // Left or up
                                direction === 'front' || direction === 'back' ? { x: oldX + 1, y: oldY } : { x: oldX, y: oldY + 1 }  // Right or down
                            ];
                            for (let i = 0; i < adjacent.length; i++) {
                                const adjX = adjacent[i].x;
                                const adjY = adjacent[i].y;
                                //console.log(`Adjacent push ${i+1}: position=(${adjX}, ${adjY}), tile=${adjX >= 0 && adjX < W && adjY >= 0 && adjY < H ? map[adjY][adjX] : 'out of bounds'}`);
                                if (
                                    adjX >= 0 && adjX < W &&
                                    adjY >= 0 && adjY < H &&
                                    map[adjY][adjX] !== 1 && // Not a wall
                                    map[adjY][adjX] !== 6 // Not a hole
                                ) {
                                    pushX = adjX;
                                    pushY = adjY;
                                    validPosition = true;
                                    //console.log(`Valid adjacent push position found at (${pushX}, ${pushY})`);
                                    break;
                                }
                            }
                        }
                    }

                    // Final check to ensure player doesn't land on hole
                    if (validPosition && pushX >= 0 && pushX < W && pushY >= 0 && pushY < H && map[pushY][pushX] === 6) {
                        //console.log(`Error: Final position is a hole at (${pushX}, ${pushY}); resetting to invalid`);
                        validPosition = false;
                    }

                    if (!validPosition) {
                        console.log(`No valid position found; player may be stuck at (${pushX}, ${pushY}), tile=${pushX >= 0 && pushX < W && pushY >= 0 && pushY < H ? map[pushY][pushX] : 'out of bounds'}`);
                    }

                    // Update player position if valid
                    if (validPosition) {
p.x = pushX;
p.y = pushY;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;
                    } else {
                        // Fallback: keep player at original position if no valid move
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;
return;
                    }

                    // Reset falling flag and animation state
                    p.isFalling = false;
                    p.anim.frameIndex = 0; // Reset to first frame
                    p.anim.direction = direction; // Restore original direction
                    // ⬅️ UNBLOCK INPUT HERE
                    setTimeout(() => {
                        inputBlocked = false;
                    }, 200); // Small delay to ensure smooth transition
                    needsRedraw = true;
                }
            }
            // Ensure we reset to first frame before starting animation
            p.anim.frameIndex = 0;
            animateFall();
            return; // Exit move early to prevent further movement
        }

// Add this after the stairs logic in move function:
if (exit && p.x === exit.x && p.y === exit.y && !inHideout) { // ← Removed !inPuzzleRoom check (puzzle room now uses same stairs)
    // clear console log for each stage to keep it from blowing up
    console.clear()
    // NEW: make sure the scroll flag is reset for the next floor
    scrollDroppedThisFloor = false;
    sounds.stairs.play().catch(e => console.error('Stairs sound error:', e));
    if (p.immortal) {
        p.immortal = false;
        logBattleEvent(`Floor ${floor} - HODL immortality has worn off!`);
    }
   
    enemiesSpawnedThisFloor = 0;
    uniqueMonstersSpawnedThisFloor = 0; // Reset unique monster spawn counter
    initialSpawnDoneThisFloor = false;
    enemies = [];
   
    // ← Removed the old inPuzzleRoom return logic — we now always go to next floor
    // (finishPuzzleRoom() already set inPuzzleRoom = false and placed stairs)
   
    floor++;
    
    // CRITICAL: FULL WAVE & ENEMY RESET — this fixes dead Floor 2 after puzzle
    wave = 1;
    document.getElementById('wave').textContent = wave;
    waveActive = false;
    initialWaveSpawned = false;
    initialSpawnDoneThisFloor = false;
    enemiesSpawnedThisFloor = 0;
    uniqueMonstersSpawnedThisFloor = 0;
    whalesSpawnedThisFloor = 0;
    enemies = [];
    exit = null;  // Let placeStairs() work normally on new floor

    // Build soul resonance +2% per floor (every 50 floors, max 100%)
    soulResonance = Math.min(100, soulResonance + 2);
    resonanceTriggeredThisRun = false; // Reset for new run
    logBattleEvent(`Floor ${floor} - Soul Resonance: ${soulResonance}%`); // Optional subtle log
    
    // Spawn wisp on floor 3
    if (floor === 3 && wisps.length === 0) {
        const wispType = WISP_TYPES[Math.floor(Math.random() * WISP_TYPES.length)];
        wisps.push({
            x: p.x, y: p.y,
            currentX: p.x * S, currentY: p.y * S,
            hp: Math.floor(p.hp / 2), maxHP: Math.floor(p.maxHP / 2),
            type: wispType,
            attackCounter: 0,
            targetTileX: p.x, targetTileY: p.y,
            deltaX: 0, deltaY: 0, stepsLeft: 0, moving: false,
            anim: { frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 }, // Cycle every 200ms
            lastPos: null
        });
        logBattleEvent(`Floor ${floor} - A loyal wisp companion appears!`);
        const floorIndicator = document.getElementById('floor-indicator');
        // Triple wisp spawn chime (staggered for audibility)
        playWebAudioSound(sounds.pickup);
        setTimeout(() => playWebAudioSound(sounds.pickup), 100);
        setTimeout(() => playWebAudioSound(sounds.pickup), 200);
        floorIndicator.textContent = `Floor ${floor} - Wisp joined!`;
        wispPromptTimeout = setTimeout(() => {
            floorIndicator.textContent = `Floor ${floor}`;
        }, 3000);
    }
   
    p.shrineUsedThisFloor = false; // Reset shrine flag for new floor
    initialWaveSpawned = false;
    waveActive = false;
    exit = null;
    killsLog = [];
    battleLog = []; // Clear battleLog to prevent memory buildup
   
    // Reset special sound tracking for the new floor
    specialSoundsPlayedThisFloor.lava = false;
    specialSoundsPlayedThisFloor.quicksand = false;
    specialSoundsPlayedThisFloor.pond = false;
    specialSoundsPlayedThisFloor.rune = false;
    specialSoundsPlayedThisFloor.hole = false;
   
    // Reset runewords to allow reactivation on new floor
    p.runewords = [];
    
catPos = null;
catVisible = false;
    
    // Clear runeDrops specific runes to prevent stale entries
    runeDrops = runeDrops.filter(r => !r.specific);
   
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
   
    // Reset attack to base value before new floor (accounts for diamond hand)
    p.atk = p.hasDiamondHand ? 3 : 2;
   
    initMap();
    puzzleCurrentLayout = null;  // ← NEW: clear after any floor change
    isFetchingTxs = false;   // ← THIS IS THE FIX – clears the stuck flag!
    nextApiCallTime = null;
    deadWispCorpse = null; // Clear wisp corpse on floor transition
   
    // Show runeword message if active, otherwise show theme name for 3 s then revert to floor number
    const floorIndicator = document.getElementById('floor-indicator');
    if (themeTimeoutId) clearTimeout(themeTimeoutId); // cancel any old timer
   
    // Check if any runewords are active
    const hasActiveRunewords = p.runewords.length > 0;
   
    if (hasActiveRunewords) {
        // Show runeword message with the whole rune part in uppercase
        const uppercasedRunewords = p.runewords.map(r => r.toUpperCase());
        floorIndicator.textContent = `Runeword${uppercasedRunewords.length > 1 ? 's' : ''} ${uppercasedRunewords.join(', ')} found!`;
        themeTimeoutId = setTimeout(() => {
            floorIndicator.textContent = `Floor ${floor}`;
            themeTimeoutId = null;
        }, 5000);
    } else {
        // Show theme name for 3 s, then revert to floor number
        const themeName = currentTheme.charAt(0).toUpperCase() + currentTheme.slice(1);
        floorIndicator.textContent = themeName; // show theme
        themeTimeoutId = setTimeout(() => { // after 3 s …
            floorIndicator.textContent = `Floor ${floor}`; // revert
            themeTimeoutId = null;
        }, 3000);
    }
   
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value = '';
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
   
    // Immediately trigger fetchTxs after floor transition
    if (!gameOver && !splashActive && floor > 0) {
        fetchTxs();
        console.log(`Triggered fetchTxs for wave ${wave} on floor ${floor}`);
    }
   
    // Add proper exit handling to prevent teleportation issues
    return; // This is CRUCIAL - stops further execution after exit
}

        // In move function - before calling fetchTxs
        // Town Portal
if (map[ny][nx] === 12 && !inHideout) {
    playWebAudioSound(sounds.town_portal);
    inHideout = true;
    initMap();
    return;
}
// Puzzle Portal — Enter the trial!
if (map[ny][nx] === 25) {
    const portal = portals.find(p => p.x === nx && p.y === ny && p.type === 'puzzle');
    if (portal) {
        playWebAudioSound(sounds.secret);  // Epic sound!

        // SAVE where we came from — position + theme
        puzzleReturnPos = { x: p.x, y: p.y };
        puzzlePreviousTheme = currentTheme;  // ← THIS IS THE KEY!

        logBattleEvent("You step into the shimmering rift... a sacred trial begins!");
        startPuzzleRoom();
        return;
    }
}

        if (map[ny][nx] === 16 && inHideout) {
            playWebAudioSound(sounds.town_portal);
            if (previousFloorState) {
                // Restore previous floor state
                map = previousFloorState.map.map(row => [...row]);
                enemies = previousFloorState.enemies.map(e => ({ ...e, type: { ...e.type } }));
                rooms = previousFloorState.rooms.map(r => ({ ...r }));
                exit = previousFloorState.exit ? { ...previousFloorState.exit } : null;
                satoshiDrops = [...previousFloorState.satoshiDrops];
                runeDrops = [...previousFloorState.runeDrops];
                scrollDrops = [...previousFloorState.scrollDrops];
                portals = previousFloorState.portals.map(p => ({ ...p }));
                floor = previousFloorState.floor;
                wave = previousFloorState.wave;
                enemiesSpawnedThisFloor = previousFloorState.enemiesSpawnedThisFloor;
                whalesSpawnedThisFloor = previousFloorState.whalesSpawnedThisFloor;
                initialSpawnDoneThisFloor = previousFloorState.initialSpawnDoneThisFloor;
                initialWaveSpawned = previousFloorState.initialWaveSpawned;
                waveActive = previousFloorState.waveActive;
currentTheme = previousFloorState.currentTheme;
updateSnowState();
fogMap = previousFloorState.fogMap.map(row => [...row]);  // ← Add this line
const portal = previousFloorState.portals.find(p => p.x !== undefined && p.y !== undefined);
p.x = portal ? portal.x : 2;
p.y = portal ? portal.y : 2;
p.currentX = p.x * S;
p.currentY = p.y * S;
p.moving = false;
p.stepsLeft = 0;
p.deltaX = 0;
p.deltaY = 0;
p.targetTileX = p.x;
p.targetTileY = p.y;
camera.x = 0;
camera.y = 0;
needsRedraw = true;

inHideout = false;
document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
updateFogMap(p.x, p.y);
needsRedraw = true;
logBattleEvent(`Floor ${floor} - Returned from hideout via waypoint!`);
                document.documentElement.style.setProperty('--text-color', currentTheme === 'hell' ? '#00ff00' : '#ff8c00');
                document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                    el.style.color = currentTheme === 'hell' ? '#00ff00' : '#ff8c00';
                });
                return;
            } else {
                inHideout = false;
                initMap();
                portals = [{ x: p.x, y: p.y, frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 }];
                map[p.y][p.x] = 12;
                logBattleEvent(`Floor ${floor} - Returned to a new floor via waypoint!`);
                document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
                needsRedraw = true;
                document.documentElement.style.setProperty('--text-color', currentTheme === 'hell' ? '#00ff00' : '#ff8c00');
                document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #sats-calc').forEach(el => {
                    el.style.color = currentTheme === 'hell' ? '#00ff00' : '#ff8c00';
                });
                return;
            }
        }

if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}

// Handle soul stash interaction
if (map[ny][nx] === 19 && !inHideout) { // Soul stash tile
    // Lock player movement while in terminal
    inputBlocked = true;
    // Store the exact position of the soul stash for proper positioning
    const stashX = nx;
    const stashY = ny;
    openSoulTerminal();
    return;
}

// In the move function, add shrine pickup logic:
if (map[ny][nx] === 22 && !inHideout) { // Shrine tile
    if (!p.shrineUsedThisFloor) {
        p.shrineCharges = 24; // Give 24 charges immediately
        p.shrineUsedThisFloor = true; // Mark that shrine was used on this floor
        logBattleEvent(`Floor ${floor} - Shrine charges activated! (24/24 charges)`);
        playWebAudioSound(sounds.pond);
    } else {
        logBattleEvent(`Floor ${floor} - Shrine already used this floor!`);
    }
}

if (map[ny][nx] === 27 && inPuzzleRoom && farmSpot && farmSpot.x === nx && farmSpot.y === ny) {
    const rawSats = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);

    if (!p.farmLocked) {
        // PLANT: First time stepping on it
        p.farmLockedSats = rawSats;
        // ZERO OUT ALL CURRENT SATS
        Object.keys(satsEarned).forEach(key => satsEarned[key] = 0);
        updateSatsDisplay();

        p.farmLocked = true;
        p.farmLockedFloor = floor;

        logBattleEvent(`Floor ${floor} - SATS planted! 2× in 50 floors.`);
        playWebAudioSound(sounds.pickup);
    }
    else if (floor >= p.farmLockedFloor + 50) {
        // HARVEST: Ready after 50 floors
        const harvest = p.farmLockedSats * 2;
        satsEarned.Farm = (satsEarned.Farm || 0) + harvest;

        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Farm: HARVEST!`;
        setTimeout(() => floorIndicator.textContent = `Floor ${floor}`, 2000);

        logBattleEvent(`Floor ${floor} - HARVEST! +${harvest} sats (2×)`);
        playWebAudioSound(sounds.pickup);
        updateSatsDisplay();

        // Reset farm
        p.farmLocked = false;
        p.farmLockedFloor = 0;
        p.farmLockedSats = 0;
    }
    else {
        // GROWING: Still waiting
        const floorsLeft = p.farmLockedFloor + 50 - floor;
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Farm: ${floorsLeft} floors left`;
        setTimeout(() => floorIndicator.textContent = `Floor ${floor}`, 2000);

        logBattleEvent(`Floor ${floor} - Growing... ${floorsLeft} floors left.`);
    }

    // Allow player to stand on the tile
    return;
}

// Add soul orb statue interaction
if (map[ny][nx] === 21 && !inHideout) { // Soul orb statue tile
	// Check if player already collected from this statue on current floor
	const currentFloorStatueKey = `statue_${floor}_${nx}_${ny}`;
	if (!p.collectedFromStatue || !p.collectedFromStatue[currentFloorStatueKey]) {
		p.soulOrbs++;
		logBattleEvent(`Block 74638: You received 1 Soul Orb!`);
		if (!p.collectedFromStatue) {
			p.collectedFromStatue = {};
		}
		p.collectedFromStatue[currentFloorStatueKey] = true;
		//map[ny][nx] = 0; // Remove statue after collection
		playWebAudioSound(sounds.buzz);
		updatePlayerState();
	} else {
		logBattleEvent(`Block 74638: Seek the masked relics’ refuge, where souls gather.`);
		needsRedraw = true;
	}
	return;
}
        
if (map[ny][nx] === 20) { // Soul stone tile
    map[ny][nx] = 0;
    playWebAudioSound(sounds.pickup);
    logBattleEvent(`Floor ${floor} - Soul Stone collected!`);
    updatePlayerState();
}

        if (map[ny][nx] === 14 && inHideout) { // Jeweller
            if (diamonds >= 3) {
                diamonds -= 3;
                p.perfectlyCutDiamonds++;
                logBattleEvent(`Jeweller refined 3 diamonds into a Perfectly Cut Diamond!`);
                playWebAudioSound(sounds.pickup);
                updatePlayerState();
            } else {
                logBattleEvent(`Jeweller requires 3 diamonds to refine!`);
            }
        }
        
        if (map[ny][nx] === 15 && inHideout) { // Blacksmith
            if (p.perfectlyCutDiamonds >= 1 && !p.hasDiamondArmor) {
                p.perfectlyCutDiamonds--;
p.hasDiamondArmor = true;
p.hasArmor = false; // Remove regular armor
p.armorImmunity = null; // Reset previous armor immunity
const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
let available = elements.filter(el => el !== p.elementImmunity);
if (available.length > 0 && !p.curseActive) {
    p.armorImmunity = available[Math.floor(Math.random() * available.length)];
    logBattleEvent(`Floor ${floor} - Diamond Armor grants 100% ${p.armorImmunity} resistance!`);
}
                p.hp += 1000;
                logBattleEvent(`Blacksmith forged Diamond Armor! HP increased to ${p.hp}`);
                playWebAudioSound(sounds.pickup);
                updatePlayerState();
            } else if (p.hasDiamondArmor) {
                logBattleEvent(`Blacksmith: You already have Diamond Armor!`);
            } else {
                logBattleEvent(`Blacksmith requires a Perfectly Cut Diamond!`);
            }
        }

        if (map[ny][nx] === 17 && inHideout) { // Rune Whisperer
            if (p.runes.length > 0) {
                const runeCount = p.runes.length;
                const healthGain = runeCount * 2;
                p.hp += healthGain;
                p.runes = [];
                runeDrops = runeDrops.filter(r => !r.specific);
                for (let y = 0; y < H; y++) {
                    for (let x = 0; x < W; x++) {
                        if (map[y][x] === 9) {
                            map[y][x] = 0; // Clear specific rune tiles
                        }
                    }
                }
                logBattleEvent(`Rune Whisperer traded ${runeCount} runes for +${healthGain} HP! (HP now: ${p.hp})`);
                playWebAudioSound(sounds.pickup);
                checkRunewords();
                updatePlayerState();
            } else {
                logBattleEvent(`Rune Whisperer: No runes to trade!`);
            }
        }

if (map[ny][nx] === 18 && inHideout) { // Hooded Heirloom
    // Player can turn in soul orbs here for 256 charges each
    if (p.soulOrbs > 0) {
        if (p.soulStormCharges >= 256) {
            logBattleEvent(`Hooded Heirloom: You already have the maximum 256 Soul Storm Charges!`);
        } else {
            p.soulOrbs--;
            const chargesToAdd = Math.min(256 - p.soulStormCharges, 256);
            p.soulStormCharges += chargesToAdd;
            logBattleEvent(`Hooded Heirloom: Received ${chargesToAdd} Soul Storm Charges!`);
            playWebAudioSound(sounds.pickup);
        }
    } else {
        logBattleEvent(`Hooded Heirloom: No Soul Orbs to trade!`);
    }
}

        if (map[ny][nx] === 8) {
            const rune = runeDrops.find(r => r.x === nx && r.y === ny);
            if (rune) {
                p.runes.push(rune.letter);
                map[ny][nx] = 9; // Specific rune image
                runeDrops = runeDrops.filter(r => r !== rune);
                runeDrops.push({ x: nx, y: ny, letter: rune.letter, specific: true }); // Mark as specific rune for drawing
                playWebAudioSound(sounds.pickup);
                logBattleEvent(`Floor ${floor} - Picked up Rune ${rune.letter.toUpperCase()}!`);
                
                // Show rune name in floor indicator when picking up rune
                const floorIndicator = document.getElementById('floor-indicator');
                floorIndicator.textContent = `Rune Found: ${rune.letter.toUpperCase()}`;
                setTimeout(() => {
                    if (!currentRuneTile || !(p.x === currentRuneTile.x && p.y === currentRuneTile.y)) {
                        floorIndicator.textContent = `Floor ${floor}`;
                    }
                }, 3000); // Reset after 3 seconds

                //checkRunewords();
                // Track that player is currently on a rune tile
                currentRuneTile = { x: nx, y: ny };
            }
        }

// Puzzle: Collect heart framers
if (inPuzzleRoom) {
    const heartIndex = puzzleHeartFramers.findIndex(h => h.x === p.x && h.y === p.y);
    if (heartIndex !== -1) {
        puzzleHeartFramers.splice(heartIndex, 1);
        playWebAudioSound(sounds.pickup);

        const totalHearts = puzzleHeartFramers.length + 1; // +1 because we just picked one up
        const collected = totalHearts - puzzleHeartFramers.length;

        logBattleEvent(`Heart Framer ${collected}/${totalHearts} collected!`);
        needsRedraw = true;
    }

    // Step on chest when all hearts are collected
    if (puzzleHeartFramers.length === 0 && puzzleChest && p.x === puzzleChest.x && p.y === puzzleChest.y) {
        finishPuzzleRoom();
    }
}

if (map[ny][nx] === 23) { // Cursed ring
    if (p.hasCursedRing) {
        logBattleEvent(`Floor ${floor} - Cannot equip another Cursed Ring!`);
    } else {
        const originalHP = p.hp; // Store pre-halving HP for aura calc
        const oldMax = p.maxHP;
        p.maxHP = Math.floor(oldMax / 2);
        p.hp = Math.floor(p.hp / 2); // Halve current HP too
        p.auraMax = originalHP * 2; // Double original (pre-halving) HP for aura
        p.auraShield = p.auraMax;
	p.hasCursedRing = true;
	p.curseActive = true;  // Lingering curse effects
	p.elementImmunity = null;
        p.armorImmunity = null;
        p.hasArmor = false; // Remove armor
        p.hasDiamondArmor = false;
        map[ny][nx] = 0;
        playWebAudioSound(sounds.pickup);
        logBattleEvent(`Floor ${floor} - Cursed Ring equipped! HP ${p.hp}, Aura Shield: ${p.auraShield}`);
        updatePlayerState();
    }
}

if (map[p.y][p.x] === 28 && catPos && catPos.x === p.x && catPos.y === p.y) {
    p.soulStormCharges = 256;
    map[p.y][p.x] = 0;
    catPos = null;
    catVisible = false;
    catAnimStart = 0;
    playCatPurr();
    needsRedraw = true;
    logBattleEvent(`Floor ${floor} - Black cat blesses you! Soul charges maxed.`);
    updatePlayerState();
}

// Check for unique monster in fog of war
function checkUniqueMonsterInFog() {
    if (activeUniqueMonsterName) return;
    
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0 && !activeUniqueMonsterName) {
        const firstVisible = visibleUniqueMonsters[0];
        activeUniqueMonsterName = firstVisible.uniqueName;
        
        // Show unique monster name in floor indicator
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName === firstVisible.uniqueName) {
                activeUniqueMonsterName = null;
                const currentText = floorIndicator.textContent;
                if (currentText === activeUniqueMonsterName || 
                    currentText.includes(firstVisible.uniqueName)) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }
        }, 5000);
    }
}

// Check for unique monster in fog of war when moving
// Only check when we DON'T have an active unique monster name
if (!activeUniqueMonsterName) {
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0) {
        const firstVisible = visibleUniqueMonsters[0];
        activeUniqueMonsterName = firstVisible.uniqueName;
        
        // Show unique monster name in floor indicator
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = activeUniqueMonsterName;
        
        // Auto-clear after 5 seconds like Harbringer message
        setTimeout(() => {
            if (activeUniqueMonsterName === firstVisible.uniqueName) {
                activeUniqueMonsterName = null;
                const currentText = floorIndicator.textContent;
                if (currentText === activeUniqueMonsterName || 
                    currentText.includes(firstVisible.uniqueName)) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }
        }, 5000);
    }
}

// Check for unique monster in fog of war
const uniqueMonstersInFog = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 0);

// Check if player moved from a rune tile
if (currentRuneTile && !(p.x === currentRuneTile.x && p.y === currentRuneTile.y)) {
    const floorIndicator = document.getElementById('floor-indicator');
    if (floorIndicator.textContent.startsWith("Rune Found:") || 
        floorIndicator.textContent.startsWith("Rune:")) {
        // Reset to normal floor text if leaving rune tile
        setTimeout(() => {
            // Double-check that player is still not on a rune tile before resetting
            const stillOnRuneTile = map[p.y][p.x] === 9 && 
                runeDrops.some(r => r.x === p.x && r.y === p.y && r.specific);
            
            if (!stillOnRuneTile) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 100); // Small delay to prevent flicker
    }
}

        // === ARROW TILES FORCE MOVEMENT ===
        if (inPuzzleRoom) {
            const arrow = puzzleArrows.find(a => a.x === p.x && a.y === p.y);
            if (arrow) {
                let dir = null;
                switch(arrow.dir) {
                    case 'right': dir = 'right'; break;
                    case 'left':  dir = 'left';  break;
                    case 'up':    dir = 'up';    break;
                    case 'down':  dir = 'down';  break;
                }
                if (dir) {
                    // Force move in arrow direction
                    move(dir);
                    return; // Prevent normal movement this frame
                }
            }
        }

        updateFogMap(p.x, p.y);
        
    // ——— ECHO WARDEN AWAKENS: First step on Floor 1 only ———
    if (floor === 1 && !p.echoWardenBlessingGiven) {
        p.hp += 100;
        p.maxHP += 100;
        p.echoWardenBlessingGiven = true;

        // 1. FLASH FIRST
        wardenFlashStart = Date.now();

        // 2. AXIS-PRIORITY SPAWN: Right → Left → Down → Up → Diagonals → Safety
        setTimeout(() => {
            const candidates = [
                // Cardinal directions (closest first)
                { x: p.x + 1, y: p.y },   // right
                { x: p.x - 1, y: p.y },   // left
                { x: p.x,     y: p.y + 1 }, // down
                { x: p.x,     y: p.y - 1 }, // up

                // Diagonals (next closest)
                { x: p.x + 1, y: p.y + 1 },
                { x: p.x + 1, y: p.y - 1 },
                { x: p.x - 1, y: p.y + 1 },
                { x: p.x - 1, y: p.y - 1 },

                // 2-step cardinals (if really cramped)
                { x: p.x + 2, y: p.y },
                { x: p.x - 2, y: p.y },
                { x: p.x,     y: p.y + 2 },
                { x: p.x,     y: p.y - 2 },
            ];

            let placed = false;
            for (const pos of candidates) {
                if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 0) {
                    echoWardenPos = { x: pos.x, y: pos.y, spawnTime: Date.now() };
echoWardenPos.currentX = echoWardenPos.x * S;
echoWardenPos.currentY = echoWardenPos.y * S;
echoWardenPos.moving = false;
echoWardenPos.stepsLeft = 0;
echoWardenPos.deltaX = 0;
echoWardenPos.deltaY = 0;
                    map[pos.y][pos.x] = 24;
                    placed = true;
                    break;
                }
            }

            // Final emergency fallback (should never trigger)
            if (!placed) {
                echoWardenPos = { x: p.x, y: p.y, spawnTime: Date.now() };
                map[p.y][p.x] = 24; // spawn on player if no space (dramatic!)
            }

            logBattleEvent(`Floor 1 - You take your first step...`);
        }, 0);

        // 3. Message + sound
        setTimeout(() => {
            logBattleEvent(`The Echo Warden awakens from the void! +100 HP granted forever!`);
            playWebAudioSound(sounds.pickup);
        }, 600);

        needsRedraw = true;
    }
        
    }
    
    moveEnemies();
updateWisps(); // Update wisp pos/attacks synced to player/enemy turns
    updatePlayerState();
    
    // Check if player is standing on a rune tile (specifically placed rune)
    if (map[p.y][p.x] === 9) {
        const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
        if (rune) {
            const floorIndicator = document.getElementById('floor-indicator');
            // Show rune name when stepping on rune tile
            if (!floorIndicator.textContent.startsWith("Rune:")) {
                floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
            } else {
                // Update rune letter if it's different from what's currently displayed
                const currentRuneText = floorIndicator.textContent;
                const expectedRune = `Rune: ${rune.letter.toUpperCase()}`;
                if (currentRuneText !== expectedRune) {
                    floorIndicator.textContent = expectedRune;
                }
            }
            currentRuneTile = { x: p.x, y: p.y };
        }
    } else if (currentRuneTile && map[p.y][p.x] !== 9) {
        // Player moved away from rune tile
        const floorIndicator = document.getElementById('floor-indicator');
        if (floorIndicator.textContent.startsWith("Rune:")) {
            // Reset to floor text after a delay, but only if not currently on another rune tile
            setTimeout(() => {
                // Check again if player is now on a different rune tile
                const stillOnRuneTile = map[p.y][p.x] === 9 && 
                    runeDrops.some(r => r.x === p.x && r.y === p.y && r.specific);
                
                if (!stillOnRuneTile) {
                    floorIndicator.textContent = `Floor ${floor}`;
                }
            }, 100);
        }
    }
    
    needsRedraw = true;

}

function moveEnemies() {
    if (gameOver || splashActive) return;

    // Unique monster spells damage player even when standing still
    dangerousAreas.forEach(area => {
        if (area.x === p.x && area.y === p.y) {
            applySpellDamage(p.x, p.y);
        }
    });    

enemies.forEach(e => {
    if (e.frozen && e.frozenTurns > 0) {
        e.frozenTurns--;
        if (e.frozenTurns <= 0) e.frozen = false;
        return; // Skip move
    }
    let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
        if (dist <= 5) {
// Mark first time they see the player this turn
            if (!e.justSawPlayer && fogMap[e.y][e.x] === 1) {
                e.justSawPlayer = true;
            }
            let moves = e.type.move, steps = 0;
let startX = e.x, startY = e.y;
let finalX = e.x, finalY = e.y;
let numTileSteps = 0;
let tempDx = dx, tempDy = dy;
while (steps < moves) {
    let nx = finalX, ny = finalY;
    if (e.type.name === 'Crab') {
        nx += tempDx > 0 ? 1 : -1;
    } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
        if (Math.abs(tempDx) > Math.abs(tempDy)) nx += tempDx > 0 ? 1 : -1;
        else ny += tempDy > 0 ? 1 : -1;
    } else {
        if (Math.abs(tempDx) > Math.abs(tempDy)) nx += tempDx > 0 ? 1 : -1;
        else ny += tempDy > 0 ? 1 : -1;
    }
    if (
       nx >= 0 && nx < W && ny >= 0 && ny < H &&
       map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) &&
        !enemies.some(en => en.x === nx && en.y === ny && en !== e)
    ) {
        finalX = nx;
        finalY = ny;
        numTileSteps++;
    } else break;
    steps++;
    tempDx = p.x - finalX; tempDy = p.y - finalY;
}
if (numTileSteps > 0) {
    const totalDeltaX = (finalX - startX) * S;
    const totalDeltaY = (finalY - startY) * S;
    const totalDistance = Math.abs(totalDeltaX) + Math.abs(totalDeltaY);
    const numSubSteps = totalDistance / 2;
    e.deltaX = totalDeltaX > 0 ? 2 : (totalDeltaX < 0 ? -2 : 0);
    e.deltaY = totalDeltaY > 0 ? 2 : (totalDeltaY < 0 ? -2 : 0);
    e.stepsLeft = numSubSteps;
    e.moving = true;
    e.x = finalX;
    e.y = finalY;
    e.targetTileX = finalX;
    e.targetTileY = finalY;
    e.currentX = startX * S;
    e.currentY = startY * S;
}
dx = p.x - e.x; dy = p.y - e.y;  // Update for attack
            }
            if (
                (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark' || e.type.name === 'Cursed Trader') ?
                (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
            ) {
                // Set sword animation for Cursed Trader
                if (e.type.name === 'Cursed Trader') {
                    e.swordActive = true;
                    e.swordStart = Date.now();
                    // Determine sword direction towards player
                    const dx = p.x - e.x;
                    const dy = p.y - e.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        e.swordDir = dx > 0 ? 'right' : 'left';
                    } else {
                        e.swordDir = dy > 0 ? 'down' : 'up';
                    }
                }
                
                // Apply damage to aura first if cursed ring active
                const damage = e.type.name === 'Whale' ? Math.ceil(p.hp / 10) + 3 : e.type.atk;
                if (p.hasCursedRing && p.auraShield > 0) {
                    const oldAura = p.auraShield;
                    p.auraShield -= damage;
                    if (p.auraShield < 0) {
                        p.hp += p.auraShield; // Overflow to HP
                        logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks Aura! ${damage} DMG (overflow ${Math.abs(p.auraShield)} to HP; Aura now 0/${p.auraMax})`);
                        p.auraShield = 0;
                    } else {
                        logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks Aura! ${damage} DMG (now ${p.auraShield}/${p.auraMax})`);
                    }
                    // Trigger visual flash
                    auraHitStartTime = Date.now();
                } else {
p.hp -= damage;
const auraMsg = p.hasCursedRing ? ' (Aura depleted; ' : ' ';
logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${damage} DMG${auraMsg}HP now ${p.hp}${p.hasCursedRing ? ')' : ''}`);

// Wisp vulnerability: Attack wisp if close (like player)
if (wisps.length > 0) {
    const wisp = wisps[0];
    let wdx = wisp.x - e.x, wdy = wisp.y - e.y;
    let wdist = Math.abs(wdx) + Math.abs(wdy);
    if (wdist <= 1) { // Adjacent
        let wDmg = e.type.atk;
        wisp.hp -= wDmg;
        logBattleEvent(`Floor ${floor} - ${e.type.name} attacks wisp for ${wDmg} dmg! (Wisp HP: ${wisp.hp})`);
        if (wisp.hp <= 0) {
            wisps = []; // Remove from active array
            logBattleEvent(`Floor ${floor} - Wisp perishes!`);
            sounds.gameover.currentTime = 0;
            sounds.gameover.play().catch(e => console.error('Wisp death sound error:', e));
            // Place dead wisp on ground
            deadWispCorpse = {
                x: wisp.x, y: wisp.y,
                frameIndex: wisp.anim.frameIndex,
                fadeStart: Date.now()
            };
        }
    }
}
                }
logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${damage} DMG`);

playWebAudioSound(sounds.hit);
if (p.hp <= 0 && p.immortal) {
    p.hp = 1;
    logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
} else if (p.hp <= 0) {
    p.hp = 0;
    diamonds = 0;                // reset diamonds
    updatePlayerState();          // update inventory
    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
}

updatePlayerState(); // Check HP and armor state after damage
            }
            
            // —— BIT SHOOTING (ranged attack) ——
            if (e.bitAmmo > 0 && fogMap[e.y][e.x] === 1) {
                const dx = p.x - e.x;
                const dy = p.y - e.y;
                const dist = Math.abs(dx) + Math.abs(dy);

                if (dist >= 2 && dist <= 7) {
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                            // Zelda-ish aiming: only fire when clearly aligned horizontally or vertically
                            let dirX = 0, dirY = 0;
                            if (absDx >= 2 * absDy && absDx > 0) {
                                dirX = dx > 0 ? 1 : -1;
                            } else if (absDy >= 2 * absDx && absDy > 0) {
                                dirY = dy > 0 ? 1 : -1;
                            } else {
                                // Not aligned enough – no shot
                                // Mark that enemy can see player this turn (for immediate shooting next time)
                                if (fogMap[e.y][e.x] === 1 && !e.justSawPlayer) {
                                    e.justSawPlayer = true;
                                }
                                return; // safe inside forEach – skips rest of this enemy's turn
                            }

                    // Strict tile-by-tile LOS along the chosen cardinal direction
                    let hasLOS = true;
                    let testX = e.x + dirX;
                    let testY = e.y + dirY;
                    while (testX !== p.x || testY !== p.y) {
                        if (map[testY][testX] === 1) {
                            hasLOS = false;
                            break;
                        }
                        testX += dirX;
                        testY += dirY;
                    }

                    if (hasLOS) {
                        const now = Date.now();
                        if (now - e.lastBitShot > 1200) {
                            e.lastBitShot = now;

                            if (e.justSawPlayer) {
                                e.justSawPlayer = false;
                                logBattleEvent(`Floor ${floor} - ${e.uniqueName || e.type.name} spots you!`);
                                playPigSnort();
                            }

                            // Fire the spear
                            e.bitAmmo--;
                            e.bits = e.bitAmmo;

                            projectiles.push({
                                x: e.x, y: e.y,
                                currentX: e.x * S, currentY: e.y * S,
                                dirX: dirX, dirY: dirY,
                                value: 1,
                                moveStartTime: now,
                                moving: true
                            });
                            const proj = projectiles[projectiles.length - 1];
                            proj.targetTileX = e.x + dirX;
                            proj.targetTileY = e.y + dirY;
                            proj.targetX = proj.targetTileX * S;
                            proj.targetY = proj.targetTileY * S;

                            logBattleEvent(`Floor ${floor} - ${e.uniqueName || e.type.name} fires a bit spear!`);
                            needsRedraw = true;
                        }
                    }
                }

                // Mark that enemy can see player this turn (for immediate shooting next time)
                if (fogMap[e.y][e.x] === 1 && !e.justSawPlayer) {
                    e.justSawPlayer = true;
                }
            }
            
    });
        
    // Single death/surge check after all enemy actions
    updatePlayerState();
    
// === ONLY PLACE STAIRS IN NORMAL DUNGEON — NEVER IN PUZZLE ROOMS ===
if (!inPuzzleRoom && enemies.length === 0 && !exit && waveActive && !p.ripBlast && !ripBlastActive && !inHideout) {
    if (placeStairs()) {
        wave++;
        if (wisps.length > 0) wispSpeak('victory');
        waveActive = false;
        document.getElementById('wave').textContent = wave;
        logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);
    } else {
        logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
    }
}
}

function doScourgeSpinAttack() {
    const dirs = [
        {dx:-1,dy:-1},{dx:0,dy:-1},{dx:1,dy:-1},
        {dx:-1,dy:0},             {dx:1,dy:0},
        {dx:-1,dy:1}, {dx:0,dy:1},{dx:1,dy:1}
    ];

    dirs.forEach(d => {
        const x = p.x + d.dx;
        const y = p.y + d.dy;
        if (x < 0 || x >= W || y < 0 || y >= H || map[y][x] === 1) return;

        const enemy = enemies.find(e => e.x === x && e.y === y);
        if (enemy) {
            enemy.hp -= 2;
            enemy.scourgeHit = Date.now();
            if (enemy.hp <= 0) {
                kills[enemy.type.name]++;
                handleUniqueMonsterReward(enemy);
                tryDropScroll(enemy.x, enemy.y);
                if (!enemy.uniqueName && map[y][x] === 0) {
                    map[y][x] = 3;
                    satoshiDrops.push({x, y, sats: enemy.sats, type: enemy.type.name});
                }
                enemies = enemies.filter(e => e !== enemy);
            }
        }
    });
}

// ——— SCROLL DROP — 5% chance on any enemy kill ———
function tryDropScroll(deadX, deadY) {
    if (!scrollDroppedThisFloor && Math.random() < 0.05) {
        scrollDroppedThisFloor = true;
        let placed = false;
        const positions = [{ x: deadX, y: deadY }];
        const adj = [{ dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }];
        for (const d of adj) positions.push({ x: deadX + d.dx, y: deadY + d.dy });
        for (const pos of positions) {
            if (pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 0) {
                map[pos.y][pos.x] = 11; // SCROLL TILE
                scrollDrops.push({ x: pos.x, y: pos.y });
                logBattleEvent(`Floor ${floor} - A mysterious scroll drops from the enemy!`);
                playWebAudioSound(sounds.pickup);
                placed = true;
                break;
            }
        }
        if (!placed) {
            console.warn("No space for scroll drop");
        }
    }
}

function updateWisps() {
    if (wisps.length === 0 || gameOver || splashActive) return;
    const wisp = wisps[0]; // Only 1 wisp

    wisp.attackCounter++;

    // Move close to player (realtime, random bob within 1-2 tiles)
    let dx = p.x - wisp.x, dy = p.y - wisp.y;
    let dist = Math.abs(dx) + Math.abs(dy);
    if (dist > 2 || Math.random() < 0.3) {
        let nx = wisp.x, ny = wisp.y;
        if (dist > 2) {
            nx += dx > 0 ? 1 : (dx < 0 ? -1 : 0);
            ny += dy > 0 ? 1 : (dy < 0 ? -1 : 0);
        } else {
            const dirs = [{dx:0,dy:-1}, {dx:0,dy:1}, {dx:-1,dy:0}, {dx:1,dy:0}];
            const randDir = dirs[Math.floor(Math.random() * dirs.length)];
            nx += randDir.dx; ny += randDir.dy;
        }
        if (nx >= 0 && nx < W && ny >= 0 && ny < H &&
            map[ny][nx] === 0 &&
            !(nx === p.x && ny === p.y) &&
            ![7,23].includes(map[ny][nx])) {
            const oldX = wisp.x, oldY = wisp.y;
            wisp.x = nx; wisp.y = ny;
            wisp.targetTileX = nx; wisp.targetTileY = ny;
            wisp.deltaX = (nx - oldX) * 2;
            wisp.deltaY = (ny - oldY) * 2;
            wisp.stepsLeft = 8;
            wisp.moving = true;
        }
    }

    // Attack every 2nd enemy turn if enemy in range
    if (wisp.attackCounter % 2 === 0) {
        const inRangeEnemies = enemies.filter(e => {
            let edist = Math.abs(e.x - wisp.x) + Math.abs(e.y - wisp.y);
            return edist <= wisp.type.range && e.hp > 1; // ignore 1-HP enemies
        });
        if (inRangeEnemies.length > 0) {
            const target = inRangeEnemies[0];
            applyWispAttack(wisp, target);
        }
    }

    // Animate idle bob
    const now = performance.now();
    if (now - wisp.anim.lastFrameTime >= 400) {
        wisp.anim.frameIndex = (wisp.anim.frameIndex + 1) % 3;
        wisp.anim.lastFrameTime = now;
    }
    needsRedraw = true;
}

function applyWispAttack(wisp, primaryTarget) {
    const now = Date.now();
    let hitEnemies = new Set(); // Track all affected enemies for flash

    // ——— MAIN TARGET (always hits first) ———
    if (wisp.type.damage > 0) {
        // Fire / Earth / Chain respect bit shield — Cold (freeze) ignores it
        if (primaryTarget.bitAmmo > 0 && wisp.type.effect !== 'freeze') {
            primaryTarget.bitAmmo--;
            primaryTarget.bits = primaryTarget.bitAmmo;
            primaryTarget.shieldFlash = { active: true, startTime: now };
            logBattleEvent(`Wisp ${wisp.type.name.toUpperCase()} blocked by shield!`);
        } else {
            const dmg = wisp.type.damage;
            const actualDmg = Math.min(dmg, primaryTarget.hp - 1); // ← MERCY: never below 1
            if (actualDmg > 0) {
                primaryTarget.hp -= actualDmg;
                let verb = '';
                let effect = '';
                switch (wisp.type.name) {
                    case 'fire': verb = 'scorches'; effect = '[FIRE BOLT]'; break;
                    case 'chain': verb = 'zaps'; effect = '[CHAIN LIGHTNING]'; break;
                    case 'earth': verb = 'smashes'; effect = '[EARTHQUAKE]'; break;
                }
                logBattleEvent(`Wisp ${verb} ${primaryTarget.type.name} for ${actualDmg} damage! ${effect}`);
                playWebAudioSound(sounds.attack);
            }
            if (primaryTarget.hp === 1) {
                logBattleEvent(`Wisp spares ${primaryTarget.type.name}!`);
            }
        }
        hitEnemies.add(primaryTarget);
    }
    else if (wisp.type.effect === 'freeze') {
        // Cold = freeze (ignores shield, no damage, no mercy needed)
        primaryTarget.frozen = true;
        primaryTarget.frozenTurns = 2;
        logBattleEvent(`Wisp freezes ${primaryTarget.type.name}! [FROST LOCK]`);
        playWebAudioSound(sounds.attack);
        hitEnemies.add(primaryTarget);
    }

    // ——— AOE EFFECTS (only apply to nearby enemies) ———
    const range = wisp.type.range;

    enemies.forEach(enemy => {
        if (enemy === primaryTarget) return;
        const dist = Math.abs(enemy.x - wisp.x) + Math.abs(enemy.y - wisp.y);
        if (dist > range) return;

        let affected = false;

        if (wisp.type.name === 'cold' && wisp.type.aoe === 'medium') {
            // Medium AOE freeze
            const dx = Math.abs(enemy.x - primaryTarget.x);
            const dy = Math.abs(enemy.y - primaryTarget.y);
            if (dx <= 1 && dy <= 1) {
                enemy.frozen = true;
                enemy.frozenTurns = 2;
                logBattleEvent(`Wisp freezes ${enemy.type.name} in cold nova!`);
                affected = true;
            }
        }
        else if (wisp.type.name === 'chain' && wisp.type.aoe === 'large') {
            // Large chain: 1 damage to all in range
            if (enemy.bitAmmo > 0) {
                enemy.bitAmmo--;
                enemy.bits = enemy.bitAmmo;
                enemy.shieldFlash = { active: true, startTime: now };
                logBattleEvent(`[CHAIN LIGHTNING] jumps to ${enemy.type.name} — blocked!`);
            } else {
                const chainDmg = Math.min(1, enemy.hp - 1);
                if (chainDmg > 0) {
                    enemy.hp -= 1;
                    logBattleEvent(`[CHAIN LIGHTNING] jumps to ${enemy.type.name} for 1 dmg!`);
                } else {
                    logBattleEvent(`[CHAIN LIGHTNING] jumps to ${enemy.type.name} — spared!`);
                }
            }
            affected = true;
        }
        else if (wisp.type.name === 'earth' && wisp.type.aoe === 'small') {
            // Small cross quake around primary target
            const dx = Math.abs(enemy.x - primaryTarget.x);
            const dy = Math.abs(enemy.y - primaryTarget.y);
            if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                const quakeDmg = Math.min(2, enemy.hp - 1);
                if (quakeDmg > 0) {
                    enemy.hp -= quakeDmg;
                    logBattleEvent(`Earthquake hits ${enemy.type.name} for ${quakeDmg} dmg!`);
                } else {
                    logBattleEvent(`Earthquake shakes ${enemy.type.name} — spared!`);
                }
                affected = true;
            }
        }

        if (affected) {
            hitEnemies.add(enemy);
            enemy.wispHitFlash = { time: now, type: wisp.type.name };
        }
    });

    // ——— FINAL FLASH ON ALL HIT ENEMIES ———
    hitEnemies.forEach(e => {
        e.wispHitFlash = { time: now, type: wisp.type.name };
    });

    // ——— WISP DEATH CHECK (player can still lose wisp) ———
    if (wisp.hp <= 0) {
        wisps = [];
        logBattleEvent(`Floor ${floor} - Wisp slain!`);
        sounds.gameover.currentTime = 0;
        sounds.gameover.play().catch(() => {});
        deadWispCorpse = {
            x: wisp.x, y: wisp.y,
            frameIndex: wisp.anim.frameIndex,
            fadeStart: now
        };
    }

    needsRedraw = true;
}

// Function to apply spell damage to player
function applySpellDamage(x, y) {
    const dangerousArea = dangerousAreas.find(area => area.x === x && area.y === y);
    if (dangerousArea) {
        let damage = 0;
        let damageType = "";
        switch (dangerousArea.spellType) {
            case SPELL_TYPES.FIRE_WALL:
                damage = 2;
                damageType = "Fire";
                break;
            case SPELL_TYPES.LIGHTNING_STORM:
                damage = 1;
                damageType = "Lightning";
                break;
            case SPELL_TYPES.FROST_NOVA:
                damage = 2;
                damageType = "Frost";
                break;
            case SPELL_TYPES.POISON_CLOUD:
                damage = 1;
                damageType = "Poison";
                break;
        }
        if (p.elementImmunity === damageType || p.armorImmunity === damageType) {
            logBattleEvent(`Floor ${floor} - Immune to ${damageType} spell! No damage taken.`);
        } else {
            p.hp -= damage;
            logBattleEvent(`Floor ${floor} - ${damageType} spell damage! ${damage} DMG`);
            playWebAudioSound(sounds.hit);
        }
        updatePlayerState(); // Centralized: surge if eligible, no early gameOver
    }
}

// Fixed updateProjectiles – pure cardinal movement, spears always destroy on player hit, no laying on ground
function updateProjectiles() {
    if (gameOver || splashActive) return;

    projectiles = projectiles.filter(proj => {
        const now = Date.now();

        // --------------------------------------------------------------
        // 1. Smooth interpolation to current target tile (200ms per tile)
        // --------------------------------------------------------------
        if (proj.moving && proj.moveStartTime) {
            const elapsed = now - proj.moveStartTime;
            const playerSpeed = (proj.value === undefined) ? 67 : 200; // Player swords 3x faster (67ms/tile)
            const progress = Math.min(elapsed / playerSpeed, 1);
            const eased = 0.5 + 0.5 * Math.sin(Math.PI * progress - Math.PI / 2);

            proj.currentX = proj.x * S + eased * (proj.targetX - proj.x * S);
            proj.currentY = proj.y * S + eased * (proj.targetY - proj.y * S);

            if (progress >= 1) {
                // Arrived → snap position and stop moving this step
                proj.currentX = proj.targetX;
                proj.currentY = proj.targetY;
                proj.x = proj.targetTileX;
                proj.y = proj.targetTileY;
                proj.moving = false;
            }
        }

        // --------------------------------------------------------------
        // 2. When not moving (or just arrived), advance to next tile
        // --------------------------------------------------------------
        if (!proj.moving) {
            const nx = proj.x + (proj.dirX || 0);
            const ny = proj.y + (proj.dirY || 0);

            // Out of bounds → destroy
            if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
                needsRedraw = true;
                return false;
            }

            // Wall → destroy
            if (map[ny][nx] === 1) {
                needsRedraw = true;
                return false;
            }

            // --------------------- Player sword hits enemy ---------------------
            if (proj.value === undefined) { // player shooting sword
                const hit = enemies.find(e => e.x === nx && e.y === ny);
                if (hit) {
                    // Bit shield: absorb 1 melee hit if any bits left
                    if (hit.bitAmmo > 0) {
                        hit.bitAmmo--;
                        hit.bits = hit.bitAmmo;
                        hit.shieldFlash = { active: true, startTime: Date.now() };
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} blocks with bit shield!`);
                        playWebAudioSound(sounds.hit);
                    } else {
                    // Bit shield works on any melee hit (close or far)
                    // Soul Sword / Diamond Hand ignore bit shield on shooting sword too
                    // Pickaxe sword does NOT ignore it
                    const ignoreShield = (p.soulStormCharges >= 4 || p.hasDiamondHand) && !usePickaxeSword;

                    if (ignoreShield) {
                        const damage = Math.floor(p.atk * 0.5);
                        hit.hp -= damage;
                        logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (shield ignored)`);
                        playWebAudioSound(sounds.hit);
                    } else if (hit.bitAmmo > 0) {
                        hit.bitAmmo--;
                        hit.bits = hit.bitAmmo;
                        hit.shieldFlash = { active: true, startTime: Date.now() };
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} blocks shooting sword with bit shield!`);
                        playWebAudioSound(sounds.hit);
                    } else {
                        const damage = Math.floor(p.atk * 0.5);
                        hit.hp -= damage;
                        logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (HP: ${hit.hp})`);
                        playWebAudioSound(sounds.hit);
                    }
                    }

                    if (hit.hp <= 0) {
                        kills[hit.type.name]++;
                        let dropPlaced = false;

                        handleUniqueMonsterReward(hit);
                        if (hit.type.name === 'Cursed Trader') {
                            dropSoulStone(hit.x, hit.y);
                        }

                        enemies = enemies.filter(e => e !== hit);

                        // Normal sats drop (skip uniques & Cursed Trader)
                        if (hit.type.name !== 'Cursed Trader') {
                            if (!hit.uniqueName) {
                                if (map[hit.y][hit.x] === 0) {
                                    map[hit.y][hit.x] = 3;
                                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                                    dropPlaced = true;
                                } else {
                                    const adjacent = [
                                        {x: hit.x, y: hit.y - 1},
                                        {x: hit.x, y: hit.y + 1},
                                        {x: hit.x - 1, y: hit.y},
                                        {x: hit.x + 1, y: hit.y}
                                    ];
                                    for (const pos of adjacent) {
                                        const ax = pos.x, ay = pos.y;
                                        if (ax >= 0 && ax < W && ay >= 0 && ay < H && map[ay][ax] === 0 && !enemies.some(e => e.x === ax && e.y === ay)) {
                                            map[ay][ax] = 3;
                                            satoshiDrops.push({x: ax, y: ay, sats: hit.sats, type: hit.type.name});
                                            dropPlaced = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        // Cursed Ring drop (50% for Cursed Trader only)
                        if (hit.type.name === 'Cursed Trader' && Math.random() < 0.5) {
                            let ringPlaced = false;
                            if (map[hit.y][hit.x] === 0 && !p.hasCursedRing) {
                                map[hit.y][hit.x] = 23;
                                ringPlaced = true;
                            } else {
                                const adjacent = [
                                    {x: hit.x, y: hit.y - 1},
                                    {x: hit.x, y: hit.y + 1},
                                    {x: hit.x - 1, y: hit.y},
                                    {x: hit.x + 1, y: hit.y}
                                ];
                                for (const pos of adjacent) {
                                    const ax = pos.x, ay = pos.y;
                                    if (ax >= 0 && ax < W && ay >= 0 && ay < H && map[ay][ax] === 0 && !enemies.some(e => e.x === ax && e.y === ay) && !p.hasCursedRing) {
                                        map[ay][ax] = 23;
                                        ringPlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (ringPlaced) {
                                logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                                playWebAudioSound(sounds.pickup);
                            }
                        }

                        // Rune drop (20% Hell Shrimp, 10% others)
                        if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                            let runeLetter;
                            if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                                const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                                runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                            } else {
                                const runeLetters = ['a','b','c','d','e','f','g','h','i','k','l','m','n','o','p','q','r','s','t','u','v','y','z','æ','ø'];
                                runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                            }
                            let runePlaced = false;
                            if (map[hit.y][hit.x] === 0) {
                                map[hit.y][hit.x] = 8;
                                runeDrops.push({x: hit.x, y: hit.y, letter: runeLetter});
                                runePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: hit.x, y: hit.y - 1},
                                    {x: hit.x, y: hit.y + 1},
                                    {x: hit.x - 1, y: hit.y},
                                    {x: hit.x + 1, y: hit.y}
                                ];
                                for (const pos of adjacent) {
                                    const ax = pos.x, ay = pos.y;
                                    if (ax >= 0 && ax < W && ay >= 0 && ay < H && map[ay][ax] === 0 && !enemies.some(e => e.x === ax && e.y === ay)) {
                                        map[ay][ax] = 8;
                                        runeDrops.push({x: ax, y: ay, letter: runeLetter});
                                        runePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (runePlaced) {
                                logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                                playWebAudioSound(sounds.rune_drop);
                            }
                        }

                        enemies = enemies.filter(e => e !== hit);
                    }
                    needsRedraw = true;
                    return false; // sword stops on hit
                }
            }

            // --------------------- Bit spear hits player ---------------------
if (nx === p.targetTileX && ny === p.targetTileY) {
    const dmg = proj.value === 1 ? 2 : 0;
    p.hp -= dmg;

    // ←←←←←←←←←←←  SPEAR HIT SHAKE  ←←←←←←←←←←←
    if (dmg > 0) {
        spearHitShakeIntensity = 1.0;              // full intensity for real hit
        spearHitShakeStart = Date.now();
    } else {
        spearHitShakeIntensity = 0.4;              // lighter shake for blank spear
        spearHitShakeStart = Date.now();
    }
    // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←

    // Decrement shooter ammo
    const shooter = enemies.find(e =>
        e.x === proj.x - (proj.dirX || 0) &&
        e.y === proj.y - (proj.dirY || 0)
    );
    if (shooter && shooter.bitAmmo > 0) {
        shooter.bitAmmo--;
        shooter.bits = shooter.bitAmmo;
    }
    const shooterName = shooter ? (shooter.uniqueName || shooter.type.name) : 'Enemy';
    
    if (dmg > 0) {
        logBattleEvent(`Floor ${floor} - ${shooterName} spear hits! ${dmg} DMG`);
        spearHitShakeIntensity = 1.0;  // strong shake
    } else {
        logBattleEvent(`Floor ${floor} - ${shooterName} spear flies by!`);
        spearHitShakeIntensity = 0.6;  // ↑ slightly stronger miss shake (noticeable!)
    }
    playWebAudioSound(sounds.hit);
    updatePlayerState();
    needsRedraw = true;
    return false; // spear destroyed
}

            // --------------------- Continue flying ---------------------
            proj.targetTileX = nx;
            proj.targetTileY = ny;
            proj.targetX = nx * S;
            proj.targetY = ny * S;
            proj.moveStartTime = now;
            proj.moving = true;
        }

        needsRedraw = true;
        return true; // keep alive
    });
}

function updateAndDrawMatrix() {
    const now = performance.now();

    // === ENEMY AURA RINGS + FLOATING BITS (makes dull emojis feel alive & powerful) ===
    enemies.forEach(e => {
        // Skip effects if enemy is in fog of war
        if (fogMap[e.y][e.x] === 0) return;

        const dist = Math.sqrt((e.x - p.x)**2 + (e.y - p.y)**2);
        if (dist > 7) return; // only nearby enemies

        const isUnique = !!e.uniqueName;
        // Individual per-enemy sync + more flamboyant energy
        const phaseOffset = e.x * 123.45 + e.y * 678.9; // unique phase per enemy position
        const baseSpeed = isUnique ? 280 : 450;
        const flamboyant = Math.sin(now / 180 + phaseOffset * 0.01) * 0.3; // quick flashy bursts
        const pulse = 0.5 + 0.5 * Math.sin(now / baseSpeed + phaseOffset * 0.02) + flamboyant;

        // === DRAW EFFECTS IN FRONT OF THE ENEMY (cleaner, no composite issues) ===
        c.save();

        // 2. Clean, performant floating bits (visible but mobile-friendly)
        const bitCount = e.bits;
        if (bitCount > 0) {
            const angleIncrement = Math.PI * 2 / bitCount;
            const baseRadius = S / 2 + 5;        // nicely spaced
            const bitSize = 3;                   // 3x3 – clear but tiny

            for (let i = 0; i < bitCount; i++) {
                // Simple smooth orbit – no extra Math.sin wobble (saves CPU)
                const angle = now * 0.001 + i * angleIncrement;
                const bx = e.currentX + S / 2 + Math.cos(angle) * baseRadius;
                const by = e.currentY + S / 2 + Math.sin(angle) * baseRadius;

                c.fillStyle = isUnique ? '#ff3366' : '#f7931a';
                c.fillRect(bx - bitSize/2, by - bitSize/2, bitSize, bitSize);
            }
        }

        // 3. Matrix rain – 4 pillars, stepped random length 2/4/6/8, custom chars
        const matrixText = "0B1";
        const textSize = 6;
        const textColor = isUnique ? '#ff3366' : '#f7931a';
        const baseR = parseInt(textColor.slice(1,3),16);
        const baseG = parseInt(textColor.slice(3,5),16);
        const baseB = parseInt(textColor.slice(5,7),16);

        c.font = `${textSize}px 'VT323', monospace`;
        c.textAlign = 'center';
        c.textBaseline = 'middle';

        const pillarCount = 4;
        const pillarWidth = S / pillarCount;
        const speedBase = 0.001;

        for (let i = 0; i < pillarCount; i++) {
            const pillarX = e.currentX + (i + 0.5) * pillarWidth;
            const speed = speedBase + (i + Math.floor(phaseOffset * 10)) * 0.004;

            // Stepped random length: 2, 4, 6, or 8 characters
            const enemySeed = Math.floor(phaseOffset * 1000);
            const pillarSeed = enemySeed + i * 7919;
            const stepIndex = Math.abs(pillarSeed + Math.floor(now / 1200)) % 4;
            const length = [2, 4, 6][stepIndex]; // ← now shorter and cleaner

            for (let j = 0; j < length; j++) {
                const yPos = e.currentY - j * textSize;
                const charIdx = Math.floor((now * speed + j * 1.8) % matrixText.length);
                const alpha = 0.7 * (1 - j / length);
                c.fillStyle = `rgba(${baseR},${baseG},${baseB},${alpha})`;
                c.fillText(matrixText[charIdx], pillarX, yPos);
            }
        }

        // 4. Subtle screen distortion ripple (using canvas drawing methods)
        if (Math.random() < 0.3) {
            c.globalAlpha = 0.15;
            const rippleX = e.currentX - 2 + Math.random() * 4;
            const rippleY = e.currentY - 2 + Math.random() * 4;
            const rippleSize = S + 4;

            c.beginPath();
            c.arc(rippleX + rippleSize / 2, rippleY + rippleSize / 2, rippleSize / 2, 0, Math.PI * 2);
            c.fillStyle = 'rgba(255, 255, 255, 0.1)';
            c.fill();
        }

        // 5. Aery and offset effect
        const offsetX = Math.sin(now * 0.01 + phaseOffset) * 2; // Slight horizontal offset
        const offsetY = Math.cos(now * 0.01 + phaseOffset) * 2; // Slight vertical offset
        const offsetAlpha = 0.3; // More transparent offset

        c.globalAlpha = offsetAlpha;
        c.beginPath();
        c.arc(e.currentX + S / 2 + offsetX, e.currentY + S / 2 + offsetY, S / 2, 0, Math.PI * 2);
        c.fillStyle = isUnique ? 'rgba(255, 51, 102, 0.5)' : 'rgba(247, 147, 26, 0.5)';
        c.fill();
        c.globalAlpha = 1;

        c.restore();
    });
}


let usePickaxeSword = false; // Global flag for draw
let ripBlastActive = false; // Flag for RIP blast gradient overlay effect
let ripBlastStartTime = 0; // Timestamp for RIP blast start
let columnProgress = 0; // Progress of gradient columns (0 to 1)

let enemyTempCanvas = document.createElement('canvas');
enemyTempCanvas.width = S;
enemyTempCanvas.height = S;
let enemyTempCtx = enemyTempCanvas.getContext('2d');

let auraTempCanvas = document.createElement('canvas');
auraTempCanvas.width = W * S;
auraTempCanvas.height = H * S;
let auraTempCtx = auraTempCanvas.getContext('2d');

// Initialize gradient column overlay for RIP blast effect
function initGradientOverlay() {
    columnProgress = 0; // Start at beginning of animation
}

// Modified checkRunewords function to display 5x5 rune grid with counts
function checkRunewords() {
    // Define all possible runes
    const allRunes = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
    
    // Count occurrences of each rune, capped at 9
    const runeCounts = {};
    allRunes.forEach(rune => runeCounts[rune] = 0);
    p.runes.forEach(rune => {
        if (runeCounts[rune] < 9) {
            runeCounts[rune]++;
        }
    });
    
// Build 5x5 grid display
let displayText = '<br>'; // Start with a <br> for the first row
for (let i = 0; i < 5; i++) {
    const row = allRunes.slice(i * 5, (i + 1) * 5).map(rune => {
        const count = runeCounts[rune];
        const letter = rune.toUpperCase();
        const display = `${letter}<sup style="font-size: 0.6em;">${count}</sup>`;
        if (count > 0) {
            return display;
        }
        return `<span style="opacity: 0;">${display}</span>`;
    }).join('  '); // Two spaces for separation
    //displayText += row + (i < 4 ? '<br>' : ''); // Newline except for last row
    displayText += row + (i < 4 ? ' ' : ''); // Newline except for last row
}
    
    // Wrap displayText in a span with Safari-compatible nbsp styling
    const wrappedDisplayText = `<span style="-webkit-nbsp-mode: normal;">${displayText}</span>`;
    
    // Update inventory display
    document.getElementById('runes').innerHTML = wrappedDisplayText; // Apply wrapped text to runes element
}

// Modified checkRunewordsAtFloorStart function to check for BTC, HODL, RIP and SAT runes in any order
function checkRunewordsAtFloorStart() {
    // Only check for runewords at start of floor (no continuous checking)
    const runewords = [
        { name: 'btc', runes: ['b', 't', 'c'], effect: () => {
            p.hp += 444;
            p.maxHP = Math.max(p.maxHP, p.hp);
            p.runewords.push('btc');
            logBattleEvent(`Floor ${floor} - Runeword BTC activated! +444 HP (now ${p.hp})`);
            updatePlayerState();
            needsRedraw = true;
        }},
        { name: 'hodl', runes: ['h', 'o', 'd', 'l'], effect: () => {
            p.immortal = true;
            p.runewords.push('hodl');
            logBattleEvent(`Floor ${floor} - Runeword HODL activated! You are immortal!`);
            updatePlayerState();
            needsRedraw = true;
        }},
	{ name: 'rip', runes: ['r', 'i', 'p'], effect: () => {
	    p.ripBlast = true;
	    p.runewords.push('rip');
	    logBattleEvent(`Floor ${floor} - Runeword RIP activated! Incoming blast...`);
	    needsRedraw = true;
	}},
	{ name: 'sat', runes: ['s', 'a', 't'], effect: () => {
	    p.atk *= 2;
	    p.runewords.push('sat');
	    logBattleEvent(`Floor ${floor} - Runeword SAT activated! Attack doubled to ${p.atk}! (Satoshi's blessing)`);
	    updatePlayerState();
	    needsRedraw = true;
	}}
    ];

    // Compute rune counts and indices in a single pass
    const runeData = { counts: {}, indices: {} };
    p.runes.forEach((rune, i) => {
        if (!runeData.counts[rune]) {
            runeData.counts[rune] = 0;
            runeData.indices[rune] = [];
        }
        runeData.counts[rune]++;
        runeData.indices[rune].push(i);
    });

    let usedIndices = [];
    let activatedRunewords = [];

    // Check each runeword
    for (const runeword of runewords) {
        if (p.runewords.includes(runeword.name)) continue; // Skip already activated runewords

        // Check if all required runes are available
        const hasAllRunes = runeword.runes.every(rune => (runeData.counts[rune] || 0) > 0);
        if (hasAllRunes) {
            // Collect indices for the required runes
            const indices = [];
            for (const rune of runeword.runes) {
                if (runeData.indices[rune].length > 0) {
                    indices.push(runeData.indices[rune].shift()); // Take first available index
                    runeData.counts[rune]--;
                } else {
                    break; // Missing a rune, stop checking this runeword
                }
            }
            if (indices.length === runeword.runes.length) { // All runes found
                runeword.effect();
                usedIndices.push(...indices);
                activatedRunewords.push(runeword.name.toUpperCase());
            }
        }
    }

    // Display runeword message if any were activated
    if (activatedRunewords.length > 0) {
        const floorIndicator = document.getElementById('floor-indicator');
        floorIndicator.textContent = `Runeword${activatedRunewords.length > 1 ? 's' : ''} ${activatedRunewords.join(', ')} found!`;
        if (!specialSoundsPlayedThisFloor.rune) {
            playWebAudioSound(sounds.rune);
            specialSoundsPlayedThisFloor.rune = true;
        }
        setTimeout(() => {
            const currentText = floorIndicator.textContent;
            if (currentText.startsWith("Runeword")) {
                floorIndicator.textContent = `Floor ${floor}`;
            }
        }, 5000);
    }

    // Remove used runes
    if (usedIndices.length > 0) {
        usedIndices.sort((a, b) => b - a); // Sort descending to avoid index issues
        for (const index of usedIndices) {
            p.runes.splice(index, 1);
        }
    }

    // Clear specific rune drops
    runeDrops = runeDrops.filter(r => !r.specific);
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 9) {
                map[y][x] = 0; // Clear specific rune tiles
            }
        }
    }

    checkRunewords(); // Update inventory display
    needsRedraw = true;
}

// Modified handleUniqueMonsterReward function with fadeout before removing dangerous areas
function handleUniqueMonsterReward(hit) {
    if (!hit.uniqueName) return false;
    
    // Reward for unique monster: at least 2X (up to 4X) the normal sats/btc
    const baseReward = hit.sats;
    const floorMultiplier = floor / 100; // Calculate floor multiplier
    const added = Math.floor(baseReward * floorMultiplier); // Apply floor multiplier
    const baseWithMultiplier = baseReward + added; // Base reward with floor multiplier
    
// Apply additional random multiplier for unique monsters (2x to 4x)
    const randomMultiplier = 2 + Math.random() * 2; // Random multiplier from 2x to 4x
    const reward = Math.round(baseWithMultiplier * randomMultiplier);
    
    // Add bitcoin drops around the monster position (skip for Cursed Trader)
    let dropPlaced = false;
    if (hit.type.name !== 'Cursed Trader') {
        if (map[hit.y][hit.x] === 0) {
            map[hit.y][hit.x] = 3;
            satoshiDrops.push({x: hit.x, y: hit.y, sats: reward, type: hit.type.name});
            dropPlaced = true;
        } else {
            const adjacent = [
                {x: hit.x, y: hit.y - 1},
                {x: hit.x, y: hit.y + 1},
                {x: hit.x - 1, y: hit.y},
                {x: hit.x + 1, y: hit.y}
            ];
            for (const pos of adjacent) {
                const nx = pos.x, ny = pos.y;
                if (
                    nx >= 0 && nx < W && ny >= 0 && ny < H &&
                    map[ny][nx] === 0 &&
                    !enemies.some(e => e.x === nx && e.y === ny)
                ) {
                    map[ny][nx] = 3;
                    satoshiDrops.push({x: nx, y: ny, sats: reward, type: hit.type.name});
                    dropPlaced = true;
                    break;
                }
            }
        }
    }
    
    if (dropPlaced) {
        const rewardBtc = reward / 1e8;
        const [displayAmount, displayUnit] = rewardBtc < 1 ? [Math.round(reward), 'sats'] : [rewardBtc.toFixed(2), 'BTC'];
        logBattleEvent(`Floor ${floor} - Unique monster ${hit.uniqueName} defeated! Reward: ${displayAmount} ${displayUnit}`);

        // Clear harbinger message if it was active for this monster
        const floorIndicator = document.getElementById('floor-indicator');
        if (floorIndicator.textContent === "A harbinger of doom is near.") {
            floorIndicator.textContent = `Floor ${floor}`;
        }
        activeUniqueMonsterName = null; // Also clear any lingering visible name
        // Also add to satsEarned for proper display (skip Cursed Trader)
        if (hit.type.name !== 'Cursed Trader') {
            satsEarned[hit.type.name] += reward;
        }
        updateSatsDisplay();
    } else {
        logBattleEvent(`Floor ${floor} - Unique monster ${hit.uniqueName} defeated!`);
    }
    
// Tag all areas with this monster's death timestamp for global fadeout/removal
if (hit.uniqueName && hit.spell) {
    const deathTime = Date.now();
    dangerousAreas.forEach(area => {
        if (area.spellType === hit.spell) {
            area.deathTime = deathTime; // Tag for fadeout
        }
    });
    

}
    
    return true;
}

// Function to assign a spell to a unique monster when it spawns
function assignUniqueMonsterSpell(enemy) {
    // Only assign spells to unique monsters
    if (!enemy.uniqueName || !uniqueMonsterNames[enemy.type.name]) {
        return null;
    }

    // Elemental keyword correlations (case-insensitive)
    const correlations = {
        fire: SPELL_TYPES.FIRE_WALL, blaze: SPELL_TYPES.FIRE_WALL, inferno: SPELL_TYPES.FIRE_WALL,
        storm: SPELL_TYPES.LIGHTNING_STORM, lightning: SPELL_TYPES.LIGHTNING_STORM, bolt: SPELL_TYPES.LIGHTNING_STORM, thunder: SPELL_TYPES.LIGHTNING_STORM,
        cold: SPELL_TYPES.FROST_NOVA, frost: SPELL_TYPES.FROST_NOVA, ice: SPELL_TYPES.FROST_NOVA, chill: SPELL_TYPES.FROST_NOVA,
        poison: SPELL_TYPES.POISON_CLOUD, viper: SPELL_TYPES.POISON_CLOUD, snot: SPELL_TYPES.POISON_CLOUD, plague: SPELL_TYPES.POISON_CLOUD,
        bile: SPELL_TYPES.POISON_CLOUD, pox: SPELL_TYPES.POISON_CLOUD, ooze: SPELL_TYPES.POISON_CLOUD, venom: SPELL_TYPES.POISON_CLOUD
    };

    // Check for matching keyword in name
    const nameLower = enemy.uniqueName.toLowerCase();
    let matchedSpell = null;
    for (const [keyword, spell] of Object.entries(correlations)) {
        if (nameLower.includes(keyword)) {
            matchedSpell = spell;
            break;
        }
    }

    // Assign matched spell or fallback to random
    const spell = matchedSpell || Object.values(SPELL_TYPES)[Math.floor(Math.random() * Object.keys(SPELL_TYPES).length)];
    enemy.spell = spell;
    return spell;
}

// Enhanced draw for fading dangerous areas based on deathTime
function drawFadingDangerousAreas() {
    dangerousAreas.forEach(area => {
        const dist = Math.sqrt((area.x - p.x) ** 2 + (area.y - p.y) ** 2);
        const isVisible = fogMap[area.y][area.x] === 1 || dist <= 4;
        if (!isVisible) return; // Skip fog-hidden areas
        
        let spellAlpha = 0.5;
        let spellColor = 'rgba(255, 255, 255, 0.5)';
        
        // Fade if tagged with deathTime
        if (area.deathTime) {
            const elapsed = Date.now() - area.deathTime;
            const fadeDuration = 5000;
            const progress = Math.min(elapsed / fadeDuration, 1);
            spellAlpha *= (1 - progress);
            
            // Set color based on spell
            switch (area.spellType) {
                case SPELL_TYPES.FIRE_WALL: spellColor = `rgba(255, 0, 0, ${spellAlpha})`; break;
                case SPELL_TYPES.LIGHTNING_STORM: spellColor = `rgba(255, 255, 0, ${spellAlpha})`; break;
                case SPELL_TYPES.FROST_NOVA: spellColor = `rgba(0, 255, 255, ${spellAlpha})`; break;
                case SPELL_TYPES.POISON_CLOUD: spellColor = `rgba(0, 255, 0, ${spellAlpha})`; break;
            }
        } else {
            // Non-fading areas
            switch (area.spellType) {
                case SPELL_TYPES.FIRE_WALL: spellColor = 'rgba(255, 0, 0, 0.5)'; break;
                case SPELL_TYPES.LIGHTNING_STORM: spellColor = 'rgba(255, 255, 0, 0.5)'; break;
                case SPELL_TYPES.FROST_NOVA: spellColor = 'rgba(0, 255, 255, 0.5)'; break;
                case SPELL_TYPES.POISON_CLOUD: spellColor = 'rgba(0, 255, 0, 0.5)'; break;
            }
        }
        
        c.save();
        c.fillStyle = spellColor;
        c.fillRect(area.x * S, area.y * S, S, S);
        c.restore();
    });

    // Continuous cleanup: remove fully faded areas
    const now = Date.now();
    dangerousAreas = dangerousAreas.filter(area => {
        if (area.deathTime) {
            const elapsed = now - area.deathTime;
            return elapsed < 2000;  // Remove after 2s
        }
        return true;
    });

    if (needsRedraw) needsRedraw = true;  // Ensure redraw if cleaned
}

// Modified attack function with Hell Shrimp rune drop rate changed to 20%
function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    
    // Update player direction
    let newDirection = p.anim.direction;
    if (swordDir === 'up') newDirection = 'back';
    if (swordDir === 'down') newDirection = 'front';
    if (swordDir === 'left') newDirection = 'left';
    if (swordDir === 'right') newDirection = 'right';
    p.anim.direction = newDirection;
    
    const initialPickaxes = p.pickaxes;
    
    // Check for enemy or wall one tile away in swordDir
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    
    const isEnemyNearby = enemies.some(e => e.x === sx && e.y === sy);
    const isWallNearby = sx >= 0 && sx < W && sy >= 0 && sy < H && map[sy][sx] === 1;
    
    if (initialPickaxes > 0 || isEnemyNearby || isWallNearby) {
        usePickaxeSword = initialPickaxes > 0;
        let hit = enemies.find(e => e.x === sx && e.y === sy);
        
if (hit) {
    // Check if the enemy is a unique monster that can cast spells
    if (hit.uniqueName && hit.spell) {
        // Unique monster uses its spell
        const spellEffect = hit.spell;
        logBattleEvent(`Floor ${floor} - ${hit.uniqueName} casts ${spellEffect}!`);
        
        // Create the spell effect area around the enemy position
        switch (spellEffect) {
            case SPELL_TYPES.FIRE_WALL:
                // Create fire wall in a 3x3 area centered on the enemy
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
            case SPELL_TYPES.LIGHTNING_STORM:
                // Create lightning storm in a 5x5 area centered on the enemy
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
            case SPELL_TYPES.FROST_NOVA:
                // Create frost nova in a 3x3 area centered on the enemy
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
            case SPELL_TYPES.POISON_CLOUD:
                // Create poison cloud in a 5x5 area centered on the enemy
                for (let dx = -2; dx <= 2; dx++) {
                    for (let dy = -2; dy <= 2; dy++) {
                        const x = hit.x + dx;
                        const y = hit.y + dy;
                        if (x >= 0 && x < W && y >= 0 && y < H) {
                            // Only create the spell area if it's not already a wall or another spell area
                            if (map[y][x] !== 1 && !dangerousAreas.some(area => area.x === x && area.y === y)) {
                                createDangerousArea(x, y, spellEffect);
                            }
                        }
                    }
                }
                break;
        }
    }
    if (p.hasDiamondHand && !(p.pickaxes > 0 && usePickaxeSword)) {
        // Diamond hand AOE damage - updated to match the specified pattern
        const damageArea = [];
        
        // Determine damage tiles based on direction
        if (swordDir === 'up') {
            const close_y = p.y - 1;
            const far_y = p.y - 2;
            for (let dx = -1; dx <= 1; dx++) {
                damageArea.push({x: p.x + dx, y: close_y});
            }
            for (let dx = -2; dx <= 2; dx++) {
                damageArea.push({x: p.x + dx, y: far_y});
            }
        } else if (swordDir === 'down') {
            const close_y = p.y + 1;
            const far_y = p.y + 2;
            for (let dx = -1; dx <= 1; dx++) {
                damageArea.push({x: p.x + dx, y: close_y});
            }
            for (let dx = -2; dx <= 2; dx++) {
                damageArea.push({x: p.x + dx, y: far_y});
            }
        } else if (swordDir === 'left') {
            const close_x = p.x - 1;
            const far_x = p.x - 2;
            for (let dy = -1; dy <= 1; dy++) {
                damageArea.push({x: close_x, y: p.y + dy});
            }
            for (let dy = -2; dy <= 2; dy++) {
                damageArea.push({x: far_x, y: p.y + dy});
            }
        } else if (swordDir === 'right') {
            const close_x = p.x + 1;
            const far_x = p.x + 2;
            for (let dy = -1; dy <= 1; dy++) {
                damageArea.push({x: close_x, y: p.y + dy});
            }
            for (let dy = -2; dy <= 2; dy++) {
                damageArea.push({x: far_x, y: p.y + dy});
            }
        }
        
        // Apply damage to all valid tiles in the area
        const damage = 3; // Diamond hand AOE damage
        let enemiesHit = 0;
        let totalDamage = 0;
        
        highlightTiles = []; // Clear previous highlights
        for (const tile of damageArea) {
            const {x, y} = tile;
            
            // Check if tile is within bounds and not a wall
            if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 1) {
                highlightTiles.push({x, y, highlightStart: Date.now()}); // Add tile to highlight
                // And add this ONCE per frame (best in draw() or gameLoop):
                highlightTiles = highlightTiles.filter(t => Date.now() - t.highlightStart < 500);
                // Check if there's an enemy at this tile
                const enemy = enemies.find(e => e.x === x && e.y === y);
                
                if (enemy) {
                    // Apply damage to enemy
                    enemy.hp -= damage;
                    logBattleEvent(`Floor ${floor} - Diamond Hand hits ${enemy.type.name} for ${damage} DMG (HP: ${enemy.hp})`);
                    playWebAudioSound(sounds.hit);
                    
                    if (enemy.hp <= 0) {
                        kills[enemy.type.name]++;
                        let dropPlaced = false;

handleUniqueMonsterReward(enemy);
tryDropScroll(enemy.x, enemy.y);
                        
                        // Drop satoshi
                        if (map[enemy.y][enemy.x] === 0) {
                            map[enemy.y][enemy.x] = 3;
                            satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                            dropPlaced = true;
                        } else {
                            const adjacent = [
                                {x: enemy.x, y: enemy.y - 1},
                                {x: enemy.x, y: enemy.y + 1},
                                {x: enemy.x - 1, y: enemy.y},
                                {x: enemy.x + 1, y: enemy.y}
                            ];
                            for (const pos of adjacent) {
                                const nx = pos.x, ny = pos.y;
                                if (
                                    nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                    map[ny][nx] === 0 &&
                                    !enemies.some(e => e.x === nx && e.y === ny)
                                ) {
                                    map[ny][nx] = 3;
                                    satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                                    dropPlaced = true;
                                    break;
                                }
                            }
                        }
                        
                        if (!dropPlaced) {
                            // No space for satoshi drop
                        }

                        // Soul stone drop logic (5% chance)
                        if (Math.random() < 0.05) {
                            let stonePlaced = false;
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 20; // Soul stone tile
                                stonePlaced = true;
                            } else {
                                const adjacent = [
                                    {x: enemy.x, y: enemy.y - 1},
                                    {x: enemy.x, y: enemy.y + 1},
                                    {x: enemy.x - 1, y: enemy.y},
                                    {x: enemy.x + 1, y: enemy.y}
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 20; // Soul stone tile
                                        stonePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (stonePlaced) {
                                p.soulStones++;
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a Soul Stone!`);
                                playWebAudioSound(sounds.buzz);
                            }
                        }

                        // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
                        if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                            let runeLetter;
                            if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                                // Hell Shrimp: Use specific rune letters
                                const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                                runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                            } else {
                                // Regular rune drop
                                const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                                runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                            }
                            let runePlaced = false;
                            if (map[enemy.y][enemy.x] === 0) {
                                map[enemy.y][enemy.x] = 8; // Generic rune on floor
                                runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                                runePlaced = true;
                            } else {
                                const adjacent = [
                                    { x: enemy.x, y: enemy.y - 1 },
                                    { x: enemy.x, y: enemy.y + 1 },
                                    { x: enemy.x - 1, y: enemy.y },
                                    { x: enemy.x + 1, y: enemy.y }
                                ];
                                for (const pos of adjacent) {
                                    const nx = pos.x, ny = pos.y;
                                    if (
                                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                        map[ny][nx] === 0 &&
                                        !enemies.some(e => e.x === nx && e.y === ny)
                                    ) {
                                        map[ny][nx] = 8; // Generic rune on floor
                                        runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                        runePlaced = true;
                                        break;
                                    }
                                }
                            }
                            if (runePlaced) {
                                logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                                playWebAudioSound(sounds.rune_drop);
                            }
                        }
if (enemy.type.name === 'Cursed Trader') {
        dropSoulStone(enemy.x, enemy.y);
    }
                        enemies = enemies.filter(en => en !== enemy);
                        enemiesHit++;
                    }
                    totalDamage += damage;
                }
            }
        }
    } else {
        // Regular sword attack
        const damage = p.atk; // Remove armor bonus
                // Soul Sword / Diamond Hand ignore bit shield
                // Pickaxe sword does NOT ignore it
                const ignoreShield = (p.soulStormCharges >= 4 || p.hasDiamondHand) && !usePickaxeSword;

                if (ignoreShield) {
                    hit.hp -= damage;
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG (shield ignored)!`);
                } else if (hit.bitAmmo > 0) {
                    hit.bitAmmo--;
                    hit.bits = hit.bitAmmo;
                    hit.shieldFlash = { active: true, startTime: Date.now() };
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} blocks with bit shield!`);
                } else {
                    hit.hp -= damage;
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG`);
                }
                playWebAudioSound(sounds.hit);
        
        // Wisp sync attack: Assist player's target
        if (wisps.length > 0) {
            const wisp = wisps[0];
            applyWispAttack(wisp, hit);
        }
        
if (hit.hp <= 0) {
    kills[hit.type.name]++;
    
tryDropScroll(hit.x, hit.y);
    
    let dropPlaced = false;
    
// Handle unique monster rewards using new function
handleUniqueMonsterReward(hit);

        // Normal enemy reward (skip for uniques/Cursed Trader)
        if (!hit.uniqueName && hit.type.name !== 'Cursed Trader') {
            if (map[hit.y][hit.x] === 0) {
                map[hit.y][hit.x] = 3;
                satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                dropPlaced = true;
            } else {
                const adjacent = [
                    {x: hit.x, y: hit.y - 1},
                    {x: hit.x, y: hit.y + 1},
                    {x: hit.x - 1, y: hit.y},
                    {x: hit.x + 1, y: hit.y}
                ];
                for (const pos of adjacent) {
                    const nx = pos.x, ny = pos.y;
                    if (
                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                        map[ny][nx] === 0 &&
                        !enemies.some(e => e.x === nx && e.y === ny)
                    ) {
                        map[ny][nx] = 3;
                        satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                        dropPlaced = true;
                        break;
                    }
                }
            }
        }

        // Cursed Ring drop (50% for Cursed Trader only)
        if (hit.type.name === 'Cursed Trader' && Math.random() < 0.5 && !p.hasCursedRing) {
            let ringPlaced = false;
            if (map[hit.y][hit.x] === 0) {
                map[hit.y][hit.x] = 23; // Cursed ring tile
                ringPlaced = true;
            } else {
                const adjacent = [
                    { x: hit.x, y: hit.y - 1 },
                    { x: hit.x, y: hit.y + 1 },
                    { x: hit.x - 1, y: hit.y },
                    { x: hit.x + 1, y: hit.y }
                ];
                for (const pos of adjacent) {
                    const nx = pos.x, ny = pos.y;
                    if (
                        nx >= 0 && nx < W && ny >= 0 && ny < H &&
                        map[ny][nx] === 0 &&
                        !enemies.some(e => e.x === nx && e.y === ny)
                    ) {
                        map[ny][nx] = 23; // Cursed ring tile
                        ringPlaced = true;
                        break;
                    }
                }
            }
            if (ringPlaced) {
                logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                playWebAudioSound(sounds.pickup);
            }
        }

        if (!dropPlaced && hit.type.name !== 'Cursed Trader') {
            // No space for satoshi drop
        }

            // Soul stone drop logic (5% chance)
            if (Math.random() < 0.05) {
                let stonePlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 20; // Soul stone tile
                    stonePlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 20; // Soul stone tile
                            stonePlaced = true;
                            break;
                        }
                    }
                }
                if (stonePlaced) {
                    p.soulStones++;
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a Soul Stone!`);
                    playWebAudioSound(sounds.buzz);
                }
            }

            // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
            if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                let runeLetter;
                if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                    // Hell Shrimp: Use specific rune letters
                    const hellShrimpRunes = ['r', 'i', 'p', 'h', 'o', 'd', 'l'];
                    runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                } else {
                    // Regular rune drop
                    const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                    runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                }
                let runePlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 8; // Generic rune on floor
                    runeDrops.push({ x: hit.x, y: hit.y, letter: runeLetter });
                    runePlaced = true;
                } else {
                    const adjacent = [
                        { x: hit.x, y: hit.y - 1 },
                        { x: hit.x, y: hit.y + 1 },
                        { x: hit.x - 1, y: hit.y },
                        { x: hit.x + 1, y: hit.y }
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 8; // Generic rune on floor
                            runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                            runePlaced = true;
                            break;
                        }
                    }
                }
                if (runePlaced) {
                    logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                    playWebAudioSound(sounds.rune_drop);
                }
            }

if (hit.type.name === 'Cursed Trader') {
        dropSoulStone(hit.x, hit.y);
    }
            enemies = enemies.filter(en => en !== hit);
        }
    }
} else if (initialPickaxes > 0 && isWallNearby) {
    if (inPuzzleRoom) {
        logBattleEvent("The trial forbids breaking walls – complete it first!");
        // optional short sound feedback
        playWebAudioSound(sounds.buzz || sounds.hit);
    } else {
        p.pickaxes--;
        sounds.secret.play().catch(e => console.error('Secret sound error:', e));
        logBattleEvent(`Floor ${floor} - Wall Broken!`);
        createSecretRoom(sx, sy, p.x, p.y, swordDir);
    }
}

    }
    
// ——— PROJECTILE SPAWNING: SOUL SWORD & NORMAL FULL HP ———
// Only allowed if NO enemy is touching the player (8 surrounding tiles)
function canShootProjectile() {
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue; // Skip player tile
            const nx = p.x + dx;
            const ny = p.y + dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H) {
                if (enemies.some(e => e.x === nx && e.y === ny)) {
                    return false; // Enemy touching → NO projectile
                }
            }
        }
    }
    return true; // All clear → can shoot
}

// ——— SATOSHI'S SCOURGE: Full 360° spin attack ———
if (p.currentWeapon === 'satoshi_scourge' && !usePickaxeSword) {
    // Prevent spam + cost
    if (p.scourgeCooldown > Date.now()) return;
    if (p.soulStormCharges >= 8) {
        p.soulStormCharges -= 8;
        p.scourgeSpin = { start: Date.now() };
        p.scourgeCooldown = Date.now() + 600; // 600ms cooldown
        doScourgeSpinAttack();
        playScourgeSpin();
       
        moveEnemies();
        updateWisps();
        needsRedraw = true;
        return; // Exit early — no other attack
    }
}

// ——— SOUL SWORD: 4+ charges → AOE wave + ranged projectile ———
if (p.soulStormCharges >= 4 && !p.hasDiamondHand && projectiles.length === 0 && !usePickaxeSword) {
    if (!canShootProjectile()) {
        // Still consume charges and do AOE, but NO projectile
        p.soulStormCharges -= 4;
        activateSoulStorm();
        //logBattleEvent(`Soul Sword AOE unleashed — too close for ranged strike!`);
    } else {
        p.soulStormCharges -= 4;
        activateSoulStorm();

        // Fire projectile
        let dirX = 0, dirY = 0;
        if (swordDir === 'right') dirX = 1;
        else if (swordDir === 'left') dirX = -1;
        else if (swordDir === 'down') dirY = 1;
        else if (swordDir === 'up') dirY = -1;

        projectiles.push({
            x: p.x, y: p.y,
            currentX: p.x * S, currentY: p.y * S,
            dirX, dirY,
            moveStartTime: Date.now(),
            moving: true
        });

        const proj = projectiles[projectiles.length - 1];
        proj.targetTileX = p.x + dirX;
        proj.targetTileY = p.y + dirY;
        proj.targetX = proj.targetTileX * S;
        proj.targetY = proj.targetTileY * S;

        sounds.shoot_sword.currentTime = 0;
        sounds.shoot_sword.play().catch(() => {});
    }
}

// ——— NORMAL FULL HP PROJECTILE (HP ≥ 24 + not using special swords) ———
else if (p.hp >= 24 && !p.hasDiamondHand && projectiles.length === 0 && !usePickaxeSword) {
    if (!canShootProjectile()) {
        // Do nothing — no free ranged attack when snugging
        // (Optional: add a subtle "clank" sound or log?)
        // logBattleEvent(`Too close — sword strike only!`);
    } else {
        let dirX = 0, dirY = 0;
        if (swordDir === 'right') dirX = 1;
        else if (swordDir === 'left') dirX = -1;
        else if (swordDir === 'down') dirY = 1;
        else if (swordDir === 'up') dirY = -1;

        projectiles.push({
            x: p.x, y: p.y,
            currentX: p.x * S, currentY: p.y * S,
            dirX, dirY,
            moveStartTime: Date.now(),
            moving: true
        });

        const proj = projectiles[projectiles.length - 1];
        proj.targetTileX = p.x + dirX;
        proj.targetTileY = p.y + dirY;
        proj.targetX = proj.targetTileX * S;
        proj.targetY = proj.targetTileY * S;

        sounds.shoot_sword.currentTime = 0;
        sounds.shoot_sword.play().catch(() => {});
    }
}
    
    moveEnemies();
updateWisps(); // Update wisp pos/attacks synced to player/enemy turns
    needsRedraw = true;
    setTimeout(() => {
        swordActive = false;
        usePickaxeSword = false;
        highlightTiles = []; // Clear highlights after flash
        needsRedraw = true;
    }, 200);
}

function usePotion() {
    if (gameOver || splashActive || p.potions <= 0) return;
if (p.curseActive) {
    logBattleEvent(`Floor ${floor} - Cannot use potion: Lingering curse blocks healing!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Block and play sound for feedback
    }
    if (p.hp >= 24) {
        logBattleEvent(`Floor ${floor} - Potion Returned: HP already at ${p.hp}!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Refund potion by not decrementing p.potions
    }
    p.potions--;
    const oldHP = p.hp;
    p.hp = Math.min(24, p.hp + 12);
    logBattleEvent(`Floor ${floor} - Potion Used: +${p.hp - oldHP} HP (now ${p.hp})`);
    sounds.potion.play().catch(e => console.error('Potion sound error:', e));
    moveEnemies();
updateWisps(); // Update wisp pos/attacks synced to player/enemy turns
    updatePlayerState();
    needsRedraw = true;
}

// Add these functions near the other utility functions
function openSoulTerminal() {
    if (p.inSoulTerminal) return; // Already in terminal
    
    p.inSoulTerminal = true;
    p.soulTerminalActive = true;
    p.soulTerminalCommand = '';
    p.soulTerminalCursorPos = 0;
    
    // Show soul terminal overlay
    const overlay = document.getElementById('soul-terminal-overlay');
    const content = document.getElementById('soul-terminal-content');
    const input = document.getElementById('soul-terminal-input');
    
    // Clear content and add welcome message
    content.innerHTML = '';
    addTerminalLineToContent('Welcome to Soul Terminal!');
    addTerminalLineToContent('Type "help" for available commands.');
    updateSoulTerminalInventory();
    
    // Show overlay and focus input
    overlay.style.display = 'flex';
    setTimeout(() => {
        input.focus();
    }, 100);
}

function closeSoulTerminal() {
    p.inSoulTerminal = false;
    p.soulTerminalActive = false;
    p.soulTerminalCommand = '';
    p.soulTerminalCursorPos = 0;
    
    // Hide soul terminal overlay
    const overlay = document.getElementById('soul-terminal-overlay');
    overlay.style.display = 'none';
    
    // Restore input control
    inputBlocked = false;
    
    // Ensure player is properly positioned after terminal exit
    // This prevents teleportation issues when exiting soul terminal
    updateFogMap(p.x, p.y);
    
    needsRedraw = true;
}

function addTerminalLine(line) {
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value += line + '\n';
    battleEvents.scrollTop = battleEvents.scrollHeight;
}

function addTerminalLineToContent(line) {
    const content = document.getElementById('soul-terminal-content');
    const lineElement = document.createElement('div');
    lineElement.textContent = line;
    content.appendChild(lineElement);
    content.scrollTop = content.scrollHeight;
}

function updateSoulTerminalInventory() {
checkRunewords();
//    addTerminalLineToContent('');
            const clearContent = document.getElementById('soul-terminal-content');
            clearContent.innerHTML = '';
            addTerminalLineToContent('Soul Terminal ver 1.0');
            addTerminalLineToContent('');  
    // Display soul-related items
    addTerminalLineToContent('---- Soul Inventory ----');
    addTerminalLineToContent(`Soul Resonance: ${soulResonance}%`);
    addTerminalLineToContent(`Soul Stones: ${p.soulStones}`);
    addTerminalLineToContent(`Soul Shards: ${p.soulShards}`);
    addTerminalLineToContent(`Soul Orbs: ${p.soulOrbs}`);
    addTerminalLineToContent(`Soul Storm Charges: ${p.soulStormCharges}/256`);
    addTerminalLineToContent('');

    // Display regular inventory items
    addTerminalLineToContent('---- Regular Inventory ----');
    
// Display resistances (elemental and armor)
let resistanceText = '';
if (p.elementImmunity) {
    resistanceText += `${p.elementImmunity} 100%`;
}
if (p.armorImmunity) {
    if (resistanceText) resistanceText += ', ';
    resistanceText += `${p.armorImmunity} 100%`;
}
if (resistanceText) {
    addTerminalLineToContent(`Resistances: ${resistanceText}`);
    addTerminalLineToContent('');
}
// Cursed Ring vulnerability warning
if (p.hasCursedRing) {
    addTerminalLineToContent(`WARNING: Cursed Ring active, -100% to ALL resistances!`);
    addTerminalLineToContent(`Aura Shield: ${p.auraShield}/${p.auraMax}`);
    addTerminalLineToContent('');
}
    
    addTerminalLineToContent(`Health: ${p.hp}`);
    addTerminalLineToContent(`Potions: ${p.potions}`);
    addTerminalLineToContent(`Pickaxes: ${p.pickaxes}`);
    addTerminalLineToContent(`Diamonds: ${diamonds}`);
    addTerminalLineToContent(`Perfectly Cut Diamonds: ${document.getElementById('perfectlyCutDiamonds').textContent}`);
    //addTerminalLineToContent(`Runes: ${document.getElementById('runes').textContent}`); // all runes
    // Get runes text and filter out runes ending with 0 (like p0)
    let runesText = document.getElementById('runes').textContent;
    let displayRunes = 'None'; // Default to 'None' if no runes remain
    if (runesText) {
        // Split by spaces and filter out runes ending with 0
        const runeArray = runesText.split(/\s+/).filter(rune => rune && !rune.endsWith('0'));
        if (runeArray.length > 0) {
            displayRunes = runeArray.join(' ');
        }
    }
    addTerminalLineToContent(`Runes: ${displayRunes}`);
    addTerminalLineToContent('');
//    addTerminalLineToContent('--- Audio Settings ---');
//    addTerminalLineToContent(`Sound Volume: ${(soundVolume * 100).toFixed(0)}%`);
//    addTerminalLineToContent(`Music Volume: ${(musicVolume * 100).toFixed(0)}%`);
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
}

function processSoulCommand(command) {
    const trimmed = command.trim();
    
    if (trimmed === '') return;
    
    // Clear screen before executing any command (always)
    const content = document.getElementById('soul-terminal-content');
    content.innerHTML = '';
            addTerminalLineToContent('Soul Terminal ver 1.0');
            addTerminalLineToContent('');
    // Parse command and arguments
    const parts = trimmed.split(' ');
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1);
    
    switch (cmd) {
case 'ls':
            updateSoulTerminalInventory();
            break;
case 'clear':
            const clearContent = document.getElementById('soul-terminal-content');
            // Check if there are arguments after 'clear'
            if (args.length > 0) {
                // Join all arguments with spaces to create the ASCII art text
                const asciiText = args.join(' ');
                // Create a simple ASCII art effect by displaying each character
                clearContent.innerHTML = '';
                addTerminalLineToContent(asciiText.padEnd(54));
            } else {
                clearContent.innerHTML = '';
            }
            break;
        case 'exit':
            closeSoulTerminal();
            return;
case 'help':
    addTerminalLineToContent('Available commands:');
    addTerminalLineToContent('  ls ---------- View inventory');
    addTerminalLineToContent('  convert ----- Convert soul stones, shards, wisp');
    addTerminalLineToContent('  swap -------- Swap weapons');
    addTerminalLineToContent('  reset ------- Restart current puzzle trial');
    addTerminalLineToContent('  set --------- Settings');
    addTerminalLineToContent('  clear ------- Clear screen');
    addTerminalLineToContent('  leaderboard - View top 10 scores');
    addTerminalLineToContent('  exit -------- Exit terminal');
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
case 'convert':
            if (args.length === 0) {
                addTerminalLineToContent('Usage: convert stones [count]');
                addTerminalLineToContent('Usage: convert shards [count]');
                addTerminalLineToContent('Usage: convert wisp [count]');
                addTerminalLineToContent('_____________________');
                addTerminalLineToContent('Type "help" for help.');
            } else {
                const type = args[0].toLowerCase();
                let count = 1; // Default to 1 if no count specified
                
                // Check if a count was provided (second argument)
                if (args.length > 1 && !isNaN(args[1])) {
                    count = parseInt(args[1]);
                }
                
                switch (type) {
                    case 'stones':
                        const maxStonesToConvert = Math.floor(p.soulStones / 3) * 3; // Ensure we convert in multiples of 3
                        if (args.length > 1 && !isNaN(args[1])) {
                            count = Math.min(count, maxStonesToConvert);
                        } else {
                            count = maxStonesToConvert;
                        }
                        
                        if (count >= 3) {
                            const shardsToGain = Math.floor(count / 3);
                            p.soulStones -= count;
                            p.soulShards += shardsToGain;
                            addTerminalLineToContent(`Converted ${count} Soul Stones into ${shardsToGain} Soul Shards.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else if (p.soulStones >= 3) {
                            // If no count specified or count < 3, convert minimum
                            p.soulStones -= 3;
                            p.soulShards++;
                            addTerminalLineToContent('Converted 3 Soul Stones into 1 Soul Shard.');
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else {
                            addTerminalLineToContent(`Need at least 3 Soul Stones, you have ${p.soulStones}.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        }
                        break;
                    case 'shards':
                        const maxShardsToConvert = Math.floor(p.soulShards / 2) * 2; // Ensure we convert in multiples of 2
                        if (args.length > 1 && !isNaN(args[1])) {
                            count = Math.min(count, maxShardsToConvert);
                        } else {
                            count = maxShardsToConvert;
                        }
                        
                        if (count >= 2) {
                            const orbsToGain = Math.floor(count / 2);
                            p.soulShards -= count;
                            p.soulOrbs += orbsToGain;
                            addTerminalLineToContent(`Converted ${count} Soul Shards into ${orbsToGain} Soul Orbs.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else if (p.soulShards >= 2) {
                            // If no count specified or count < 2, convert minimum
                            p.soulShards -= 2;
                            p.soulOrbs++;
                            addTerminalLineToContent('Converted 2 Soul Shards into 1 Soul Orb.');
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        } else {
                            addTerminalLineToContent(`Need at least 2 Soul Shards, you have ${p.soulShards}.`);
                            addTerminalLineToContent('_____________________');
    	                    addTerminalLineToContent('Type "help" for help.');
                        }
                        break;
                    case 'wisp':
                        if (floor < 3) {
                            addTerminalLineToContent('You must reach Floor 3 to resurrect a wisp.');
                        } else if (wisps.length > 0) {
                            addTerminalLineToContent('You already have a loyal wisp companion.');
                        } else if (p.soulOrbs >= 10) {
                            p.soulOrbs -= 10;
                            const wispType = WISP_TYPES[Math.floor(Math.random() * WISP_TYPES.length)];
                            wisps.push({
                                x: p.x, y: p.y,
                                currentX: p.x * S, currentY: p.y * S,
                                hp: Math.floor(p.hp / 2), maxHP: Math.floor(p.maxHP / 2),
                                type: wispType,
                                attackCounter: 0,
                                targetTileX: p.x, targetTileY: p.y,
                                deltaX: 0, deltaY: 0, stepsLeft: 0, moving: false,
                                anim: { frameIndex: 0, lastFrameTime: performance.now(), frameDuration: 200 },
                                lastPos: null
                            });
                            addTerminalLineToContent('10 Soul Orbs consumed – a loyal wisp has been resurrected!');
                            logBattleEvent(`Floor ${floor} - Wisp resurrected from the Soul Terminal!`);
                            playWebAudioSound(sounds.pickup);
                            setTimeout(() => playWebAudioSound(sounds.pickup), 100);
                            setTimeout(() => playWebAudioSound(sounds.pickup), 200);
                        } else {
                            addTerminalLineToContent(`Need 10 Soul Orbs (you have ${p.soulOrbs}).`);
                        }
                        addTerminalLineToContent('_____________________');
                        addTerminalLineToContent('Type "help" for help.');
                        break;
                    default:
                        addTerminalLineToContent('ERROR!');
                        addTerminalLineToContent('Usage: convert stones');
                        addTerminalLineToContent('Usage: convert shards');
                        addTerminalLineToContent('_____________________');
    	                addTerminalLineToContent('Type "help" for help.');
                }
            }
            break;
case 'reset':
    if (!inPuzzleRoom) {
        addTerminalLineToContent('ERROR: Can only reset from inside a trial!');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
        break;
    }

    addTerminalLineToContent('Trial is reset!');
    addTerminalLineToContent('Type exit or press start on the gamepad.');
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');

    // Save current player position (so we don't teleport to @)
    const savedPlayerX = p.x;
    const savedPlayerY = p.y;

    // Reset puzzle state
    puzzleReturnPos = { x: p.x, y: p.y };
    puzzlePreviousTheme = currentTheme;
    enemies = [];
    isFetchingTxs = true;
    exit = null;
    currentTheme = 'dungeon';
    updateSnowState();
    musicManager.play('hideout');
    musicManager.current = 'hideout';

    puzzleHazards = [];
    puzzleArrows = [];
    puzzleBoulders = [];
    puzzleHeartFramers = [];
    puzzleChest = null;
    soulStashPos = null;
    farmSpot = null;

    const PX = 3, PY = 2;

    // Clear puzzle area
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (x >= PX && x < PX + 14 && y >= PY && y < PY + 12) {
                map[y][x] = 0;
            } else {
                map[y][x] = 1;
            }
        }
    }

    fogMap = Array(H).fill().map(() => Array(W).fill(1));

    const layoutStr = puzzleCurrentLayout;
    const layout = layoutStr.trim().split('\n');

    // Parse layout but PRESERVE player position
    for (let y = 0; y < layout.length; y++) {
        for (let x = 0; x < layout[y].length; x++) {
            const cx = PX + x;
            const cy = PY + y;
            const ch = layout[y][x];

            if (ch === '#') map[cy][cx] = 1;
            if (ch === '@') {
                // DO NOT move player — keep saved position
                // Just treat as floor
                map[cy][cx] = 0;
            }
            if (ch === 'B') { puzzleBoulders.push({x:cx, y:cy, pushed: false}); map[cy][cx] = 26; }
            if (ch === 'H') puzzleHeartFramers.push({x:cx,y:cy});
            if (ch === 'C') puzzleChest = {x:cx,y:cy};
            if (ch === 'L') { puzzleHazards.push({x:cx,y:cy,type:'lava'}); map[cy][cx] = 6; }
            if (ch === '>') puzzleArrows.push({x:cx,y:cy,dir:'right'});
            if (ch === '<') puzzleArrows.push({x:cx,y:cy,dir:'left'});
            if (ch === '^') puzzleArrows.push({x:cx,y:cy,dir:'up'});
            if (ch === 'v') puzzleArrows.push({x:cx,y:cy,dir:'down'});
            if (ch === 'S') { map[cy][cx] = 19; soulStashPos = {x:cx, y:cy}; }
            if (ch === 'F') { map[cy][cx] = 27; farmSpot = {x:cx, y:cy}; }
        }
    }

    // Restore saved player position
    p.x = savedPlayerX;
    p.y = savedPlayerY;
    p.currentX = p.x * S;
    p.currentY = p.y * S;

    // Rebuild static background (same as startPuzzleRoom)
    puzzleStaticCanvas = document.createElement('canvas');
    puzzleStaticCanvas.width = 320;
    puzzleStaticCanvas.height = 320;
    puzzleStaticCtx = puzzleStaticCanvas.getContext('2d');

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, x*S, y*S, S, S);
            if (map[y][x] === 1) puzzleStaticCtx.drawImage(assets.themes.dungeon.wall, x*S, y*S, S, S);
            if (map[y][x] === 6) puzzleStaticCtx.drawImage(assets.themes.hell.special, x*S, y*S, S, S);
            if (map[y][x] === 19) puzzleStaticCtx.drawImage(assets.soul_stash, x*S, y*S, S, S);
            if (map[y][x] === 27) {
                const img = (p.farmLocked && floor >= p.farmLockedFloor + 50) ? assets.farmSpot2 : assets.farmSpot1;
                puzzleStaticCtx.drawImage(img, x*S, y*S, S, S);
            }
        }
    }

    // Arrows (if you have pre-rotated sprites)
    const arrowSprites = {
        up: assets.arrow_up,
        right: assets.arrow_right,
        down: assets.arrow_down,
        left: assets.arrow_left
    };
    puzzleArrows.forEach(a => {
        const sprite = arrowSprites[a.dir];
        if (sprite?.complete) {
            puzzleStaticCtx.drawImage(sprite, a.x * S, a.y * S, S, S);
        }
    });
    
    logBattleEvent("The trial has been reborn from the void...");
    needsRedraw = true;
    closeSoulTerminal();
    break;
case 'swap':
    // Split command and ignore anything after "swap"
    const cmdParts = command.trim().split(' ');
    const baseCmd = cmdParts[0].toLowerCase();

    if (baseCmd !== 'swap') break; // safety (should never happen)

    // If player typed extra garbage like "swap balloon" → show usage
    if (cmdParts.length > 1) {
        addTerminalLineToContent('Usage: swap');
        addTerminalLineToContent('No arguments needed.');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
        break;
    }

    // Normal swap behavior
    if (p.currentWeapon === 'sword') {
        p.currentWeapon = 'satoshi_scourge';
        addTerminalLineToContent('Satoshi\'s Scourge equipped');
    } 
    else if (p.currentWeapon === 'satoshi_scourge') {
        p.currentWeapon = 'sword';
        addTerminalLineToContent('Returned to sword');
    } 
    else if (p.currentWeapon === 'soul_sword') {
        p.currentWeapon = 'sword';
        addTerminalLineToContent('Soul Sword dismissed');
    }

    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
case 'set':
    if (args.length === 0) {
        addTerminalLineToContent('Settings:');
        addTerminalLineToContent('  set sound [0-100]  – Control sound volume');
        addTerminalLineToContent('  set music [0-100]  – Control music volume');
        addTerminalLineToContent('  set zoom [on/off]  – 2× zoom on playfield');
        addTerminalLineToContent('_____________________');
        addTerminalLineToContent('Type "help" for help.');
    } else {
        const subCmd = args[0].toLowerCase();

        if (subCmd === 'sound') {
            if (args.length < 2) {
                addTerminalLineToContent('Usage: set sound [volume]');
                addTerminalLineToContent('Example: set sound 50');
            } else {
                const volume = parseFloat(args[1]);
                if (isNaN(volume) || volume < 0 || volume > 100) {
                    addTerminalLineToContent('ERROR! Volume must be 0–100');
                } else {
                    setSoundVolume(volume / 100);
                    addTerminalLineToContent(`Sound volume set to ${volume}%`);
                }
            }
        }
        else if (subCmd === 'music') {
            if (args.length < 2) {
                addTerminalLineToContent('Usage: set music [volume]');
                addTerminalLineToContent('Example: set music 75');
            } else {
                const volume = parseFloat(args[1]);
                if (isNaN(volume) || volume < 0 || volume > 100) {
                    addTerminalLineToContent('ERROR! Volume must be 0–100');
                } else {
                    setMusicVolume(volume / 100);
                    addTerminalLineToContent(`Music volume set to ${volume}%`);
                }
            }
        }
else if (subCmd === 'zoom') {
    if (args.length < 2) {
        addTerminalLineToContent('Usage: set zoom [on/off]');
        addTerminalLineToContent('Current: ' + (zoomEnabled ? 'ON' : 'OFF'));
    } else {
        const state = args[1].toLowerCase();
        if (state === 'on' || state === 'true' || state === '1') {
            zoomEnabled = true;
            localStorage.setItem('zoomEnabled', 'true');
            minimapVisible = zoomEnabled;
            needsRedraw = true;
            addTerminalLineToContent('2× ZOOM ACTIVATED – PLAYFIELD ONLY');
        } 
        else if (state === 'off' || state === 'false' || state === '0') {
            zoomEnabled = false;
            localStorage.setItem('zoomEnabled', 'false');
            // instantly center camera again so you don’t see empty space
            camera.x = p.x * S + S/2 - 160;
            camera.y = p.y * S + S/2 - 160;
            addTerminalLineToContent('2× zoom deactivated');
            addTerminalLineToContent('Back to classic 1:1 view');
        } 
        else {
            addTerminalLineToContent('Invalid argument – use "on" or "off"');
        }
        needsRedraw = true; // force immediate redraw
        }
    }
}
    break;
case 'leaderboard':
    if (!cachedLeaderboard || cachedLeaderboard.length === 0) {
        addTerminalLineToContent('No cached leaderboard available. Play more to fetch!');
    } else {
        const leaderboardTotalSats = Object.values(satsEarned).reduce((sum, v) => sum + v, 0);
        const displayedMultText = document.getElementById('sats-calc').textContent.trim();
        const multMatch = displayedMultText.match(/:\s*([\d.]+)\s*(sats|BTC)/);
        const leaderboardPlayerScore = multMatch ? (multMatch[2] === 'BTC' ? parseFloat(multMatch[1]) * 1e8 : parseInt(multMatch[1])) : leaderboardTotalSats;
        const playerEst = getPlayerEstimatedRank(cachedLeaderboard, leaderboardTotalSats, floor);
        
        // Format cached list with player inserted
        const maxUsernameLength = 20;
        const numberWidth = 10;
        
        let rows = cachedLeaderboard.slice(0, 10).map((entry, index) => {
            const rank = (index + 1).toString().padStart(2, '0');
            const username = entry.username.length > maxUsernameLength
                ? entry.username.substring(0, maxUsernameLength - 2) + '..'
                : entry.username;
            const scoreValue = entry.score;
            let numberPart, unitPart;
            if (scoreValue >= 1e8) {
                numberPart = (scoreValue / 1e8).toFixed(1);
                unitPart = 'BTC';
            } else {
                numberPart = scoreValue.toString();
                unitPart = 'sats';
            }
            return `Rank: ${rank}, ${username}, ${numberPart} ${unitPart}`;
        });
        
        // Insert player at estimated rank if in top 10
        const playerUsername = 'You';
        let playerNumberPart, playerUnitPart;
        if (leaderboardPlayerScore >= 1e8) {
            playerNumberPart = (leaderboardPlayerScore / 1e8).toFixed(1);
            playerUnitPart = 'BTC';
        } else {
            playerNumberPart = leaderboardPlayerScore.toString();
            playerUnitPart = 'sats';
        }
        const playerRow = `Rank: ${playerEst.rank.toString().padStart(2, '0')}, ${playerUsername}, ${playerNumberPart} ${playerUnitPart}`;
        
        if (playerEst.rank <= 10) {
            rows.splice(playerEst.rank - 1, 0, playerRow); // Insert at rank (shifts others down)
            rows = rows.slice(0, 10); // Limit to top 10 including player
        }
        
        // Format for display (no header)
        let fullText = `Top 10 scores (leaderboard)`;
        rows.forEach(row => {
            fullText += `\n${row}`;
        });
        
        if (playerEst.rank > 10) {
            const estRow = `Rank: ??, ${playerUsername}, ${playerNumberPart} ${playerUnitPart}`;
            fullText += `\n${estRow}`;
        }
        
        const lines = fullText.split('\n');
        lines.forEach(line => addTerminalLineToContent(line));
    }
    addTerminalLineToContent('_____________________');
    addTerminalLineToContent('Type "help" for help.');
    break;
        default:
            addTerminalLineToContent(`Command not found: ${cmd}`);
            addTerminalLineToContent('_____________________');
            addTerminalLineToContent('Type "help" for help.');
    }
}

function activateSoulStorm() {
    // Create a horizontal wave of 3 tiles that lights up with soul light
    const damageArea = [];
    
    // Determine damage tiles based on direction
    if (swordDir === 'up') {
        const close_y = p.y - 1;
        const far_y = p.y - 2;
        for (let dx = -1; dx <= 1; dx++) {
            damageArea.push({x: p.x + dx, y: close_y});
        }
        for (let dx = -2; dx <= 2; dx++) {
            damageArea.push({x: p.x + dx, y: far_y});
        }
    } else if (swordDir === 'down') {
        const close_y = p.y + 1;
        const far_y = p.y + 2;
        for (let dx = -1; dx <= 1; dx++) {
            damageArea.push({x: p.x + dx, y: close_y});
        }
        for (let dx = -2; dx <= 2; dx++) {
            damageArea.push({x: p.x + dx, y: far_y});
        }
    } else if (swordDir === 'left') {
        const close_x = p.x - 1;
        const far_x = p.x - 2;
        for (let dy = -1; dy <= 1; dy++) {
            damageArea.push({x: close_x, y: p.y + dy});
        }
        for (let dy = -2; dy <= 2; dy++) {
            damageArea.push({x: far_x, y: p.y + dy});
        }
    } else if (swordDir === 'right') {
        const close_x = p.x + 1;
        const far_x = p.x + 2;
        for (let dy = -1; dy <= 1; dy++) {
            damageArea.push({x: close_x, y: p.y + dy});
        }
        for (let dy = -2; dy <= 2; dy++) {
            damageArea.push({x: far_x, y: p.y + dy});
        }
    }
    
    // Apply damage to all valid tiles in the area
    const damage = 1; // 1 damage per hit
    let enemiesHit = 0;
    let totalDamage = 0;
    
    highlightTiles = []; // Clear previous highlights
    for (const tile of damageArea) {
        const {x, y} = tile;
        
        // Check if tile is within bounds and not a wall
        if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 1) {
            highlightTiles.push({x, y, highlightStart: Date.now()}); // Add tile to highlight
            // And add this ONCE per frame (best in draw() or gameLoop):
            highlightTiles = highlightTiles.filter(t => Date.now() - t.highlightStart < 500);
            // Check if there's an enemy at this tile
            const enemy = enemies.find(e => e.x === x && e.y === y);
            
if (enemy) {
    const isSoulSword = p.soulStormCharges >= 4;
    const isDiamondHand = p.hasDiamondHand && !usePickaxeSword;

    let actualDamage = 0;
    let message = "";

    if (isDiamondHand) {
        // Diamond Hand = 3 damage, ignores shield completely
        actualDamage = 3;
        enemy.hp -= 3;
        message = `Diamond Hand wave hits ${enemy.type.name} for 3 DMG!`;
    }
    else if (isSoulSword) {
        // Soul Sword AOE wave = only 1 damage, ignores shield
        actualDamage = 1;
        enemy.hp -= 1;
        message = `Soul Sword wave hits ${enemy.type.name} for 1 DMG!`;
    }
    else if (enemy.bitAmmo > 0) {
        // Normal attack blocked by bit shield
        enemy.bitAmmo--;
        enemy.bits = enemy.bitAmmo;
        enemy.shieldFlash = { active: true, startTime: Date.now() };
        message = `${enemy.type.name} blocks with bit shield!`;
        playWebAudioSound(sounds.hit);
    }
    else {
        // Normal melee attack = 2 damage
        actualDamage = 2;
        enemy.hp -= 2;
        message = `Hit ${enemy.type.name} for 2 DMG!`;
    }

    // Only log and play sound if damage was actually dealt
    if (actualDamage > 0) {
        logBattleEvent(`Floor ${floor} - ${message}`);
        playWebAudioSound(sounds.hit);
    }

    // FULL DEATH — no mercy rule, no 1 HP leftovers
    if (enemy.hp <= 0) {
        kills[enemy.type.name]++;
        handleUniqueMonsterReward(enemy);
        tryDropScroll(enemy.x, enemy.y);

        // Drop satoshi (skip uniques & Cursed Trader)
        if (!enemy.uniqueName && enemy.type.name !== 'Cursed Trader') {
            let dropPlaced = false;
            if (map[enemy.y][enemy.x] === 0) {
                map[enemy.y][enemy.x] = 3;
                satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                dropPlaced = true;
            } else {
                const adjacent = [
                    {x: enemy.x, y: enemy.y - 1},
                    {x: enemy.x, y: enemy.y + 1},
                    {x: enemy.x - 1, y: enemy.y},
                    {x: enemy + 1, y: enemy.y}
                ];
                for (const pos of adjacent) {
                    const {x: nx, y: ny} = pos;
                    if (nx >= 0 && nx < W && ny >= 0 && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                        map[ny][nx] = 3;
                        satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                        dropPlaced = true;
                        break;
                    }
                }
            }
        }

        // Cursed Ring drop (50% chance for Cursed Trader only)
        if (enemy.type.name === 'Cursed Trader' && Math.random() < 0.5 && !p.hasCursedRing) {
            let ringPlaced = false;
            if (map[enemy.y][enemy.x] === 0) {
                map[enemy.y][enemy.x] = 23;
                ringPlaced = true;
            } else {
                const adjacent = [
                    {x: enemy.x, y: enemy.y - 1},
                    {x: enemy.x, y: enemy.y + 1},
                    {x: enemy.x - 1, y: enemy.y},
                    {x: enemy.x + 1, y: enemy.y}
                ];
                for (const pos of adjacent) {
                    const {x: nx, y: ny} = pos;
                    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                        map[ny][nx] = 23;
                        ringPlaced = true;
                        break;
                    }
                }
            }
            if (ringPlaced) {
                logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Cursed Ring!`);
                playWebAudioSound(sounds.pickup);
            }
        }

        // Cursed Trader soul stone drop
        if (enemy.type.name === 'Cursed Trader') {
            dropSoulStone(enemy.x, enemy.y);
        }

        // Remove the dead enemy
        enemies = enemies.filter(en => en !== enemy);
        enemiesHit++;
    }

    totalDamage += actualDamage;
}
        }
    }
    
    if (enemiesHit > 0) {
        logBattleEvent(`Soul Storm hit ${enemiesHit} enemies for ${totalDamage} total damage!`);
    }
}

function handleTerminalInput(e) {
    const key = e.key;
    
    // If terminal is not focused, focus it and add the key
    if (!document.activeElement.matches('#soul-terminal-input')) {
        const input = document.getElementById('soul-terminal-input');
        input.focus();
        input.value = p.soulTerminalCommand; // Update value to reflect current command
        
        // Handle key press immediately
        if (key.length === 1 && key !== 'Enter') {
            const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
            const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
            p.soulTerminalCommand = before + key + after;
            p.soulTerminalCursorPos++;
            input.value = p.soulTerminalCommand.substring(1); // One-liner hack to remove first character
        }
        
        return;
    }
    
    if (key === 'Enter') {
        e.preventDefault();
        processSoulCommand(p.soulTerminalCommand);
        p.soulTerminalCommand = '';
        p.soulTerminalCursorPos = 0;
        // Blur the input field when Enter is pressed
        const input = document.getElementById('soul-terminal-input');
        if (input) {
            input.blur();
        }
        return;
    }
    
    if (key === 'Backspace') {
        if (p.soulTerminalCursorPos > 0) {
            p.soulTerminalCommand = 
                p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos - 1) + 
                p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
            p.soulTerminalCursorPos--;
        }
        return;
    }
    
    if (key === 'ArrowLeft' && p.soulTerminalCursorPos > 0) {
        p.soulTerminalCursorPos--;
        return;
    }
    
    if (key === 'ArrowRight' && p.soulTerminalCursorPos < p.soulTerminalCommand.length) {
        p.soulTerminalCursorPos++;
        return;
    }
    
    // Add regular character
    if (key.length === 1 && key !== 'Enter') {
        const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
        const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
        p.soulTerminalCommand = before + key + after;
        p.soulTerminalCursorPos++;
    }
}

// Add this function to handle terminal input when not focused
function handleBlurredTerminalInput(key) {
    const input = document.getElementById('soul-terminal-input');
    if (input && !input.matches(':focus')) {
        // Focus the input field
        input.focus();
        
        // Update command with new key
        const before = p.soulTerminalCommand.slice(0, p.soulTerminalCursorPos);
        const after = p.soulTerminalCommand.slice(p.soulTerminalCursorPos);
        p.soulTerminalCommand = before + key + after;
        p.soulTerminalCursorPos++;
        
        // Update display
        input.value = p.soulTerminalCommand.substring(1);
    }
}

// Function to create dangerous spell area (called when unique monster uses a spell)
function createDangerousArea(x, y, spellType) {
    // Add the dangerous area to the array
    dangerousAreas.push({
        x: x,
        y: y,
        spellType: spellType
    });
    
    // Draw immediate visual feedback
    needsRedraw = true;
}

// Function to remove dangerous areas when a unique monster dies
function removeDangerousAreas(monster) {
    if (!monster.uniqueName || !monster.spell) return;
    
    // Remove all dangerous areas that match this spell type
    dangerousAreas = dangerousAreas.filter(area => area.spellType !== monster.spell);
    
    // Redraw to reflect changes
    needsRedraw = true;
}

// ———————————————————————————————————————————————————————
// PUZZLE ROOM SYSTEM — L2 Style (final, perfect)
// ———————————————————————————————————————————————————————

// Puzzle designs
// NOTICE!
// parsing REQUIRE no spaces or empty lines here to work
const PUZZLE_TEMPLATES = {
    common: [
`##############
#BHB.........#
#.B......B...#
#.<<<<<<<L<<.#
#.vLL.....L^.#
#.vLL.B.LLL^.#
#.vLLBCBLLL^.#
#.vLLBBBLLL^.#
#.v>>>>>>>>^.#
S............#
F....@.......#
##############`,
`##############
#..L.....BBB.#
#.BHB....BHB.#
#.BBB.....L..#
#............#
#............#
#.....C......#
#......B.....#
#...@........#
S............#
F............#
##############`
    ],
    rare: [
`##############
#..#..#..#...#
#.BL..#.BL.B.#
#..#..#..#BCB#
#..#..#..#.B.#
#..#..#..#...#
#..#..#..#LLL#
#..#..#..#LLL#
#@.#..#..#...#
S..#.BL..#.H.#
F..#..#..#...#
##############`,
`##############
#....BLLL....#
#...B.##..H..#
#..B..##BBBBB#
#.....##..L..#
#.....###LLL##
#.....##..L..#
#.....##.....#
#.@...##.....#
S.....##..C..#
F.....##.....#
##############`
    ],
    legendary: [
`##############
#LHLLLLLLLLLL#
#LLLLLLLLLLLL#
#.BLLL.LLLLLL#
#.BLBLCLBLLLL#
#.BLLL.LLLBHB#
#..LLLLLLL.B.#
#..LLLLLLL...#
#..v<<<>>#<<<#
S..>>>@....B.#
F............#
##############`,
`##############
#BC.B.###....#
#B.BB.LHL....#
#BB.B.###....#
#.....######.#
#.....##...#.#
#.....B....#.#
#.....##...#.#
#.....##...#.#
S...@...B..#.#
F.....##H###H#
##############`
    ]
};

function startPuzzleRoom() {
    inPuzzleRoom = true;
    puzzleReturnPos = { x: p.x, y: p.y };
    puzzlePreviousTheme = currentTheme;
    enemies = [];
    isFetchingTxs = true;
    exit = null;

    const PX = 3, PY = 2;
    const PW = 14, PH = 12;

    currentTheme = 'dungeon';
    updateSnowState();
    musicManager.play('hideout');
    musicManager.current = 'hideout';

    // Clear puzzle area
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (x >= PX && x < PX + PW && y >= PY && y < PY + PH) {
                map[y][x] = 0;
            } else {
                map[y][x] = 1;
            }
        }
    }
    fogMap = Array(H).fill().map(() => Array(W).fill(1));

    // Reset puzzle state
    puzzleHazards = [];
    puzzleArrows = [];
    puzzleBoulders = [];
    puzzleHeartFramers = [];
    puzzleChest = null;
    soulStashPos = null;
    farmSpot = null;

    // Layout selection
    let tierTemplates;
    if (floor >= 30) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare, ...PUZZLE_TEMPLATES.legendary];
    else if (floor >= 15) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare];
    else tierTemplates = PUZZLE_TEMPLATES.common;

    // Use saved layout if resetting, else pick new and save it
    if (!puzzleCurrentLayout) {
        let tierTemplates;
        if (floor >= 30) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare, ...PUZZLE_TEMPLATES.legendary];
        else if (floor >= 15) tierTemplates = [...PUZZLE_TEMPLATES.common, ...PUZZLE_TEMPLATES.rare];
        else tierTemplates = PUZZLE_TEMPLATES.common;
        puzzleCurrentLayout = tierTemplates[Math.floor(Math.random() * tierTemplates.length)];
    }
    const layoutStr = puzzleCurrentLayout;
    const layout = layoutStr.trim().split('\n');

    // Parse layout
    for (let y = 0; y < layout.length; y++) {
        for (let x = 0; x < layout[y].length; x++) {
            const cx = PX + x;
            const cy = PY + y;
            const ch = layout[y][x];

            if (ch === '#') map[cy][cx] = 1;
            if (ch === '@') { p.x = cx; p.y = cy; p.currentX = cx * S; p.currentY = cy * S; }
            if (ch === 'B') { puzzleBoulders.push({x:cx, y:cy, pushed: false}); map[cy][cx] = 26; }
            if (ch === 'H') puzzleHeartFramers.push({x:cx, y:cy});
            if (ch === 'C') puzzleChest = {x:cx, y:cy};
            if (ch === 'L') { puzzleHazards.push({x:cx, y:cy, type:'lava'}); map[cy][cx] = 6; }
            if (ch === '>') puzzleArrows.push({x:cx, y:cy, dir:'right'});
            if (ch === '<') puzzleArrows.push({x:cx, y:cy, dir:'left'});
            if (ch === '^') puzzleArrows.push({x:cx, y:cy, dir:'up'});
            if (ch === 'v') puzzleArrows.push({x:cx, y:cy, dir:'down'});
            if (ch === 'S') { map[cy][cx] = 19; soulStashPos = {x:cx, y:cy}; }
            if (ch === 'F') { map[cy][cx] = 27; farmSpot = {x:cx, y:cy}; }
        }
    }

    // ───── PRE-RENDER STATIC BACKGROUND (walls, floors, lava, arrows) ─────
    puzzleStaticCanvas = document.createElement('canvas');
    puzzleStaticCanvas.width = 320;
    puzzleStaticCanvas.height = 320;
    puzzleStaticCtx = puzzleStaticCanvas.getContext('2d');

// Static tiles + puzzle objects – FLOOR FIRST, then overlays (no black background)
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        // Always draw floor under everything
        puzzleStaticCtx.drawImage(assets.themes.dungeon.floor, x*S, y*S, S, S);

        // Then overlay walls, lava, soul stash, farm spot
        if (map[y][x] === 1) puzzleStaticCtx.drawImage(assets.themes.dungeon.wall, x*S, y*S, S, S);
        if (map[y][x] === 6) puzzleStaticCtx.drawImage(assets.themes.hell.special, x*S, y*S, S, S);
        if (map[y][x] === 19) puzzleStaticCtx.drawImage(assets.soul_stash, x*S, y*S, S, S);
        if (map[y][x] === 27) {
            // Use farmSpot2 if mature, else farmSpot1
            const img = (p.farmLocked && floor >= p.farmLockedFloor + 50) ? assets.farmSpot2 : assets.farmSpot1;
            puzzleStaticCtx.drawImage(img, x*S, y*S, S, S);
        }
    }
}

    // Pre-rotated arrows
    const arrowSprites = {
        up:    assets.arrow_up,
        right: assets.arrow_right,
        down:  assets.arrow_down,
        left:  assets.arrow_left
    };
    puzzleArrows.forEach(a => {
        const sprite = arrowSprites[a.dir];
        if (sprite?.complete) {
            puzzleStaticCtx.drawImage(sprite, a.x * S, a.y * S, S, S);
        }
    });

    // UI
    document.getElementById('floor-indicator').textContent =
        floor >= 30 ? 'LEGENDARY TRIAL' :
        floor >= 15 ? 'Rare Trial' : 'Trial of Wisdom';
    logBattleEvent("A sacred trial of wisdom begins...");
    needsRedraw = true;
}

function finishPuzzleRoom() {
    logBattleEvent("The ancient chest opens... power surges through you!");
    if (wisps.length > 0) wispSpeak('victory');

// REWARDS BASED ON FLOOR — fair, consistent, feels earned
if (floor >= 30) {
    // Legendary tier floors — always give diamond + soul orb + RIP runes
    diamonds += 1;
    p.soulOrbs += 1;
    p.runes.push('r','i','p');
    logBattleEvent("LEGENDARY REWARD: +1 Diamond +1 Soul Orb + RIP runes!");
} else if (floor >= 15) {
    // Rare tier floors — always give pickaxe + RIP runes
    p.pickaxes += 1;
    p.runes.push('r','i','p');
    logBattleEvent("RARE REWARD: +1 Pickaxe + RIP runes!");
} else {
    // Common tier floors — just pickaxe
    p.pickaxes += 1;
    logBattleEvent("Trial complete! +1 Pickaxe");
}

// ——— EXIT PUZZLE ROOM ———
    inPuzzleRoom = false;
    inHideout = false;

// Restore the ORIGINAL theme we had before entering the puzzle
if (puzzlePreviousTheme !== null) {
    currentTheme = puzzlePreviousTheme;
    puzzlePreviousTheme = null;
}

// Properly restore snowy hell state if we were in a snowy hell block
if (currentTheme === 'hell') {
    if (currentThemeBlock === 'hell_snowy') {
        snowyHellActive = true;
    } else {
        snowyHellActive = false;
    }
}
updateSnowState();  // ensures snowflakes + snowy tiles match the theme

    // FAKE A HIDE-OUT VISIT — this magically restores the correct music!
    musicManager.play('hideout');
    puzzlePreviousTheme = null;

    // Clear all puzzle state
    puzzleHazards = [];
    puzzleArrows = [];
    puzzleBoulders = [];
    puzzleHeartFramers = [];
    puzzleChest = null;
    // ——— CLEAR ALL PUZZLE TILES FROM THE MAP ———
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if ([19, 27].includes(map[y][x])) {  // 19 = soul stash, 27 = farm spot
                map[y][x] = 0;
            }
        }
    }
    soulStashPos = null;
    farmSpot = null;
    puzzleReturnPos = null;
    puzzleCurrentLayout = null;  // ← NEW: prevents reusing old layout on next floor
    puzzleStaticCanvas = null;
    puzzleStaticCtx = null;

    // Stairs appear under player
    exit = { x: p.x, y: p.y };
    map[p.y][p.x] = 0;

    logBattleEvent("Stairs appear beneath you!");
    needsRedraw = true;
}

function cleanupEventListeners() {
    // Clear any existing intervals
    if (touchMoveInterval) {
        clearInterval(touchMoveInterval);
        touchMoveInterval = null;
    }
    if (touchTimeout) {
        clearTimeout(touchTimeout);
        touchTimeout = null;
    }
    
    // Clear existing touch listeners from dpad buttons
    dpadButtons.forEach(button => {
        button.classList.remove('pressed');
        // Remove all event listeners for each button
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
            button._touchstartHandler = null;
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
            button._touchendHandler = null;
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
            button._touchcancelHandler = null;
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
            button._clickHandler = null;
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
            button._contextmenuHandler = null;
        }
    });

    // Clear existing touch listeners from actions buttons
    actionsButtons.forEach(button => {
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
            button._touchstartHandler = null;
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
            button._touchendHandler = null;
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
            button._touchcancelHandler = null;
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
            button._clickHandler = null;
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
            button._contextmenuHandler = null;
        }
    });
    
    // Clear existing touch listeners from gamepad buttons
    if (gamepadIndex !== null && navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        if (gamepads[gamepadIndex]) {
            const gamepad = gamepads[gamepadIndex];
            if (gamepad.buttons && gamepad.buttons.length > 0) {
                // Remove event listeners from gamepad buttons
                for (let i = 0; i < gamepad.buttons.length; i++) {
                    if (gamepad.buttons[i]._clickHandler) {
                        gamepad.buttons[i].removeEventListener('click', gamepad.buttons[i]._clickHandler);
                        gamepad.buttons[i]._clickHandler = null;
                    }
                }
            }
        }
    }
    
    // Clear existing event listeners from document
    if (document._keydownHandler) {
        document.removeEventListener('keydown', document._keydownHandler);
        document._keydownHandler = null;
    }
    if (document._keyupHandler) {
        document.removeEventListener('keyup', document._keyupHandler);
        document._keyupHandler = null;
    }

    // Clear keyboard movement interval
    if (keyboardMovementTimer) {
        clearInterval(keyboardMovementTimer);
        keyboardMovementTimer = null;
    }
    if (document._touchstartHandler) {
        document.removeEventListener('touchstart', document._touchstartHandler);
        document._touchstartHandler = null;
    }
    if (document._touchmoveHandler) {
        document.removeEventListener('touchmove', document._touchmoveHandler);
        document._touchmoveHandler = null;
    }
    if (document._touchendHandler) {
        document.removeEventListener('touchend', document._touchendHandler);
        document._touchendHandler = null;
    }
    if (document._gamepadConnectedHandler) {
        window.removeEventListener('gamepadconnected', document._gamepadConnectedHandler);
        document._gamepadConnectedHandler = null;
    }
    if (document._gamepadDisconnectedHandler) {
        window.removeEventListener('gamepaddisconnected', document._gamepadDisconnectedHandler);
        document._gamepadDisconnectedHandler = null;
    }
}

/* ------------------------------------------------------------------
   Enhanced touch controls with 200ms movement delay
   ------------------------------------------------------------------ */
function initTouchControls() {
    let activeTouchId = null;
    let currentTouchDir = null;
    let isMoving = false;
    let lastMoveTime = 0;

    // Use the global dpadButtons
    dpadButtons.forEach(button => {
        button._touchstartHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            if (inputBlocked || splashActive || gameOver) return;

            const touch = e.changedTouches[0];
            if (!activeTouchId) {
                activeTouchId = touch.identifier;
                button.classList.add('pressed');
                currentTouchDir = button.id;
                isMoving = true;

                // Start continuous movement with 200ms delay
                const moveLoop = () => {
                    if (isMoving && currentTouchDir && !inputBlocked && !gameOver) {
                        const now = Date.now();
                        if (now - lastMoveTime >= 200) { // Enforce 200ms delay
                            move(currentTouchDir);
                            lastMoveTime = now;
                        }
                        requestAnimationFrame(moveLoop);
                    }
                };
                requestAnimationFrame(moveLoop);
            }
        };

        button._touchmoveHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            // Keep touch active but don't trigger move
            const touch = Array.from(e.changedTouches).find(t => t.identifier === activeTouchId);
            if (touch && currentTouchDir && !inputBlocked && !gameOver) {
                // No move call here; let moveLoop handle movement
            }
        };

        button._touchendHandler = function (e) {
            e.preventDefault();
            e.stopPropagation();
            const touch = e.changedTouches[0];
            if (touch.identifier === activeTouchId) {
                button.classList.remove('pressed');
                activeTouchId = null;
                currentTouchDir = null;
                isMoving = false;
            }
        };

        button._touchcancelHandler = button._touchendHandler;
        button._contextmenuHandler = function (e) { 
            e.preventDefault(); 
            e.stopPropagation();
        };
        button._clickHandler = function (e) { 
            e.preventDefault(); 
            e.stopPropagation();
        };

        // Remove existing listeners and add new ones
        if (button._touchstartHandler) {
            button.removeEventListener('touchstart', button._touchstartHandler);
        }
        if (button._touchmoveHandler) {
            button.removeEventListener('touchmove', button._touchmoveHandler);
        }
        if (button._touchendHandler) {
            button.removeEventListener('touchend', button._touchendHandler);
        }
        if (button._touchcancelHandler) {
            button.removeEventListener('touchcancel', button._touchcancelHandler);
        }
        if (button._clickHandler) {
            button.removeEventListener('click', button._clickHandler);
        }
        if (button._contextmenuHandler) {
            button.removeEventListener('contextmenu', button._contextmenuHandler);
        }

        button.addEventListener('touchstart', button._touchstartHandler, { passive: false });
        button.addEventListener('touchmove', button._touchmoveHandler, { passive: false });
        button.addEventListener('touchend', button._touchendHandler, { passive: false });
        button.addEventListener('touchcancel', button._touchcancelHandler, { passive: false });
        button.addEventListener('contextmenu', button._contextmenuHandler, { passive: false });
        button.addEventListener('click', button._clickHandler, { passive: false });
    });

    /* Clean up on restart */
    document.addEventListener('restart', () => {
        dpadButtons.forEach(button => {
            button.classList.remove('pressed');
            if (button._touchstartHandler) button.removeEventListener('touchstart', button._touchstartHandler);
            if (button._touchmoveHandler) button.removeEventListener('touchmove', button._touchmoveHandler);
            if (button._touchendHandler) button.removeEventListener('touchend', button._touchendHandler);
            if (button._touchcancelHandler) button.removeEventListener('touchcancel', button._touchcancelHandler);
            if (button._clickHandler) button.removeEventListener('click', button._clickHandler);
            if (button._contextmenuHandler) button.removeEventListener('contextmenu', button._contextmenuHandler);
        });
        activeTouchId = null;
        currentTouchDir = null;
        isMoving = false;
        lastMoveTime = 0;
        initTouchControls(); // Re-attach listeners
    });
}

/* ------------------------------------------------------------------
   Restart the game – reset state & re‑initialise listeners
   ------------------------------------------------------------------ */
function restart() {

    /* ------------------------------------------------------------------
       1. Clean up old listeners/timers
       ------------------------------------------------------------------ */
    cleanupEventListeners();
    document.dispatchEvent(new Event('restart')); // Trigger custom restart event

    // Reset fetch flag
    isFetchingTxs = false;
    
    /* ------------------------------------------------------------------
       2. Reset all game state variables
       ------------------------------------------------------------------ */
    floor = 1;
    inHideout = false;
    previousFloorState = null;
    jewellerPos = null;
    blacksmithPos = null;
    waypointPos = null;
    p.hasDiamondArmor = false;
    p.hasDiamondHand = false;
    p.currentWeapon = 'sword';
    p.hasCursedRing = false;
    p.echoWardenBlessingGiven = false;
p.curseActive = false;  // Lift lingering curse
// Restore a random immunity on restart
const elements = ['Fire', 'Lightning', 'Cold', 'Poison'];
p.elementImmunity = elements[Math.floor(Math.random() * elements.length)];
p.auraMax = 0; // Explicitly reset aura max
p.auraShield = 0; // Explicitly reset aura shield
p.lastAuraRefillMove = 0; // Reset aura refill tracking
p.auraMoveCounter = 0; // Reset aura move counter
    p.perfectlyCutDiamonds = 0;
    // Reset soul items
    p.soulStones = 0;
    p.soulShards = 0;
    p.soulOrbs = 0;
    p.soulStormCharges = 256;
  
farmSpot = null;  
p.farmLocked = false;
p.farmLockedFloor = 0;
p.farmLockedSats = 0;
    
    // Reset shrine tracking
    p.shrineCharges = 0;
    p.shrineUsedThisFloor = false;
    currentTheme = 'dungeon';            // default theme
    p.maxHP = 24;                       // default max HP
    document.documentElement.style.setProperty('--text-color', '#ff8c00'); // orange
    wave = 1;
    document.getElementById('wave').textContent = wave;
    p.hp = 36;
    p.potions = 0;
    p.pickaxes = 0;
    diamonds = 0;
    p.hasArmor = true;
    p.armorImmunity = null; // Reset armor immunity on restart
    soulResonance = 0;
    wardenFlashStart = 0; // Clear flash on restart
    
    p.runes = [];
    runeDrops = runeDrops.filter(r => !r.specific);			// maybe
    for (let y = 0; y < H; y++) {					// \
        for (let x = 0; x < W; x++) {					//  \
            if (map[y][x] === 9) {					//   \
                map[y][x] = 0; // Clear specific rune tiles		//    \
            }								//     \
        }								//      \
    }									//       overkill
    
    p.x = 2;
    p.y = 2;
    p.atk = 2;
enemies = [];
    wisps = []; // Clear wisp on restart
    deadWispCorpse = null; // Clear corpse too
enemyBgFrameTimes.clear(); // Clear bg animation tracking
    map = [];
    rooms = [];
    exit = null;
    gameOver = false;
    gameOverSoundPlayed = false;
    autoSubmitTriggered = false;
enemiesSpawnedThisFloor = 0;
uniqueMonstersSpawnedThisFloor = 0; // Reset unique monster spawn counter
whalesSpawnedThisFloor = 0;
scrollDroppedThisFloor = false;
initialSpawnDoneThisFloor = false;
initialWaveSpawned = false;
waveActive = false;
    nextApiCallTime = null;
    whaleHashIds = ['Whale Transactions:'];
    battleLog = [];
    killsLog = [];
    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    satoshiDrops = [];
    scrollDrops = [];
    portals = [];
    swordDir = 'right';
    swordActive = false;
    swordStart = 0;
    fogMap = [];
    scoreSubmitted = false;
    gameOverBPressed = false;
    hasPlayedOnce = true;  // allow the "Enter" key to start the next game
    projectiles = []; // Add this line to reset projectiles array on restart
    populateNameList();
 
    currentThemeBlock = null;  // 'hell_normal' or 'hell_snowy' for the current 3-floor block

    currentWeapon = 'sword';
    
// Fix: Properly reset MusicManager state and ensure audio context is ready
    try {
        if (audioContext && audioContext.state === 'suspended') {
        musicManager.current = null;
            audioContext.resume();
        }

        // Set initial volumes
        setSoundVolume(soundVolume);
        setMusicVolume(musicVolume);
    } catch (e) {
        console.warn('Error resetting music manager:', e);
    }


    /* ------------------------------------------------------------------
       3. Reset UI elements
       ------------------------------------------------------------------ */
    const whaleHashIdsDiv = document.getElementById('whale-hash-ids');
    whaleHashIdsDiv.innerHTML = ''; // clear
    const newDiv = document.createElement('div');
    newDiv.innerHTML = whaleHashIds.join('<br>');
    whaleHashIdsDiv.appendChild(newDiv);
    const whaleLog = document.getElementById('whale-log');
    whaleLog.scrollTop = whaleLog.scrollHeight;

    document.getElementById('battle-events').value = '';
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    document.getElementById('health').textContent = p.hp;
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('sats').textContent = '0';
    window.currentFloorText = `Floor ${floor}`;
    window.lastUniqueSetTime = 0;
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('submit-score').style.display = 'none';
    document.getElementById('view-leaderboard').style.display = 'none';
    document.getElementById('restart-game').style.display = 'none';
    document.getElementById('username-input').value = '';
    document.getElementById('leaderboard-output').textContent = '';
    document.getElementById('leaderboard-output').style.display = 'none';
    document.getElementById('submit-score').disabled = false;
    document.getElementById('submit-score').style.background = '#ff8c00';
    document.getElementById('splash-screen').style.display = 'block';
    //window.location.reload(); // Nuke: Full page reload to clear all events/sprites/memory (nah ..)

    /* ------------------------------------------------------------------
       4. Re-initialize button variables and touch listeners
       ------------------------------------------------------------------ */
    // Re-initialize button variables properly
    dpadButtons = document.querySelectorAll('#dpad button');
    actionsButtons = document.querySelectorAll('#actions button');
    
    // Cleanup old listeners first
    cleanupEventListeners();
    
    // Re-initialize touch controls
    initTouchControls(); // Re-initialize touch controls
    
    /* ------------------------------------------------------------------
       5. Reset audio & gamepad polling
       ------------------------------------------------------------------ */
    if (apiTimeoutId) clearTimeout(apiTimeoutId);
    if (movementTimer) clearInterval(movementTimer);
    movementTimer = null;
    gamepadMoveDir = null;
    gamepadLastMoveTime = 0;
    lastButtonsState = [];
    if (gamepadIndex !== null) {
        // Check for gamepad at restart
        if (navigator.getGamepads) {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepadIndex = i;
                    console.log('Gamepad detected at restart:', gamepads[i].id);
                    break;
                }
            }
        }
        gamepadPollingActive = true;
        if (!movementTimer) {
            movementTimer = setInterval(() => {
                if (!splashActive && !gameOver && gamepadMoveDir) {
                    const now = Date.now();
                    if (now - gamepadLastMoveTime >= 200) {
                        move(gamepadMoveDir);
                        gamepadLastMoveTime = now;
                    }
                }
            }, 50);
        }
        requestAnimationFrame(updateGamepad);
    }

    /* ------------------------------------------------------------------
       6. Reset visual state
       ------------------------------------------------------------------ */
    resetSplashScreen();
    initMap();
    updatePlayerState();
    updateSatsDisplay();
    needsRedraw = true;
    inputBlocked = false;
}

function dropSoulStone(x, y) {
    let placed = false;
    if (map[y][x] === 0) {
        map[y][x] = 20; // Soul stone tile
        placed = true;
    } else {
        const dirs = [{dx: 0, dy: -1}, {dx: 0, dy: 1}, {dx: -1, dy: 0}, {dx: 1, dy: 0}];
        for (let d of dirs) {
            let nx = x + d.dx, ny = y + d.dy;
            if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] === 0 && !enemies.some(e => e.x === nx && e.y === ny)) {
                map[ny][nx] = 20; // Soul stone tile
                placed = true;
                break;
            }
        }
    }
    if (placed) {
        logBattleEvent(`Floor ${floor} - Cursed Trader dropped a Soul Stone!`);
        playWebAudioSound(sounds.pickup);
    }
}

function draw() {
    // Add frame rate limiting - cap to maximum 50ms updates (20 FPS)
    const now = performance.now();
    if (now - lastDrawTime < 50) {
        needsRedraw = true;
        return;
    }
    lastDrawTime = now;
    
// Animation frame update logic here
if (p.moving) {
    const now = performance.now();
    // Cap animation updates to 20 FPS (50ms)
    if (now - p.anim.lastFrameTime >= 50) { // 20 FPS capped
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
}
    
    if (!map?.[0] || !p || !enemies || !rooms?.length || !fogMap?.[0]) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms, 'fogMap=', fogMap);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);

// ───── 2× ZOOM – JET FUEL ORBIT CAMERA (ignores player janks, silky momentum) ─────
if (zoomEnabled && !splashActive && !gameOver) {
    c.save();
    c.imageSmoothingEnabled = false;

    c.translate(160, 160);
    c.scale(2, 2);

    // Base target: player center
    const baseX = -(p.currentX + S / 2);
    const baseY = -(p.currentY + S / 2);

    // JET FUEL MOMENTUM: impulse AHEAD of movement direction
    if (p.moving) {
        // Trigger "jet fuel" impulse on direction change or movement start
        if (p.deltaX !== camera.lastDeltaX || p.deltaY !== camera.lastDeltaY) {
            // SNAP TO CARDINAL DIRECTIONS ONLY (up/right/down/left)
            if (Math.abs(p.deltaX) > Math.abs(p.deltaY)) {
                camera.velocityX = p.deltaX * -5;  // less extreme = stable
                camera.velocityY = 0;
            } else {
                camera.velocityX = 0;
                camera.velocityY = p.deltaY * -5;
            }
        }
        camera.lastDeltaX = p.deltaX;
        camera.lastDeltaY = p.deltaY;
    } else {
        // Coast gently to stop
camera.velocityX *= 0.85;  // stops faster = more stable
camera.velocityY *= 0.85;
    }

    // Apply velocity as smooth offset (orbits/coasts)
    let targetX = baseX + camera.velocityX;
    let targetY = baseY + camera.velocityY;

    // Ultra-smooth lerp to target (ignores player janks)
camera.x += (targetX - camera.x) * 0.35;  // direct but stable
camera.y += (targetY - camera.y) * 0.35;

    c.translate(Math.floor(camera.x + 0.5), Math.floor(camera.y + 0.5));
}
    
    // Warden entry flash:
// ——— ECHO WARDEN FLASH: Divine ἀρχάγγελος ———
if (wardenFlashStart > 0) {
    const elapsed = Date.now() - wardenFlashStart;
    const duration = 700; // total flash duration

    if (elapsed < duration) {
        // Smooth pulse: 0 → 1 → 0
        const progress = elapsed / duration;
        const intensity = Math.sin(progress * Math.PI); // 0 to 1 to 0

        // Bitcoin orange (easy on eyes, but made it black instead)
        c.fillStyle = `rgba(247, 147, 26, 1})`;
        c.fillRect(0, 0, W * S, H * S);

    } else {
        wardenFlashStart = 0;    
    }    
}
    if (gameOver) {
        const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
        gameOverCanvas.clearRect(0, 0, 320, 320);
        gameOverCanvas.fillStyle = '#000';
        gameOverCanvas.fillRect(0, 0, 320, 320);
        const scale = window.innerWidth <= 700 ? 1.5 : 2;
        const gw = 128 * scale, gh = 32 * scale;
        const offsetY = (Math.sin(Date.now() / 500) * 10);
        gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh) / 2 + offsetY, gw, gh);
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('submit-score').style.display = 'block';
        document.getElementById('view-leaderboard').style.display = 'block';
        document.getElementById('restart-game').style.display = 'block';
        return;
    }
    if (splashActive) { needsRedraw = false; return; }

    const radius = 4;
// ───── WALLS ONLY (with Snowy Hell tint) ─────
for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
    if (map[y][x] === 1) { // walls only
        if (snowyHellActive) {
            c.save();
            c.drawImage(assets.themes.hell.wall, x * S, y * S, S, S);
            c.globalCompositeOperation = 'source-atop';
            c.fillStyle = 'rgba(190,240,255,0.85)'; // icy tint on walls
            c.fillRect(x * S, y * S, S, S);
            c.restore();
        } else {
            c.drawImage(assets.themes[currentTheme].wall, x * S, y * S, S, S);
        }
    }
}
// Save floor state before entering hideout (moved here to run once per draw)
if (!inHideout) {
previousFloorState = {
    map: map.map(row => [...row]),
    enemies: enemies.map(e => ({ ...e, type: { ...e.type } })),
    rooms: rooms.map(r => ({ ...r })),
    exit: exit ? { ...exit } : null,
    satoshiDrops: [...satoshiDrops],
    runeDrops: [...runeDrops],
    scrollDrops: [...scrollDrops],
    portals: portals.map(p => ({ ...p })),
    fogMap: fogMap.map(row => [...row]),  // ← Add this line
    floor: floor,
    wave: wave,
    enemiesSpawnedThisFloor: enemiesSpawnedThisFloor,
    whalesSpawnedThisFloor: whalesSpawnedThisFloor,
    initialSpawnDoneThisFloor: initialSpawnDoneThisFloor,
    initialWaveSpawned: initialWaveSpawned,
    waveActive: waveActive,
    currentTheme: currentTheme
};
}

// Draw floors, items, stairs, and runes
for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
    const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
    const isVisible = fogMap[y][x] === 1 || dist <= radius || map[y][x] === 1;
    if (isVisible && map[y][x] !== 1) {

// Draw floor — snowy hell only when BOTH in hell theme AND snowy block is active
if (currentTheme === 'hell' && snowyHellActive) {
    c.drawImage(assets.themes.hell.snowy_floor, x * S, y * S, S, S);
} else {
    c.drawImage(assets.themes[currentTheme].floor, x * S, y * S, S, S);
}
        
        // Draw dangerous areas (spells) before other items
        dangerousAreas.forEach(area => {
            if (area.x === x && area.y === y) {
                let spellColor = 'rgba(255, 255, 255, 0.5)';
                switch (area.spellType) {
                    case SPELL_TYPES.FIRE_WALL:
                        spellColor = 'rgba(255, 0, 0, 0.5)'; // Red for fire
                        break;
                    case SPELL_TYPES.LIGHTNING_STORM:
                        spellColor = 'rgba(255, 255, 0, 0.5)'; // Yellow for lightning
                        break;
                    case SPELL_TYPES.FROST_NOVA:
                        spellColor = 'rgba(0, 255, 255, 0.5)'; // Cyan for frost
                        break;
                    case SPELL_TYPES.POISON_CLOUD:
                        spellColor = 'rgba(0, 255, 0, 0.5)'; // Green for poison
                        break;
                }
                c.fillStyle = spellColor;
                c.globalAlpha = 0.5;
                c.fillRect(x * S, y * S, S, S);
                c.globalAlpha = 1;
            }
        });
        
        if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
        if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
        if (map[y][x] === 4) c.drawImage(assets.pickaxe, x * S, y * S, S, S);
        if (map[y][x] === 5) c.drawImage(assets.armor, x * S, y * S, S, S);
        if (map[y][x] === 6 && currentTheme !== 'dungeon') c.drawImage(assets.themes[currentTheme].special, x * S, y * S, S, S);
        if (map[y][x] === 7) c.drawImage(assets.gnome, x * S, y * S, S, S);
        if (map[y][x] === 8) c.drawImage(assets.runes.on_floor, x * S, y * S, S, S);
        if (map[y][x] === 9) {
            const rune = runeDrops.find(r => r.x === x && r.y === y && r.specific);
            if (rune && assets.runes[rune.letter]) {
                c.globalAlpha = 0.9; // Apply 10% transparency
                c.drawImage(assets.runes[rune.letter], x * S, y * S, S, S);
                c.globalAlpha = 1; // Restore full opacity
            }
        }
        if (map[y][x] === 10) { // diamond tile
            c.drawImage(assets.diamond, x * S, y * S, S, S);
        }
        if (map[y][x] === 11) { // scroll tile
            c.drawImage(assets.scroll, x * S, y * S, S, S);
        }
        if (map[y][x] === 12) { // portal tile
            const portal = portals.find(p => p.x === x && p.y === y);
            if (portal) {
                const now = performance.now();
                if (now - portal.lastFrameTime >= portal.frameDuration) {
                    portal.frameIndex = (portal.frameIndex + 1) % assets.town_portal.length;
                    portal.lastFrameTime = now;
                    needsRedraw = true; // Ensure redraw for animation
                }
                c.drawImage(assets.town_portal[portal.frameIndex], x * S, y * S, S, S);
            }
        }
if (map[y][x] === 25) { // Puzzle portal tile
    const portal = portals.find(p => p.x === x && p.y === y && p.type === 'puzzle');
    if (portal) {
        const now = performance.now();
        if (now - portal.lastFrameTime >= portal.frameDuration) {
            portal.frameIndex = (portal.frameIndex + 1) % assets.puzzlePortal.length;
            portal.lastFrameTime = now;
            needsRedraw = true;
        }
        c.drawImage(assets.puzzlePortal[portal.frameIndex], x * S, y * S, S, S);
    }
}
        if (map[y][x] === 13) { // Diamond wall
            c.drawImage(assets.themes.hideout.diamond_wall, x * S, y * S, S, S);
        }
        if (map[y][x] === 14) { // Jeweller
            c.drawImage(assets.jeweller, x * S, y * S, S, S);
        }
        if (map[y][x] === 15) { // Blacksmith
            c.drawImage(assets.blacksmith, x * S, y * S, S, S);
        }
        if (map[y][x] === 16) { // Waypoint
            c.drawImage(assets.waypoint, x * S, y * S, S, S);
        }
        if (map[y][x] === 17) { // Rune Whisperer
            c.drawImage(assets.rune_whisperer, x * S, y * S, S, S);
        }
        if (map[y][x] === 18) { // Hooded Heirloom
            c.drawImage(assets.hooded_heirloom, x * S, y * S, S, S);
        }
        if (map[y][x] === 19) { // Soul Stash
            c.drawImage(assets.soul_stash, x * S, y * S, S, S);
        }
        if (map[y][x] === 20) { // Soul Stone
            c.drawImage(assets.soul_stone, x * S, y * S, S, S);
        }
        if (map[y][x] === 21) { // Soul Orb Statue
            c.drawImage(assets.soul_orb_statue, x * S, y * S, S, S);
        }
        if (map[y][x] === 22) { // Shrine
            c.drawImage(assets.shrine, x * S, y * S, S, S);
        }
        if (map[y][x] === 23) { // Cursed Ring
            c.drawImage(assets.cursed_ring, x * S, y * S, S, S);
        }

// ───── PUZZLE ROOM – FINAL FIXES: FLOOR REVEAL + BOULDER TRAILS + ZOOM-CENTERED REVEAL ─────
if (inPuzzleRoom && puzzleStaticCanvas) {
    c.clearRect(0, 0, 320, 320);
    c.drawImage(puzzleStaticCanvas, 0, 0);

    // DYNAMIC FLOOR REVEAL: one-frame flash when boulder sinks or moves
    highlightTiles.forEach(t => {
        if (Date.now() - t.highlightStart < 500) {
            c.fillStyle = t.color || 'rgba(100,100,100,0.7)';
            c.fillRect(t.x * S, t.y * S, S, S);
        }
    });

    // Boulders
    puzzleBoulders.forEach(b => c.drawImage(assets.boulder, b.x * S, b.y * S, S, S));

    // Heart framers (pulsing)
    puzzleHeartFramers.forEach((h, i) => {
        const pulse = 0.9 + 0.1 * Math.sin(performance.now() / 250 + i * 0.3);
        c.globalAlpha = pulse;
        c.drawImage(assets.heartFramer, h.x * S, h.y * S, S, S);
    });
    c.globalAlpha = 1;

    // Chest
    if (puzzleChest) {
        const img = puzzleHeartFramers.length === 0 ? assets.chestOpen : assets.chestClosed;
        c.drawImage(img, puzzleChest.x * S, puzzleChest.y * S, S, S);
    }
}
                
// keep a flag that tells the main render loop “the warden is done”
let wardenFinished = false;

if (map[y][x] === 24 && echoWardenPos && echoWardenPos.x === x && echoWardenPos.y === y) {
    const age = Date.now() - echoWardenPos.spawnTime;
    const spawnDuration = 1200;
    const holdDuration   = 3800;
    const fadeOutDuration = 1500;

    // -------------------------------------------------
    // 1️⃣  End‑of‑life handling – *do not* touch the map yet
    // -------------------------------------------------
    if (age >= spawnDuration + holdDuration + fadeOutDuration) {
        wardenFinished = true;          // mark it for later cleanup
        echoWardenPos = null;
        // still draw the last (fully transparent) frame so the
        // background tile isn’t swapped out mid‑frame
    } else {
        // -------------------------------------------------
        // 2️⃣  Normal drawing logic (unchanged)
        // -------------------------------------------------
        let alpha = 1.0;
        let scale = 1.0;

        if (age < spawnDuration) {
            const t = age / spawnDuration;
            alpha = t * t;               // ease‑in
            scale = 0.2 + 0.8 * t;
        } else if (age < spawnDuration + holdDuration) {
            alpha = 1.0;
            scale = 1.0;
        } else {
            const fadeT = (age - spawnDuration - holdDuration) / fadeOutDuration;
            alpha = 1.0 - fadeT;
            scale = 1.0;
        }

        const drawX = echoWardenPos.moving ? echoWardenPos.currentX : x * S;
        const drawY = echoWardenPos.moving ? echoWardenPos.currentY : y * S;

        c.save();
        c.globalAlpha = alpha;
        c.translate(drawX + S / 2, drawY + S / 2);
        c.scale(scale, scale);
        c.translate(-S / 2, -S / 2);
        c.drawImage(assets.echo_warden, 0, 0, S, S);
        c.restore();
    }
}

// -------------------------------------------------
// 3️⃣  After the whole frame has been rendered, clean up
// -------------------------------------------------
if (wardenFinished) {
    // now it’s safe to replace the tile – the frame that showed the
    // fully‑transparent warden has already been presented.
    map[y][x] = 0;
    wardenFinished = false;
}

// Black cat — MATRIX GLITCH (mega digital rain + distortion)
if (catPos && catPos.x === x && catPos.y === y) {
    const now = performance.now();
    const glitchTime = now * 0.01;
    
    c.save();
    
    // 1. BASE CAT with green glow + flicker
    const flicker = 0.6 + 0.4 * Math.sin(glitchTime * 17);
    c.globalAlpha = flicker;
    c.shadowColor = 'lime';
    c.shadowBlur = 4 + Math.sin(glitchTime * 9) * 2;
    c.drawImage(assets.cat, x * S, y * S, S, S);
    c.shadowBlur = 0;
    
    // 2. HORIZONTAL SCANLINES (Matrix TV static)
    for (let i = 0; i < 4; i++) {
        const scanY = y * S + (i * 4) + (Math.sin(now * 0.02 + i) * 2);
        c.strokeStyle = `rgba(0,255,0,${0.3 * flicker})`;
        c.lineWidth = 1;
        c.beginPath();
        c.moveTo(x * S, scanY);
        c.lineTo(x * S + S, scanY);
        c.stroke();
    }
    
    // 3. PIXEL SHIFT DISTORTION (left/right shake)
    const shiftX = Math.sin(glitchTime * 23) * 1;
    c.globalAlpha = 0.4 * flicker;
    c.drawImage(assets.cat, (x * S) + shiftX, y * S, S, S);
    
    // 4. MATRIX RAIN — 6 falling chars behind cat
    c.font = '8px VT323';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    const chars = '01ABTC₿';
    for (let i = 0; i < 6; i++) {
        const rainY = (y * S + S/2) + (i * 3) - (now * 0.03 * (i + 1));
        const rainX = (x * S + S/2) + (Math.sin(now * 0.05 + i) * 3);
        const char = chars[Math.floor(now * 0.1 + i) % chars.length];
        c.globalAlpha = 0.7 * (1 - i/6) * flicker;
        c.fillStyle = 'lime';
        c.fillText(char, rainX, rainY);
    }
    
    c.restore();
    needsRedraw = true;
}
        
        // Draw stairs after portals to ensure proper visibility
        if (exit && exit.x === x && exit.y === y) {
            c.drawImage(assets.stairs, x * S, y * S, S, S);
        }
    }
}

///////////
// NOTICE: DRAW ORDER IS A THING! ;)
/////////

// Draw flash effect for diamond hand AOE damage
highlightTiles.forEach(tile => {
    if (Date.now() - tile.highlightStart < 200 && tile.x >= 0 && tile.x < W && tile.y >= 0 && tile.y < H && map[tile.y][tile.x] !== 1) {
        const dist = Math.sqrt((tile.x - p.x) ** 2 + (tile.y - p.y) ** 2);
        const isVisible = fogMap[tile.y][tile.x] === 1 || dist <= radius;
        if (isVisible) {
            c.save();
            c.fillStyle = 'rgba(247, 147, 26, 0.5)'; // Bitcoin orange flash
            c.fillRect(tile.x * S, tile.y * S, S, S);
            c.restore();
        }
    }
});

// Draw fading dead wisp corpse
if (deadWispCorpse) {
    const elapsed = Date.now() - deadWispCorpse.fadeStart;
    const fadeAlpha = Math.max(0, 1 - (elapsed / 5000)); // Fade over 5s
    if (fadeAlpha > 0) {
        const frame = assets.wispFrames[deadWispCorpse.frameIndex];
        if (frame.complete) {
            c.save();
            c.globalAlpha = fadeAlpha * 0.75; // 0.75 opacity for corpse
            c.drawImage(frame, deadWispCorpse.x * S, deadWispCorpse.y * S, S, S);
            c.restore();
        }
    } else {
        deadWispCorpse = null; // Cleanup after fade
    }
}

// In the draw function, after drawing items but before drawing player:
// Draw shrines with fog handling
for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
        const isVisible = fogMap[y][x] === 1 || dist <= radius;
        
        if (map[y][x] === 22 && isVisible) { // Shrine tile
            c.drawImage(assets.shrine, x * S, y * S, S, S);
            needsRedraw = true; // Add this to ensure proper redraw after shrine drawing
        }
        
        if (map[y][x] === 27 && farmSpot && farmSpot.x === x && farmSpot.y === y && isVisible) {
            const mature = p.farmLocked && floor >= p.farmLockedFloor + 50;
            c.drawImage(mature ? assets.farmSpot2 : assets.farmSpot1, x * S, y * S, S, S);
        }
    }
}

    // Draw projectiles – enemy bits use bit_spear.png, player sword uses shoot_sword.png
    projectiles.forEach(proj => {
        if (proj.x >= 0 && proj.x < W && proj.y >= 0 && proj.y < H &&
            (proj.x !== p.x || proj.y !== p.y)) {
            c.save();

                        const drawX = proj.currentX !== undefined ? proj.currentX : proj.x * S;
            const drawY = proj.currentY !== undefined ? proj.currentY : proj.y * S;
            c.translate(drawX + S / 2, drawY + S / 2);

            let angle = 0;
            if (proj.dirX !== undefined) {
                // Enemy bit spear – pure cardinal
                if (proj.dirX > 0) angle = 0;          // right →
                else if (proj.dirX < 0) angle = Math.PI; // left ←
                else if (proj.dirY > 0) angle = Math.PI / 2;   // down ↓
                else if (proj.dirY < 0) angle = -Math.PI / 2;  // up ↑
            } else if (proj.dir) {
                // Legacy player sword projectile
                if (proj.dir === 'right') angle = 0;
                if (proj.dir === 'left')  angle = Math.PI;
                if (proj.dir === 'down')  angle = Math.PI / 2;
                if (proj.dir === 'up')    angle = -Math.PI / 2;
            }
            c.rotate(angle);

            // Choose the correct sprite
            if (proj.value !== undefined) {
                // enemy bit projectile
                c.drawImage(assets.bit_spear, -S / 2, -S / 2, S, S);
            } else {
                // player's shooting sword
                c.drawImage(assets.shoot_sword, -S / 2, -S / 2, S, S);
            }

            c.restore();
        }
    });
// Draw player
// Add this to the existing draw function for player rendering
    if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
const now = performance.now();
// Animation frame update logic here
if (p.moving) {
    // Half speed animation during movement (5 FPS - doubled interval)
    if (now - p.anim.lastFrameTime >= 50) {
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
        p.anim.lastFrameTime = now;
    }
} else {
    // Idle: No animation (fixed frame)
    p.anim.frameIndex = 0;
}
        
let drawX = p.currentX;
let drawY = p.currentY;
        
        const direction = p.anim.direction;
        const baseDirection = direction === 'left' ? 'right' : direction;
let frameKey = p.hasDiamondArmor ? `diamond_armor_${baseDirection}` : (p.hasArmor ? `armor_${baseDirection}` : baseDirection);
if (p.isFalling) {
    frameKey = 'fall';
}
	const frame = p.anim.frames[frameKey][p.anim.frameIndex];
        c.save();
                
        if (direction === 'left') {
            c.translate(drawX + S, drawY);
            c.scale(-1, 1);
            c.drawImage(frame, 0, 0, S, S);
        } else {
            c.drawImage(frame, drawX, drawY, S, S);
        }
        c.restore();

// New: Draw bluish aura hit flash circle
if (p.hasCursedRing && auraHitStartTime > 0) {
    const elapsed = Date.now() - auraHitStartTime;
    if (elapsed < auraFlashDuration) {
        const flashAlpha = 0.6 * (1 - (elapsed / auraFlashDuration)); // Fade out
        // Clear reusable aura canvas
        auraTempCtx.clearRect(0, 0, W * S, H * S);
        auraTempCtx.fillStyle = `rgba(75, 0, 130, ${flashAlpha})`; // Indigo-purple curse flash
        auraTempCtx.beginPath();
        const centerX = p.currentX + S / 2;
        const centerY = p.currentY + S / 2;
        const radius = S * 1 * (elapsed / auraFlashDuration) + (S / 2); // Expand from S/2 to 1.5S
        auraTempCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        auraTempCtx.fill();
        c.drawImage(auraTempCanvas, 0, 0);
    } else {
        auraHitStartTime = 0; // End flash
    }
}
    }
// Draw sword or pickaxe-sword or diamond hand
if (swordActive && Date.now() - swordStart < 200) {
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    if (sx >= 0 && sx < W && sy >= 0 && sy < H && Math.sqrt((sx - p.x) ** 2 + (sy - p.y) ** 2) <= radius) {
        c.save();
        c.translate(sx * S + S / 2, sy * S + S / 2);
        if (swordDir === 'up') c.rotate(-Math.PI / 2);
        if (swordDir === 'down') c.rotate(Math.PI / 2);
        if (swordDir === 'left') c.rotate(Math.PI);
        // Prioritize pickaxe sword if player has pickaxes and is using it, then diamond hand, then regular sword
        if (p.pickaxes > 0 && usePickaxeSword) {
            c.drawImage(assets.pickaxe_sword, -S / 2, -S / 2, S, S);
            p.atk = 2; // Reset attack power
        } else if (p.hasDiamondHand) {
            c.drawImage(assets.diamond_hand, -S / 2, -S / 2, S, S);
            p.atk = 3; // diamond hand attack power
        } else {
   if (p.soulStormCharges >= 8) {
       c.drawImage(assets.soul_sword, -S / 2, -S / 2, S, S);
   } else {
       c.drawImage(assets.sword, -S / 2, -S / 2, S, S);
   }
            p.atk = 2; // Reset attack power
        }
        c.restore();
    }
}

// SATOSHI'S SCOURGE — TRUE 360° MACE SPIN (mace orbits)
if (p.scourgeSpin && Date.now() - p.scourgeSpin.start < 520) {
    c.imageSmoothingEnabled = false;

    const elapsed = Date.now() - p.scourgeSpin.start;
    const angle = (elapsed / 520) * Math.PI * 2;
    const radius = S * 1.4;
    const cx = p.currentX + S/2;
    const cy = p.currentY + S/2;

    // 1. MACE HEAD — orbits and points outward
    const mx = cx + Math.cos(angle) * radius;
    const my = cy + Math.sin(angle) * radius;

    c.save();
    c.translate(mx, my);
    c.rotate(angle + Math.PI/2);  // +90° so right-pointing sprite faces away
    c.drawImage(assets.satoshi_scourge, -S/2, -S/2, S, S);
    c.restore();

    // 2. Crisp trail (4 ghosts)
    for (let i = 1; i <= 4; i++) {
        const trailAngle = angle - i * 0.35;
        const tx = cx + Math.cos(trailAngle) * radius;
        const ty = cy + Math.sin(trailAngle) * radius;
        c.save();
        c.globalAlpha = 0.8 / i;
        c.translate(tx, ty);
        c.rotate(trailAngle + Math.PI/2);
        c.drawImage(assets.satoshi_scourge, -S/2, -S/2, S, S);
        c.restore();
    }

    needsRedraw = true;
} else if (p.scourgeSpin) {
    p.scourgeSpin = null;
}
    
// Add rune tile indicator when player is on a rune tile
if (currentRuneTile && map[p.y][p.x] === 9) {
    const rune = runeDrops.find(r => r.x === p.x && r.y === p.y && r.specific);
    if (rune) {
        const floorIndicator = document.getElementById('floor-indicator');
        if (!floorIndicator.textContent.startsWith("Rune:")) {
            floorIndicator.textContent = `Rune: ${rune.letter.toUpperCase()}`;
        }
    }
}
    
// Draw gradient column overlay for RIP blast
if (ripBlastActive && Date.now() - ripBlastStartTime < 3000) {
    if (columnProgress === 0) {
        initGradientOverlay(); // Initialize overlay on first draw
    }
    c.save();
    c.globalCompositeOperation = 'screen'; // Subtle glow for visibility
    const elapsed = Date.now() - ripBlastStartTime;
    columnProgress = elapsed / 2000; // 0 to 1 over 2 seconds
    const columnWidth = 20; // Width of each column in pixels
    const numColumns = Math.ceil(W * S / columnWidth) + 1; // Cover entire width
    for (let i = 0; i < numColumns; i++) {
        const x = i * columnWidth + columnProgress * W * S; // Sweep left to right
        if (x > W * S) continue; // Skip columns off-screen
        const gradient = c.createLinearGradient(x, 0, x + columnWidth, 0);
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0)'); // Transparent edge
        gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.4)'); // Smudged orange center
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)'); // Transparent edge
        c.fillStyle = gradient;
        c.fillRect(x, 0, columnWidth, H * S); // Draw full-height column
    }
    c.restore();
    needsRedraw = true; // Ensure continuous redraw during effect
} else if (ripBlastActive) {
    ripBlastActive = false; // End effect after 3 seconds
    columnProgress = 0;
    if (enemies.length === 0 && !exit) {
        if (placeStairs()) {
            wave++;
            if (wisps.length > 0) wispSpeak('victory'); // happy jingle
            waveActive = false;
            document.getElementById('wave').textContent = wave;
            logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);
        } else {
            logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
        }
    }
    needsRedraw = true;
}

// Draw wisp companion (always, no dist gate + debug)
wisps.forEach(wisp => {
    if (wisp.x >= 0 && wisp.x < W && wisp.y >= 0 && wisp.y < H) {
        const dist = Math.sqrt((wisp.x - p.x) ** 2 + (wisp.y - p.y) ** 2);
        const alpha = 1.0; // Force full vis for debug (revert to fade later)
     
        // Auto-sync if too far
        if (dist > 6) {
            wisp.x = p.x; wisp.y = p.y;
            wisp.currentX = p.x * S; wisp.currentY = p.y * S;
            console.log('Wisp synced'); // Debug: Check console
        }
     
        const now = performance.now();
        const bobOffset = Math.floor(Math.sin(now / 400) * 2 + 1); // Snaps to 0,1,2px (prominent, pixel-perfect)
        let drawY = wisp.currentY + bobOffset;
     
        c.save();
        c.globalAlpha = alpha;
    
        // Trail (keep for path vis)
        if (wisp.lastPos) {
            c.strokeStyle = `rgba(255,255,255,${0.3 * alpha})`;
            c.lineWidth = 2;
            c.beginPath();
            c.moveTo(wisp.lastPos.x, wisp.lastPos.y);
            c.lineTo(wisp.currentX + S/2, drawY + S/2);
            c.stroke();
        }
        wisp.lastPos = {x: wisp.currentX + S/2, y: drawY + S/2};
    
        // Color tint based on HP ratio (white to red)
        const hpRatio = wisp.hp / wisp.maxHP;
        c.save(); // Inner tint isolation
        c.globalCompositeOperation = 'multiply';
        const tintColor = `rgb(${Math.floor(255 * (1 - hpRatio))}, ${Math.floor(255 * hpRatio)}, ${Math.floor(255 * hpRatio)})`;
        const tintGradient = c.createLinearGradient(0, 0, S, S);
        tintGradient.addColorStop(0, tintColor);
        tintGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
        c.fillStyle = tintGradient;
        c.fillRect(wisp.currentX, drawY, S, S);
        c.globalCompositeOperation = 'source-over'; // Reset after multiply
        c.restore(); // End inner tint
        const frame = assets.wispFrames[wisp.anim.frameIndex];
        if (frame.complete) {
            c.drawImage(frame, wisp.currentX, drawY, S, S);
        }
    
        c.restore();
     
        // Subtle always-visible HP bar (green outline, scales with HP)
        c.save();
        c.strokeStyle = 'rgba(0, 255, 0, 0.9)'; // Live green (50% more opaque)
        c.lineWidth = 1.5; // 50% thicker
        c.lineCap = 'round';
        const ratio = wisp.hp / wisp.maxHP;
        const sensitiveRatio = Math.max(0, Math.min(1, ratio * 1.5)); // 1.5x sensitivity (shrinks 50% faster, clamped 0-1)
        const barWidth = S * sensitiveRatio; // No min needed—stays 0-S
        c.beginPath();
        c.moveTo(wisp.currentX, drawY - 3);
        c.lineTo(wisp.currentX + barWidth, drawY - 3);
        c.stroke();
        c.restore();
    }
});

// Draw fog overlay — SKIP IN PUZZLE ROOMS (mobile performance fix!)
if (!inPuzzleRoom) {
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] !== 1 && !fogMap[y][x]) {
                c.fillStyle = 'rgba(0,0,0,0.7)';
                c.fillRect(x * S, y * S, S, S);
            }
        }
    }
}
       
/**
 * Makes pure‑red pixels transparent (α = 0).  
 * Works for desert and ruins – the same color is used for the “eyes” in those PNGs.
 */
function punchHoleThroughRed(imageData) {
    const d = imageData.data;
    for (let i = 0; i < d.length; i += 4) {
        // Check for pure red or near-red with wider tolerance
        if (
            d[i] >= 200 && d[i] <= 255 && // Red component (wider range)
            d[i+1] <= 50 && // Green component (wider range)
            d[i+2] <= 50 // Blue component (wider range)
        ) {
            //console.log(`Found near-red pixel at index ${i}: R=${d[i]}, G=${d[i+1]}, B=${d[i+2]}, A=${d[i+3]}`);
            d[i+3] = 1; // Mark eye pixels with a unique alpha (1) to identify them later
        }
    }
}

// (removed old pulseAlpha calc - now using PNG frames)

const tempCanvas = document.createElement('canvas');
tempCanvas.width = S;
tempCanvas.height = S;
const tempCtx = tempCanvas.getContext('2d');

// Draw enemies with theme-based color overlays, preserving transparent backgrounds
enemies.forEach(e => {
    if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
        const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
        const isVisible = fogMap[e.y][e.x] === 1 || dist <= radius;
        
        // Check if this enemy is a unique monster
        const isUniqueMonster = e.uniqueName !== undefined;
        // Invisible in fog for Cursed Trader
        if (e.type.name === 'Cursed Trader' && fogMap[e.y][e.x] === 0) {
            return; // Skip drawing
        }
        
        // Draw sword for Cursed Trader if attacking
        if (e.swordActive && Date.now() - e.swordStart < 200 && e.type.name === 'Cursed Trader') {
            let sx = e.x, sy = e.y;
            if (e.swordDir === 'up') sy--;
            if (e.swordDir === 'down') sy++;
            if (e.swordDir === 'left') sx--;
            if (e.swordDir === 'right') sx++;
            if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
                c.save();
                c.translate(sx * S + S / 2, sy * S + S / 2);
                if (e.swordDir === 'up') c.rotate(-Math.PI / 2);
                if (e.swordDir === 'down') c.rotate(Math.PI / 2);
                if (e.swordDir === 'left') c.rotate(Math.PI);
                c.drawImage(assets.sword, -S / 2, -S / 2, S, S);
                c.restore();
            }
        }
        
        c.save();
        const doPixelEffect = (frameCount % 1 === 0); 

        // Draw animated red bg circle before enemy (only if visible)
        if (isVisible) {
            const bgStartTime = enemyBgFrameTimes.get(e) || performance.now();
            enemyBgFrameTimes.set(e, bgStartTime);
            const now = performance.now();
            const frameIndex = Math.floor((now - bgStartTime) / 200) % 3; // Cycle every 200ms
            const bgImg = assets.enemyBg[frameIndex];
            if (bgImg.complete) {
                c.drawImage(bgImg, e.currentX, e.currentY, S, S);
            }
        }

        // Clear reusable canvas for this enemy
        enemyTempCtx.clearRect(0, 0, S, S);
        
        // Handle animation for enemies with anim property (e.g., Shrimp) - throttled
        let img;
        if (e.type.anim && e.anim) {
            const now = performance.now();
            const numFrames = (e.type.name === 'Shrimp' && currentTheme === 'hell' && e.type.anim.hellFrames) ? e.type.anim.hellFrames.length : e.type.anim.frames.length;
            if (now - e.anim.lastFrameTime >= 200) {
                e.anim.frameIndex = (e.anim.frameIndex + 1) % numFrames;
                e.anim.lastFrameTime = now;
            }
            // Use Hell Shrimp frames if theme is hell, enemy is Shrimp, and visible
            if (e.type.name === 'Shrimp' && currentTheme === 'hell' && isVisible && e.type.anim.hellFrames) {
                img = e.type.anim.hellFrames[e.anim.frameIndex];
            } else {
                img = e.type.anim.frames[e.anim.frameIndex];
            }
        } else {
            img = e.type.img;
        }
        
        let spriteCanvas, spriteCtx;
        if (isVisible) {
            if (doPixelEffect && isVisible) {
                // Reuse enemyTempCanvas for sprite processing (clear first if needed, but already cleared)
                spriteCtx = enemyTempCtx;
                spriteCtx.imageSmoothingEnabled = false;
                spriteCtx.drawImage(img, 0, 0, S, S);
                
                // Skip theme tints for Cursed Trader
                if (e.type.name !== 'Cursed Trader') {
                    // Apply theme-based effects to the sprite canvas
                    if (currentTheme === 'desert') {
                        const imageData = spriteCtx.getImageData(0, 0, S, S);
                        const data = imageData.data;
                        punchHoleThroughRed(imageData); // Mark eye pixels
                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i + 3] === 1) { // Eye pixel
                                data[i] = 255;     // Red
                                data[i + 1] = 0;   // Green
                                data[i + 2] = 0;   // Blue
                                data[i + 3] = 255; // Full opacity
                            } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel
                                data[i] = 255;     // Red
                                data[i + 1] = 242; // Green
                                data[i + 2] = 230; // Blue
                                data[i + 3] = Math.round(0.95 * 255); // 95% opacity
                            }
                        }
                        spriteCtx.putImageData(imageData, 0, 0);
                    } else if (currentTheme === 'ruins') {
                        const imageData = spriteCtx.getImageData(0, 0, S, S);
                        const data = imageData.data;
                        punchHoleThroughRed(imageData); // Mark eye pixels
                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i + 3] === 1) { // Eye pixel
                                data[i] = 255;     // Red
                                data[i + 1] = 0;   // Green
                                data[i + 2] = 0;   // Blue
                                data[i + 3] = 255; // Full opacity
                            } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel
                                data[i] = 144;     // Red
                                data[i + 1] = 126; // Green
                                data[i + 2] = 105; // Blue
                                data[i + 3] = 255; // Full opacity (removed 95% opacity)
                            }
                        }
                        spriteCtx.putImageData(imageData, 0, 0);
                    } else if (currentTheme === 'hell') {
                        // Apply red tint for hell theme
                        spriteCtx.globalCompositeOperation = 'source-atop';
                        spriteCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                        spriteCtx.fillRect(0, 0, S, S);
                        spriteCtx.globalCompositeOperation = 'source-over'; // Reset
                        
                        // Punch white fringes after tint
                        const imageData = spriteCtx.getImageData(0, 0, S, S);
                        spriteCtx.putImageData(imageData, 0, 0);
                    } else if (currentTheme === 'paradise') {
                        // Apply purple tint for paradise theme + red eyes
                        const imageData = spriteCtx.getImageData(0, 0, S, S);
                        punchHoleThroughRed(imageData); // Mark eye pixels
                        const data = imageData.data;
                        const width = S;  // 16
                        const height = S; // 16
                        const threshold = 100; // Tune: higher = fewer transparencies

                        // CPU-friendly neighbor diff check: zero alpha for color outliers (non-eyes)
                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i + 3] > 0 && data[i + 3] !== 1) {  // Opaque non-eye only
                                const row = Math.floor(i / (4 * width));
                                const col = (i / 4) % width;
                                const r = data[i], g = data[i + 1], b = data[i + 2];

                                const neighbors = [];
                                const dirs = [
                                    { dx: 0, dy: -1 },  // up
                                    { dx: 0, dy: 1 },   // down
                                    { dx: -1, dy: 0 },  // left
                                    { dx: 1, dy: 0 }    // right
                                ];

                                for (const d of dirs) {
                                    const nr = row + d.dy;
                                    const nc = col + d.dx;
                                    if (nr >= 0 && nr < height && nc >= 0 && nc < width) {
                                        const ni = (nr * width + nc) * 4;
                                        if (data[ni + 3] > 0) {  // Only opaque neighbors
                                            const nrgb = data[ni], ngb = data[ni + 1], nbgb = data[ni + 2];
                                            neighbors.push([nrgb, ngb, nbgb]);
                                        }
                                    }
                                }

                                if (neighbors.length === 0) {
                                    data[i + 3] = 0;  // Isolated: transparent
                                    continue;
                                }

                                let totalDiff = 0;
                                for (const [nrgb, ngb, nbgb] of neighbors) {
                                    totalDiff += Math.sqrt(
                                        (r - nrgb) ** 2 + (g - ngb) ** 2 + (b - nbgb) ** 2
                                    );
                                }
                                const avgDiff = totalDiff / neighbors.length;

                                if (avgDiff > threshold) {
                                    data[i + 3] = 0;  // Outlier: transparent
                                }
                            }
                        }
                        for (let i = 0; i < data.length; i += 4) {
                            if (data[i + 3] === 1) { // Eye pixel - make red
                                data[i] = 255;     // Red
                                data[i + 1] = 0;   // Green
                                data[i + 2] = 0;   // Blue
                                data[i + 3] = 255; // Full opacity
                            } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel - purple tint
                                data[i] = Math.min(255, data[i] + 50); // Subtle red for violet base
                                data[i + 1] = Math.min(255, data[i + 1] + 51); // Subtle green
                                data[i + 2] = Math.min(255, data[i + 2] + 153); // Blue for purple
                                data[i + 3] = Math.round(0.95 * 255); // 95% opacity
                            }
                        }
                        spriteCtx.putImageData(imageData, 0, 0);
                    }
                }
                
                // Special handling for unique monsters (poison green with red eyes) - skip Cursed Trader
                if (isUniqueMonster && e.type.name !== 'Cursed Trader') {
                    const imageData = spriteCtx.getImageData(0, 0, S, S);
                    const data = imageData.data;
                    punchHoleThroughRed(imageData); // Mark eye pixels
                    for (let i = 0; i < data.length; i += 4) {
                        if (data[i + 3] === 1) { // Eye pixel - make red
                            data[i] = 255;     // Red
                            data[i + 1] = 0;   // Green
                            data[i + 2] = 0;   // Blue
                            data[i + 3] = 255; // Full opacity
                        } else if (data[i + 3] > 0) { // Non-eye, non-transparent pixel - make poison green
                            data[i] = 0;       // Red
                            data[i + 1] = 255; // Green (poison green)
                            data[i + 2] = 0;   // Blue
                            data[i + 3] = Math.round(0.95 * 255); // 95% opacity
                        }
                    }
                    spriteCtx.putImageData(imageData, 0, 0);
                }
            }
            // Fallback draw if pixel effect skipped
            if (!doPixelEffect || !isVisible) {
                enemyTempCtx.drawImage(img, 0, 0, S, S);
            }
        } else {
            // Outside fog of war, draw original sprite to show red eyes
            enemyTempCtx.drawImage(img, 0, 0, S, S);
            
            // Punch white fringes on fog sprites too
            const imageData = enemyTempCtx.getImageData(0, 0, S, S);
            enemyTempCtx.putImageData(imageData, 0, 0);
        }
        
                        // Draw the processed sprite to the main canvas
                        c.drawImage(enemyTempCanvas, e.currentX, e.currentY, S, S);

                        // SCOURGE HIT FLASH (bright orange-red)
                        if (e.scourgeHit && Date.now() - e.scourgeHit < 200) {
                            c.save();
                            c.fillStyle = 'rgba(255,100,0,0.7)';
                            c.fillRect(e.currentX, e.currentY, S, S);
                            c.restore();
                        }

                        // Draw bit shield flash when active (transparent-ish blue circle)
                        if (e.shieldFlash && e.shieldFlash.active) {
                            const elapsed = Date.now() - e.shieldFlash.startTime;
                            if (elapsed < 300) { // flash for 300ms
                                const alpha = 0.6 * (1 - elapsed / 300);
                                c.fillStyle = `rgba(0, 200, 255, ${alpha})`; // bright cyan
                                c.beginPath();
                                c.arc(e.currentX + S/2, e.currentY + S/2, S/2 + 4, 0, Math.PI * 2);
                                c.fill();
                                needsRedraw = true;
                            } else {
                                e.shieldFlash.active = false;
                            }
                        }

c.restore();

// Wisp hit flash on enemies (inside loop)
        if (e.wispHitFlash && Date.now() - e.wispHitFlash.time < 200) {
            c.save();
            let flashColor = 'rgba(0, 232, 216, 0.5)'; // Default cyan (freeze)
            switch (e.wispHitFlash.type) {
                case 'earth': flashColor = 'rgba(139, 69, 19, 0.6)'; // Brown quake
                    break;
                case 'chain': flashColor = 'rgba(255, 255, 0, 0.5)'; // Yellow lightning
                    break;
                case 'fire': flashColor = 'rgba(103, 0, 0, 0.55)'; // Red fire bolt
                    break;
                // cold/freeze stays cyan
            }
            c.fillStyle = flashColor;
            c.fillRect(e.currentX, e.currentY, S, S);
            c.restore();
            if (Date.now() - e.wispHitFlash.time > 200) delete e.wispHitFlash;
        }
    }
});

// Draw fading dangerous spell areas after enemies
drawFadingDangerousAreas();

// Draw low-health warning border with smooth transition
if ((p.hp <= 4 || (p.hp > 4 && p.hp < 9)) && !gameOver && !splashActive) {
    // Use a smooth, consistent pulse instead of frame-rate dependent flashing
    const pulse = Math.sin(Date.now() / 100); // Slower, smoother pulse
    let alpha, color;
    
    if (p.hp <= 4) {
        alpha = 0.5 + 0.1 * pulse; // Smooth red transition (0.7 to 1.0)
        color = `rgba(255, 0, 0, ${alpha})`; // Red border for hp <= 4
    } else {
        alpha = 0.5 + 0.1 * pulse; // Smooth orange transition (0.5 to 0.8)
        color = `rgba(255, 165, 0, ${alpha})`; // Bitcoin orange border for 4 < hp < 9
    }
    
    c.strokeStyle = color;
    c.lineWidth = Math.max(5, window.innerWidth > 700 ? 10 : 5); // Responsive thickness
    c.beginPath();
    // Draw the border around the entire canvas
    c.moveTo(0, 0);
    c.lineTo(W * S, 0);
    c.lineTo(W * S, H * S);
    c.lineTo(0, H * S);
    c.closePath();
    c.stroke();
}

    document.getElementById('potions').textContent = p.potions;
    document.getElementById('health').textContent = Math.max(0, p.hp);

// (deleted: moved to updatePlayerState() for centralized death check)
    document.getElementById('pickaxes').textContent = p.pickaxes;
    
// Consolidated unique monster name display (prevents flicker)
let uniqueNameToShow = null;
let isHarbinger = false;
const visibleUniques = enemies.filter(e => e.uniqueName && e.type.name !== 'Cursed Trader' && fogMap[e.y][e.x] === 1);
if (visibleUniques.length > 0) {
    uniqueNameToShow = visibleUniques[0].uniqueName; // First visible
} else {
    const fogUniques = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 0);
    if (fogUniques.length > 0) {
        uniqueNameToShow = "A harbinger of doom is near.";
        isHarbinger = true;
    }
}
const floorIndicator = document.getElementById('floor-indicator');
const cachedText = window.currentFloorText || `Floor ${floor}`;
const debounceMs = isHarbinger ? 2000 : 1000; // Longer for harbinger
// Always set text for harbinger/visible (separate from animation trigger)
if (uniqueNameToShow && uniqueNameToShow !== cachedText && (now - (window.lastUniqueSetTime || 0) > debounceMs) && !floorIndicator.textContent.startsWith("Runeword")) {
    floorIndicator.textContent = uniqueNameToShow;
    window.currentFloorText = uniqueNameToShow;
    window.lastUniqueSetTime = now;
    activeUniqueMonsterName = uniqueNameToShow;
   
    // Auto-clear after 5s
    setTimeout(() => {
        if (activeUniqueMonsterName === uniqueNameToShow) {
            activeUniqueMonsterName = null;
            floorIndicator.textContent = `Floor ${floor}`;
            window.currentFloorText = `Floor ${floor}`;
        }
    }, 5000);
} else if (!uniqueNameToShow && cachedText !== `Floor ${floor}` && !floorIndicator.textContent.startsWith("Runeword")) {
    floorIndicator.textContent = `Floor ${floor}`;
    window.currentFloorText = `Floor ${floor}`;
    activeUniqueMonsterName = null;
}

    updateAndDrawMatrix();  // ← PERFECT SPOT! Magical flames + red balls

// —————————————————————————————
    // BIT SPEAR HIT SHAKE — FINAL & FLAWLESS
    // —————————————————————————————
    if (spearHitShakeStart > 0) {
        const elapsed = Date.now() - spearHitShakeStart;

        if (elapsed >= 200) {
            // Shake finished → clean reset once
            spearHitShakeStart = 0;
            spearHitShakeIntensity = 0;
            c.setTransform(1, 0, 0, 1, 0, 0); // Reset any translation if shake was active
        } else {
            // Apply shake every frame while active
            const decay = 1 - (elapsed / 200);
            let intensity = spearHitShakeIntensity * decay;

            if (intensity > 0.5) {
                const shake = (intensity - 0.5) * 2; // extra punchy
                c.translate(
                    (Math.random() * 2 - 1) * shake * 8,
                    (Math.random() * 2 - 1) * shake * 6
                );
            }
        }
    }

// ───── SNOW (snowy hell – zoom-aware, no snapping) ─────
if (snowyHellActive && snowflakes.length) {
    const SCREEN_W = zoomEnabled ? 640 : 320;
    const SCREEN_H = zoomEnabled ? 640 : 320;
    const SCALE = zoomEnabled ? 2 : 1;

    c.fillStyle = 'rgba(255,255,255,0.9)';
    snowflakes.forEach(f => {
        f.y += f.speed * SCALE;
        f.x += Math.sin(performance.now() / 1000 + f.sway) * 0.3 * SCALE;
        if (f.y > SCREEN_H) {
            f.y = -f.size * SCALE;
            f.x = Math.random() * SCREEN_W;
        }
        if (f.x < -10) f.x = SCREEN_W - 1;
        if (f.x > SCREEN_W + 10) f.x = 0;
        c.fillRect(f.x, f.y, f.size * SCALE, f.size * SCALE);
    });
}

// ───── RESTORE ONLY IF WE ZOOMED ─────
if (zoomEnabled && !splashActive && !gameOver) {

// Bitcoin orange stairs arrow (world‑plane, floats above player)
if (exit) {
    const now   = performance.now();
    const angle = Math.atan2(exit.y - p.y, exit.x - p.x);
    const pulse = 1 + 0.15 * Math.sin(now / 600);
    const bob   = 0.08 * Math.sin(now / 300);

    const arrowX = p.currentX + S / 2;
    const arrowY = p.currentY - S * 1.5 + bob * S;

    c.save();
    c.translate(arrowX, arrowY);
    c.rotate(angle);
    c.scale(pulse, pulse);

    // ---- RETRO PIXEL ARROW (mid size) ----
    c.font = 'bold 14px "Courier New", monospace';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    c.fillStyle   = '#F7931A';
    c.strokeStyle = '#FF4400';
    c.lineWidth   = 1.5;
    c.shadowColor = '#F7931A';
    c.shadowBlur  = 6;

    // Size choice: 9 px total height (≈ 75 % of original)
    const size      = 9;   // overall height
    const tipHeight = 3;   // tip length (half of total height)
    // shaft height is implicit: size - tipHeight

    c.beginPath();
    // tip
    c.moveTo( tipHeight, -size/2 );
    c.lineTo( size,      0 );
    c.lineTo( tipHeight,  size/2 );
    // shaft
    c.lineTo( tipHeight,  size/4 );
    c.lineTo( 0,          size/4 );
    c.lineTo( 0,         -size/4 );
    c.lineTo( tipHeight, -size/4 );
    c.closePath();

    c.stroke();   // outline
    c.fill();     // fill

    c.restore();
}

    c.restore();
}

// ───── ZELDA-ISH RADAR MINIMAP – TOP-LEFT BELOW FLOOR TEXT (PERFECTION) ─────
if (minimapVisible && zoomEnabled) {
    const MINI_W = 64;
    const MINI_H = 64;
    const MINI_S = MINI_W / W;  // 3.2px per tile

    // Position: top-left, just below "Floor X" text
    const PADDING = 8;
    const X = PADDING;
    const Y = 38;  // 38px down = just below floor text (perfect on all screens)

    c.save();
    c.translate(X, Y);

    // Dark semi-transparent background
    c.fillStyle = 'rgba(27, 22, 16, 0.5)';
    c.fillRect(0, 0, MINI_W, MINI_H);

    // ALL enemies (true radar)
    enemies.forEach(e => {
        const mx = e.x * MINI_S;
        const my = e.y * MINI_S;
        c.fillStyle = '#F7931A';
        c.fillRect(mx + 0.5, my + 0.5, MINI_S * 0.8, MINI_S * 0.8); // same size as player
    });

    // Player (white dot)
    const px = p.x * MINI_S + 0.5;
    const py = p.y * MINI_S + 0.5;
    c.fillStyle = '#FFFFFF';
    c.fillRect(px - 1, py - 1, MINI_S * 0.8, MINI_S * 0.8);

    c.restore();
}

    // THIS IS THE MAIN DRAW, MADE TO CREATE EFFECTS BEFORE "needsRedraw = false"
    needsRedraw = false;
    frameCount++;
}

function gameLoop(timestamp) {
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state');
        initMap();
        needsRedraw = true;
    }
    
if (gameOver) {
    musicManager.mute(true);
    musicManager.play(currentTheme);
    if (!gameOverSoundPlayed) {
        sounds.gameover.play().catch(e => console.error('Gameover sound error:', e));
        gameOverSoundPlayed = true;
    }
    document.getElementById('health').textContent = 0;
    // Reset text color to Bitcoin orange for game-over screen
    document.documentElement.style.setProperty('--text-color', '#ff8c00');
    document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #leaderboard-output, #username-input, #sats-calc').forEach(el => {
        el.style.color = '#ff8c00';
    });
    
    // Add gamepad control blocking logic
    if (gamepadIndex !== null && !inputBlocked) {
        inputBlocked = true;
        // Block controls for 1 second (1000ms)
        setTimeout(() => {
            inputBlocked = false;
        }, 1000);
    }
    
// Auto-submit score with random name from names array only if gamepad is connected
   if (!scoreSubmitted && gamepadIndex !== null && !autoSubmitTriggered) {
       autoSubmitTriggered = true;
       // Do NOT auto-submit anymore - user must press B button to submit
   }
    needsRedraw = true;
}
    
updateProjectiles();

    // Unique monster harasses player who stands still inside its spell
    const playerOnSpell = dangerousAreas.some(area => area.x === p.x && area.y === p.y);
    if (playerOnSpell) {
        if (spellHarassTimer === 0) {
            spellHarassTimer = performance.now() + 2000 + Math.random() * 2000; // first harass in 2–4s
        }
        if (performance.now() >= spellHarassTimer) {
            const caster = enemies.find(e => 
                e.uniqueName && e.spell && dangerousAreas.some(a => a.spellType === e.spell && a.x === p.x && a.y === p.y)
            );
            if (caster) {
                applySpellDamage(p.x, p.y); // harass = damage
                logBattleEvent(`Floor ${floor} - ${caster.uniqueName} surges through the ${caster.spell}!`);
                moveEnemies(); // normal AI moves everyone naturally
                needsRedraw = true;
            }
            spellHarassTimer = performance.now() + 2000 + Math.random() * 2000; // next pulse every 2–4s
        }
    } else {
        spellHarassTimer = 0; // reset when player leaves spell
    }

// Simple delta updates (run every frame for smooth movement)
if (p.moving) {
    const elapsed = performance.now() - p.moveStartTime;
    const progress = Math.min(elapsed / p.moveDuration, 1); // 0 to 1 over duration
    const eased = 0.5 + 0.5 * Math.sin(Math.PI * progress - Math.PI / 2); // Smooth ease-in-out
    p.currentX = p.startX * S + eased * (p.x * S - p.startX * S);
    p.currentY = p.startY * S + eased * (p.y * S - p.startY * S);
    p.currentX = Math.floor(p.currentX); // Pixel-snap
    p.currentY = Math.floor(p.currentY);
    if (progress >= 1) {
        p.moving = false;
        p.anim.frameIndex = 0; // Reset to idle frame on stop
        p.currentX = p.x * S;
        p.currentY = p.y * S;
    }
    needsRedraw = true;
}
enemies.forEach(e => {
    if (e.moving) {
        e.currentX += e.deltaX;
        e.currentY += e.deltaY;
        e.stepsLeft--;
        if (e.stepsLeft <= 0) {
            e.moving = false;
            e.currentX = e.x * S;
            e.currentY = e.y * S;
        }
        needsRedraw = true;
    }
});

        // Warden interpolation (smooth pixel steps)
        if (echoWardenPos && echoWardenPos.moving) {
            echoWardenPos.currentX += echoWardenPos.deltaX;
            echoWardenPos.currentY += echoWardenPos.deltaY;
            echoWardenPos.stepsLeft--;

            if (echoWardenPos.stepsLeft <= 0) {
                echoWardenPos.moving = false;
                echoWardenPos.currentX = echoWardenPos.x * S;
                echoWardenPos.currentY = echoWardenPos.y * S;
            }
            needsRedraw = true;
        }

// Interp wisp movement
wisps.forEach(wisp => {
    if (wisp.moving) {
        wisp.currentX += wisp.deltaX;
        wisp.currentY += wisp.deltaY;
        wisp.stepsLeft--;
        if (wisp.stepsLeft <= 0) {
            wisp.moving = false;
            wisp.currentX = wisp.x * S;
            wisp.currentY = wisp.y * S;
        }
        needsRedraw = true;
    }
});

// Frame animation (only when moving) - throttled
const now = performance.now();
if (p.moving && now - p.anim.lastFrameTime >= 50) {
    p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
    p.anim.lastFrameTime = now;
}
    
    // Check for invisible health warning animation (activated at above 8 HP)
    const showInvisibleHealthWarning = p.hp > 8; // Trigger animation at higher threshold
    
    // Throttle draw to 20 FPS, but keep updates smooth
    if ((needsRedraw || p.hp <= 8 || showInvisibleHealthWarning) && !splashActive) {
        draw();
    }
    
    // Revert to unthrottled RAF for smooth interpolation; draw throttling is internal
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
        // Check if Enter is coming from username input field
        if (document.activeElement && document.activeElement.id === 'username-input') {
            return; // Let the username input handler handle this
        }
        
        if (splashActive && !hasPlayedOnce) {
            return; // Block Enter on initial splash screen
        }
        if (splashActive && hasPlayedOnce) {
            const startButton = document.getElementById('start-button');
            startButton.style.background = '#00b7ef'; // Mimic :hover color
            setTimeout(() => {
                startButton.style.background = '#00e8d8'; // Revert to original color
            }, 200); // Short duration to simulate tap

currentTheme = 'dungeon'; // Force default theme on game start
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }
    
if (splashActive) {
        preloadSounds();
        // Ensure AudioContext is resumed for iOS
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                // Reset music manager state and play music after AudioContext is resumed
                musicManager.current = null;
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
            }).catch(e => console.error('Failed to resume AudioContext:', e));
        } else {
            // Reset music manager state on restart
            musicManager.current = null;
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
        }
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);
        fadeSplash();
        setTimeout(() => {
            if (!gameOver && !splashActive) {
                fetchTxs();
                lastUpdate = Date.now();
                console.log('Initial fetchTxs triggered after splash, wave=', wave);
            }
        }, 2000);
    }
    
    // Set music volume to max when starting
if (musicManager.current) {
    const currentAudio = musicManager.audios[musicManager.current];
    if (currentAudio) {
        currentAudio.currentTime = 0;
        currentAudio.volume = 1;
    }
}
// Restore sound volume after preloading
setTimeout(() => {
    setSoundVolume(soundVolume);
}, 100);

            fadeSplash();
            setTimeout(() => {
                if (!gameOver && !splashActive) {
                    fetchTxs();
                    lastUpdate = Date.now();
                    console.log('Initial fetchTxs triggered after splash via Enter, wave=', wave);
                }
            }, 2000); // Match delay in start-button and startGame
            return;
        }
        
if (gameOver && hasPlayedOnce) {
    restart();
    return;
}
    }
    if (gameOver || splashActive) return;

    // Handle terminal input when active
    if (p.inSoulTerminal && p.soulTerminalActive) {
        handleTerminalInput(e);
        return;
    }

    /*
    // DEBUG: Runeword testing with keys 1-9 - comment out when not needed
    if (['1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(e.key)) {
        debugRuneword(e.key);
        needsRedraw = true;
        return;
    }
    */

    // Update key states and handle actions
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
        keyStates[e.key] = true;
    } else if (e.key === 'a') {
        attack();
    } else if (e.key === 'd') {
        usePotion();
    }

    // Start keyboard movement polling if not already started
    if (!keyboardMovementTimer) {
        keyboardMovementTimer = setInterval(() => {
            if (!splashActive && !gameOver) {
                let newMoveDir = null;
                if (keyStates.ArrowUp) {
                    newMoveDir = 'up';
                } else if (keyStates.ArrowDown) {
                    newMoveDir = 'down';
                } else if (keyStates.ArrowLeft) {
                    newMoveDir = 'left';
                } else if (keyStates.ArrowRight) {
                    newMoveDir = 'right';
                }

                if (newMoveDir) {
                    const now = Date.now();
                    if (!currentMoveDir || newMoveDir !== currentMoveDir || now - lastMoveTime >= 200) {
                        move(newMoveDir);
                        lastMoveTime = now;
                        currentMoveDir = newMoveDir;
                    }
                } else if (currentMoveDir) {
                    currentMoveDir = null;
                    lastMoveTime = 0;
                }
            }
        }, 50); // Poll frequently, moves capped at 200ms
    }
});

// Add this after the main document.addEventListener('keydown', ... line
document.getElementById('soul-terminal-input').addEventListener('keydown', function(e) {
    if (p.inSoulTerminal && p.soulTerminalActive) {
        // Prevent default for Enter to avoid duplicate handling
        if (e.key === 'Enter') {
            e.preventDefault();
        }
        handleTerminalInput(e);
        
        // Handle Enter key for terminal input
        if (e.key === 'Enter') {
            const command = this.value;
            processSoulCommand(command);
            this.value = '';
            this.focus();
        }
    }
});

// Add this after the existing soul-terminal-input keydown listener
document.addEventListener('keydown', function(e) {
    if (p.inSoulTerminal && p.soulTerminalActive && !e.target.matches('#soul-terminal-input')) {
        // Handle keyboard input when terminal is active but not focused
        const key = e.key;
        if (key.length === 1 && key !== 'Enter') {
            handleBlurredTerminalInput(key);
        }
    }
});

// Add global event listeners with proper cleanup handling
document._keydownHandler = function(e) {
    // Existing keydown handler logic here
};
document.addEventListener('keydown', document._keydownHandler);

document._keyupHandler = function(e) {
    // Existing keyup handler logic here
};
document.addEventListener('keyup', document._keyupHandler);

// Add touch event listeners with proper cleanup
document._touchstartHandler = function(e) {
    // Existing touchstart handler logic here
};
document.addEventListener('touchstart', document._touchstartHandler);

document._touchmoveHandler = function(e) {
    // Existing touchmove handler logic here
};
document.addEventListener('touchmove', document._touchmoveHandler);

document._touchendHandler = function(e) {
    // Existing touchend handler logic here
};
document.addEventListener('touchend', document._touchendHandler);

// Add gamepad event listeners with proper cleanup
document._gamepadConnectedHandler = function(e) {
    // Existing gamepadconnected handler logic here
};
window.addEventListener('gamepadconnected', document._gamepadConnectedHandler);

document._gamepadDisconnectedHandler = function(e) {
    // Existing gamepaddisconnected handler logic here
};
window.addEventListener('gamepaddisconnected', document._gamepadDisconnectedHandler);

// Update key states on release
document.addEventListener('keyup', e => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        keyStates[e.key] = false;
    }
});

// Add a global animation update for continuous animation when player moves or health changes
function animateHealthWarning() {
    // This function will be called periodically to trigger invisible animations
    if (p.hp > 8 && !gameOver && !splashActive) {
        needsRedraw = true;
    }
}

// Set up interval for invisible health warning animation updates
setInterval(animateHealthWarning, 100); // Update every 100ms when health is above threshold

document.getElementById('game-over').addEventListener('click', (event) => {
    if (
        gameOver &&
        !document.getElementById('username-input').contains(event.target) &&
        !document.getElementById('submit-score').contains(event.target) &&
        !document.getElementById('view-leaderboard').contains(event.target) &&
        !document.getElementById('restart-game').contains(event.target) &&
        !document.getElementById('leaderboard-output').contains(event.target)
    ) {
    }
});

        initMap();
        updateSatsDisplay();
        populateNameList();
        requestAnimationFrame(gameLoop);
        
// Removed redundant D-pad touch event listeners; handled in initTouchControls

//////////////////////
// Gamepad support //
////////////////////
let gamepadIndex = null; // Track connected gamepad
let lastButtonsState = []; // Track previous button states
let lastAxesState = { axis0: 0, axis1: 0 }; // Track previous D-pad axis states
let lastStartPressTime = 0; // Debounce Start button
const DEBOUNCE_MS = 200; // Debounce interval
const GAMEPAD_POLL_INTERVAL = 50; // Poll rate in ms
let lastGamepadPollTime = 0; // Throttle polling
let movementTimer = null; // Timer for continuous movement
let currentMoveDir = null; // Track current movement direction
let lastMoveTime = 0; // Track last move to enforce 200ms interval
let gamepadMoveDir = null; // Track gamepad movement direction
let gamepadLastMoveTime = 0; // Track last gamepad move to enforce 200ms interval
let gamepadPollingActive = false; // Track if gamepad polling is enabled
let hasPlayedOnce = false; // Track if player has played at least one game


const keyStates = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false
};
let keyboardMovementTimer = null;

// Simplified gamepad axis handling class without excessive profiling
class GamepadAxes {
    constructor(gamepad) {
        this.gamepad = gamepad;
        this.axis0 = 0;
        this.axis1 = 0;
    }
    
    // Update axes with current state
    update() {
        if (this.gamepad.axes.length >= 2) {
            this.axis0 = this.gamepad.axes[0];
            this.axis1 = this.gamepad.axes[1];
        }
    }
    
    // Get direction based on buttons or axes
    getDirection() {
        let newMoveDir = null;
        const deadZone = 0.2;
        
        // First check if we have a valid gamepad
        if (!this.gamepad) return null;
        
        // Check button-based D-pad (indices 12-15 for standard mapping)
        if (this.gamepad.buttons.length >= 16) {
            const upBtn = this.gamepad.buttons[12];
            const downBtn = this.gamepad.buttons[13];
            const leftBtn = this.gamepad.buttons[14];
            const rightBtn = this.gamepad.buttons[15];
            
            // Check each button individually
            if (leftBtn.pressed) {
                newMoveDir = 'left';
            } else if (rightBtn.pressed) {
                newMoveDir = 'right';
            } else if (upBtn.pressed) {
                newMoveDir = 'up';
            } else if (downBtn.pressed) {
                newMoveDir = 'down';
            }
        }
        
        // If no button direction, check axes 0 and 1
        if (!newMoveDir) {
            if (Math.abs(this.axis0) > deadZone) {
                newMoveDir = this.axis0 > 0 ? 'right' : 'left';
            } else if (Math.abs(this.axis1) > deadZone) {
                newMoveDir = this.axis1 > 0 ? 'down' : 'up';
            }
        }
        
        return newMoveDir;
    }
    
    // Check if D-pad is active (button-based or axis-based)
    isDpadActive() {
        const deadZone = 0.2;
        
        // Check button-based D-pad
        if (this.gamepad.buttons.length >= 16) {
            const upBtn = this.gamepad.buttons[12];
            const downBtn = this.gamepad.buttons[13];
            const leftBtn = this.gamepad.buttons[14];
            const rightBtn = this.gamepad.buttons[15];
            
            if (upBtn.pressed || downBtn.pressed || leftBtn.pressed || rightBtn.pressed) {
                return true;
            }
        }
        
        // Check axis-based D-pad
        return Math.abs(this.axis0) > deadZone || Math.abs(this.axis1) > deadZone;
    }
}

// Global instance for current gamepad axes
let currentAxes = null;

// Start game function for splash screen
function startGame() {
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪'; // Update mute button UI based on saved state
    if (!splashActive) {
        return;
    }
    
    // Switch back to splash.png when starting
    if (currentSplashImage !== 'splash.png') {
        currentSplashImage = 'splash.png';
        splashCanvas.clearRect(0, 0, 320, 320);
        splashImg.src = currentSplashImage;
        splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }
    
    const startButton = document.getElementById('start-button');
    startButton.style.background = '#00b7ef'; // Mimic hover
    setTimeout(() => {
        startButton.style.background = '#00e8d8'; // Revert
    }, 200);
    
    // Check for gamepad at game start
    if (navigator.getGamepads) {
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                console.log('Gamepad detected at game start:', gamepads[i].id);
                break;
            }
        }
    }
    
    // Resume AudioContext
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
        }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    preloadSounds(); // Preload sounds after user interaction
    
    currentTheme = 'dungeon'; // Force default theme on game start
    // Set mute state based on saved preference
    musicManager.mute(musicMuted);
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪'; // Update mute button UI
    musicManager.current = null; // Reset MusicManager state
    musicManager.audios[currentTheme].pause(); // Ensure audio is stopped
    musicManager.audios[currentTheme].currentTime = 0; // Reset to start of track
    
    if (musicManager.audios[currentTheme].readyState >= 2) { // Check if audio is loaded
        console.log('Playing music from start:', currentTheme); // Debug log
        musicManager.play(currentTheme); // Play the music immediately
    } else {
        console.log('Audio not ready, waiting for', currentTheme); // Debug log
        musicManager.audios[currentTheme].load(); // Force reload
        musicManager.audios[currentTheme].oncanplaythrough = () => {
            console.log('Audio ready, playing from start:', currentTheme); // Debug log
            musicManager.audios[currentTheme].currentTime = 0; // Reset to start of track
if (!musicMuted && !inPuzzleRoom) {
    musicManager.play(currentTheme);
}
        };
    }
    
    fadeSplash();
    
    // Start gamepad polling if gamepad is connected
    if (gamepadIndex !== null) {
        gamepadPollingActive = true;
        updateGamepad();
    }
    
    hasPlayedOnce = true; // Mark that the player has started a game
    
    // Ensure fetchTxs is triggered after splash fade
    setTimeout(() => {
        if (!gameOver && !splashActive && floor > 0) {
            console.log('Post-splash fetchTxs triggered: floor=', floor, 'wave=', wave);
            fetchTxs();
        } else {
            console.log('Post-splash fetchTxs skipped: gameOver=', gameOver, 'splashActive=', splashActive, 'floor=', floor);
        }
    }, 2000); // Match original start-button delay
}

window.addEventListener("gamepadconnected", (e) => {
    // Only connect if no gamepad is currently connected or if it's a different gamepad
    if (gamepadIndex === null) {
        gamepadIndex = e.gamepad.index;
        lastButtonsState = new Array(e.gamepad.buttons.length).fill(false);
        lastGamepadPollTime = performance.now();
        console.log('Gamepad connected:', e.gamepad.id);
        
        if (!splashActive) {
            gamepadPollingActive = true;
            if (!movementTimer) {
                movementTimer = setInterval(() => {
                    if (!splashActive && !gameOver && gamepadMoveDir) {
                        const now = Date.now();
                        if (now - gamepadLastMoveTime >= 200) {
                            move(gamepadMoveDir);
                            gamepadLastMoveTime = now;
                        }
                    }
                }, 50);
            }
            updateGamepad();
        }
    } else {
        console.log('Gamepad connected but already tracking:', e.gamepad.id);
    }
});

window.addEventListener("gamepaddisconnected", (e) => {
    // Only handle disconnection if this is the same gamepad we were tracking
    if (gamepadIndex === e.gamepad.index) {
        gamepadIndex = null;
        lastButtonsState = [];
        gamepadPollingActive = false;
        
        // Clear movement timer if active
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
        }
        
        // Reset gamepad movement tracking
        gamepadMoveDir = null;
        gamepadLastMoveTime = 0;
        
        console.log('Gamepad disconnected:', e.gamepad.id);
    }
});

// Modify the updateGamepad function to handle start button press for pausing
function updateGamepad(timestamp) {
    if (gamepadIndex === null) {
        // Try to find a connected gamepad
        const gamepads = navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (gamepads[i]) {
                gamepadIndex = i;
                gamepadPollingActive = true;
                break;
            }
        }
        if (gamepadIndex === null) {
            return; // No gamepad found, stop polling
        }
    }

    if (!gamepadPollingActive) {
        const gamepad = navigator.getGamepads()[gamepadIndex];
        if (gamepad && gamepad.buttons[3].pressed && !lastButtonsState[3] && splashActive) {
            const nowTime = Date.now();
            if (nowTime - lastStartPressTime > DEBOUNCE_MS) {
                startGame();
                lastStartPressTime = nowTime;
                gamepadPollingActive = true;
                if (!movementTimer) {
                    movementTimer = setInterval(() => {
                        if (!splashActive && !gameOver && gamepadMoveDir) {
                            const now = Date.now();
                            if (now - gamepadLastMoveTime >= 200) {
                                move(gamepadMoveDir);
                                gamepadLastMoveTime = now;
                            }
                        }
                    }, 50);
                }
            }
            lastButtonsState[3] = gamepad.buttons[3].pressed;
        }
        requestAnimationFrame(updateGamepad);
        return;
    }

    const now = performance.now();
    if (now - lastGamepadPollTime < GAMEPAD_POLL_INTERVAL) {
        requestAnimationFrame(updateGamepad);
        return;
    }
    lastGamepadPollTime = now;
    const gamepad = navigator.getGamepads()[gamepadIndex];
    if (!gamepad) {
        gamepadIndex = null;
        gamepadPollingActive = false;
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            currentMoveDir = null;
            lastMoveTime = 0;
        }
        return;
    }

    // Update axes with new state
    currentAxes = new GamepadAxes(gamepad);
    currentAxes.update();

    // Check for actual gamepad input (buttons or axes)
    const buttons = gamepad.buttons;
    const hasInput = buttons.some(b => b.pressed) || currentAxes.isDpadActive();
    
if (!splashActive && !gameOver && inputBlocked) {
    // Allow Start button (index 3) to exit terminal even when blocked
    const buttons = gamepad.buttons;
    const nowTime = Date.now();
    if (buttons[3].pressed && !lastButtonsState[3] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        if (p.inSoulTerminal && p.soulTerminalActive) {
            //console.log('Gamepad Start: Exiting soul terminal'); // Debug log
            closeSoulTerminal();
        }
        lastStartPressTime = nowTime;
    }
    // Update button states for Start
    lastButtonsState[3] = buttons[3].pressed;
    requestAnimationFrame(updateGamepad);
    return;
}

    // Handle buttons (A=0, B=1, Select=2, Start=3)
    const nowTime = Date.now();

    // A Button (0) - usePotion
    if (buttons[0].pressed && !lastButtonsState[0] && !splashActive && !gameOver) {
        usePotion();
        lastMoveTime = nowTime; // Update lastMoveTime to maintain consistency with other actions
    }

// B Button (1) - attack or submit score during game over
if (buttons[1].pressed && !lastButtonsState[1]) {
    if (!splashActive && !gameOver) {
        // Normal gameplay B button action
        attack();
        lastMoveTime = nowTime; // Update lastMoveTime to maintain consistency with other actions
    } else if (gameOver && gamepadIndex !== null && !inputBlocked) {  // ← Add !inputBlocked check here
        if (!gameOverBPressed) {
            if (!scoreSubmitted && floor >= 3) {
                // Submit score if eligible
                submitScoreWithRandomName();
            } else if (floor < 3) {
                // Show message for low floors
                document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
                document.getElementById('leaderboard-output').style.display = 'block';
            } // If already submitted, do nothing on first press
            gameOverBPressed = true;
        } else {
            // Second press always restarts to splash
            restart();
        }
    }
}

    // Select Button (2) - toggleMute
    if (buttons[2].pressed && !lastButtonsState[2] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        toggleMute();
        lastStartPressTime = nowTime; // Reuse lastStartPressTime for debouncing
    }

// Start Button (3) - startGame, restart, or exit soul terminal
if (buttons[3].pressed && !lastButtonsState[3] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
    if (p.inSoulTerminal && p.soulTerminalActive) {
        // Exit soul terminal
        closeSoulTerminal();
    } else if (splashActive) {
        startGame();
    } else if (gameOver) {
        restart();
    } else {
        // Existing else logic (if any)
    }
    lastStartPressTime = nowTime;
}

    // Update button states
    lastButtonsState = buttons.map(b => b.pressed);

    // Update movement direction using the new axes class
    if (!splashActive && !gameOver) {
        let newMoveDir = currentAxes.getDirection();
        gamepadMoveDir = newMoveDir; // Always update gamepadMoveDir
        
        // Rely on movementTimer for continuous movement
        if (newMoveDir && !movementTimer) {
            movementTimer = setInterval(() => {
                if (!splashActive && !gameOver && gamepadMoveDir) {
                    const now = Date.now();
                    if (now - gamepadLastMoveTime >= 200) {
                        move(gamepadMoveDir);
                        gamepadLastMoveTime = now;
                    }
                }
            }, 50);
        } else if (!newMoveDir && movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            gamepadLastMoveTime = 0;
        }
    }

    // Continue polling
    requestAnimationFrame(updateGamepad);
}

// Initialize touch controls after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    // Initialize the global button variables
    dpadButtons = document.querySelectorAll('#dpad button');
    actionsButtons = document.querySelectorAll('#actions button');
    
    setTimeout(() => {
        initTouchControls();
    }, 100);
    
    // Add event listener for soul terminal input
    const soulTerminalInput = document.getElementById('soul-terminal-input');
    if (soulTerminalInput) {
        soulTerminalInput.addEventListener('keydown', function(e) {
            if (p.inSoulTerminal && p.soulTerminalActive) {
                handleTerminalInput(e);
                
                // Handle Enter key for terminal input
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const command = this.value;
                    processSoulCommand(command);
                    this.value = '';
                    this.focus();
                }
            }
        });
    }
});

// Add this to prevent context menu issues
document.addEventListener('contextmenu', function(e) {
    // Only prevent context menu for elements that might cause issues
    if (e.target.closest('#game-container, #dpad, #actions') || 
        e.target.id === 'game' || 
        e.target.id === 'battle-events') {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
}, { passive: false });

// Function to submit score with random name
function submitScoreWithRandomName() {
    if (gameOver && !scoreSubmitted && gamepadIndex !== null) {
        // Select a random name from the names array
        const randomName = names[Math.floor(Math.random() * names.length)];
        document.getElementById('username-input').value = randomName;
        
        // Submit the score
        submitScore();
    }
}

function displayUniqueMonsterName() {
    if (!activeUniqueMonsterName) return;
    
    // Check if any visible unique monsters are present
    const visibleUniqueMonsters = enemies.filter(e => e.uniqueName && fogMap[e.y][e.x] === 1);
    
    if (visibleUniqueMonsters.length > 0) {
        // Clear previous display
        activeUniqueMonsterName = null;
        return;
    }
    
    // Check if unique monster is in fog of war but still has a name to show
    const uniqueMonsterInFog = enemies.find(e => e.uniqueName && fogMap[e.y][e.x] === 0);
    
    if (uniqueMonsterInFog && !activeUniqueMonsterName) {
        activeUniqueMonsterName = uniqueMonsterInFog.uniqueName;
        logBattleEvent(`A harbinger of doom is near.`);
        
// Clear only when enemy is killed or when leaving the area
// No auto-clear timeout needed anymore
    }
}

// Screensaver: black background, slow drifting orange ball (#f7931a) with white "₿" and soft glows.
// Smooth fade-out/fade-in, minimal breathing and drift.

let screensaverActive = false;
let screensaverCanvas = null;
let screensaverCtx = null;
let screensaverInitialized = false;
let screensaverLoopId = null;

(function ensureScreensaverOverlay() {
  if (!document.getElementById('screensaver-overlay')) {
    const newOverlay = document.createElement('div');
    newOverlay.id = 'screensaver-overlay';
    newOverlay.style.display = 'none';
    newOverlay.style.position = 'fixed';
    newOverlay.style.left = '0';
    newOverlay.style.top = '0';
    newOverlay.style.width = '100%';
    newOverlay.style.height = '100%';
    newOverlay.style.zIndex = '9999';
    newOverlay.innerHTML = '<canvas id="screensaver-canvas"></canvas>';
    document.body.appendChild(newOverlay);
  }
})();

function initScreensaver() {
  if (screensaverInitialized) return true;
  screensaverCanvas = document.getElementById('screensaver-canvas');
  if (!screensaverCanvas) return false;
  screensaverCanvas.style.display = 'block';
  screensaverCanvas.style.width = '100%';
  screensaverCanvas.style.height = '100%';
  screensaverCtx = screensaverCanvas.getContext('2d');
  if (!screensaverCtx) return false;

  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    if (screensaverCanvas.width !== w || screensaverCanvas.height !== h) {
      screensaverCanvas.width = w;
      screensaverCanvas.height = h;
    }
  }
  resize();
  window.addEventListener('resize', resize);

  screensaverInitialized = true;
  return true;
}

function activateScreensaver() {
  if (!initScreensaver()) return;
  const overlay = document.getElementById('screensaver-overlay');
  if (!overlay) return;
  overlay.style.display = 'block';
  screensaverActive = true;
  if (!screensaverLoopId) screensaverLoopId = requestAnimationFrame(drawScreensaver);
}

function exitScreensaver() {
  const overlay = document.getElementById('screensaver-overlay');
  if (overlay) overlay.style.display = 'none';
  screensaverActive = false;
  if (screensaverLoopId) {
    cancelAnimationFrame(screensaverLoopId);
    screensaverLoopId = null;
  }
  if (screensaverCanvas) {
    screensaverCtx.clearRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);
  }
  startTime = 0;
}

// Visual settings
const ORANGE_HEX = '#f7931a';
const ORANGE_RGB = { r: 247, g: 147, b: 26 }; // for rgba usage
const BASE_RADIUS_RATIO = 0.10;
const SLOW_BREATHE_AMPL = 0.02;
const BREATHE_PERIOD = 10.0;
const DRIFT_PERIOD_Y = 20.0;
const DRIFT_AMPL_Y = 0.05;
const DRIFT_PERIOD_X = 26.0;
const DRIFT_AMPL_X = 0.07;

const VISIBLE_INTERVAL = 9.0;
const HIDE_DURATION = 3.5;
const FADE_DURATION = 1.0;

let startTime = 0;

function easeInOutCubic(t) {
  return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function alphaForTime(tSec) {
  const cycleLen = VISIBLE_INTERVAL + FADE_DURATION + HIDE_DURATION + FADE_DURATION;
  const p = tSec % cycleLen;
  if (p < VISIBLE_INTERVAL) return 1;
  let q = p - VISIBLE_INTERVAL;
  if (q < FADE_DURATION) return 1 - easeInOutCubic(q / FADE_DURATION);
  q -= FADE_DURATION;
  if (q < HIDE_DURATION) return 0;
  q -= HIDE_DURATION;
  if (q < FADE_DURATION) return easeInOutCubic(q / FADE_DURATION);
  return 1;
}

function drawScreensaver(timestamp) {
  if (!screensaverActive || !screensaverCtx) {
    screensaverLoopId = null;
    return;
  }
  if (!startTime) startTime = timestamp || performance.now();
  const now = timestamp || performance.now();
  const tSec = (now - startTime) / 1000;

  // Clear
  screensaverCtx.fillStyle = 'black';
  screensaverCtx.fillRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);

  const alpha = alphaForTime(tSec);
  if (alpha <= 0) {
    // Fully clean up during long invisible periods – prevents memory leak
    screensaverCtx.fillStyle = 'black';
    screensaverCtx.fillRect(0, 0, screensaverCanvas.width, screensaverCanvas.height);
    if (screensaverLoopId) {
      cancelAnimationFrame(screensaverLoopId);
      screensaverLoopId = null;
    }
    // Restart the loop only after the hide duration ends
    setTimeout(() => {
      if (screensaverActive) {
        startTime = performance.now(); // reset cycle timer
        screensaverLoopId = requestAnimationFrame(drawScreensaver);
      }
    }, HIDE_DURATION * 1000);
    return;
  }

  const w = screensaverCanvas.width;
  const h = screensaverCanvas.height;
  const minWH = Math.min(w, h);

  const baseRadius = minWH * BASE_RADIUS_RATIO;
  const breathe = 1 + SLOW_BREATHE_AMPL * Math.sin((2 * Math.PI * tSec) / BREATHE_PERIOD);
  const radius = baseRadius * breathe;

  const offsetY = DRIFT_AMPL_Y * h * Math.sin((2 * Math.PI * tSec) / DRIFT_PERIOD_Y);
  const offsetX = DRIFT_AMPL_X * w * Math.sin((2 * Math.PI * tSec) / DRIFT_PERIOD_X + 0.9);

  const cx = w / 2 + offsetX;
  const cy = h / 2 + offsetY;

  // Orange glow (soft, larger than before)
  const glowRadius = radius * 2.8;
  const glowAlpha = 0.22 * alpha;
  const grad = screensaverCtx.createRadialGradient(cx, cy, radius * 0.25, cx, cy, glowRadius);
  grad.addColorStop(0, `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${(glowAlpha).toFixed(3)})`);
  grad.addColorStop(0.45, `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${(glowAlpha * 0.55).toFixed(3)})`);
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  screensaverCtx.fillStyle = grad;
  screensaverCtx.beginPath();
  screensaverCtx.arc(cx, cy, glowRadius, 0, Math.PI * 2);
  screensaverCtx.fill();

  // Main steady circle
  const mainAlpha = 0.75 * alpha;
  screensaverCtx.fillStyle = `rgba(${ORANGE_RGB.r},${ORANGE_RGB.g},${ORANGE_RGB.b},${mainAlpha.toFixed(3)})`;
  screensaverCtx.beginPath();
  screensaverCtx.arc(cx, cy, radius, 0, Math.PI * 2);
  screensaverCtx.fill();

  // White ₿ with soft white halo
  const fontSize = Math.max(12, Math.round(radius * 1.05));
  screensaverCtx.save();
  // white halo using shadow
  screensaverCtx.globalAlpha = alpha;
  screensaverCtx.shadowColor = 'rgba(255,255,255,0.75)';
  screensaverCtx.shadowBlur = Math.max(6, radius * 0.22);
  screensaverCtx.fillStyle = '#ffffff';
  screensaverCtx.font = `${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`;
  screensaverCtx.textAlign = 'center';
  screensaverCtx.textBaseline = 'middle';
  screensaverCtx.fillText('₿', cx, cy + (fontSize * 0.02));
  screensaverCtx.restore();

  screensaverLoopId = requestAnimationFrame(drawScreensaver);
}

/* Input handlers to exit screensaver (kept minimal) */
let screensaverMovementTimeout = null;
let lastMovementTime = 0;
const DEBOUNCE_DELAY = 50;

function handleMovement() {
  const now = Date.now();
  if (!screensaverActive) return;
  if (now - lastMovementTime > DEBOUNCE_DELAY) {
    lastMovementTime = now;
    if (screensaverMovementTimeout) {
      clearTimeout(screensaverMovementTimeout);
      screensaverMovementTimeout = null;
    }
    screensaverMovementTimeout = setTimeout(() => {
      // Make screensaver exit behave like gamepad select button
      const muteButton = document.getElementById('mute');
      if (muteButton.textContent === '☀') { // Screensaver active state
        exitScreensaver();
        musicMuted = false;
        musicManager.mute(false);
        muteButton.textContent = '♪';
        if (!splashActive) {
          musicManager.current = null; // Reset MusicManager state
          musicManager.play(currentTheme);
        }
        localStorage.setItem('musicMuted', 'false');
      } else {
        exitScreensaver();
      }
    }, DEBOUNCE_DELAY * 2);
  }
}

document.addEventListener('pointerdown', function (e) {
  if (e.pointerType === 'mouse' && e.button !== 0) return;
  handleMovement();
}, { passive: true });

document.addEventListener('touchstart', function (e) {
  if (e.touches && e.touches.length > 1) return;
  handleMovement();
}, { passive: true });

document.addEventListener('mousedown', function (e) {
  if (e.button !== 0) return;
  handleMovement();
}, { passive: true });

document.addEventListener('keydown', function (e) {
  if (['a', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Enter'].includes(e.key)) {
    handleMovement();
  }
});
// Prevent battle-log focus from gamepad/shoulder buttons
document.getElementById('battle-events').addEventListener('focus', function() {
    this.blur();
});
    </script>
</body>
</html>
