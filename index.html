<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self' https://noexxibndcooqjquhqzk.supabase.co https://mempool.space; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 10px; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: pan-x pan-y; /* Prevents pinch-to-zoom */
            -webkit-user-select: none; /* Prevents selection */
            -webkit-touch-callout: none; /* Disables iOS callouts */
        }
        /* Existing styles remain unchanged */
        #console { 
            background: #111;
            border: 4px solid #ff8c00;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            max-width: 800px;
            width: 100%;
            box-sizing: border-box;
        }
#whale-log { 
            width: 618px; 
            height: 24px; 
            overflow-y: auto;
            scroll-behavior: smooth; 
            background: #111; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
#battle-log { 
            width: 620px;
            margin-left: 20px; 
            background: transparent; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 16px; 
            border: none; 
            font-size: 16px;
            z-index: 10;
            margin-top: -240px;
        }
#battle-log textarea {
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    resize: none;
    width: 100%;
    height: 200px;
    padding: 0;
    overflow-y: auto;
    scroll-behavior: smooth;
    z-index: 10;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.2s ease;
    transform: translateX(-100%);
    opacity: 0;
    /* Hide scrollbar */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}
#inventory { 
            position: absolute;
            top: 10px;
            right: -24px;
            background: transparent;
            color: var(--text-color, #ff8c00) !important;
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
            border: none;
            padding: 8px;
            z-index: 10;
            font-family: 'VT323', monospace;
            font-size: 20px;
            line-height: 1.5;
            width: 160px;
        }
        #floor-indicator { 
            position: absolute; 
            top: 11px; 
            left: 10px; 
            background: transparent; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 8px; 
            z-index: 10; 
            font-family: 'VT323', monospace;
            font-size: 24px; 
        }
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
            grid-area: t;
            z-index: 40;
            border-radius: 5%;
        }
        #left { 
            grid-area: l;
            z-index: 40;
            border-radius: 5%;
        }
        #right { 
            grid-area: r;
            z-index: 40; 
            border-radius: 5%;
        }
        #down { 
            grid-area: b;
            z-index: 40;
            border-radius: 5%;
        }
        #actions { 
            display: flex; 
            gap: 5px; 
            align-items: center; 
        }
        button { 
            background-color: transparent;
            border: 1px solid #ff8c00;
            color: #ff8c00;
            padding: 8px; 
            border: 0px solid #000; 
            cursor: pointer; 
            font-size: 14px; 
            width: 40px; 
            height: 40px;
            box-sizing: border-box; 
        }
        button:hover {
            background: rgba(224, 123, 0, 0.5);
        }
        #mute {
            padding: 0px;
            border-radius: 25%;
            height: 20px;
            width: 30px;
            background: #fff;
            color: #000;
            margin-right: 50px;
            z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #attack, #potion {
            margin-right: 20px;
            background: #ff8c00;
            color: #fff;
            height: 50px;
            width: 50px; 
            border-radius: 50%;
        }
        #attack:hover, #potion:hover {
            background: #e07b00;
        }
        #start-button {
            position: absolute;
            top: 75%;
            left: 50%;
            width: 120px;
            height: 50px;
            transform: translate(-50%, -50%);
            background: #00e8d8;
            color: #fff;
            border: none;
            padding: 0px 20px;
            font-family: 'VT323', monospace;
            font-size: 42px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 40;
        }
        #start-button:hover {
            background: #00b7ef;
        }
#dpad button:active, #dpad button.pressed {
    background: rgba(224, 123, 0, 0.7); /* Slightly darker than hover */
}

#submit-score, #view-leaderboard, #restart-game {
    background: #ff8c00;
    color: #fff;
    border: none;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 18px;
    cursor: pointer;
    border-radius: 5px;
    width: 120px; /* Keep for view-leaderboard and restart-game */
    height: 40px;
    z-index: 40;
}
#submit-score {
    width: 220px; /* Almost doubled from 120px */
}

#submit-score:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
}

#leaderboard-output {
    position: absolute;
    top: 0px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #ff8c00;
    border: 2px solid #ff8c00;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    width: 640px;
    max-width: 100%;
    text-align: left;
    white-space: pre;
    line-height: 1.2;
    box-sizing: border-box;
    word-break: break-word; /* Handle long text */
}
    
/* Phones (320px–767px) */
@media only screen and (min-width: 320px) and (max-width: 767px) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 9px;
    }
    #whale-hash-ids {
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 9px;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: 8px;
        height: 110px;
        font-size: 10px; /* Match font-size for consistency */
    }
    #inventory {
        width: 100px;
        font-size: 12px;
        line-height: 1.5;
        margin-right: 2px;
    }
    #floor-indicator {
        font-size: 10px;
    }
    button {
        width: 55px;
        height: 55px;
        font-size: 12px;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 40px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: -10px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 0px;
        margin-left: -15px;
        margin-top: 60px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 0px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 0px;
                margin-left: 20px;
        background: #ff8c00;
        height: 35px;
        width: 35px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }
    
    #submit-score, #view-leaderboard, #restart-game {
        width: 80px; /* Keep for view-leaderboard and restart-game */
        height: 30px;
        font-size: 16px;
    }
    #submit-score {
        width: 160px; /* Doubled from 80px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 14px;
}
    #leaderboard-output {
        top: -12px;
        width: 100%;
        max-width: 640px;
        font-size: 12px;
        max-height: 160px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}

/* Tablets (768px–1024px, high pixel ratio) */
@media only screen and (min-width: 768px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
        max-width: 640px;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 1.2rem;
    }
    #whale-hash-ids {
        font-size: 1.2rem;
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 1.2rem;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: -60px;
        height: 146px;
        font-size: 1.2rem;
    }
    #inventory {
        width: 170px;
        font-size: 1.4rem;
        line-height: 1.5;
        margin-right: 20px;
    }
    #floor-indicator {
        font-size: 1.6rem;
    }
    button {
        width: 65px;
        height: 65px;
        font-size: 1.2rem;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 120px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: 20px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 24px;
        width: 24px;
        background: #fff;
        color: #000;
        margin-right: 80px;
        margin-left: -15px;
        margin-top: 45px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 5px;
        background: #ff8c00;
        height: 65px;
        width: 65px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 5px;
        margin-left: 20px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }

    #submit-score, #view-leaderboard, #restart-game {
        width: 100px; /* Keep for view-leaderboard and restart-game */
        height: 48px;
        font-size: 18px;
    }
    #submit-score {
        width: 200px; /* Doubled from 100px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 16px;
}
    #leaderboard-output {
        top: 0px;
        width: 100%;
        max-width: 640px;
        font-size: 14px;
        max-height: 200px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}
    </style>
</head>
<body>
    <div id="console">
        <div id="whale-log">
            <div id="whale-hash-ids">Whale Transactions:</div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
    		<canvas id="splash-canvas" width="320" height="320"></canvas>
    	    <button id="start-button">START</button>
	    </div>
<div id="game-over">
    <pre id="leaderboard-output"></pre>
    <canvas id="game-over-canvas" width="320" height="320"></canvas>
    <div style="position: absolute; top: 60%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px;"> <!-- Increased gap from 10px to 15px -->
        <input id="username-input" type="text" placeholder="Enter Username" maxlength="20" list="name-list" style="background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 8px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; width: 200px;">
<datalist id="name-list"></datalist>
        <button id="submit-score" onclick="submitScore()">Submit Score</button>
        <button id="view-leaderboard" onclick="fetchLeaderboard()">Leaderboard</button>
        <button id="restart-game" onclick="restart()">Restart</button>
    </div>
</div>
            <div id="floor-indicator">Floor 1</div>
<div id="inventory">
    Wave: <span id="wave">0</span><br>
    <br>
    Health: <span id="health">24</span><br>
    Potions: <span id="potions">0</span><br>
    Pickaxes: <span id="pickaxes">0</span><br> <!-- New pickaxe display -->
    Bag: <span id="sats">0</span><br>
</div>
        </div>
<div id="battle-log">
    <textarea id="battle-events" readonly>Battle Log:</textarea>
</div>
        <div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">↑</button>
                <button id="left" onclick="move('left')">←</button>
                <button id="right" onclick="move('right')">→</button>
                <button id="down" onclick="move('down')">↓</button>
            </div>
            <div id="actions">
                <button id="mute" onclick="toggleMute()">♪</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>

const names = [
    "Acrocanthosaurus",
    "Aerith",
    "Agilisaurus",
    "Albertosaurus",
    "Alex",
    "Allosaurus",
    "Alucard",
    "Ankylosaur",
    "Ankylosaurus",
    "Apatosaurus",
    "Argentinosaurus",
    "Attak Trak",
    "Azeroth",
    "Barret",
    "Bashasaurus",
    "Battle Cat",
    "Battle Ram",
    "Beast Man",
    "Birdo",
    "Blade",
    "Blanka",
    "Blaise",
    "Blast-Attak",
    "Bomberman",
    "Bowser",
    "Brachiosaurus",
    "Bronto",
    "Brontosaurus",
    "Brother",
    "Bub",
    "Bubblun",
    "Buzz-Off",
    "Cait Sith",
    "Camptosaurus",
    "Captain Falcon",
    "Carnotaurus",
    "Castle Grayskull",
    "Catra",
    "Cecil",
    "Centrosaurus",
    "Ceratosaurus",
    "Chasmosaurus",
    "Chocobo",
    "Chuck Norris",
    "Chun-Li",
    "Cid",
    "Clawful",
    "Clubtail",
    "Coelophysis",
    "Compsognathus",
    "Corythosaurus",
    "Cringer",
    "Daspletosaurus",
    "Deinonychus",
    "Dhalsim",
    "Diddy Kong",
    "Dig Dug",
    "Dilophosaurus",
    "Diplodocus",
    "Donkey Kong",
    "Dr. Robotnik",
    "Dr. Wily",
    "Dracorex",
    "Dragon Walker",
    "Dragstor",
    "Dromaeosaurus",
    "Dryosaurus",
    "Edmontosaurus",
    "Elasmosaurus",
    "Entrapta",
    "Eoraptor",
    "Eternia",
    "Evil-Lyn",
    "Faker",
    "Father",
    "Fire Mario",
    "Fisto",
    "Fox McCloud",
    "Frogger",
    "Galaga",
    "Gallimimus",
    "Ganon",
    "Gerden",
    "Gorgosaurus",
    "Goomba",
    "Granamyr",
    "Grayskull",
    "Grizzlor",
    "Guile",
    "Gwildor",
    "Hadrosaurus",
    "Hammer Bro",
    "He-Man",
    "Herrerasaurus",
    "Homalocephale",
    "Hordak",
    "Hypsilophodon",
    "Ichthyosaurus",
    "Iguanodon",
    "Impa",
    "Jitsu",
    "Joanna Dark",
    "Kain",
    "Kentrosaurus",
    "King",
    "King Hiss",
    "King K. Rool",
    "King Randor",
    "Kirby",
    "Knuckles",
    "Kobra Khan",
    "Koopa",
    "Kraid",
    "Kratos",
    "Lakitu",
    "Lambeosaurus",
    "Leech",
    "Leptoceratops",
    "Lesothosaurus",
    "Link",
    "Lizard Man",
    "Luigi",
    "M. Bison",
    "Maiasaura",
    "Man-At-Arms",
    "Man-E-Faces",
    "Mario",
    "Marth",
    "Mantenna",
    "Mega Man",
    "Mekaneck",
    "Mer-Man",
    "Meta Knight",
    "Microraptor",
    "Modulok",
    "Mosasaurus",
    "Moss Man",
    "Mother",
    "Ms. Pac-Man",
    "Multi-Bot",
    "Nea",
    "Ness",
    "Night Stalker",
    "Orko",
    "Ornithomimus",
    "Othnielia",
    "Ouranosaurus",
    "Oviraptor",
    "Pac-Man",
    "Pachycephalosaurus",
    "Panthor",
    "Parasaurolophus",
    "Patrich",
    "Peach",
    "Peppy Hare",
    "Plesiosaurus",
    "Point Dread",
    "Ponyo",
    "Prenocephale",
    "Prince Adam",
    "Protoceratops",
    "Proto Man",
    "Psittacosaurus",
    "Pteranodon",
    "Pterodactyl",
    "Q*bert",
    "Queen Marlena",
    "Raccoon Mario",
    "Ram Man",
    "Rambo",
    "Raptor",
    "Rattlor",
    "Red XIII",
    "Revolver Ocelot",
    "Ridley",
    "Road Ripper",
    "Robo",
    "Rocky",
    "Rokkon",
    "Rydia",
    "Ryu",
    "Sagat",
    "Samus",
    "Satoshi Nakamoto",
    "Saurornithoides",
    "Saurod",
    "Scelidosaurus",
    "Scorpia",
    "Screeech",
    "Scutellosaurus",
    "Sephiroth",
    "Shadow Weaver",
    "Simon Belmont",
    "Sinornithoides",
    "Sinornitholestes",
    "Sister",
    "Skeletor",
    "Slippy Toad",
    "Snake Face",
    "Snake Mountain",
    "Solan",
    "Solid Snake",
    "Sonic",
    "Sorceress",
    "Spiketail",
    "Spikor",
    "Spinosaurus",
    "Sssqueeze",
    "Stego",
    "Stegosaurus",
    "Stinkor",
    "Stonedar",
    "Stratos",
    "Stridor",
    "Struthiomimus",
    "Stygimoloch",
    "Suchomimus",
    "Sy-Klone",
    "Tails",
    "Talon Fighter",
    "Tanooki Mario",
    "Teela",
    "Therizinosaurus",
    "Tifa",
    "Tingle",
    "Titanosaur",
    "Toad",
    "Torosaurus",
    "Trap Jaw",
    "Triceratops",
    "Tri-Klops",
    "Troodon",
    "Tsintaosaurus",
    "Tung Lashor",
    "Two Bad",
    "Tyrannosaurus",
    "T-Rex",
    "Tytus",
    "Utahraptor",
    "Vega",
    "Velociraptor",
    "Vincent",
    "Wario",
    "Wart",
    "Webstor",
    "Whiplash",
    "Wind Raider",
    "Yoshi",
    "Yuffie",
    "Zangief",
    "Zelda",
    "Zero",
    "Zoar"
];

function populateNameList() {
    const datalist = document.getElementById('name-list');
    datalist.innerHTML = ''; // Clear existing options
    names.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        datalist.appendChild(option);
    });
}

function levenshtein(a, b) {
    const matrix = Array(b.length + 1).fill().map(() => Array(a.length + 1).fill(0));
    for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
    for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
            matrix[j][i] = Math.min(
                matrix[j-1][i] + 1,
                matrix[j][i-1] + 1,
                matrix[j-1][i-1] + (a[i-1].toLowerCase() === b[j-1].toLowerCase() ? 0 : 1)
            );
        }
    }
    return matrix[b.length][a.length];
}

// Modified submitScore function with nearest name matching and random fallback
async function submitScore() {
    if (!gameOver) return;
    if (scoreSubmitted) {
        document.getElementById('leaderboard-output').textContent = 'Score already submitted for this game!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: already submitted');
        return;
    }
    if (floor < 3) {
        document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: floor=', floor, '< 3');
        return;
    }
    let username = document.getElementById('username-input').value.trim();
    if (!username) {
        // Select random name if input is empty
        username = names[Math.floor(Math.random() * names.length)];
        console.log(`Empty username, selected random name: '${username}'`);
    } else if (!names.includes(username)) {
        // Find the closest matching name (case-insensitive)
        let minDistance = Infinity;
        let closestName = username;
        for (const name of names) {
            const distance = levenshtein(username.toLowerCase(), name.toLowerCase());
            if (distance < minDistance) {
                minDistance = distance;
                closestName = name;
            }
        }
        // Use closest name if distance is small enough (threshold: 3 edits)
        if (minDistance <= 3) {
            console.log(`Username '${username}' matched to '${closestName}' (distance=${minDistance})`);
            username = closestName;
        } else {
            // Select random name if no close match
            username = names[Math.floor(Math.random() * names.length)];
            console.log(`Username '${username}' not matched (distance=${minDistance}), selected random name: '${username}'`);
        }
    }
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ username, score: totalSats, floor })
        });
        const text = await response.text();
        console.log(`POST Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : {};
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok) {
            scoreSubmitted = true;
            document.getElementById('submit-score').disabled = true;
            document.getElementById('submit-score').style.background = '#666';
            document.getElementById('leaderboard-output').textContent = `Score submitted: ${username}, ${totalSats} sats (Floor ${floor})`;
            document.getElementById('leaderboard-output').style.display = 'block';
            await fetchLeaderboard(username, totalSats, floor);
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
            if (response.status === 400 && text.includes('new row violates row-level security policy')) {
                document.getElementById('leaderboard-output').textContent = 'Submission blocked: Must reach at least Floor 3!';
            }
            document.getElementById('leaderboard-output').style.display = 'block';
        }
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

const SUPABASE_URL = 'https://noexxibndcooqjquhqzk.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5vZXh4aWJuZGNvb3FqcXVocXprIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkyNzY3NDgsImV4cCI6MjA2NDg1Mjc0OH0.LvN81angnwKM5IS1lCrr-dUESgeJfvO6VjkC0lMB0y4';
const headers = {
    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
    'apikey': SUPABASE_ANON_KEY,
    'Content-Type': 'application/json',
    'Prefer': 'return=representation'
};

async function fetchLeaderboard(submittedUsername = null, submittedScore = null, submittedFloor = null) {
    try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?select=username,score,floor&order=score.desc&limit=10`, {
            method: 'GET',
            headers
        });
        const text = await response.text();
        console.log(`GET Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : [];
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok && Array.isArray(data)) {
            let playerInTop10 = submittedUsername ? data.some(entry => entry.username === submittedUsername && entry.score === submittedScore && entry.floor === submittedFloor) : false;
            let playerEntry = null;
            let playerRank = null;

            // Fetch player's score and rank if not in top 10 and floor >= 3
            if (submittedUsername && !playerInTop10 && submittedFloor >= 3) {
                try {
                    const playerResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/leaderboard?select=username,score,floor&username=eq.${encodeURIComponent(submittedUsername)}&score=eq.${submittedScore}&floor=eq.${submittedFloor}`,
                        { method: 'GET', headers }
                    );
                    const playerData = await playerResponse.json();
                    if (playerResponse.ok && playerData.length > 0) {
                        playerEntry = playerData[0];
                        const rankResponse = await fetch(
                            `${SUPABASE_URL}/rest/v1/leaderboard?select=score&score=gt.${submittedScore}&order=score.desc`,
                            { method: 'GET', headers }
                        );
                        const rankData = await rankResponse.json();
                        if (rankResponse.ok) {
                            playerRank = rankData.length + 1;
                        }
                    }
                } catch (e) {
                    console.error('Error fetching player score or rank:', e);
                }
            }

            // Format leaderboard
            const maxUsernameLength = 20;
            const scoreWidth = 14; // Increased from 12 to handle large BTC values
            const numberWidth = 10; // Increased from 8 for consistent score padding
            const floorWidth = 6;  // Increased from 5 for better floor alignment
            const header = `Rank  Username                Score         Floor`; // Adjusted spacing
            let rows = data.map((entry, index) => {
                const rank = (index + 1).toString().padStart(2, '0');
                const username = entry.username.length > maxUsernameLength
                    ? entry.username.substring(0, maxUsernameLength - 2) + '..'
                    : entry.username.padEnd(maxUsernameLength);
                const scoreValue = entry.score;
                let numberPart, unitPart;
                if (scoreValue >= 1e8) {
                    numberPart = (scoreValue / 1e8).toFixed(1);
                    unitPart = 'BTC';
                } else {
                    numberPart = scoreValue.toString();
                    unitPart = 'sats';
                }
                const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
                const score = scoreDisplay.padEnd(scoreWidth);
                const floor = entry.floor.toString().padStart(floorWidth);
                return `${rank}    ${username}${score}${floor}`;
            });

            // Replace or append player's entry with actual rank if not in top 10
            if (playerEntry && !playerInTop10 && playerRank) {
                const username = playerEntry.username.length > maxUsernameLength
                    ? playerEntry.username.substring(0, maxUsernameLength - 2) + '..'
                    : playerEntry.username.padEnd(maxUsernameLength);
                const scoreValue = playerEntry.score;
                let numberPart, unitPart;
                if (scoreValue >= 1e8) {
                    numberPart = (scoreValue / 1e8).toFixed(1);
                    unitPart = 'BTC';
                } else {
                    numberPart = scoreValue.toString();
                    unitPart = 'sats';
                }
                const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
                const score = scoreDisplay.padEnd(scoreWidth);
                const floor = playerEntry.floor.toString().padStart(floorWidth);
                const playerRow = `${playerRank.toString().padStart(2, '0')}    ${username}${score}${floor}`;
                if (rows.length >= 10) {
                    rows[9] = playerRow; // Replace 10th entry
                } else {
                    rows.push(playerRow); // Append if fewer than 10 entries
                }
            }

            const leaderboardText = `${header}\n${rows.join('\n') || 'No entries yet!'}`;
            document.getElementById('leaderboard-output').textContent = leaderboardText;
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
        }
        document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        console.error('Fetch leaderboard error:', error);
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

document.getElementById('username-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameOver) {
        e.preventDefault(); // Prevent any default behavior
        submitScore(); // Trigger score submission
    }
});

// Prevent pinch-to-zoom and double-tap zoom
document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Blocked multi-touchstart');
    }
}, { passive: false });
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Blocked multi-touchmove or pinch');
    }
}, { passive: false });
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked gesturestart');
}, { passive: false });
document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked gesturechange');
}, { passive: false });
document.addEventListener('gestureend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked gestureend');
}, { passive: false });
document.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
    console.log('Blocked dblclick');
}, { passive: false });

// Block canvas touch interference
const canvas = document.getElementById('game');
canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Canvas blocked multi-touchstart');
    } else if (!e.target.closest('#dpad, #actions')) {
        e.preventDefault();
        console.log(`Canvas single-touchstart blocked at ${e.touches[0].clientX}, ${e.touches[0].clientY}`);
    }
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
        console.log('Canvas blocked multi-touchmove or pinch');
    }
}, { passive: false });

// Touch handlers for #dpad buttons
document.querySelectorAll('#dpad button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
        console.log(`Touchstart on ${button.id}, relying on onclick`);
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed'); // Remove visual feedback
        console.log(`Touchend on ${button.id}`);
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default click behavior after onclick
        console.log(`Click processed on ${button.id}`);
    }, { passive: false });
});

// Touch handlers for #actions buttons
document.querySelectorAll('#actions button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
        if (button.id === 'mute') toggleMute();
        else if (button.id === 'attack') attack();
        else if (button.id === 'potion') usePotion();
        console.log(`Touchstart triggered on ${button.id}`);
    }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed'); // Remove visual feedback
        console.log(`Touchend on ${button.id}`);
    }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default click behavior
        console.log(`Click processed on ${button.id}`);
    }, { passive: false });
});
        

const c = canvas.getContext('2d');
const W = 20, H = 20, S = 16;
let currentTheme = 'dungeon'; // Default theme
const themes = ['dungeon', 'desert', 'paradise', 'hell'];
let initialWaveSpawned = false; // Track if initial wave has spawned

function selectNewTheme(current) {
    const availableThemes = themes.filter(t => t !== current);
    return availableThemes[Math.floor(Math.random() * availableThemes.length)];
}
        
let map = [], 
    p = {
        x: 2,
        y: 2,
        hp: 24,
        potions: 0,
        atk: 2,
        pickaxes: 0,
        hasArmor: false,
        anim: {
            frames: {
                front: [new Image(), new Image()],
                back: [new Image(), new Image()],
                right: [new Image(), new Image()],
                armor_front: [new Image(), new Image()],
                armor_back: [new Image(), new Image()],
                armor_right: [new Image(), new Image()]
            },
            direction: 'front',
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 200
        }
    }, 
    enemies = [], 
    rooms = [];
// Load animation frames
p.anim.frames.front[0].src = 'player-front1.png';
p.anim.frames.front[1].src = 'player-front2.png';
p.anim.frames.back[0].src = 'player-back1.png';
p.anim.frames.back[1].src = 'player-back2.png';
p.anim.frames.right[0].src = 'player-right1.png';
p.anim.frames.right[1].src = 'player-right2.png';
p.anim.frames.armor_front[0].src = 'player_armor-front1.png';
p.anim.frames.armor_front[1].src = 'player_armor-front2.png';
p.anim.frames.armor_back[0].src = 'player_armor-back1.png';
p.anim.frames.armor_back[1].src = 'player_armor-back2.png';
p.anim.frames.armor_right[0].src = 'player_armor-right1.png';
p.anim.frames.armor_right[1].src = 'player_armor-right2.png';

let floor = 1, wave = 0, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
let scoreSubmitted = false; // Tracks if score has been submitted
let whaleHashIds = ['Whale Transactions:'], battleLog = [], killsLog = [];
let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let satoshiDrops = [];
let lastSpecialTiles = new Set(); // Track special tiles player was near last move
let splashActive = true;
let waveActive = false;
let musicMuted = false;        
let swordDir = 'right', swordActive = false, swordStart = 0;
let gameOverSoundPlayed = false;
let fogMap = [];
let battleLogTimeout = null;
let projectiles = [];
    const types = [
        {
            name: 'Shrimp',
            min: 0,
            max: 0.01,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 2,
            atk: 1,
            reward: 0,
            move: 1
        },
        {
            name: 'Crab',
            min: 0.01,
            max: 0.1,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 3,
            atk: 2,
            reward: 0,
            move: 1
        },
        {
            name: 'Squid',
            min: 0.1,
            max: 1,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 4,
            atk: 2,
            reward: 0,
            move: 2
        },
        {
            name: 'Dolphin',
            min: 1,
            max: 10,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 4,
            atk: 3,
            reward: 0,
            move: 2
        },
        {
            name: 'Shark',
            min: 10,
            max: 100,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 5,
            atk: 5,
            reward: 0,
            move: 2
        },
        {
            name: 'Whale',
            min: 100,
            max: Infinity,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 6,
            atk: 4,
            reward: 0,
            move: 2
        }
    ];
const assets = {
    themes: {
        dungeon: { floor: new Image(), wall: new Image() },
        desert: { floor: new Image(), wall: new Image(), special: new Image() },
        paradise: { floor: new Image(), wall: new Image(), special: new Image() },
        hell: { floor: new Image(), wall: new Image(), special: new Image() }
    },
    potion: new Image(),
    player: new Image(),
    stairs: new Image(),
    bitcoin: new Image(),
    gameOver: new Image(),
    sword: new Image(),
    pickaxe: new Image(),
    armor: new Image(),
    player_armor: new Image(),
    pickaxe_sword: new Image(),
    shoot_sword: new Image(),
    gnome: new Image()
};
        types[0].anim.frames[0].src = 'shrimp_1.png';
	types[0].anim.frames[1].src = 'shrimp_2.png';
	types[0].anim.frames[2].src = 'shrimp_3.png';
    	types[1].anim.frames[0].src = 'crab_1.png';
    	types[1].anim.frames[1].src = 'crab_2.png';
    	types[1].anim.frames[2].src = 'crab_3.png';
    	types[2].anim.frames[0].src = 'squid_1.png';
    	types[2].anim.frames[1].src = 'squid_2.png';
    	types[2].anim.frames[2].src = 'squid_3.png';
    	types[3].anim.frames[0].src = 'dolphin_1.png';
    	types[3].anim.frames[1].src = 'dolphin_2.png';
    	types[3].anim.frames[2].src = 'dolphin_3.png';
    	types[4].anim.frames[0].src = 'shark_1.png';
    	types[4].anim.frames[1].src = 'shark_2.png';
    	types[4].anim.frames[2].src = 'shark_3.png';
    	types[5].anim.frames[0].src = 'whale_1.png';
    	types[5].anim.frames[1].src = 'whale_2.png';
    	types[5].anim.frames[2].src = 'whale_3.png';

    Object.values(assets).forEach(asset => {
        if (asset instanceof Image) {
            asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
        } else if (typeof asset === 'object') {
            Object.values(asset).forEach(subAsset => {
                subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
            });
        }
    });
    types.forEach(t => {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    });
        assets.themes.dungeon.floor.src = 'floor.png';
        assets.themes.dungeon.wall.src = 'wall.png';
        assets.themes.desert.floor.src = 'sand_floor.png';
        assets.themes.desert.wall.src = 'sand_wall.png';
        assets.themes.desert.special.src = 'quicksand.png';
        assets.themes.paradise.floor.src = 'paradise_floor.png';
        assets.themes.paradise.wall.src = 'paradise_wall.png';
        assets.themes.paradise.special.src = 'pond.png';
        assets.themes.hell.floor.src = 'hell_floor.png';
        assets.themes.hell.wall.src = 'hell_wall.png';
        assets.themes.hell.special.src = 'lava.png';
        assets.potion.src = 'potion.png';
        assets.gnome.src = 'gnome.png';
	assets.player.src = 'player.png';
	assets.pickaxe.src = 'pickaxe.png';
	assets.armor.src = 'armor.png';
	assets.player_armor.src = 'player_armor.png';
        assets.stairs.src = 'stairs.png'; 
        assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png'; assets.sword.src = 'sword.png';
        assets.pickaxe_sword.src = 'pickaxe-sword.png';
        assets.shoot_sword.src = 'shoot_sword.png';
Object.values(assets).forEach(asset => {
    if (asset instanceof Image) {
        asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
    } else if (typeof asset === 'object') {
        Object.values(asset).forEach(subAsset => {
            subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
        });
    }
});
types.forEach(t => {
    if (t.img) {
        t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`);
    } else if (t.anim) {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});

const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();
const sounds = {
    attack: new Audio('attack.wav'),
    potion: new Audio('potion.wav'),
    hit: { buffer: null, url: 'hit.wav', isPlaying: false, duration: 720 },
    pickup: { buffer: null, url: 'pickup.wav', isPlaying: false, duration: 950 },
    music: new Audio('music.mp3'),
    gameover: new Audio('gameover.wav'),
    stairs: new Audio('stairs.wav'),
    secret: new Audio('secret.wav'),
    shoot_sword: new Audio('shoot_sword.wav'),
    heads: { buffer: null, url: 'heads.wav', isPlaying: false, duration: 1000 },
    tails: { buffer: null, url: 'tails.wav', isPlaying: false, duration: 1000 },
    lava: { buffer: null, url: 'lava.wav', isPlaying: false, duration: 1000 },
    quicksand: { buffer: null, url: 'quicksand.wav', isPlaying: false, duration: 1000 },
    pond: { buffer: null, url: 'pond.wav', isPlaying: false, duration: 1000 }
};

sounds.music.loop = true;

// Load Web Audio buffers
function loadSoundBuffer(url, key) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(data => audioContext.decodeAudioData(data))
        .then(buffer => {
            sounds[key].buffer = buffer;
            console.log(`Loaded Web Audio buffer for ${key}: ${url}`);
        })
        .catch(e => console.error(`Failed to load Web Audio buffer for ${key}: ${url}`, e));
}
loadSoundBuffer('hit.wav', 'hit');
loadSoundBuffer('pickup.wav', 'pickup');
loadSoundBuffer('heads.wav', 'heads');
loadSoundBuffer('tails.wav', 'tails');
loadSoundBuffer('lava.wav', 'lava');
loadSoundBuffer('quicksand.wav', 'quicksand');
loadSoundBuffer('pond.wav', 'pond');

Object.values(sounds).forEach(s => {
    if (s instanceof Audio) {
        s.volume = 1.0;
        s.onerror = () => console.error(`Failed to load sound: ${s.src}`);
    }
});

function preloadSounds() {
    Object.entries(sounds).forEach(([key, sound]) => {
        if (key === 'music' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond') return;
        if (Array.isArray(sound)) {
            sound.forEach((instance, idx) => {
                instance.volume = 0;
                instance.play().then(() => {
                    instance.pause();
                    instance.currentTime = 0;
                    instance.volume = 1.0;
                    console.log(`Preloaded sound instance ${idx}: ${instance.src}, volume=${instance.volume}`);
                }).catch(e => console.error(`Preload sound error for ${instance.src} instance ${idx}:`, e));
            });
        } else {
            sound.volume = 0;
            sound.play().then(() => {
                sound.pause();
                sound.currentTime = 0;
                sound.volume = 1.0;
                console.log(`Preloaded sound: ${sound.src}, volume=${sound.volume}`);
            }).catch(e => console.error(`Preload sound error for ${sound.src}:`, e));
        }
    });
}

function playWebAudioSound(soundObj) {
    if (!soundObj.buffer) {
        console.warn(`Buffer not loaded for ${soundObj.url}`);
        return;
    }
    if (soundObj.isPlaying) {
        console.log(`Skipping playback of ${soundObj.url}: already playing`);
        return;
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            console.log('AudioContext resumed');
        }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    soundObj.isPlaying = true; // Set flag
    const source = audioContext.createBufferSource();
    source.buffer = soundObj.buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 1.0; // Max volume
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
    console.log(`Playing Web Audio sound: ${soundObj.url}, volume=${gainNode.gain.value}`);
    source.onended = () => {
        soundObj.isPlaying = false; // Clear flag
        console.log(`Web Audio sound ended: ${soundObj.url}`);
    };
    // Fallback timeout to clear flag if onended fails
    setTimeout(() => {
        if (soundObj.isPlaying) {
            soundObj.isPlaying = false;
            console.log(`Cleared isPlaying flag for ${soundObj.url} via timeout`);
        }
    }, soundObj.duration);
}

const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
const splashImg = new Image();
splashImg.src = 'splash.png';
splashImg.onload = () => {
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    console.log('Splash started: active=', splashActive, 'bg=#F7931A');
};

function fadeSplash() {
    setTimeout(() => {
        const imgData = splashCanvas.getImageData(0, 0, 320, 320);
        const pixels = imgData.data;
        const totalPixels = 320 * 320;
        const fadePerFrame = totalPixels / 20;
        let fadedPixels = 0;
        const fadeInterval = setInterval(() => {
            for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                const px = Math.floor(Math.random() * totalPixels) * 4;
                pixels[px + 3] = 0;
                fadedPixels++;
            }
            splashCanvas.putImageData(imgData, 0, 0);
            if (fadedPixels >= totalPixels) {
                clearInterval(fadeInterval);
                splashActive = false;
                document.getElementById('splash-screen').style.display = 'none'; // Hide instead of remove
                console.log('Splash ended: active=', splashActive);
            }
        }, 75);
    }, 25);
}

function resetSplashScreen() {
    splashActive = true;
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block'; // Show splash screen
    // Redraw splash image
    splashCanvas.clearRect(0, 0, 320, 320);
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    console.log('Splash screen reset: active=', splashActive);
}

document.getElementById('start-button').addEventListener('click', () => {
    if (splashActive) {
        console.log('START button clicked: splashActive=', splashActive, 'musicMuted=', musicMuted, 'wave=', wave);
        preloadSounds();
        // Preload player animation frames
        const imagesToLoad = [
            p.anim.frames.front[0], p.anim.frames.front[1],
            p.anim.frames.back[0], p.anim.frames.back[1],
            p.anim.frames.right[0], p.anim.frames.right[1],
            p.anim.frames.armor_front[0], p.anim.frames.armor_front[1],
            p.anim.frames.armor_back[0], p.anim.frames.armor_back[1],
            p.anim.frames.armor_right[0], p.anim.frames.armor_right[1]
        ];
        let loadedCount = 0;
        imagesToLoad.forEach(img => {
            if (img.complete) {
                loadedCount++;
                if (loadedCount === imagesToLoad.length) {
                    console.log('All player animation frames loaded');
                }
            } else {
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === imagesToLoad.length) {
                        console.log('All player animation frames loaded');
                    }
                };
                img.onerror = () => console.error(`Failed to load image: ${img.src}`);
            }
        });
        if (!musicMuted) {
            sounds.music.pause();
            sounds.music.currentTime = 0;
            sounds.music.play().then(() => {
                console.log('Music started successfully');
            }).catch(e => console.error('Music play failed on START:', e));
        }
        fadeSplash();
        setTimeout(() => {
            if (!gameOver && !splashActive) {
                fetchTxs();
                lastUpdate = Date.now();
                console.log('Initial fetchTxs triggered after splash, wave=', wave);
            }
        }, 2000);
    }
});

function toggleMute() {
    musicMuted = !musicMuted;
    sounds.music.muted = musicMuted;
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪';
    if (!musicMuted && !splashActive) {
        sounds.music.currentTime = 0; // Start from beginning
        sounds.music.play().catch(e => console.error('Music play failed on unmute:', e));
    }
}

        function logWhaleHashId(txid) {
            whaleHashIds.push(`Floor ${floor} - <a href="https://www.blockchain.com/explorer/transactions/btc/${txid}" target="_blank">${txid}</a>`);
            document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
            const whaleLog = document.getElementById('whale-log');
            whaleLog.scrollTop = whaleLog.scrollHeight;
            console.log('Whale Hash ID:', txid);
        }

function logBattleEvent(event) {
    if (gameOver) return;
    const battleEvents = document.getElementById('battle-events');
    // Handle kills display (static, no fading)
    if (event.startsWith('Kills:') || event.match(/^(Shrimp|Crab|Squid|Dolphin|Shark|Whale):/) || event === '') {
        // Clear killsLog if starting a new kills block
        if (event === 'Kills:') {
            killsLog = [event];
        } else {
            killsLog.push(event);
        }
        if (exit && enemies.length === 0) {
            // Show exactly 8 kills lines
            battleEvents.value = killsLog.join('\n');
            battleEvents.scrollTop = battleEvents.scrollHeight;
            // Keep visible without fade-out
            battleEvents.style.transform = 'translateX(0)';
            battleEvents.style.opacity = '1';
            if (battleLogTimeout) {
                clearTimeout(battleLogTimeout);
                battleLogTimeout = null;
            }
            console.log('Kills display updated: persistent, lines=', killsLog.length, killsLog);
            return;
        }
    }
    // Keep last 3 messages for regular events (reverse waterfall)
    battleLog.push(event);
    battleLog = battleLog.slice(-3); // Keep last 3 events
    battleEvents.value = battleLog.join('\n');
    battleEvents.scrollTop = battleEvents.scrollHeight;
    // Clear any existing timeout
    if (battleLogTimeout) {
        clearTimeout(battleLogTimeout);
    }
    // Slide in and fade in
    battleEvents.style.transform = 'translateX(0)';
    battleEvents.style.opacity = '1';
    // Schedule slide out after 3 seconds for non-kills events
    battleLogTimeout = setTimeout(() => {
        battleEvents.style.transform = 'translateX(-100%)';
        battleEvents.style.opacity = '0';
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(battleEvents);
            if (computedStyle.opacity === '0') {
                battleLog = [];
                battleEvents.value = '';
                console.log('Battle log cleared after fade-out');
                // Restore kills display if still valid
                if (exit && enemies.length === 0) {
                    killsLog = [
                        'Kills:',
                        `Shrimp: ${kills.Shrimp}`,
                        `Crab: ${kills.Crab}`,
                        `Squid: ${kills.Squid}`,
                        `Dolphin: ${kills.Dolphin}`,
                        `Shark: ${kills.Shark}`,
                        `Whale: ${kills.Whale}`,
                        '' // Empty line for 8 lines total
                    ];
                    battleEvents.value = killsLog.join('\n');
                    battleEvents.style.transform = 'translateX(0)';
                    battleEvents.style.opacity = '1';
                    battleEvents.scrollTop = battleEvents.scrollHeight;
                    console.log('Kills display restored after fade-out, lines=', killsLog.length, killsLog);
                }
            }
        }, 300); // Wait for transition (0.3s)
        battleLogTimeout = null;
    }, 3000);
}

function updateSatsDisplay() {
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    document.getElementById('sats').textContent = totalSats < 1e8 ? `${totalSats} sats` : `${(totalSats / 1e8).toFixed(1)} BTC`;
    // Trigger kills display only when exit exists and no enemies remain
    if (exit && enemies.length === 0) {
        logBattleEvent(`Kills:`);
        for (const type of types) {
            if (kills[type.name] > 0) {
                logBattleEvent(`${type.name}: ${kills[type.name]}`);
            }
        }
    }
}

function spawnItemWithChance(item, chance, maxItems, proximityRange, avoidPlayer) {
    let positions = [];
    let attempts = 0;
    const maxAttempts = 100;

    while (positions.length < maxItems && attempts < maxAttempts) {
        if (Math.random() < chance) {
            let x = Math.floor(Math.random() * W);
            let y = Math.floor(Math.random() * H);
            let valid = map[y][x] === 0;

            if (avoidPlayer) {
                valid = valid && Math.abs(x - p.x) >= 3 && Math.abs(y - p.y) >= 3; // Ensure 5x5 clear area
            }

            if (valid) {
                let isNearOtherItem = false;
                for (let pos of positions) {
                    if (Math.abs(x - pos[0]) <= 2 && Math.abs(y - pos[1]) <= 2) {
                        isNearOtherItem = true;
                        break;
                    }
                }
                if (!isNearOtherItem) {
                    positions.push([x, y]);
                    if (item !== -1) {
                        map[y][x] = item;
                    }
                }
            }
        }
        attempts++;
    }

    return positions;
}

function initMap() {
    try {
        // Change theme every fourth floor
        if (floor % 4 === 0 && floor > 1) {
            currentTheme = selectNewTheme(currentTheme);
            console.log(`Floor ${floor} - Changed theme to ${currentTheme}`);
        }
        // Update text color based on theme
        let textColor;
        switch (currentTheme) {
            case 'hell':
                textColor = '#00ff00'; // Matrix green for hell
                break;
            case 'desert':
            case 'paradise':
                textColor = '#ff8c00'; // Orange for desert and paradise
                break;
            default:
                textColor = '#ff8c00'; // Orange for dungeon
        }
        document.documentElement.style.setProperty('--text-color', textColor);
        // Force re-render of text color
        document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator').forEach(el => {
            el.style.color = textColor;
        });
        // Reset enemy spawning variables
        enemies = [];
        enemiesSpawnedThisFloor = 0;
        initialSpawnDoneThisFloor = false;
        initialWaveSpawned = false;
        map = Array(H).fill().map(() => Array(W).fill(1));
        fogMap = Array(H).fill().map(() => Array(W).fill(0));
        rooms = [];
        satoshiDrops = [];
        lastSpecialTiles = new Set(); // Reset on map change
        
        // Generate rooms (existing code unchanged)
        let maxAttempts = 100;
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        maxAttempts = 50;
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap();
        }
        
        // Connect rooms with corridors (existing code unchanged)
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r1.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }
        
        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;
        
        // Place player
        p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
        if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) { p.x = x; p.y = y; break; }
        }
        
        // Mark initial player area as explored
        updateFogMap(p.x, p.y);
        
        // Place special tiles based on theme (pond, quicksand, lava)
        let specialPositions = [];
        if (currentTheme !== 'dungeon') {
            specialPositions = spawnItemWithChance(6, 0.5, 2, 5, true); // 50% chance, max 2 tiles
            console.log(`Special tiles (${currentTheme}) placed:`, specialPositions);
        }

// Place gnome with X% chance, only if no conflict with special tiles
let gnomePositions = [];
console.log('Attempting gnome spawn: theme=', currentTheme, 'specialPositions=', specialPositions.length);
if (
    currentTheme === 'dungeon' || 
    currentTheme === 'desert' || 
    currentTheme === 'hell' || 
    currentTheme === 'paradise' || 
    specialPositions.length < 2
) {
    if (Math.random() < 0.1) { // 10% chance to spawn a gnome
        gnomePositions = spawnItemWithChance(7, 1.0, 1, 5, true);
        if (gnomePositions.length > 0) {
            console.log(`Gnome placed at:`, gnomePositions);
        } else {
            console.log('Gnome spawn failed: no valid positions found');
        }
    } else {
        console.log('Gnome spawn skipped: failed 10% chance check');
    }
} else {
    console.log(`Gnome skipped to prioritize ${currentTheme} special tiles`);
}

        // Place potions (existing code)
        let potionPositions = [];
        let selectedRooms = rooms.sort(() => 0.5 - Math.random()).slice(0, Math.min(3, rooms.length));
        let proximityRange = 5;
        for (let r of selectedRooms) {
            let x, y, attempts = 100;
            while (attempts > 0 && potionPositions.length < 3) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);
                if (map[y][x] === 0 && (x !== p.x || y !== p.y) && !potionPositions.some(p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange)) {
                    map[y][x] = 2;
                    potionPositions.push({x, y});
                    if (potionPositions.length === 3) break;
                }
                attempts--;
            }
            if (attempts === 0 && potionPositions.length < 3) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;
                continue;
            }
        }

        // Place pickaxe (chance to drop a pickaxe)
        let pickaxePositions = [];
        if (Math.random() < 0.2) { // 20% chance to spawn a pickaxe
        pickaxePositions = spawnItemWithChance(4, 1.0, 1, 5, true);
        if (pickaxePositions.length > 0) {
            console.log(`Pickaxe placed at:`, pickaxePositions);
        } else {
            console.log('Pickaxe spawn failed: no valid positions found');
        }
        }    
        
        console.log('Rooms generated:', rooms.length, 'Potions placed:', potionPositions, 'Pickaxes placed:', pickaxePositions);
        exit = null;
        initialWaveSpawned = false;
        needsRedraw = true;
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

function createSecretRoom(wx, wy, px, py, dir) {
    // Create a 3x3 room based on player's facing direction
    const roomSize = 3;
    let rx, ry;
    // Position room based on direction
    switch (dir) {
        case 'up':
            rx = wx;
            ry = wy - roomSize;
            break;
        case 'down':
            rx = wx;
            ry = wy + 1;
            break;
        case 'left':
            rx = wx - roomSize;
            ry = wy;
            break;
        case 'right':
            rx = wx + 1;
            ry = wy;
            break;
        default:
            console.error(`Invalid direction: ${dir}`);
            p.pickaxes++;
            logBattleEvent(`Floor ${floor} - Secret Room Failed: Invalid direction`);
            return;
    }
    // Check if room fits within map bounds
    if (rx < 1 || rx + roomSize > W - 1 || ry < 1 || ry + roomSize > H - 1) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): out of bounds`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Check if the 3x3 area is all walls
    let allWalls = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (map[y][x] !== 1) {
                allWalls = false;
                break;
            }
        }
        if (!allWalls) break;
    }
    if (!allWalls) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): not a 3x3 wall block`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No 3x3 wall block for secret room! Pickaxe refunded`);
        return;
    }
    // Validate room placement
    let valid = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (
                [2, 3, 4, 5].includes(map[y][x]) || // Items
                (x === px && y === py) || // Player
                enemies.some(e => e.x === x && e.y === y) // Enemies
            ) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
    }
    // Allow overlap with one room (e.g., corridor)
    let overlapCount = 0;
    rooms.forEach(r => {
        if (!(rx >= r.x + r.w || rx + roomSize <= r.x || ry >= r.y + r.h || ry + roomSize <= r.y)) {
            overlapCount++;
        }
    });
    if (overlapCount > 1) valid = false;
    if (!valid) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): invalid placement (items, player, or overlap)`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Carve out the room
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            map[y][x] = 0;
        }
    }
    // Clear the broken wall
    map[wy][wx] = 0;
    // Punch a non-directional hole (clear one adjacent tile)
    const adjacent = [
        { x: wx - 1, y: wy }, // Left
        { x: wx + 1, y: wy }, // Right
        { x: wx, y: wy - 1 }, // Up
        { x: wx, y: wy + 1 }  // Down
    ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] !== 0);
    if (adjacent.length > 0) {
        const hole = adjacent[Math.floor(Math.random() * adjacent.length)];
        map[hole.y][hole.x] = 0;
        console.log(`Punched hole at (${hole.x}, ${hole.y}) for access`);
    }
    // Carve a corridor to a nearby floor tile
    let floorTiles = [];
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 0 && !(x === px && y === py) && !(x === wx && y === wy)) {
                floorTiles.push({ x, y });
            }
        }
    }
    if (floorTiles.length > 0) {
        floorTiles.sort((a, b) => {
            const distA = Math.abs(a.x - wx) + Math.abs(a.y - wy);
            const distB = Math.abs(b.x - wx) + Math.abs(b.y - wy);
            return distA - distB;
        });
        const target = floorTiles[0];
        let x = wx, y = wy;
        while (x !== target.x || y !== target.y) {
            if (Math.abs(target.x - x) > Math.abs(target.y - y)) {
                x += target.x > x ? 1 : -1;
            } else {
                y += target.y > y ? 1 : -1;
            }
            if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 0) {
                map[y][x] = 0;
            }
        }
        console.log(`Carved corridor from (${wx}, ${wy}) to (${target.x}, ${target.y})`);
    } else {
        console.warn(`No floor tile found to connect secret room at (${wx}, ${wy})`);
    }
    // Place armor in the center
    const armorX = rx + 1;
    const armorY = ry + 1;
    map[armorY][armorX] = 5;
    rooms.push({ x: rx, y: ry, w: roomSize, h: roomSize });
    // Show "Found Secret!" in Whale alert area and log success
    const floorIndicator = document.getElementById('floor-indicator');
    floorIndicator.textContent = `Found Secret!`;
    logBattleEvent(`Floor ${floor} - Secret Room Created!`);
    setTimeout(() => {
        floorIndicator.textContent = `Floor ${floor}`;
    }, 5000);
    updateFogMap(px, py);
    console.log(`Secret room (3x3) created at (${rx}, ${ry}), armor at (${armorX}, ${armorY}), entry at (${wx}, ${wy}), dir=${dir}`);
    needsRedraw = true;
}

function updatePlayerState() {
    if (p.hp <= 24 && p.hasArmor) {
        p.hasArmor = false;
        logBattleEvent(`Floor ${floor} - Armor boost lost!`);
        console.log(`Armor boost lost: p.hp=${p.hp}, p.hasArmor=${p.hasArmor}`);
    }
    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = true;
}

function updateFogMap(px, py) {
    const radius = 4; // Visibility radius
    const currentRoom = rooms.find(r => px >= r.x && px < r.x + r.w && py >= r.y && py < r.y + r.h);

    // Enhanced Bresenham's line algorithm with corner checking
    function hasLineOfSight(x0, y0, x1, y1) {
        let x = x0, y = y0;
        const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
            // Check current tile and adjacent tiles to block diagonal slips
            if (x >= 0 && x < W && y >= 0 && y < H) {
                if (map[y][x] === 1) return false; // Hit a wall
                // Check adjacent tiles to prevent corner penetration
                if (dx === dy) { // 45-degree line, check orthogonally adjacent tiles
                    if (sx === 1 && sy === 1) { // Moving SE
                        if (y - 1 >= 0 && map[y - 1][x] === 1) return false; // Wall above
                        if (x - 1 >= 0 && map[y][x - 1] === 1) return false; // Wall left
                    } else if (sx === 1 && sy === -1) { // Moving NE
                        if (y + 1 < H && map[y + 1][x] === 1) return false; // Wall below
                        if (x - 1 >= 0 && map[y][x - 1] === 1) return false; // Wall left
                    } else if (sx === -1 && sy === 1) { // Moving SW
                        if (y - 1 >= 0 && map[y - 1][x] === 1) return false; // Wall above
                        if (x + 1 < W && map[y][x + 1] === 1) return false; // Wall right
                    } else if (sx === -1 && sy === -1) { // Moving NW
                        if (y + 1 < H && map[y + 1][x] === 1) return false; // Wall below
                        if (x + 1 < W && map[y][x + 1] === 1) return false; // Wall right
                    }
                }
            } else {
                return false; // Out of bounds
            }
            if (x === x1 && y === y1) return true; // Reached target
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x += sx; }
            if (e2 < dx) { err += dx; y += sy; }
        }
    }

    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (dist <= radius) {
                // Check if tile is in the same room or has line-of-sight
                const tileRoom = rooms.find(r => x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h);
                const inSameRoom = currentRoom && tileRoom && currentRoom === tileRoom;
                const hasLOS = hasLineOfSight(px, py, x, y);
                if (inSameRoom || hasLOS) {
                    fogMap[y][x] = 1; // Mark as explored
                }
            }
        }
    }
}

let enemiesSpawnedThisFloor = 0;
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 20000; // 20 seconds

async function fetchTxs() {
    if (gameOver || splashActive || floor === 0) {
        console.log(`Skipping fetchTxs: gameOver=${gameOver}, splashActive=${splashActive}, floor=${floor}`);
        return;
    }
    const now = Date.now();
    if (nextApiCallTime && now < nextApiCallTime) {
        console.log(`Skipping API call, next call in ${(nextApiCallTime - now) / 1000} seconds`);
        return;
    }
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }
    try {
        console.log(`fetchTxs: floor=${floor}, wave=${wave}, enemiesSpawnedThisFloor=${enemiesSpawnedThisFloor}, initialSpawnDoneThisFloor=${initialSpawnDoneThisFloor}, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}, enemies=${enemies.length}`);
        if (initialSpawnDoneThisFloor) {
            console.log(`Initial spawn done for floor ${floor}, checking for Whales`);
        } else {
            console.log(`Spawning enemies for floor ${floor}, ${enemiesSpawnedThisFloor}/10 spawned`);
        }
        await new Promise(resolve => setTimeout(resolve, 25));
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        console.log('Mempool response:', res.data);
        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }
        let enemyCount = 0;
        const processedTxids = new Set();
        console.warn(`[WHALE ATTEMPT] Checking ${res.data.length} transactions for Whale spawns (> 100 BTC)`);
        for (const tx of res.data.slice(0, 10)) {
            if (processedTxids.has(tx.txid)) continue;
            processedTxids.add(tx.txid);
            let value = 0;
            let address = 'Invalid address';
            try {
                await new Promise(resolve => setTimeout(resolve, 25));
                const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
                if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                    value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                    address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
                } else {
                    console.log(`Invalid tx data from api/tx/${tx.txid}:`, txRes.data);
                    continue;
                }
            } catch (e) {
                console.log(`Skipping tx ${tx.txid} due to fetch error:`, e.message);
                continue;
            }
            if (value <= 0) {
                console.log(`Skipping tx ${tx.txid}: Zero/negative value`, value);
                continue;
            }
            const btc = value / 1e8;
            const type = types.find(t => btc > t.min && btc <= t.max);
            console.log(`Tx ${tx.txid}: BTC=${btc.toFixed(8)}, Type=${type ? type.name : 'None'}, Value=${value}`);
            if (!type) {
                console.log(`No type for BTC: ${btc}, Tx: ${tx.txid}`);
                continue;
            }

            // Handle initial spawn (up to 10 enemies, including Whales)
            if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10 && enemies.length < 10) {
                if (type.name !== 'Whale' && exit) {
                    console.log(`Exit exists at (${exit.x}, ${exit.y}), skipping non-Whale spawn for tx ${tx.txid}`);
                    continue;
                }
                console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`);
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y, attempts = 50;
                const auraRadius = 2; // 5x5 grid
                let validPosition = false;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                    validPosition = (
                        map[y][x] === 0 &&
                        !(x === p.x && y === p.y) &&
                        !enemies.some(e => e.x === x && e.y === y) &&
                        Math.abs(x - p.x) > auraRadius &&
                        Math.abs(y - p.y) > auraRadius
                    );
                    attempts--;
                } while (attempts > 0 && !validPosition);
                const newEnemy = { x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) };
                if (!validPosition) {
                    // Fallback: try any floor tile in any room
                    for (let r of rooms) {
                        for (let y = r.y; y < r.y + r.h; y++) {
                            for (let x = r.x; x < r.x + r.w; x++) {
                                if (
                                    map[y][x] === 0 &&
                                    !(x === p.x && y === p.y) &&
                                    Math.abs(x - p.x) > auraRadius &&
                                    Math.abs(y - p.y) > auraRadius &&
                                    !enemies.some(e => e.x === x && e.y === y)
                                ) {
                                    newEnemy.x = x;
                                    newEnemy.y = y;
                                    validPosition = true;
                                    break;
                                }
                            }
                            if (validPosition) break;
                        }
                        if (validPosition) break;
                    }
                }
                if (!validPosition) {
                    console.log(`No valid spawn position found for tx ${tx.txid}, skipping`);
                    continue;
                }
                enemies.push(newEnemy);
                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
                enemiesSpawnedThisFloor++;
                enemyCount++;
                if (type.name === 'Whale') {
                    console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                    logWhaleHashId(tx.txid);
                    document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                    setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
                }
                if (enemiesSpawnedThisFloor >= 10) {
                    initialSpawnDoneThisFloor = true;
                }
            } else if (type.name === 'Whale') {
                console.log(`[WHALE SPAWN ATTEMPT] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}`);
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y, attempts = 50;
                const auraRadius = 2; // 5x5 grid
                let validPosition = false;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                    validPosition = (
                        map[y][x] === 0 &&
                        !(x === p.x && y === p.y) &&
                        !enemies.some(e => e.x === x && e.y === y) &&
                        Math.abs(x - p.x) > auraRadius &&
                        Math.abs(y - p.y) > auraRadius
                    );
                    attempts--;
                } while (attempts > 0 && !validPosition);
                if (!validPosition) {
                    // Fallback: try any floor tile in any room
                    for (let r of rooms) {
                        for (let y = r.y; y < r.y + r.h; y++) {
                            for (let x = r.x; x < r.x + r.w; x++) {
                                if (
                                    map[y][x] === 0 &&
                                    !(x === p.x && y === p.y) &&
                                    Math.abs(x - p.x) > auraRadius &&
                                    Math.abs(y - p.y) > auraRadius &&
                                    !enemies.some(e => e.x === x && e.y === y)
                                ) {
                                    x = x;
                                    y = y;
                                    validPosition = true;
                                    break;
                                }
                            }
                            if (validPosition) break;
                        }
                        if (validPosition) break;
                    }
                }
                if (!validPosition) {
                    console.log(`No valid spawn position found for Whale tx ${tx.txid}, skipping`);
                    continue;
                }
                const newEnemy = { x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) };
                enemies.push(newEnemy);
                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
                console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                logWhaleHashId(tx.txid);
                document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
                enemyCount++;
            }
        }
        if (enemiesSpawnedThisFloor > 0 && enemiesSpawnedThisFloor < 10 && !initialSpawnDoneThisFloor) {
            console.warn(`Only spawned ${enemiesSpawnedThisFloor} enemies due to insufficient valid blockchain data`);
        }
        if (enemyCount > 0 && enemies.length > 0 && !exit) {
            if (!waveActive) {
                wave++;
                initialWaveSpawned = true;
                waveActive = true;
                document.getElementById('wave').textContent = wave;
                logBattleEvent(`Floor ${floor} - Wave ${wave} Started!`);
                console.log(`New wave started: wave=${wave}, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
            } else {
                console.log(`Additional enemies added to wave ${wave}, enemies=${enemies.length}, waveActive=${waveActive}`);
            }
            needsRedraw = true;
        } else {
            console.log(`No enemies spawned, wave=${wave}, scheduling retry in ${API_INTERVAL / 1000}s`);
        }
    } catch (e) {
        console.error('fetchTxs Error:', e, e.stack);
    } finally {
        nextApiCallTime = now + API_INTERVAL;
        apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    }
}

function move(dir) {
    if (gameOver || splashActive) return;
    swordDir = dir;
    let nx = p.x, ny = p.y;
    let newDirection = p.anim.direction; // Default to current direction
    if (dir === 'up') {
        ny--;
        newDirection = 'back';
    }
    if (dir === 'down') {
        ny++;
        newDirection = 'front';
    }
    if (dir === 'left') {
        nx--;
        newDirection = 'left';
    }
    if (dir === 'right') {
        nx++;
        newDirection = 'right';
    }
    // Update direction even if move is blocked
    p.anim.direction = newDirection;
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        return;
    }
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        p.x = nx;
        p.y = ny;
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2; // Cycle frames
        p.anim.lastFrameTime = performance.now(); // Update frame time
        if (map[ny][nx] === 2) { 
            p.potions++; 
            map[ny][nx] = 0; 
            playWebAudioSound(sounds.pickup);
        }
        if (map[ny][nx] === 6) {
            if (currentTheme === 'paradise') {
                if (p.hp <= 36) {
                    const oldHP = p.hp;
                    p.hp = 24 + (p.hasArmor ? 12 : 0); // Full health (24 or 36 with armor)
                    logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
                    playWebAudioSound(sounds.pickup);
                }
                // If p.hp > 36, do nothing and continue
            } else if (currentTheme === 'desert') {
                p.hp = Math.max(0, p.hp - 2);
                logBattleEvent(`Floor ${floor} - Quicksand: -2 HP (now ${p.hp})`);
                playWebAudioSound(sounds.hit);
                if (p.hp <= 0) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    gameOver = true;
                    console.log(`Game Over: p.hp=${p.hp} due to quicksand`);
                }
            } else if (currentTheme === 'hell') {
                p.hp = Math.max(0, p.hp - 8);
                logBattleEvent(`Floor ${floor} - Lava: -8 HP (now ${p.hp})`);
                playWebAudioSound(sounds.hit);
                if (p.hp <= 0) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    gameOver = true;
                    console.log(`Game Over: p.hp=${p.hp} due to lava`);
                }
            }
            updatePlayerState();
        }
        if (map[ny][nx] === 7) {
            const coinToss = Math.random() < 0.5; // 50/50 chance
            if (coinToss) {
                // Grant max health (original behavior)
                const healthGain = p.potions * 12;
                p.maxHP += healthGain;
                p.hp += healthGain;
                logBattleEvent(`Floor ${floor} - Gnome flips a coin... Heads! Traded ${p.potions} potions for +${healthGain} max HP (new max HP: ${p.hp})`);
                playWebAudioSound(sounds.heads); // Play heads sound
            } else {
                // Remove excess health
                const currentMaxHP = p.hasArmor ? 36 : 24;
                if (p.hp > currentMaxHP) {
                    const healthLost = p.hp - currentMaxHP;
                    p.hp = currentMaxHP;
                    logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! Giggles echoes as ${healthLost} excess HP is whisked away! (HP now: ${p.hp})`);
                } else {
                    logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! The gnome giggles but finds no excess HP to take! (HP: ${p.hp})`);
                }
                playWebAudioSound(sounds.tails); // Play tails sound
            }
            p.potions = 0;
            map[ny][nx] = 0;
            updatePlayerState();
        }
        if (map[ny][nx] === 3) {
            const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
            if (drop) {
                satsEarned[drop.type] += drop.sats;
                map[ny][nx] = 0;
                satoshiDrops = satoshiDrops.filter(d => d !== drop);
                playWebAudioSound(sounds.pickup);
                updateSatsDisplay();
            }
        }
        if (map[ny][nx] === 4) {
            p.pickaxes++;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Pickaxe Found!`);
        }
        if (map[ny][nx] === 5) {
            if (p.hp >= 24) {
                p.hp += 12;
            } else {
                p.hp = 24 + 12;
            }
            p.hasArmor = true;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Armor Found: HP set to ${p.hp}`);
            updatePlayerState();
        }
        if (exit && p.x === exit.x && p.y === exit.y) {
            sounds.stairs.play().catch(e => console.error('Stairs sound error:', e));
            enemiesSpawnedThisFloor = 0;
            initialSpawnDoneThisFloor = false;
            enemies = [];
            floor++;
            initialWaveSpawned = false;
            waveActive = false;
            exit = null;
            killsLog = [];
            document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
            document.getElementById('wave').textContent = wave;
            console.log(`Moved to floor ${floor}, wave=${wave}, reset enemy spawns, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}`);
            initMap();
            nextApiCallTime = null;
            const battleEvents = document.getElementById('battle-events');
            battleEvents.value = '';
            battleEvents.style.transform = 'translateX(-100%)';
            battleEvents.style.opacity = '0';
            setTimeout(() => {
                if (!gameOver && !splashActive && floor > 0) {
                    fetchTxs();
                    console.log(`Triggered fetchTxs for wave ${wave} on floor ${floor}`);
                }
            }, 1000);
        }
        updateFogMap(p.x, p.y);
        // Define adjacentTiles for ambient sound check
        if (currentTheme !== 'dungeon') {
            const adjacentTiles = [
                [p.x, p.y - 1], // Up
                [p.x, p.y + 1], // Down
                [p.x - 1, p.y], // Left
                [p.x + 1, p.y]  // Right
            ];
            const currentSpecialTiles = new Set();
            for (const [x, y] of adjacentTiles) {
                if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] === 6) {
                    const tileKey = `${x},${y}`;
                    currentSpecialTiles.add(tileKey);
                    if (!lastSpecialTiles.has(tileKey)) {
                        // Play sound only if this is a new special tile
                        let soundToPlay;
                        switch (currentTheme) {
                            case 'hell':
                                soundToPlay = sounds.lava;
                                break;
                            case 'desert':
                                soundToPlay = sounds.quicksand;
                                break;
                            case 'paradise':
                                soundToPlay = sounds.pond;
                                break;
                        }
                        if (soundToPlay) {
                            playWebAudioSound(soundToPlay);
                            console.log(`Played ambient sound for ${currentTheme} at tile ${tileKey}`);
                        }
                    }
                }
            }
            lastSpecialTiles = currentSpecialTiles; // Update for next move
        }
    }
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

function moveEnemies() {
    if (gameOver || splashActive) return;
    enemies.forEach(e => {
        let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
        if (dist <= 5) {
            let moves = e.type.move, steps = 0;
            while (steps < moves) {
                let nx = e.x, ny = e.y;
                if (e.type.name === 'Crab') {
                    nx += dx > 0 ? 1 : -1;
                } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
                    if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                    else ny += dy > 0 ? 1 : -1;
                } else {
                    if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                    else ny += dy > 0 ? 1 : -1;
                }
                if (
                    nx >= 0 && nx < W && ny >= 0 && ny < H && 
                    map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) && 
                    !enemies.some(en => en.x === nx && en.y === ny && en !== e)
                ) {
                    e.x = nx; e.y = ny;
                } else break;
                steps++;
                dx = p.x - e.x; dy = p.y - e.y;
            }
            if (
                (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark') ?
                (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
            ) {
                p.hp -= e.type.atk;
                logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${e.type.atk} DMG`);
                playWebAudioSound(sounds.hit);
                if (p.hp <= 0) {
                    p.hp = 0;
                    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
                    gameOver = true;
                    console.log(`Game Over: p.hp=${p.hp}`);
                }
                updatePlayerState(); // Check HP and armor state after damage
            }
        }
    });
    if (enemies.length === 0 && !exit && waveActive) {
        let r = rooms[Math.floor(Math.random() * rooms.length)];
        let x, y;
        do { x = r.x + Math.floor(Math.random() * r.w); y = r.y + Math.floor(Math.random() * r.h); }
        while (map[y][x] !== 0 || (x === p.x && y === p.y));
        exit = {x, y};
        console.log(`Stairs spawned at (${x}, ${y}) on floor ${floor}, wave=${wave}`);
        updateSatsDisplay();
        needsRedraw = true;
    }
    if (enemies.length === 0 && waveActive) {
        waveActive = false;
        logBattleEvent(`Floor ${floor} - Wave ${wave} Completed!`);
        initialWaveSpawned = false;
        console.log(`Wave ${wave} completed, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
        needsRedraw = true;
    }
    needsRedraw = true;
}

function updateProjectiles() {
    if (gameOver || splashActive) return;
    projectiles = projectiles.filter(proj => {
        // Only move every 50ms
        if (Date.now() - proj.lastMoveTime < 50) return true;
        
        // Calculate next position
        let nx = proj.x, ny = proj.y;
        if (proj.dir === 'up') ny--;
        if (proj.dir === 'down') ny++;
        if (proj.dir === 'left') nx--;
        if (proj.dir === 'right') nx++;
        
        // Check bounds
        if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
            needsRedraw = true;
            return false;
        }
        
        // Check for wall hit before moving
        if (map[ny][nx] === 1) {
            needsRedraw = true;
            return false;
        }
        
        // Check for first enemy hit and deal damage
        let hit = enemies.find(e => e.x === nx && e.y === ny);
        if (hit) {
            const damage = Math.floor(p.atk * 0.5) + (p.hasArmor ? 1 : 0); // Half player attack, +1 with armor
            hit.hp -= damage;
            logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (HP: ${hit.hp})`);
            playWebAudioSound(sounds.hit);
            if (hit.hp <= 0) {
                kills[hit.type.name]++;
                let dropPlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 3;
                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(en => en.x === nx && en.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }
                if (!dropPlaced) {
                    console.log(`No space to place drop for ${hit.type.name} at (${hit.x}, ${hit.y})`);
                }
                enemies = enemies.filter(en => en !== hit);
                if (exit && enemies.length === 0) {
                    updateSatsDisplay();
                }
            }
            needsRedraw = true;
            return false; // Destroy projectile on enemy hit
        }
        
        // Update projectile position and move time
        proj.x = nx;
        proj.y = ny;
        proj.lastMoveTime = Date.now();
        needsRedraw = true;
        return true;
    });
}

let usePickaxeSword = false; // Global flag for draw

function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    // Update player direction
    let newDirection = p.anim.direction;
    if (swordDir === 'up') newDirection = 'back';
    if (swordDir === 'down') newDirection = 'front';
    if (swordDir === 'left') newDirection = 'left';
    if (swordDir === 'right') newDirection = 'right';
    p.anim.direction = newDirection;
    const initialPickaxes = p.pickaxes;
    
    // Check for enemy or wall one tile away in swordDir
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    const isEnemyNearby = enemies.some(e => e.x === sx && e.y === sy);
    const isWallNearby = sx >= 0 && sx < W && sy >= 0 && sy < H && map[sy][sx] === 1;
    
    if (initialPickaxes > 0 || isEnemyNearby || isWallNearby) {
        usePickaxeSword = initialPickaxes > 0;
        let hit = enemies.find(e => e.x === sx && e.y === sy);
        if (hit) {
            const damage = p.atk + (p.hasArmor ? 1 : 0); // Bonus damage with armor
            hit.hp -= damage;
            logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG (HP: ${hit.hp})`);
            playWebAudioSound(sounds.hit);
            if (hit.hp <= 0) {
                kills[hit.type.name]++;
                let dropPlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 3;
                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }
                if (!dropPlaced) {
                    console.log(`No space to place drop for ${hit.type.name} at (${hit.x}, ${hit.y})`);
                }
                enemies = enemies.filter(e => e !== hit);
                if (exit && enemies.length === 0) {
                    updateSatsDisplay();
                }
            }
        } else if (initialPickaxes > 0 && isWallNearby) {
            p.pickaxes--;
            sounds.secret.play().catch(e => console.error('Secret sound error:', e));
            logBattleEvent(`Floor ${floor} - Wall Broken!`);
            createSecretRoom(sx, sy, p.x, p.y, swordDir);
        }
    } else if (p.hp >= 24 && projectiles.length === 0) {
        let sx = p.x, sy = p.y; // Start at player's position
        if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
            projectiles.push({ x: sx, y: sy, dir: swordDir, startTime: Date.now(), lastMoveTime: Date.now() });
            sounds.shoot_sword.pause();
            sounds.shoot_sword.currentTime = 0;
            sounds.shoot_sword.play().catch(e => console.error('Shoot sword sound error:', e));
        }
    }
    moveEnemies();
    needsRedraw = true;
    setTimeout(() => {
        swordActive = false;
        usePickaxeSword = false;
        needsRedraw = true;
    }, 200);
}

function usePotion() {
    if (gameOver || splashActive || p.potions <= 0) return;
    if (p.hp >= 24) {
        logBattleEvent(`Floor ${floor} - Potion Returned: HP already at ${p.hp}!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Refund potion by not decrementing p.potions
    }
    p.potions--;
    const oldHP = p.hp;
    p.hp = Math.min(24, p.hp + 12);
    logBattleEvent(`Floor ${floor} - Potion Used: +${p.hp - oldHP} HP (now ${p.hp})`);
    sounds.potion.play().catch(e => console.error('Potion sound error:', e));
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

function restart() {
    console.log('Restarting game');
    floor = 1;
    currentTheme = 'dungeon'; // Reset to default theme
    p.maxHP = 24; // Reset max HP to default
    document.documentElement.style.setProperty('--text-color', '#ff8c00'); // Reset to orange
    document.documentElement.style.setProperty('--text-shadow', '-1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000'); // Reset outlined font
    // Force re-render of text color
    document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator').forEach(el => {
        el.style.color = '#ff8c00';
    });
    wave = 1;
    p.hp = 24;
    p.potions = 0;
    p.pickaxes = 0;
    p.hasArmor = false;
    p.x = 2;
    p.y = 2;
    p.atk = 2;
    enemies = [];
    map = [];
    rooms = [];
    exit = null;
    gameOver = false;
    gameOverSoundPlayed = false;
    enemiesSpawnedThisFloor = 0;
    initialSpawnDoneThisFloor = false;
    initialWaveSpawned = false;
    waveActive = false;
    nextApiCallTime = null;
    whaleHashIds = ['Whale Transactions:'];
    battleLog = [];
    killsLog = [];
    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    satoshiDrops = [];
    swordDir = 'right';
    swordActive = false;
    swordStart = 0;
    fogMap = [];
    scoreSubmitted = false;
    populateNameList();
    projectiles = []; // Reset projectiles

    document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
    document.getElementById('battle-events').value = '';
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    document.getElementById('health').textContent = p.hp;
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('sats').textContent = '0';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('submit-score').style.display = 'none';
    document.getElementById('view-leaderboard').style.display = 'none';
    document.getElementById('restart-game').style.display = 'none';
    document.getElementById('username-input').value = '';
    document.getElementById('leaderboard-output').textContent = '';
    document.getElementById('leaderboard-output').style.display = 'none';
    document.getElementById('submit-score').disabled = false;
    document.getElementById('submit-score').style.background = '#ff8c00';
    document.getElementById('splash-screen').style.display = 'block';
    const battleEvents = document.getElementById('battle-events');
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
    splashActive = true;

    sounds.music.pause();
    sounds.music.currentTime = 0;

    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }

    resetSplashScreen();
    initMap();
    updateSatsDisplay();
    needsRedraw = true;
    console.log('Restart complete, floor=', floor, 'wave=', wave, 'splashActive=', splashActive, 'enemies=', enemies.length, 'exit=', exit, 'gameOver=', gameOver, 'scoreSubmitted=', scoreSubmitted);
}

function draw() {
    if (!map?.[0] || !p || !enemies || !rooms?.length || !fogMap?.[0]) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms, 'fogMap=', fogMap);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);
    if (gameOver) {
        const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
        gameOverCanvas.clearRect(0, 0, 320, 320);
        gameOverCanvas.fillStyle = '#000';
        gameOverCanvas.fillRect(0, 0, 320, 320);
        const scale = window.innerWidth <= 700 ? 1.5 : 2;
        const gw = 128 * scale, gh = 32 * scale;
        const offsetY = (Math.sin(Date.now() / 500) * 10);
        gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh) / 2 + offsetY, gw, gh);
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('submit-score').style.display = 'block';
        document.getElementById('view-leaderboard').style.display = 'block';
        document.getElementById('restart-game').style.display = 'block';
        return;
    }
    if (splashActive) { needsRedraw = false; return; }

    const radius = 4;
    // Draw walls first
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] === 1) c.drawImage(assets.themes[currentTheme].wall, x * S, y * S, S, S);
    }
    // Draw floors, items, and stairs
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
        const isVisible = fogMap[y][x] === 1 || dist <= radius || map[y][x] === 1;
        if (isVisible && map[y][x] !== 1) {
            c.drawImage(assets.themes[currentTheme].floor, x * S, y * S, S, S);
            if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
            if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
            if (map[y][x] === 4) c.drawImage(assets.pickaxe, x * S, y * S, S, S);
            if (map[y][x] === 5) c.drawImage(assets.armor, x * S, y * S, S, S);
            if (map[y][x] === 6 && currentTheme !== 'dungeon') c.drawImage(assets.themes[currentTheme].special, x * S, y * S, S, S);
            if (map[y][x] === 7) c.drawImage(assets.gnome, x * S, y * S, S, S);
            if (exit && exit.x === x && exit.y === y) c.drawImage(assets.stairs, x * S, y * S, S, S);
        }
    }
    // Draw projectiles, skipping player's position
    projectiles.forEach(proj => {
        if (proj.x >= 0 && proj.x < W && proj.y >= 0 && proj.y < H && 
            (proj.x !== p.x || proj.y !== p.y)) {
            c.save();
            c.translate(proj.x * S + S / 2, proj.y * S + S / 2);
            if (proj.dir === 'up') c.rotate(-Math.PI / 2);
            if (proj.dir === 'down') c.rotate(Math.PI / 2);
            if (proj.dir === 'left') c.rotate(Math.PI);
            c.drawImage(assets.shoot_sword, -S / 2, -S / 2, S, S);
            c.restore();
        }
    });
    // Draw player
    if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
        const now = performance.now();
        if (now - p.anim.lastFrameTime >= p.anim.frameDuration) {
            p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
            p.anim.lastFrameTime = now;
        }
        const direction = p.anim.direction;
        const baseDirection = direction === 'left' ? 'right' : direction;
        const frameKey = p.hasArmor ? `armor_${baseDirection}` : baseDirection;
        const frame = p.anim.frames[frameKey][p.anim.frameIndex];
        c.save();
        if (direction === 'left') {
            c.translate((p.x + 1) * S, p.y * S);
            c.scale(-1, 1);
            c.drawImage(frame, 0, 0, S, S);
        } else {
            c.drawImage(frame, p.x * S, p.y * S, S, S);
        }
        c.restore();
    }
    // Draw sword or pickaxe-sword
    if (swordActive && Date.now() - swordStart < 200) {
        let sx = p.x, sy = p.y;
        if (swordDir === 'up') sy--;
        if (swordDir === 'down') sy++;
        if (swordDir === 'left') sx--;
        if (swordDir === 'right') sx++;
        if (sx >= 0 && sx < W && sy >= 0 && sy < H && Math.sqrt((sx - p.x) ** 2 + (sy - p.y) ** 2) <= radius) {
            c.save();
            c.translate(sx * S + S / 2, sy * S + S / 2);
            if (swordDir === 'up') c.rotate(-Math.PI / 2);
            if (swordDir === 'down') c.rotate(Math.PI / 2);
            if (swordDir === 'left') c.rotate(Math.PI);
            c.drawImage(usePickaxeSword ? assets.pickaxe_sword : assets.sword, -S / 2, -S / 2, S, S);
            c.restore();
        }
    }
    // Draw fog overlay
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] !== 1 && !fogMap[y][x]) {
            c.fillStyle = 'rgba(0, 0, 0, 0.7)';
            c.fillRect(x * S, y * S, S, S);
        }
    }
// Draw enemies with theme-based color overlays, preserving transparent backgrounds
enemies.forEach(e => {
    if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
        const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
        const isVisible = fogMap[e.y][e.x] === 1 || dist <= radius;
        c.save();
        // Create a temporary canvas to handle tinting without affecting transparent areas
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = S;
        tempCanvas.height = S;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Handle animation for enemies with anim property (e.g., Shrimp)
        let img;
        if (e.type.anim) {
            const now = performance.now();
            if (now - e.type.anim.lastFrameTime >= e.type.anim.frameDuration) {
                e.type.anim.frameIndex = (e.type.anim.frameIndex + 1) % e.type.anim.frames.length;
                e.type.anim.lastFrameTime = now;
            }
            img = e.type.anim.frames[e.type.anim.frameIndex];
        } else {
            img = e.type.img;
        }
        
        tempCtx.drawImage(img, 0, 0, S, S);
        if (isVisible && currentTheme !== 'dungeon') {
            // Apply tint only to non-transparent pixels
            let tintColor;
            switch (currentTheme) {
                case 'hell':
                    tintColor = 'rgba(255, 0, 0, 0.3)'; // Transparent red
                    break;
                case 'desert':
                    tintColor = 'rgba(245, 245, 220, 0.3)'; // Transparent bone
                    break;
                case 'paradise':
                    tintColor = 'rgba(255, 246, 0, 0.3)'; // Transparent yellow-green
                    break;
            }
            tempCtx.globalCompositeOperation = 'source-atop';
            tempCtx.fillStyle = tintColor;
            tempCtx.fillRect(0, 0, S, S);
        }
        // Draw the enemy (tinted if visible, normal if in fog)
        c.drawImage(tempCanvas, e.x * S, e.y * S, S, S);
        c.restore();
    }
});
// Draw low-health warning border
if (p.hp <= 4 && !gameOver && !splashActive) {
    const alpha = Math.min(0.9, Math.pow(Math.sin(Date.now() / 500) + 1, 0.5) - 0.5); // Smoother pulse
    c.strokeStyle = `rgba(255, 0, 0, ${alpha})`; // Red border for hp <= 4
    c.lineWidth = Math.max(5, window.innerWidth > 700 ? 10 : 5); // Responsive thickness
    c.beginPath();
    // Top border
    c.moveTo(0, 0);
    c.lineTo(W * S, 0);
    // Right border
    c.moveTo(W * S, 0);
    c.lineTo(W * S, H * S);
    // Bottom border
    c.moveTo(W * S, H * S);
    c.lineTo(0, H * S);
    // Left border
    c.moveTo(0, H * S);
    c.lineTo(0, 0);
    c.stroke();
} else if (p.hp > 4 && p.hp < 9 && !gameOver && !splashActive) {
    const alpha = Math.min(0.9, Math.pow(Math.sin(Date.now() / 500) + 1, 0.5) - 0.5); // Same pulsing effect
    c.strokeStyle = `rgba(255, 165, 0, ${alpha})`; // Bitcoin orange border for 4 < hp < 13
    c.lineWidth = Math.max(5, window.innerWidth > 700 ? 10 : 5);
    c.beginPath();
    // Draw the same border as above
    c.moveTo(0, 0);
    c.lineTo(W * S, 0);
    c.moveTo(W * S, 0);
    c.lineTo(W * S, H * S);
    c.moveTo(W * S, H * S);
    c.lineTo(0, H * S);
    c.moveTo(0, H * S);
    c.lineTo(0, 0);
    c.stroke();
}
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = false;
}

function gameLoop(timestamp) {
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state');
        initMap();
        needsRedraw = true;
    }
if (gameOver) {
    sounds.music.pause();
    sounds.music.currentTime = 0;
    if (!gameOverSoundPlayed) {
        sounds.gameover.play().catch(e => console.error('Gameover sound error:', e));
        gameOverSoundPlayed = true;
    }
    document.getElementById('health').textContent = 0;
    // Reset text color to Bitcoin orange for game-over screen
    document.documentElement.style.setProperty('--text-color', '#ff8c00');
    document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #leaderboard-output, #username-input').forEach(el => {
        el.style.color = '#ff8c00';
    });
    needsRedraw = true;
}
    updateProjectiles();
    if ((needsRedraw || p.hp <= 8) && !splashActive) draw();
    if (p.hp <= 0 && !gameOver) {
        p.hp = 0;
        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
        gameOver = true;
    }
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if (splashActive && e.key === 'Enter') {
        console.log('Enter key pressed on splash: splashActive=', splashActive, 'musicMuted=', musicMuted);
        const startButton = document.getElementById('start-button');
        startButton.style.background = '#00b7ef'; // Mimic :hover color
        setTimeout(() => {
            startButton.style.background = '#00e8d8'; // Revert to original color
        }, 200); // Short duration to simulate tap
        preloadSounds(); // Initialize all sounds except music
        if (!musicMuted) {
            sounds.music.pause(); // Ensure clean state
            sounds.music.currentTime = 0;
            sounds.music.play().then(() => {
                console.log('Music started successfully on Enter');
            }).catch(e => console.error('Music play failed on Enter:', e));
        }
        fadeSplash();
        return; // Prevent other key actions during splash
    }
    if (gameOver || splashActive) return;
    if (e.key === 'ArrowUp') move('up');
    if (e.key === 'ArrowDown') move('down');
    if (e.key === 'ArrowLeft') move('left');
    if (e.key === 'ArrowRight') move('right');
    if (e.key === 'a') attack();
    if (e.key === 'd') usePotion();
});

document.getElementById('game-over').addEventListener('click', (event) => {
    if (
        gameOver &&
        !document.getElementById('username-input').contains(event.target) &&
        !document.getElementById('submit-score').contains(event.target) &&
        !document.getElementById('view-leaderboard').contains(event.target) &&
        !document.getElementById('restart-game').contains(event.target) &&
        !document.getElementById('leaderboard-output').contains(event.target)
    ) {
        // No action on canvas click; restart only via button
    }
});

        initMap();
        updateSatsDisplay();
        populateNameList();
        requestAnimationFrame(gameLoop);
        
document.querySelectorAll('#dpad button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        button.classList.add('pressed'); // Add visual feedback
        button.click(); // Trigger onclick
    }, { passive: false });
    button.addEventListener('touchend', () => {
        button.classList.remove('pressed'); // Remove visual feedback
    });
});

// go to game-over screen at startup (DEBUG)
//function initGameOver() {
//    gameOver = true;
//    floor = 3;
//    satsEarned = {Shrimp: 2349, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
//    kills = {Shrimp: 1, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
//    document.getElementById('game-over').style.display = 'block';
//    document.getElementById('submit-score').style.display = 'block';
//    document.getElementById('view-leaderboard').style.display = 'block';
//    document.getElementById('restart-game').style.display = 'block';
//    updateSatsDisplay();
//    needsRedraw = true;
//    console.log('Initialized to game-over: gameOver=', gameOver, 'floor=', floor);
//}
//initGameOver();
//requestAnimationFrame(gameLoop);

    </script>
</body>
</html>



