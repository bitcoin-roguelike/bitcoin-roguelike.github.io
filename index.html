<!DOCTYPE html>
<html>
<link rel="icon" href="bitcoin.ico">
<head>
    <title>btc-dungeon</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self' https://noexxibndcooqjquhqzk.supabase.co https://mempool.space; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com;">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
        body { 
            margin: 0; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            min-height: 10px; 
            background: #222; 
            font-family: 'VT323', monospace;
            overflow: hidden;
            touch-action: pan-x pan-y; /* Prevents pinch-to-zoom */
            -webkit-user-select: none; /* Prevents selection */
            -webkit-touch-callout: none; /* Disables iOS callouts */
        }
        /* Existing styles remain unchanged */
        #console { 
            background: #111;
            border: 4px solid #ff8c00;
            padding: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            max-width: 800px;
            width: 100%;
            box-sizing: border-box;
        }
#whale-log { 
            width: 618px; 
            height: 24px; 
            overflow-y: auto;
            scroll-behavior: smooth; 
            background: #111; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 12px; 
            border: 2px solid #ff8c00; 
            font-size: 14px; 
        }
        #whale-hash-ids { 
            max-width: 620px; 
        }
        #whale-hash-ids a { 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            text-decoration: none; 
        }
        #whale-hash-ids a:hover { 
            text-decoration: underline; 
        }
        #game-container { 
            position: relative; 
            width: 640px; 
            height: 640px; 
        }
        canvas { 
            width: 640px; 
            height: 640px; 
            border: 2px solid #000; 
            image-rendering: pixelated; 
        }
        #splash-screen, #game-over { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 640px; 
            height: 640px; 
            z-index: 30; 
        }
        #game-over { 
            display: none; 
            text-align: center; 
        }
#battle-log { 
            width: 620px;
            margin-left: 20px; 
            background: transparent; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 16px; 
            border: none; 
            font-size: 16px;
            z-index: 10;
            margin-top: -240px;
        }
#battle-log textarea {
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    font-family: 'VT323', monospace;
    font-size: 16px;
    resize: none;
    width: 100%;
    height: 200px;
    padding: 0;
    overflow-y: auto;
    scroll-behavior: smooth;
    z-index: 10;
    pointer-events: none;
    transition: transform 0.3s ease, opacity 0.2s ease;
    transform: translateX(-100%);
    opacity: 0;
    /* Hide scrollbar */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE and Edge */
}
#inventory { 
    position: absolute;
    top: 10px;
    right: -12px;
    background: transparent;
    color: var(--text-color, #ff8c00) !important;
    text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000;
    border: none;
    padding: 8px;
    z-index: 10;
    font-family: 'VT323', monospace;
    font-size: 20px;
    line-height: 1.5;
    width: 160px;
}
#inventory sup {
    vertical-align: super;
    font-size: 0.6em; /* Matches ™ size */
    text-shadow: none; /* Remove shadow for clarity */
}
/* Tighten line-height for Safari */
@media not all and (min-resolution: 0.001dpcm) { /* Targets Safari */
    #inventory {
        line-height: 1.0; /* Reduce line-height by ~50% */
    }
}
        #floor-indicator { 
            position: absolute; 
            top: 11px; 
            left: 10px; 
            background: transparent; 
            color: var(--text-color, #ff8c00) !important; 
            text-shadow: -1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000; 
            padding: 8px; 
            z-index: 10; 
            font-family: 'VT323', monospace;
            font-size: 24px; 
        }
        #controller { 
            grid-area: controller; 
            display: flex; 
            justify-content: left; 
            align-items: left; 
            gap: 320px; 
            padding: 5px; 
        }
        #dpad { 
            display: grid; 
            grid-template-areas: ". t ." "l c r" ". b ."; 
            gap: 5px; 
        }
        #up {
            grid-area: t;
            z-index: 40;
            border-radius: 5%;
        }
        #left { 
            grid-area: l;
            z-index: 40;
            border-radius: 5%;
        }
        #right { 
            grid-area: r;
            z-index: 40; 
            border-radius: 5%;
        }
        #down { 
            grid-area: b;
            z-index: 40;
            border-radius: 5%;
        }
        #actions { 
            display: flex; 
            gap: 5px; 
            align-items: center; 
        }
        button { 
            background-color: transparent;
            border: 1px solid #ff8c00;
            color: #ff8c00;
            padding: 8px; 
            border: 0px solid #000; 
            cursor: pointer; 
            font-size: 14px; 
            width: 40px; 
            height: 40px;
            box-sizing: border-box; 
        }
        button:hover {
            background: rgba(224, 123, 0, 0.5);
        }
        #mute {
            padding: 0px;
            border-radius: 25%;
            height: 20px;
            width: 30px;
            background: #fff;
            color: #000;
            margin-right: 50px;
            z-index: 10;
        }
        #mute:hover, #mute:hover {
            background: #ccc;
        }
        #attack, #potion {
            margin-right: 20px;
            background: #ff8c00;
            color: #fff;
            height: 50px;
            width: 50px; 
            border-radius: 50%;
        }
        #attack:hover, #potion:hover {
            background: #e07b00;
        }
        #start-button {
            position: absolute;
            top: 75%;
            left: 50%;
            width: 120px;
            height: 50px;
            transform: translate(-50%, -50%);
            background: #00e8d8;
            color: #fff;
            border: none;
            padding: 0px 20px;
            font-family: 'VT323', monospace;
            font-size: 42px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 40;
        }
        #start-button:hover {
            background: #00b7ef;
        }
#dpad button:active, #dpad button.pressed {
    background: rgba(224, 123, 0, 0.7); /* Slightly darker than hover */
}

#submit-score, #view-leaderboard, #restart-game {
    background: #ff8c00;
    color: #fff;
    border: none;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 18px;
    cursor: pointer;
    border-radius: 5px;
    width: 120px; /* Keep for view-leaderboard and restart-game */
    height: 40px;
    z-index: 40;
}
#submit-score {
    width: 220px; /* Almost doubled from 120px */
}

#submit-score:disabled {
    background: #666;
    cursor: not-allowed;
    opacity: 0.6;
}

#leaderboard-output {
    position: absolute;
    top: 0px;
    left: 50%;
    transform: translateX(-50%);
    background: #111;
    color: #ff8c00;
    border: 2px solid #ff8c00;
    padding: 0px;
    font-family: 'VT323', monospace;
    font-size: 14px;
    max-height: 200px;
    overflow-y: auto;
    display: none;
    width: 640px;
    max-width: 100%;
    text-align: left;
    white-space: pre;
    line-height: 1.2;
    box-sizing: border-box;
    word-break: break-word; /* Handle long text */
}
    
/* Phones (320px–767px) */
@media only screen and (min-width: 320px) and (max-width: 767px) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 9px;
    }
    #whale-hash-ids {
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 9px;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: 8px;
        height: 110px;
        font-size: 10px; /* Match font-size for consistency */
    }
    #inventory {
        width: 100px;
        font-size: 12px;
        line-height: 1.5;
        margin-right: 2px;
    }
    #floor-indicator {
        font-size: 10px;
    }
    button {
        width: 55px;
        height: 55px;
        font-size: 12px;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 40px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: -10px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 20px;
        width: 20px;
        background: #fff;
        color: #000;
        margin-right: 0px;
        margin-left: -15px;
        margin-top: 60px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 0px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 0px;
                margin-left: 20px;
        background: #ff8c00;
        height: 35px;
        width: 35px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }
    
    #submit-score, #view-leaderboard, #restart-game {
        width: 80px; /* Keep for view-leaderboard and restart-game */
        height: 30px;
        font-size: 16px;
    }
    #submit-score {
        width: 160px; /* Doubled from 80px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 14px;
}
    #leaderboard-output {
        top: -12px;
        width: 100%;
        max-width: 640px;
        font-size: 12px;
        max-height: 160px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}

/* Tablets (768px–1024px, high pixel ratio) */
@media only screen and (min-width: 768px) and (max-width: 1024px) and (-webkit-min-device-pixel-ratio: 2) {
    body {
        overflow: hidden;
        touch-action: pan-x pan-y;
        -webkit-user-select: none;
        user-select: none;
    }
    #console {
        padding: 5px;
        overflow: hidden;
        max-width: 640px;
    }
    canvas, #splash-screen, #game-container, #game-over {
        width: 100%;
        max-width: 640px;
        height: auto;
        aspect-ratio: 1/1;
    }
    #whale-log {
        width: 100%;
        height: 24px;
        overflow-y: auto;
        scroll-behavior: smooth;
        font-size: 1.2rem;
    }
    #whale-hash-ids {
        font-size: 1.2rem;
    }
    #battle-log {
        width: 100%;
        max-width: 480px;
        font-size: 1.2rem;
    }
    #battle-log textarea {
        width: 100%;
        margin-left: -60px;
        height: 156px;
        font-size: 1.2rem;
    }
    #inventory {
        width: 170px;
        font-size: 1.4rem;
        line-height: 1.5;
        margin-right: 20px;
    }
    #floor-indicator {
        font-size: 1.6rem;
    }
    button {
        width: 65px;
        height: 65px;
        font-size: 1.2rem;
        border-radius: 50%;
        margin-top: 0px;
    }
    button:hover {
        background: rgba(224, 123, 0, 0.5);
    }
    #controller {
        padding: 5px;
        display: flex;
        justify-content: flex-start;
        gap: 120px;
    }
    #dpad {
        display: grid;
        grid-template-areas: ". t ." "l c r" ". b .";
        gap: 0px; /* Reduced from 5px to bring buttons closer */
        margin-left: 20px;
    }
    #up {
        grid-area: t;
        margin-top: 160px;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #left {
        grid-area: l;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #right {
        grid-area: r;
        margin-top: 0;
        margin-left: 0;
        margin-right: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #down {
        grid-area: b;
        margin-top: 0;
        margin-left: 0;
        z-index: 30;
        border-radius: 10%;
    }
    #actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }
    #mute {
        padding: 0px;
        border-radius: 25%;
        height: 24px;
        width: 24px;
        background: #fff;
        color: #000;
        margin-right: 80px;
        margin-left: -15px;
        margin-top: 45px;
        z-index: 30;
    }
    #attack {
        padding: 0px;
        margin-right: 5px;
        background: #ff8c00;
        height: 65px;
        width: 65px;
        border-radius: 50%;
        margin-top: 165px;
        z-index: 30;
    }
    #potion {
        padding: 0px;
        margin-right: 5px;
        margin-left: 20px;
        background: #ff8c00;
        height: 45px;
        width: 45px;
        border-radius: 50%;
        margin-top: 80px;
        z-index: 30;
    }
    #mute:hover {
        background: #ccc;
    }

    #submit-score, #view-leaderboard, #restart-game {
        width: 100px; /* Keep for view-leaderboard and restart-game */
        height: 48px;
        font-size: 18px;
    }
    #submit-score {
        width: 200px; /* Doubled from 100px */
    }
#username-input {
    width: 200px; /* Match main style */
    font-size: 16px;
}
    #leaderboard-output {
        top: 0px;
        width: 100%;
        max-width: 640px;
        font-size: 14px;
        max-height: 200px;
        text-align: left;
        white-space: pre;
        line-height: 1.2;
        word-break: break-word;
    }

}
    </style>
</head>
<body>
    <div id="console">
        <div id="whale-log">
            <div id="whale-hash-ids">Whale Transactions:</div>
        </div>
        <div id="game-container">
            <canvas id="game" width="320" height="320"></canvas>
            <div id="splash-screen">
    		<canvas id="splash-canvas" width="320" height="320"></canvas>
    	    <button id="start-button">START</button>
	    </div>
<div id="game-over">
    <pre id="leaderboard-output"></pre>
    <canvas id="game-over-canvas" width="320" height="320"></canvas>
    <div style="position: absolute; top: 60%; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 15px;"> <!-- Increased gap from 10px to 15px -->
        <input id="username-input" type="text" placeholder="Enter Username" maxlength="20" list="name-list" style="background: #111; color: #ff8c00; border: 2px solid #ff8c00; padding: 8px; font-family: 'VT323', monospace; font-size: 18px; text-align: center; width: 200px;">
<datalist id="name-list"></datalist>
        <button id="submit-score" onclick="submitScore()">Submit Score</button>
        <button id="view-leaderboard" onclick="fetchLeaderboard()">Leaderboard</button>
        <button id="restart-game" onclick="restart()">Restart</button>
    </div>
</div>
            <div id="floor-indicator">Floor 1</div>
<div id="inventory" style="-webkit-nbsp-mode: normal;">
    <span id="wave" style="display: none;">1</span>
    Health: <span id="health">24</span><br>
    Potions: <span id="potions">0</span><br>
    Pickaxes: <span id="pickaxes">0</span><br> <!-- New pickaxe display -->
    Bag: <span id="sats">0</span><br>
    Runes: <span id="runes">None</span><br>
</div>
        </div>
<div id="battle-log">
    <textarea id="battle-events" readonly>Battle Log:</textarea>
</div>
        <div id="controller">
            <div id="dpad">
                <button id="up" onclick="move('up')">↑</button>
                <button id="left" onclick="move('left')">←</button>
                <button id="right" onclick="move('right')">→</button>
                <button id="down" onclick="move('down')">↓</button>
            </div>
            <div id="actions">
                <button id="mute" onclick="toggleMute()">♪</button>
                <button id="attack" onclick="attack()">B</button>
                <button id="potion" onclick="usePotion()">A</button>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>

const names = [
    "Acrocanthosaurus",
    "Aerith",
    "Agilisaurus",
    "Albertosaurus",
    "Alex",
    "Allosaurus",
    "Alucard",
    "Ankylosaur",
    "Ankylosaurus",
    "Apatosaurus",
    "Argentinosaurus",
    "Attak Trak",
    "Azeroth",
    "Barret",
    "Bashasaurus",
    "Battle Cat",
    "Battle Ram",
    "Beast Man",
    "Birdo",
    "Blade",
    "Blanka",
    "Blaise",
    "Blast-Attak",
    "Bomberman",
    "Bowser",
    "Brachiosaurus",
    "Bronto",
    "Brontosaurus",
    "Brother",
    "Bub",
    "Bubblun",
    "Buzz-Off",
    "Cait Sith",
    "Camptosaurus",
    "Captain Falcon",
    "Carnotaurus",
    "Castle Grayskull",
    "Catra",
    "Cecil",
    "Centrosaurus",
    "Ceratosaurus",
    "Chasmosaurus",
    "Chocobo",
    "Chuck Norris",
    "Chun-Li",
    "Cid",
    "Clawful",
    "Clubtail",
    "Coelophysis",
    "Compsognathus",
    "Corythosaurus",
    "Cringer",
    "Daspletosaurus",
    "Deinonychus",
    "Dhalsim",
    "Diddy Kong",
    "Dig Dug",
    "Dilophosaurus",
    "Diplodocus",
    "Donkey Kong",
    "Dr. Robotnik",
    "Dr. Wily",
    "Dracorex",
    "Dragon Walker",
    "Dragstor",
    "Dromaeosaurus",
    "Dryosaurus",
    "Edmontosaurus",
    "Elasmosaurus",
    "Entrapta",
    "Eoraptor",
    "Eternia",
    "Evil-Lyn",
    "Faker",
    "Father",
    "Fire Mario",
    "Fisto",
    "Fox McCloud",
    "Frogger",
    "Galaga",
    "Gallimimus",
    "Ganon",
    "Gerden",
    "Gorgosaurus",
    "Goomba",
    "Granamyr",
    "Grayskull",
    "Grizzlor",
    "Guile",
    "Gwildor",
    "Hadrosaurus",
    "Hammer Bro",
    "He-Man",
    "Herrerasaurus",
    "Homalocephale",
    "Hordak",
    "Hypsilophodon",
    "Ichthyosaurus",
    "Iguanodon",
    "Impa",
    "Jitsu",
    "Joanna Dark",
    "Kain",
    "Kentrosaurus",
    "King",
    "King Hiss",
    "King K. Rool",
    "King Randor",
    "Kirby",
    "Knuckles",
    "Kobra Khan",
    "Koopa",
    "Kraid",
    "Kratos",
    "Lakitu",
    "Lambeosaurus",
    "Leech",
    "Leptoceratops",
    "Lesothosaurus",
    "Link",
    "Lizard Man",
    "Luigi",
    "M. Bison",
    "Maiasaura",
    "Man-At-Arms",
    "Man-E-Faces",
    "Mario",
    "Marth",
    "Mantenna",
    "Mega Man",
    "Mekaneck",
    "Mer-Man",
    "Meta Knight",
    "Microraptor",
    "Modulok",
    "Mosasaurus",
    "Moss Man",
    "Mother",
    "Ms. Pac-Man",
    "Multi-Bot",
    "Nea",
    "Ness",
    "Night Stalker",
    "Orko",
    "Ornithomimus",
    "Othnielia",
    "Ouranosaurus",
    "Oviraptor",
    "Pac-Man",
    "Pachycephalosaurus",
    "Panthor",
    "Parasaurolophus",
    "Patrich",
    "Peach",
    "Peppy Hare",
    "Plesiosaurus",
    "Point Dread",
    "Ponyo",
    "Prenocephale",
    "Prince Adam",
    "Protoceratops",
    "Proto Man",
    "Psittacosaurus",
    "Pteranodon",
    "Pterodactyl",
    "Q*bert",
    "Queen Marlena",
    "Raccoon Mario",
    "Ram Man",
    "Rambo",
    "Raptor",
    "Rattlor",
    "Red XIII",
    "Revolver Ocelot",
    "Ridley",
    "Road Ripper",
    "Robo",
    "Rocky",
    "Rokkon",
    "Rydia",
    "Ryu",
    "Sagat",
    "Samus",
    "Satoshi Nakamoto",
    "Saurornithoides",
    "Saurod",
    "Scelidosaurus",
    "Scorpia",
    "Screeech",
    "Scutellosaurus",
    "Sephiroth",
    "Shadow Weaver",
    "Simon Belmont",
    "Sinornithoides",
    "Sinornitholestes",
    "Sister",
    "Skeletor",
    "Slippy Toad",
    "Snake Face",
    "Snake Mountain",
    "Solan",
    "Solid Snake",
    "Sonic",
    "Sorceress",
    "Spiketail",
    "Spikor",
    "Spinosaurus",
    "Sssqueeze",
    "Stego",
    "Stegosaurus",
    "Stinkor",
    "Stonedar",
    "Stratos",
    "Stridor",
    "Struthiomimus",
    "Stygimoloch",
    "Suchomimus",
    "Sy-Klone",
    "Tails",
    "Talon Fighter",
    "Tanooki Mario",
    "Teela",
    "Therizinosaurus",
    "Tifa",
    "Tingle",
    "Titanosaur",
    "Toad",
    "Torosaurus",
    "Trap Jaw",
    "Triceratops",
    "Tri-Klops",
    "Troodon",
    "Tsintaosaurus",
    "Tung Lashor",
    "Two Bad",
    "Tyrannosaurus",
    "T-Rex",
    "Tytus",
    "Utahraptor",
    "Vega",
    "Velociraptor",
    "Vincent",
    "Wario",
    "Wart",
    "Webstor",
    "Whiplash",
    "Wind Raider",
    "Yoshi",
    "Yuffie",
    "Zangief",
    "Zelda",
    "Zero",
    "Zoar"
];

function populateNameList() {
    const datalist = document.getElementById('name-list');
    datalist.innerHTML = ''; // Clear existing options
    names.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        datalist.appendChild(option);
    });
}

function levenshtein(a, b) {
    const matrix = Array(b.length + 1).fill().map(() => Array(a.length + 1).fill(0));
    for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
    for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
            matrix[j][i] = Math.min(
                matrix[j-1][i] + 1,
                matrix[j][i-1] + 1,
                matrix[j-1][i-1] + (a[i-1].toLowerCase() === b[j-1].toLowerCase() ? 0 : 1)
            );
        }
    }
    return matrix[b.length][a.length];
}

// Modified submitScore function with nearest name matching and random fallback
async function submitScore() {
    if (!gameOver) return;
    if (scoreSubmitted) {
        document.getElementById('leaderboard-output').textContent = 'Score already submitted for this game!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: already submitted');
        return;
    }
    if (floor < 3) {
        document.getElementById('leaderboard-output').textContent = 'Reach at least Floor 3 to submit your score!';
        document.getElementById('leaderboard-output').style.display = 'block';
        console.log('Score submission blocked: floor=', floor, '< 3');
        return;
    }
    let username = document.getElementById('username-input').value.trim();
    if (!username) {
        // Select random name if input is empty
        username = names[Math.floor(Math.random() * names.length)];
        console.log(`Empty username, selected random name: '${username}'`);
    } else if (!names.includes(username)) {
        // Find the closest matching name (case-insensitive)
        let minDistance = Infinity;
        let closestName = username;
        for (const name of names) {
            const distance = levenshtein(username.toLowerCase(), name.toLowerCase());
            if (distance < minDistance) {
                minDistance = distance;
                closestName = name;
            }
        }
        // Use closest name if distance is small enough (threshold: 3 edits)
        if (minDistance <= 3) {
            console.log(`Username '${username}' matched to '${closestName}' (distance=${minDistance})`);
            username = closestName;
        } else {
            // Select random name if no close match
            username = names[Math.floor(Math.random() * names.length)];
            console.log(`Username '${username}' not matched (distance=${minDistance}), selected random name: '${username}'`);
        }
    }
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ username, score: totalSats, floor })
        });
        const text = await response.text();
        console.log(`POST Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : {};
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok) {
            scoreSubmitted = true;
            document.getElementById('submit-score').disabled = true;
            document.getElementById('submit-score').style.background = '#666';
            document.getElementById('leaderboard-output').textContent = `Score submitted: ${username}, ${totalSats} sats (Floor ${floor})`;
            document.getElementById('leaderboard-output').style.display = 'block';
            await fetchLeaderboard(username, totalSats, floor);
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
            if (response.status === 400 && text.includes('new row violates row-level security policy')) {
                document.getElementById('leaderboard-output').textContent = 'Submission blocked: Must reach at least Floor 3!';
            }
            document.getElementById('leaderboard-output').style.display = 'block';
        }
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

const SUPABASE_URL = 'https://noexxibndcooqjquhqzk.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5vZXh4aWJuZGNvb3FqcXVocXprIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDkyNzY3NDgsImV4cCI6MjA2NDg1Mjc0OH0.LvN81angnwKM5IS1lCrr-dUESgeJfvO6VjkC0lMB0y4';
const headers = {
    'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
    'apikey': SUPABASE_ANON_KEY,
    'Content-Type': 'application/json',
    'Prefer': 'return=representation'
};



async function fetchLeaderboard(submittedUsername = null, submittedScore = null, submittedFloor = null) {
    try {
        const response = await fetch(`${SUPABASE_URL}/rest/v1/leaderboard?select=username,score,floor&order=score.desc&limit=10`, {
            method: 'GET',
            headers
        });
        const text = await response.text();
        console.log(`GET Status: ${response.status}, Response: ${text}`);
        let data;
        try {
            data = text ? JSON.parse(text) : [];
        } catch (e) {
            data = { raw: text };
        }
        if (response.ok && Array.isArray(data)) {
            let playerInTop10 = submittedUsername ? data.some(entry => entry.username === submittedUsername && entry.score === submittedScore && entry.floor === submittedFloor) : false;
            let playerEntry = null;
            let playerRank = null;

            // Fetch player's score and rank if not in top 10 and floor >= 3
            if (submittedUsername && !playerInTop10 && submittedFloor >= 3) {
                try {
                    const playerResponse = await fetch(
                        `${SUPABASE_URL}/rest/v1/leaderboard?select=username,score,floor&username=eq.${encodeURIComponent(submittedUsername)}&score=eq.${submittedScore}&floor=eq.${submittedFloor}`,
                        { method: 'GET', headers }
                    );
                    const playerData = await playerResponse.json();
                    if (playerResponse.ok && playerData.length > 0) {
                        playerEntry = playerData[0];
                        const rankResponse = await fetch(
                            `${SUPABASE_URL}/rest/v1/leaderboard?select=score&score=gt.${submittedScore}&order=score.desc`,
                            { method: 'GET', headers }
                        );
                        const rankData = await rankResponse.json();
                        if (rankResponse.ok) {
                            playerRank = rankData.length + 1;
                        }
                    }
                } catch (e) {
                    console.error('Error fetching player score or rank:', e);
                }
            }

            // Format leaderboard
            const maxUsernameLength = 20;
            const scoreWidth = 14; // Increased from 12 to handle large BTC values
            const numberWidth = 10; // Increased from 8 for consistent score padding
            const floorWidth = 6;  // Increased from 5 for better floor alignment
            const header = `Rank  Username                Score         Floor`; // Adjusted spacing
            let rows = data.map((entry, index) => {
                const rank = (index + 1).toString().padStart(2, '0');
                const username = entry.username.length > maxUsernameLength
                    ? entry.username.substring(0, maxUsernameLength - 2) + '..'
                    : entry.username.padEnd(maxUsernameLength);
                const scoreValue = entry.score;
                let numberPart, unitPart;
                if (scoreValue >= 1e8) {
                    numberPart = (scoreValue / 1e8).toFixed(1);
                    unitPart = 'BTC';
                } else {
                    numberPart = scoreValue.toString();
                    unitPart = 'sats';
                }
                const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
                const score = scoreDisplay.padEnd(scoreWidth);
                const floor = entry.floor.toString().padStart(floorWidth);
                return `${rank}    ${username}${score}${floor}`;
            });

            // Replace or append player's entry with actual rank if not in top 10
            if (playerEntry && !playerInTop10 && playerRank) {
                const username = playerEntry.username.length > maxUsernameLength
                    ? playerEntry.username.substring(0, maxUsernameLength - 2) + '..'
                    : playerEntry.username.padEnd(maxUsernameLength);
                const scoreValue = playerEntry.score;
                let numberPart, unitPart;
                if (scoreValue >= 1e8) {
                    numberPart = (scoreValue / 1e8).toFixed(1);
                    unitPart = 'BTC';
                } else {
                    numberPart = scoreValue.toString();
                    unitPart = 'sats';
                }
                const scoreDisplay = `${numberPart.padStart(numberWidth)} ${unitPart}`;
                const score = scoreDisplay.padEnd(scoreWidth);
                const floor = playerEntry.floor.toString().padStart(floorWidth);
                const playerRow = `${playerRank.toString().padStart(2, '0')}    ${username}${score}${floor}`;
                if (rows.length >= 10) {
                    rows[9] = playerRow; // Replace 10th entry
                } else {
                    rows.push(playerRow); // Append if fewer than 10 entries
                }
            }

            const leaderboardText = `${header}\n${rows.join('\n') || 'No entries yet!'}`;
            document.getElementById('leaderboard-output').textContent = leaderboardText;
        } else {
            document.getElementById('leaderboard-output').textContent = `Error: ${response.status} ${JSON.stringify(data, null, 2)}`;
        }
        document.getElementById('leaderboard-output').style.display = 'block';
    } catch (error) {
        document.getElementById('leaderboard-output').textContent = `Fetch error: ${error.message}`;
        console.error('Fetch leaderboard error:', error);
        document.getElementById('leaderboard-output').style.display = 'block';
    }
}

document.getElementById('username-input').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && gameOver) {
        e.preventDefault(); // Prevent any default behavior
        submitScore(); // Trigger score submission
    }
});

// Prevent pinch-to-zoom and double-tap zoom
document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });
document.addEventListener('gesturestart', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gesturechange', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('gestureend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });
document.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation();
    }, { passive: false });

// Block canvas touch interference
const canvas = document.getElementById('game');
canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            } else if (!e.target.closest('#dpad, #actions')) {
        e.preventDefault();
            }
}, { passive: false });
canvas.addEventListener('touchmove', (e) => {
    if (e.scale !== 1 || e.touches.length > 1) {
        e.preventDefault();
        e.stopPropagation();
            }
}, { passive: false });

// Touch handlers for #dpad buttons
document.querySelectorAll('#dpad button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
            }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed'); // Remove visual feedback
            }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default click behavior after onclick
            }, { passive: false });
});

// Touch handlers for #actions buttons
document.querySelectorAll('#actions button').forEach(button => {
    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
        if (button.id === 'mute') toggleMute();
        else if (button.id === 'attack') attack();
        else if (button.id === 'potion') usePotion();
            }, { passive: false });
    button.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        button.classList.remove('pressed'); // Remove visual feedback
            }, { passive: false });
    button.addEventListener('click', (e) => {
        e.preventDefault(); // Prevent default click behavior
            }, { passive: false });
});
        

const c = canvas.getContext('2d');
const W = 20, H = 20, S = 16;
let currentTheme = 'dungeon'; // Default theme
const themes = ['dungeon', 'desert', 'paradise', 'hell'];
let initialWaveSpawned = false; // Track if initial wave has spawned

function selectNewTheme(current) {
    const availableThemes = themes.filter(t => t !== current);
    return availableThemes[Math.floor(Math.random() * availableThemes.length)];
}
        
let map = [], 
    p = {
        x: 2,
        y: 2,
        hp: 24,
        potions: 0,
        atk: 2,
        pickaxes: 0,
        hasArmor: false,
        runes: [], // Array to store collected rune letters (e.g., ['a','b','c'])
        runewords: [], // Array to store activated runewords (e.g., ['btc', 'hodl'])
        immortal: false, // Flag for HODL runeword immortality
        ripBlast: false, // Flag for RIP runeword blast
        anim: {
            frames: {
                front: [new Image(), new Image()],
                back: [new Image(), new Image()],
                right: [new Image(), new Image()],
                armor_front: [new Image(), new Image()],
                armor_back: [new Image(), new Image()],
                armor_right: [new Image(), new Image()]
            },
            direction: 'front',
            frameIndex: 0,
            lastFrameTime: 0,
            frameDuration: 200
        }
    }, 
    enemies = [], 
    rooms = [];
    
// Load animation frames
p.anim.frames.front[0].src = 'player-front1.png';
p.anim.frames.front[1].src = 'player-front2.png';
p.anim.frames.back[0].src = 'player-back1.png';
p.anim.frames.back[1].src = 'player-back2.png';
p.anim.frames.right[0].src = 'player-right1.png';
p.anim.frames.right[1].src = 'player-right2.png';
p.anim.frames.armor_front[0].src = 'player_armor-front1.png';
p.anim.frames.armor_front[1].src = 'player_armor-front2.png';
p.anim.frames.armor_back[0].src = 'player_armor-back1.png';
p.anim.frames.armor_back[1].src = 'player_armor-back2.png';
p.anim.frames.armor_right[0].src = 'player_armor-right1.png';
p.anim.frames.armor_right[1].src = 'player_armor-right2.png';

let floor = 1, wave = 1, exit = null, needsRedraw = true, lastUpdate = 0, gameOver = false;
let scoreSubmitted = false; // Tracks if score has been submitted
let whaleHashIds = ['Whale Transactions:'], battleLog = [], killsLog = [];
let satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
let satoshiDrops = [];
let runeDrops = []; // Array to store rune drops with positions and letters
let splashActive = true;
let waveActive = false;
let musicMuted = false;        
let swordDir = 'right', swordActive = false, swordStart = 0;
let gameOverSoundPlayed = false;
let fogMap = [];
let battleLogTimeout = null;
let projectiles = [];
let autoSubmitTriggered = false;

const specialSoundsPlayedThisFloor = {
    lava: false,
    quicksand: false,
    pond: false,
    rune: false
};

    const types = [
{
    name: 'Shrimp',
    min: 0,
    max: 0.01,
    anim: {
        frames: [new Image(), new Image(), new Image()],
        hellFrames: [new Image(), new Image(), new Image()], // Hell Shrimp frames
        frameIndex: 0,
        lastFrameTime: 0,
        frameDuration: 200
    },
    hp: 2,
    atk: 1,
    reward: 0,
    move: 1
},
        {
            name: 'Crab',
            min: 0.01,
            max: 0.1,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 3,
            atk: 2,
            reward: 0,
            move: 1
        },
        {
            name: 'Squid',
            min: 0.1,
            max: 1,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 4,
            atk: 2,
            reward: 0,
            move: 2
        },
        {
            name: 'Dolphin',
            min: 1,
            max: 10,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 4,
            atk: 3,
            reward: 0,
            move: 2
        },
        {
            name: 'Shark',
            min: 10,
            max: 100,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 5,
            atk: 5,
            reward: 0,
            move: 2
        },
        {
            name: 'Whale',
            min: 100,
            max: Infinity,
            anim: {
                frames: [new Image(), new Image(), new Image()],
                frameIndex: 0,
                lastFrameTime: 0,
                frameDuration: 200
            },
            hp: 6,
            atk: 4,
            reward: 0,
            move: 2
        }
    ];
const assets = {
    themes: {
        dungeon: { floor: new Image(), wall: new Image() },
        desert: { floor: new Image(), wall: new Image(), special: new Image() },
        paradise: { floor: new Image(), wall: new Image(), special: new Image() },
        hell: { floor: new Image(), wall: new Image(), special: new Image() }
    },
    potion: new Image(),
    player: new Image(),
    stairs: new Image(),
    bitcoin: new Image(),
    gameOver: new Image(),
    sword: new Image(),
    pickaxe: new Image(),
    armor: new Image(),
    player_armor: new Image(),
    pickaxe_sword: new Image(),
    shoot_sword: new Image(),
    gnome: new Image(),
    runes: {
        on_floor: new Image(),
        a: new Image(), b: new Image(), c: new Image(), d: new Image(), e: new Image(),
        f: new Image(), g: new Image(), h: new Image(), i: new Image(), k: new Image(),
        l: new Image(), m: new Image(), n: new Image(), o: new Image(), p: new Image(),
        q: new Image(), r: new Image(), s: new Image(), t: new Image(), u: new Image(),
        v: new Image(), y: new Image(), z: new Image(), æ: new Image(), ø: new Image()
    }
};
        types[0].anim.frames[0].src = 'shrimp_1.png';
	types[0].anim.frames[1].src = 'shrimp_2.png';
	types[0].anim.frames[2].src = 'shrimp_3.png';
	types[0].anim.hellFrames[0].src = 'hell_shrimp_1.png';
	types[0].anim.hellFrames[1].src = 'hell_shrimp_2.png';
	types[0].anim.hellFrames[2].src = 'hell_shrimp_3.png';
		types[0].anim.hellFrames.forEach((frame, i) => {
    frame.onerror = () => console.error(`Failed to load Hell Shrimp frame ${i}: ${frame.src}`);
    });
    	types[1].anim.frames[0].src = 'crab_1.png';
    	types[1].anim.frames[1].src = 'crab_2.png';
    	types[1].anim.frames[2].src = 'crab_3.png';
    	types[2].anim.frames[0].src = 'squid_1.png';
    	types[2].anim.frames[1].src = 'squid_2.png';
    	types[2].anim.frames[2].src = 'squid_3.png';
    	types[3].anim.frames[0].src = 'dolphin_1.png';
    	types[3].anim.frames[1].src = 'dolphin_2.png';
    	types[3].anim.frames[2].src = 'dolphin_3.png';
    	types[4].anim.frames[0].src = 'shark_1.png';
    	types[4].anim.frames[1].src = 'shark_2.png';
    	types[4].anim.frames[2].src = 'shark_3.png';
    	types[5].anim.frames[0].src = 'whale_1.png';
    	types[5].anim.frames[1].src = 'whale_2.png';
    	types[5].anim.frames[2].src = 'whale_3.png';

    Object.values(assets).forEach(asset => {
        if (asset instanceof Image) {
            asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
        } else if (typeof asset === 'object') {
            Object.values(asset).forEach(subAsset => {
                subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
            });
        }
    });
    types.forEach(t => {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    });
        assets.themes.dungeon.floor.src = 'floor.png';
        assets.themes.dungeon.wall.src = 'wall.png';
        assets.themes.desert.floor.src = 'sand_floor.png';
        assets.themes.desert.wall.src = 'sand_wall.png';
        assets.themes.desert.special.src = 'quicksand.png';
        assets.themes.paradise.floor.src = 'paradise_floor.png';
        assets.themes.paradise.wall.src = 'paradise_wall.png';
        assets.themes.paradise.special.src = 'pond.png';
        assets.themes.hell.floor.src = 'hell_floor.png';
        assets.themes.hell.wall.src = 'hell_wall.png';
        assets.themes.hell.special.src = 'lava.png';
        assets.potion.src = 'potion.png';
        assets.gnome.src = 'gnome.png';
	assets.player.src = 'player.png';
	assets.pickaxe.src = 'pickaxe.png';
	assets.armor.src = 'armor.png';
	assets.player_armor.src = 'player_armor.png';
        assets.stairs.src = 'stairs.png'; 
        assets.bitcoin.src = 'bitcoin.png';
        assets.gameOver.src = 'gameover.png'; assets.sword.src = 'sword.png';
        assets.pickaxe_sword.src = 'pickaxe-sword.png';
        assets.shoot_sword.src = 'shoot_sword.png';        
        assets.runes.on_floor.src = 'rune_on_floor.png';
	assets.runes.a.src = 'rune-a.png';
	assets.runes.b.src = 'rune-b.png';
	assets.runes.c.src = 'rune-c.png';
	assets.runes.d.src = 'rune-d.png';
	assets.runes.e.src = 'rune-e.png';
	assets.runes.f.src = 'rune-f.png';
	assets.runes.g.src = 'rune-g.png';
	assets.runes.h.src = 'rune-h.png';
	assets.runes.i.src = 'rune-i.png';
	assets.runes.k.src = 'rune-k.png';
	assets.runes.l.src = 'rune-l.png';
	assets.runes.m.src = 'rune-m.png';
	assets.runes.n.src = 'rune-n.png';
	assets.runes.o.src = 'rune-o.png';
	assets.runes.p.src = 'rune-p.png';
	assets.runes.q.src = 'rune-q.png';
	assets.runes.r.src = 'rune-r.png';
	assets.runes.s.src = 'rune-s.png';
	assets.runes.t.src = 'rune-t.png';
	assets.runes.u.src = 'rune-u.png';
	assets.runes.v.src = 'rune-v.png';
	assets.runes.y.src = 'rune-y.png';
	assets.runes.z.src = 'rune-z.png';
	assets.runes.æ.src = 'rune-æ.png';
	assets.runes.ø.src = 'rune-ø.png';
Object.values(assets.runes).forEach(rune => {
    rune.onerror = () => console.error(`Failed to load rune asset: ${rune.src}`);
});
Object.values(assets).forEach(asset => {
    if (asset instanceof Image) {
        asset.onerror = () => console.error(`Failed to load asset: ${asset.src}`);
    } else if (typeof asset === 'object') {
        Object.values(asset).forEach(subAsset => {
            subAsset.onerror = () => console.error(`Failed to load asset: ${subAsset.src}`);
        });
    }
});
types.forEach(t => {
    if (t.img) {
        t.img.onerror = () => console.error(`Failed to load sprite: ${t.img.src}`);
    } else if (t.anim) {
        t.anim.frames.forEach((frame, i) => {
            frame.onerror = () => console.error(`Failed to load sprite frame ${i} for ${t.name}: ${frame.src}`);
        });
    }
});

function placeStairs() {
    if (exit) {
        logBattleEvent(`Floor ${floor} - Stairs placement skipped: exit already exists at (${exit.x}, ${exit.y})`);
        return true;
    }
    let x, y, placed = false;
    // Try room-based placement first
    if (rooms && rooms.length > 0) {
        let r = rooms[Math.floor(Math.random() * rooms.length)];
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = r.x + Math.floor(Math.random() * r.w);
            y = r.y + Math.floor(Math.random() * r.h);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    // Fallback to any valid floor tile
    if (!placed) {
        let attempts = 0;
        const maxAttempts = 100;
        do {
            x = Math.floor(Math.random() * W);
            y = Math.floor(Math.random() * H);
            attempts++;
        } while ((map[y][x] !== 0 || (x === p.x && y === p.y)) && attempts < maxAttempts);
        if (attempts < maxAttempts) {
            placed = true;
        }
    }
    if (placed) {
        exit = {x, y};
        map[y][x] = 2; // Stairs tile
        updateSatsDisplay();
        logBattleEvent(`Floor ${floor} - Stairs appeared at (${x}, ${y})!`);
        needsRedraw = true;
        return true;
    } else {
        logBattleEvent(`Floor ${floor} - Failed to place stairs: no valid position found!`);
        console.warn(`Stairs placement failed: rooms=${rooms.length}, map valid=${map.every(row => row.length === W)}`);
        needsRedraw = true;
        return false;
    }
}

const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();

const sounds = {
    attack: new Audio('attack.wav'),
    potion: new Audio('potion.wav'),
    hit: { buffer: null, url: 'hit.wav', isPlaying: false, duration: 720 },
    pickup: { buffer: null, url: 'pickup.wav', isPlaying: false, duration: 950 },
    music: new Audio('music.mp3'),
    gameover: new Audio('gameover.wav'),
    stairs: new Audio('stairs.wav'),
    secret: new Audio('secret.wav'),
    shoot_sword: new Audio('shoot_sword.wav'),
    heads: { buffer: null, url: 'heads.wav', isPlaying: false, duration: 650 },
    tails: { buffer: null, url: 'tails.wav', isPlaying: false, duration: 950 },
    lava: { buffer: null, url: 'lava.wav', isPlaying: false, duration: 900 },
    quicksand: { buffer: null, url: 'quicksand.wav', isPlaying: false, duration: 250 },
    pond: { buffer: null, url: 'pond.wav', isPlaying: false, duration: 500 },
    rune: { buffer: null, url: 'rune.wav', isPlaying: false, duration: 2000 },
    rune_drop: { buffer: null, url: 'rune_drop.wav', isPlaying: false, duration: 1000 }
};

sounds.music.loop = true;

// Load Web Audio buffers
function loadSoundBuffer(url, key) {
    fetch(url)
        .then(response => response.arrayBuffer())
        .then(data => audioContext.decodeAudioData(data))
        .then(buffer => {
            sounds[key].buffer = buffer;
                    })
        .catch(e => console.error(`Failed to load Web Audio buffer for ${key}: ${url}`, e));
}
loadSoundBuffer('hit.wav', 'hit');
loadSoundBuffer('pickup.wav', 'pickup');
loadSoundBuffer('heads.wav', 'heads');
loadSoundBuffer('tails.wav', 'tails');
loadSoundBuffer('lava.wav', 'lava');
loadSoundBuffer('quicksand.wav', 'quicksand');
loadSoundBuffer('pond.wav', 'pond');
loadSoundBuffer('rune.wav', 'rune');
loadSoundBuffer('rune_drop.wav', 'rune_drop');

Object.values(sounds).forEach(s => {
    if (s instanceof Audio) {
        s.volume = 1.0;
        s.onerror = () => console.error(`Failed to load sound: ${s.src}`);
    }
});

function isIOSorSafari() {
    const ua = navigator.userAgent;
    return /iPad|iPhone|iPod/.test(ua) || /Safari/.test(ua);
}

function preloadSounds() {
    if (isIOSorSafari()) {
        // iOS/Safari: Preload by setting src without playing
        Object.entries(sounds).forEach(([key, sound]) => {
            if (key === 'music' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop') return; // Skip music and Web Audio sounds
            if (Array.isArray(sound)) {
                sound.forEach((instance, idx) => {
                    // Create a new Audio object to trigger caching
                    const tempAudio = new Audio(instance.src);
                    tempAudio.volume = 1.0; // Set normal volume for later use
                                    });
            } else {
                // Create a new Audio object to trigger caching
                const tempAudio = new Audio(sound.src);
                tempAudio.volume = 1.0;
                            }
        });
    } else {
        // Non-iOS: Existing preload logic
        Object.entries(sounds).forEach(([key, sound]) => {
            if (key === 'music' || key === 'hit' || key === 'pickup' || key === 'heads' || key === 'tails' || key === 'lava' || key === 'quicksand' || key === 'pond' || key === 'rune' || key === 'rune_drop') return; // Skip music and Web Audio sounds
            if (Array.isArray(sound)) {
                sound.forEach((instance, idx) => {
                    instance.volume = 0; // Mute for preloading
                    instance.play().then(() => {
                        instance.pause();
                        instance.currentTime = 0;
                        instance.volume = 1.0;
                                            }).catch(e => console.error(`Preload sound error for ${instance.src} instance ${idx}:`, e));
                });
            } else {
                sound.volume = 0;
                sound.play().then(() => {
                    sound.pause();
                    sound.currentTime = 0;
                    sound.volume = 1.0;
                                    }).catch(e => console.error(`Preload sound error for ${sound.src}:`, e));
            }
        });
    }
}

function playWebAudioSound(soundObj) {
    if (!soundObj.buffer) {
        console.warn(`Buffer not loaded for ${soundObj.url}`);
        return;
    }
    if (soundObj.isPlaying) {
                return;
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
                    }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    soundObj.isPlaying = true; // Set flag
    const source = audioContext.createBufferSource();
    source.buffer = soundObj.buffer;
    const gainNode = audioContext.createGain();
    gainNode.gain.value = 1.0; // Max volume
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    source.start(0);
        source.onended = () => {
        soundObj.isPlaying = false; // Clear flag
            };
    // Fallback timeout to clear flag if onended fails
    setTimeout(() => {
        if (soundObj.isPlaying) {
            soundObj.isPlaying = false;
                    }
    }, soundObj.duration);
}

const splashCanvas = document.getElementById('splash-canvas').getContext('2d');
const splashImg = new Image();
splashImg.src = 'splash.png';
splashImg.onload = () => {
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    };

function fadeSplash() {
    setTimeout(() => {
        const imgData = splashCanvas.getImageData(0, 0, 320, 320);
        const pixels = imgData.data;
        const totalPixels = 320 * 320;
        const fadePerFrame = totalPixels / 20;
        let fadedPixels = 0;
        const fadeInterval = setInterval(() => {
            for (let i = 0; i < fadePerFrame && fadedPixels < totalPixels; i++) {
                const px = Math.floor(Math.random() * totalPixels) * 4;
                pixels[px + 3] = 0;
                fadedPixels++;
            }
            splashCanvas.putImageData(imgData, 0, 0);
            if (fadedPixels >= totalPixels) {
                clearInterval(fadeInterval);
                splashActive = false;
                document.getElementById('splash-screen').style.display = 'none'; // Hide instead of remove
                            }
        }, 75);
    }, 25);
}

function resetSplashScreen() {
    splashActive = true;
    const splashScreen = document.getElementById('splash-screen');
    splashScreen.style.display = 'block'; // Show splash screen
    // Redraw splash image
    splashCanvas.clearRect(0, 0, 320, 320);
    splashCanvas.drawImage(splashImg, 0, 0, 320, 320);
    }

document.getElementById('start-button').addEventListener('click', () => {
    if (splashActive) {
                preloadSounds();
        // Ensure AudioContext is resumed for iOS
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                            }).catch(e => console.error('Failed to resume AudioContext:', e));
        }
        // Preload player animation frames
        const imagesToLoad = [
            p.anim.frames.front[0], p.anim.frames.front[1],
            p.anim.frames.back[0], p.anim.frames.back[1],
            p.anim.frames.right[0], p.anim.frames.right[1],
            p.anim.frames.armor_front[0], p.anim.frames.armor_front[1],
            p.anim.frames.armor_back[0], p.anim.frames.armor_back[1],
            p.anim.frames.armor_right[0], p.anim.frames.armor_right[1]
        ];
        let loadedCount = 0;
        imagesToLoad.forEach(img => {
            if (img.complete) {
                loadedCount++;
                if (loadedCount === imagesToLoad.length) {
                                    }
            } else {
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === imagesToLoad.length) {
                                            }
                };
                img.onerror = () => console.error(`Failed to load image: ${img.src}`);
            }
        });
        if (!musicMuted) {
            sounds.music.pause();
            sounds.music.currentTime = 0;
            sounds.music.play().then(() => {
                            }).catch(e => console.error('Music play failed on START:', e));
        }
        fadeSplash();
        setTimeout(() => {
            if (!gameOver && !splashActive) {
                fetchTxs();
                lastUpdate = Date.now();
                console.log('Initial fetchTxs triggered after splash, wave=', wave);
            }
        }, 2000);
    }
});

function toggleMute() {
    musicMuted = !musicMuted;
    sounds.music.muted = musicMuted;
    document.getElementById('mute').textContent = musicMuted ? 'X' : '♪';
    if (!musicMuted && !splashActive) {
        sounds.music.currentTime = 0; // Start from beginning
        sounds.music.play().catch(e => console.error('Music play failed on unmute:', e));
    }
}

        function logWhaleHashId(txid) {
            whaleHashIds.push(`Floor ${floor} - <a href="https://www.blockchain.com/explorer/transactions/btc/${txid}" target="_blank">${txid}</a>`);
            document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
            const whaleLog = document.getElementById('whale-log');
            whaleLog.scrollTop = whaleLog.scrollHeight;
            console.log('Whale Hash ID:', txid);
        }

function logBattleEvent(event) {
    if (gameOver) return;
    const battleEvents = document.getElementById('battle-events');
    // Handle kills display (static, no fading)
    if (event.startsWith('Kills:') || event.match(/^(Shrimp|Crab|Squid|Dolphin|Shark|Whale):/) || event === '') {
        // Clear killsLog if starting a new kills block
        if (event === 'Kills:') {
            killsLog = [event];
        } else {
            killsLog.push(event);
        }
        if (exit && enemies.length === 0) {
            // Show exactly 8 kills lines
            battleEvents.value = killsLog.join('\n');
            battleEvents.scrollTop = battleEvents.scrollHeight;
            // Keep visible without fade-out
            battleEvents.style.transform = 'translateX(0)';
            battleEvents.style.opacity = '1';
            if (battleLogTimeout) {
                clearTimeout(battleLogTimeout);
                battleLogTimeout = null;
            }
                        return;
        }
    }
    // Keep last 3 messages for regular events (reverse waterfall)
    battleLog.push(event);
    battleLog = battleLog.slice(-3); // Keep last 3 events
    battleEvents.value = battleLog.join('\n');
    battleEvents.scrollTop = battleEvents.scrollHeight;
    // Clear any existing timeout
    if (battleLogTimeout) {
        clearTimeout(battleLogTimeout);
    }
    // Slide in and fade in
    battleEvents.style.transform = 'translateX(0)';
    battleEvents.style.opacity = '1';
    // Schedule slide out after 3 seconds for non-kills events
    battleLogTimeout = setTimeout(() => {
        battleEvents.style.transform = 'translateX(-100%)';
        battleEvents.style.opacity = '0';
        setTimeout(() => {
            const computedStyle = window.getComputedStyle(battleEvents);
            if (computedStyle.opacity === '0') {
                battleLog = [];
                battleEvents.value = '';
                                // Restore kills display if still valid
                if (exit && enemies.length === 0) {
                    killsLog = [
                        'Kills:',
                        `Shrimp: ${kills.Shrimp}`,
                        `Crab: ${kills.Crab}`,
                        `Squid: ${kills.Squid}`,
                        `Dolphin: ${kills.Dolphin}`,
                        `Shark: ${kills.Shark}`,
                        `Whale: ${kills.Whale}`,
                        '' // Empty line for 8 lines total
                    ];
                    battleEvents.value = killsLog.join('\n');
                    battleEvents.style.transform = 'translateX(0)';
                    battleEvents.style.opacity = '1';
                    battleEvents.scrollTop = battleEvents.scrollHeight;
                                    }
            }
        }, 300); // Wait for transition (0.3s)
        battleLogTimeout = null;
    }, 3000);
}

function updateSatsDisplay() {
    const totalSats = Object.values(satsEarned).reduce((sum, val) => sum + val, 0);
    document.getElementById('sats').textContent = totalSats < 1e8 ? `${totalSats} sats` : `${(totalSats / 1e8).toFixed(1)} BTC`;
    // Trigger kills display only when exit exists and no enemies remain
    if (exit && enemies.length === 0) {
        logBattleEvent(`Kills:`);
        for (const type of types) {
            if (kills[type.name] > 0) {
                logBattleEvent(`${type.name}: ${kills[type.name]}`);
            }
        }
    }
}

function spawnItemWithChance(item, chance, maxItems, proximityRange, avoidPlayer) {
    let positions = [];
    let attempts = 0;
    const maxAttempts = 100;

    while (positions.length < maxItems && attempts < maxAttempts) {
        if (Math.random() < chance) {
            let x = Math.floor(Math.random() * W);
            let y = Math.floor(Math.random() * H);
            let valid = map[y][x] === 0;

            if (avoidPlayer) {
                valid = valid && Math.abs(x - p.x) >= 3 && Math.abs(y - p.y) >= 3; // Ensure 5x5 clear area
            }

            if (valid) {
                let isNearOtherItem = false;
                for (let pos of positions) {
                    if (Math.abs(x - pos[0]) <= 2 && Math.abs(y - pos[1]) <= 2) {
                        isNearOtherItem = true;
                        break;
                    }
                }
                if (!isNearOtherItem) {
                    positions.push([x, y]);
                    if (item !== -1) {
                        map[y][x] = item;
                    }
                }
            }
        }
        attempts++;
    }

    return positions;
}

function initMap() {
    try {
        // Change theme every fourth floor
        if (floor % 3 === 0 && floor > 1) {
            currentTheme = selectNewTheme(currentTheme);
        }
        // Update text color based on theme
        let textColor;
        switch (currentTheme) {
            case 'hell':
                textColor = '#00ff00'; // Matrix green for hell
                break;
            case 'desert':
            case 'paradise':
                textColor = '#ff8c00'; // Orange for desert and paradise
                break;
            default:
                textColor = '#ff8c00'; // Orange for dungeon
        }
        document.documentElement.style.setProperty('--text-color', textColor);
        // Force re-render of text color
        document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator').forEach(el => {
            el.style.color = textColor;
        });
        // Reset enemy spawning variables
        enemies = [];
	enemiesSpawnedThisFloor = 0;
	whalesSpawnedThisFloor = 0; // Reset Whale counter for new floor
	initialSpawnDoneThisFloor = false;
        initialWaveSpawned = false;
        map = Array(H).fill().map(() => Array(W).fill(1));
        fogMap = Array(H).fill().map(() => Array(W).fill(0));
        rooms = [];
        satoshiDrops = [];
        runeDrops = []; // Clear rune drops on map, but keep p.runes, p.runewords, p.immortal
        
        // Generate rooms
        let maxAttempts = 100;
        while (rooms.length < 3 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        maxAttempts = 50;
        while (rooms.length < 5 && maxAttempts > 0) {
            let rw = 4 + Math.floor(Math.random() * 4);
            let rh = 4 + Math.floor(Math.random() * 4);
            let rx = 1 + Math.floor(Math.random() * (W - rw - 2));
            let ry = 1 + Math.floor(Math.random() * (H - rh - 2));
            if (!rooms.some(r => rx < r.x + r.w && rx + rw > r.x && ry < r.y + r.h && ry + rh > r.y)) {
                rooms.push({x: rx, y: ry, w: rw, h: rh});
                for (let y = ry; y < ry + rh; y++) for (let x = rx; x < rx + rw; x++) map[y][x] = 0;
            }
            maxAttempts--;
        }
        if (rooms.length < 3) {
            console.warn('Failed to generate at least 3 rooms, retrying map generation');
            return initMap();
        }
        
        // Connect rooms with corridors
        for (let i = 1; i < rooms.length; i++) {
            let r1 = rooms[i - 1], r2 = rooms[i];
            let x1 = r1.x + Math.floor(r1.w / 2), y1 = r1.y + Math.floor(r1.h / 2);
            let x2 = r2.x + Math.floor(r2.w / 2), y2 = r2.y + Math.floor(r1.h / 2);
            for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) map[y1][x] = 0;
            for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) map[y][x2] = 0;
        }
        
        // Ensure map is valid
        for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === undefined) map[y][x] = 1;
        
        // Place player
        p.x = rooms[0].x + 1; p.y = rooms[0].y + 1;
        if (!map[p.y]?.[p.x] || map[p.y][p.x] !== 0) {
            for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) if (map[y][x] === 0) { p.x = x; p.y = y; break; }
        }
        
        // Mark initial player area as explored
        updateFogMap(p.x, p.y);
        
        // Place special tiles based on theme (pond, quicksand, lava)
        let specialPositions = [];
        if (currentTheme !== 'dungeon') {
            specialPositions = spawnItemWithChance(6, 0.5, 2, 5, true); // 50% chance, max 2 tiles
        }

        // Place Gnome with X% chance, only if no conflict with special tiles
        let gnomePositions = [];
        if (
            currentTheme === 'dungeon' || 
            currentTheme === 'desert' || 
            currentTheme === 'hell' || 
            currentTheme === 'paradise' || 
            specialPositions.length < 2
        ) {
            if (Math.random() < 0.1) { // 10% chance to spawn a gnome
                gnomePositions = spawnItemWithChance(7, 1.0, 1, 5, true);
                if (gnomePositions.length > 0) {
                } else {
                }
            } else {
            }
        } else {
        }

        // Place potions
        let potionPositions = [];
        let selectedRooms = rooms.sort(() => 0.5 - Math.random()).slice(0, Math.min(3, rooms.length));
        let proximityRange = 5;
        for (let r of selectedRooms) {
            let x, y, attempts = 100;
            while (attempts > 0 && potionPositions.length < 3) {
                x = r.x + Math.floor(Math.random() * r.w);
                y = r.y + Math.floor(Math.random() * r.h);
                if (map[y][x] === 0 && (x !== p.x || y !== p.y) && !potionPositions.some(p => Math.abs(p.x - x) + Math.abs(p.y - y) < proximityRange)) {
                    map[y][x] = 2;
                    potionPositions.push({x, y});
                    if (potionPositions.length === 3) break;
                }
                attempts--;
            }
            if (attempts === 0 && potionPositions.length < 3) {
                console.warn('Potion placement failed: room=', r, 'attempts=', 100);
                proximityRange = Math.max(proximityRange - 1, 1);
                attempts = 100;
                continue;
            }
        }

        // Place pickaxe (chance to drop a pickaxe)
        let pickaxePositions = [];
        if (Math.random() < 0.2) { // 20% chance to spawn a pickaxe
            pickaxePositions = spawnItemWithChance(4, 1.0, 1, 5, true);
            if (pickaxePositions.length > 0) {
            } else {
            }
        }    
        
        exit = null;
        initialWaveSpawned = false;
        needsRedraw = true;

        // Check runewords at floor start
        checkRunewordsAtFloorStart();
        // Update rune display
        checkRunewords();
    } catch (e) {
        console.error('initMap Error:', e, e.stack);
        throw e;
    }
}

function createSecretRoom(wx, wy, px, py, dir) {
    // Create a 3x3 room based on player's facing direction
    const roomSize = 3;
    let rx, ry;
    // Position room based on direction
    switch (dir) {
        case 'up':
            rx = wx;
            ry = wy - roomSize;
            break;
        case 'down':
            rx = wx;
            ry = wy + 1;
            break;
        case 'left':
            rx = wx - roomSize;
            ry = wy;
            break;
        case 'right':
            rx = wx + 1;
            ry = wy;
            break;
        default:
            console.error(`Invalid direction: ${dir}`);
            p.pickaxes++;
            logBattleEvent(`Floor ${floor} - Secret Room Failed: Invalid direction`);
            return;
    }
    // Check if room fits within map bounds
    if (rx < 1 || rx + roomSize > W - 1 || ry < 1 || ry + roomSize > H - 1) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): out of bounds`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Check if the 3x3 area is all walls
    let allWalls = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (map[y][x] !== 1) {
                allWalls = false;
                break;
            }
        }
        if (!allWalls) break;
    }
    if (!allWalls) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): not a 3x3 wall block`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No 3x3 wall block for secret room! Pickaxe refunded`);
        return;
    }
    // Validate room placement
    let valid = true;
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            if (
                [2, 3, 4, 5].includes(map[y][x]) || // Items
                (x === px && y === py) || // Player
                enemies.some(e => e.x === x && e.y === y) // Enemies
            ) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
    }
    // Allow overlap with one room (e.g., corridor)
    let overlapCount = 0;
    rooms.forEach(r => {
        if (!(rx >= r.x + r.w || rx + roomSize <= r.x || ry >= r.y + r.h || ry + roomSize <= r.y)) {
            overlapCount++;
        }
    });
    if (overlapCount > 1) valid = false;
    if (!valid) {
        console.warn(`Failed to create secret room at (${rx}, ${ry}): invalid placement (items, player, or overlap)`);
        p.pickaxes++;
        logBattleEvent(`Floor ${floor} - No space for secret room! Pickaxe refunded`);
        return;
    }
    // Carve out the room
    for (let y = ry; y < ry + roomSize; y++) {
        for (let x = rx; x < rx + roomSize; x++) {
            map[y][x] = 0;
        }
    }
    // Clear the broken wall
    map[wy][wx] = 0;
    // Punch a non-directional hole (clear one adjacent tile)
    const adjacent = [
        { x: wx - 1, y: wy }, // Left
        { x: wx + 1, y: wy }, // Right
        { x: wx, y: wy - 1 }, // Up
        { x: wx, y: wy + 1 }  // Down
    ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] !== 0);
    if (adjacent.length > 0) {
        const hole = adjacent[Math.floor(Math.random() * adjacent.length)];
        map[hole.y][hole.x] = 0;
            }
    // Carve a corridor to a nearby floor tile
    let floorTiles = [];
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            if (map[y][x] === 0 && !(x === px && y === py) && !(x === wx && y === wy)) {
                floorTiles.push({ x, y });
            }
        }
    }
    if (floorTiles.length > 0) {
        floorTiles.sort((a, b) => {
            const distA = Math.abs(a.x - wx) + Math.abs(a.y - wy);
            const distB = Math.abs(b.x - wx) + Math.abs(b.y - wy);
            return distA - distB;
        });
        const target = floorTiles[0];
        let x = wx, y = wy;
        while (x !== target.x || y !== target.y) {
            if (Math.abs(target.x - x) > Math.abs(target.y - y)) {
                x += target.x > x ? 1 : -1;
            } else {
                y += target.y > y ? 1 : -1;
            }
            if (x >= 0 && x < W && y >= 0 && y < H && map[y][x] !== 0) {
                map[y][x] = 0;
            }
        }
            } else {
        console.warn(`No floor tile found to connect secret room at (${wx}, ${wy})`);
    }
    // Place armor in the center
    const armorX = rx + 1;
    const armorY = ry + 1;
    map[armorY][armorX] = 5;
    rooms.push({ x: rx, y: ry, w: roomSize, h: roomSize });
    // Show "Found Secret!" in Whale alert area and log success
    const floorIndicator = document.getElementById('floor-indicator');
    floorIndicator.textContent = `Found Secret!`;
    logBattleEvent(`Floor ${floor} - Secret Room Created!`);
    setTimeout(() => {
        floorIndicator.textContent = `Floor ${floor}`;
    }, 5000);
    updateFogMap(px, py);
        needsRedraw = true;
}

// Modified updatePlayerState to ensure immortality works correctly
function updatePlayerState() {
    if (p.hp <= 24 && p.hasArmor) {
        p.hasArmor = false;
        logBattleEvent(`Floor ${floor} - Armor boost lost!`);
            }

    // Prevent HP from going below 1 if immortal
    if (p.immortal && p.hp <= 0) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
            }

    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = true;
}

function updateFogMap(px, py) {
    const radius = 4; // Visibility radius
    const currentRoom = rooms.find(r => px >= r.x && px < r.x + r.w && py >= r.y && py < r.y + r.h);

    // Enhanced Bresenham's line algorithm with corner checking
    function hasLineOfSight(x0, y0, x1, y1) {
        let x = x0, y = y0;
        const dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
        let err = dx - dy;

        while (true) {
            if (x >= 0 && x < W && y >= 0 && y < H) {
                if (map[y][x] === 1) return false; // Hit a wall
                if (dx === dy) { // 45-degree line, check orthogonally adjacent tiles
                    if (sx === 1 && sy === 1) { // Moving SE
                        if (y - 1 >= 0 && map[y - 1][x] === 1) return false; // Wall above
                        if (x - 1 >= 0 && map[y][x - 1] === 1) return false; // Wall left
                    } else if (sx === 1 && sy === -1) { // Moving NE
                        if (y + 1 < H && map[y + 1][x] === 1) return false; // Wall below
                        if (x - 1 >= 0 && map[y][x - 1] === 1) return false; // Wall left
                    } else if (sx === -1 && sy === 1) { // Moving SW
                        if (y - 1 >= 0 && map[y - 1][x] === 1) return false; // Wall above
                        if (x + 1 < W && map[y][x + 1] === 1) return false; // Wall right
                    } else if (sx === -1 && sy === -1) { // Moving NW
                        if (y + 1 < H && map[y + 1][x] === 1) return false; // Wall below
                        if (x + 1 < W && map[y][x + 1] === 1) return false; // Wall right
                    }
                }
            } else {
                return false; // Out of bounds
            }
            if (x === x1 && y === y1) return true; // Reached target
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x += sx; }
            if (e2 < dx) { err += dx; y += sy; }
        }
    }

    // Track newly visible Shrimps
    const newlyVisibleShrimps = [];
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const dist = Math.sqrt((x - px) ** 2 + (y - py) ** 2);
            if (dist <= radius) {
                const tileRoom = rooms.find(r => x >= r.x && x < r.x + r.w && y >= r.y && y < r.y + r.h);
                const inSameRoom = currentRoom && tileRoom && currentRoom === tileRoom;
                const hasLOS = hasLineOfSight(px, py, x, y);
                if (inSameRoom || hasLOS) {
                    if (fogMap[y][x] !== 1) { // Tile was not previously explored
                        fogMap[y][x] = 1; // Mark as explored
                        // Check for Shrimp at this position
                        const shrimp = enemies.find(e => e.x === x && e.y === y && e.type.name === 'Shrimp' && currentTheme === 'hell');
                        if (shrimp) {
                            newlyVisibleShrimps.push(shrimp);
                        }
                    }
                }
            }
        }
    }
    // Log evolution for newly visible Shrimps
    if (newlyVisibleShrimps.length > 0) {
        logBattleEvent(`Floor ${floor} - Shrimp evolves to Hell Shrimp!`);
            }
}

let lastKeyMoveTime = 0; // Track last keyboard move time
let pendingKeyDir = null; // Track latest keyboard direction
let isKeyHeld = false; // Track if a key is held
let enemiesSpawnedThisFloor = 0;
let nextApiCallTime = null;
let initialSpawnDoneThisFloor = false;
let apiTimeoutId = null;
const API_INTERVAL = 20000; // 20 seconds

async function fetchTxs() {
    if (gameOver || splashActive || floor === 0) {
        console.log(`Skipping fetchTxs: gameOver=${gameOver}, splashActive=${splashActive}, floor=${floor}`);
        return;
    }
    const now = Date.now();
    if (nextApiCallTime && now < nextApiCallTime) {
        return;
    }
    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }
    try {
        console.log(`fetchTxs: floor=${floor}, wave=${wave}, enemiesSpawnedThisFloor=${enemiesSpawnedThisFloor}, initialSpawnDoneThisFloor=${initialSpawnDoneThisFloor}, initialWaveSpawned=${initialWaveSpawned}, waveActive=${waveActive}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}, enemies=${enemies.length}`);
        await new Promise(resolve => setTimeout(resolve, 25));
        const res = await axios.get('https://mempool.space/api/mempool/recent');
        if (!res.data || res.data.length === 0) {
            console.warn(`Empty mempool response, scheduling retry in ${API_INTERVAL / 1000}s`);
            nextApiCallTime = now + API_INTERVAL;
            apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
            return;
        }
        let enemyCount = 0;
        const processedTxids = new Set();
        console.warn(`[WHALE ATTEMPT] Checking ${res.data.length} transactions for Whale spawns (> 100 BTC)`);
        for (const tx of res.data.slice(0, 10)) {
            if (processedTxids.has(tx.txid)) continue;
            processedTxids.add(tx.txid);
            let value = 0;
            let address = 'Invalid address';
            try {
                await new Promise(resolve => setTimeout(resolve, 25));
                const txRes = await axios.get(`https://mempool.space/api/tx/${tx.txid}`);
                if (txRes.data.vout && Array.isArray(txRes.data.vout)) {
                    value = txRes.data.vout.reduce((sum, out) => sum + (Number.isFinite(out.value) ? out.value : 0), 0);
                    address = txRes.data.vout?.map(v => v.scriptpubkey_address).filter(Boolean)[0] || 'Invalid address';
                } else {
                    continue;
                }
            } catch (e) {
                continue;
            }
            if (value <= 0) {
                continue;
            }
            const btc = value / 1e8;
            const type = types.find(t => btc > t.min && btc <= t.max);
            if (!type) {
                continue;
            }

            // Handle initial spawn (up to 10 enemies, including Whales)
            if (!initialSpawnDoneThisFloor && enemiesSpawnedThisFloor < 10 && enemies.length < 10) {
                if (type.name !== 'Whale' && exit) {
                    continue;
                }
                console.log(`Initial Spawn Tx: ${tx.txid}, BTC: ${btc}, Type: ${type.name}, Address: ${address}, Value: ${value}`);
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y, attempts = 50;
                const auraRadius = 2; // 5x5 grid
                let validPosition = false;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                    validPosition = (
                        map[y][x] === 0 &&
                        !(x === p.x && y === p.y) &&
                        !enemies.some(e => e.x === x && e.y === y) &&
                        Math.abs(x - p.x) > auraRadius &&
                        Math.abs(y - p.y) > auraRadius
                    );
                    attempts--;
                } while (attempts > 0 && !validPosition);
                const newEnemy = { 
                    x, 
                    y, 
                    type, 
                    hp: type.name === 'Shrimp' && currentTheme === 'hell' ? 3 : type.hp, 
                    address, 
                    sats: Math.round(btc * 1e8) 
                };
                if (!validPosition) {
                    // Fallback: try any floor tile in any room
                    for (let r of rooms) {
                        for (let y = r.y; y < r.y + r.h; y++) {
                            for (let x = r.x; x < r.x + r.w; x++) {
                                if (
                                    map[y][x] === 0 &&
                                    !(x === p.x && y === p.y) &&
                                    Math.abs(x - p.x) > auraRadius &&
                                    Math.abs(y - p.y) > auraRadius &&
                                    !enemies.some(e => e.x === x && e.y === y)
                                ) {
                                    newEnemy.x = x;
                                    newEnemy.y = y;
                                    validPosition = true;
                                    break;
                                }
                            }
                            if (validPosition) break;
                        }
                        if (validPosition) break;
                    }
                }
                if (!validPosition) {
                    console.log(`No valid spawn position found for tx ${tx.txid}, skipping`);
                    continue;
                }
                enemies.push(newEnemy);
                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
                enemiesSpawnedThisFloor++;
                enemyCount++;
                if (type.name === 'Whale') {
                    console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                    logWhaleHashId(tx.txid);
                    document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                    setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
                }
                if (enemiesSpawnedThisFloor >= 10) {
                    initialSpawnDoneThisFloor = true;
                }
            } else if (type.name === 'Whale') {
                console.log(`[WHALE SPAWN ATTEMPT] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}`);
                const r = rooms[Math.floor(Math.random() * rooms.length)];
                let x, y, attempts = 50;
                const auraRadius = 2; // 5x5 grid
                let validPosition = false;
                do {
                    x = r.x + Math.floor(Math.random() * r.w);
                    y = r.y + Math.floor(Math.random() * r.h);
                    validPosition = (
                        map[y][x] === 0 &&
                        !(x === p.x && y === p.y) &&
                        !enemies.some(e => e.x === x && e.y === y) &&
                        Math.abs(x - p.x) > auraRadius &&
                        Math.abs(y - p.y) > auraRadius
                    );
                    attempts--;
                } while (attempts > 0 && !validPosition);
                if (!validPosition) {
                    // Fallback: try any floor tile in any room
                    for (let r of rooms) {
                        for (let y = r.y; y < r.y + r.h; y++) {
                            for (let x = r.x; x < r.x + r.w; x++) {
                                if (
                                    map[y][x] === 0 &&
                                    !(x === p.x && y === p.y) &&
                                    Math.abs(x - p.x) > auraRadius &&
                                    Math.abs(y - p.y) > auraRadius &&
                                    !enemies.some(e => e.x === x && e.y === y)
                                ) {
                                    x = x;
                                    y = y;
                                    validPosition = true;
                                    break;
                                }
                            }
                            if (validPosition) break;
                        }
                        if (validPosition) break;
                    }
                }
		if (!validPosition) {
		    console.log(`No valid spawn position found for Whale tx ${tx.txid}, skipping`);
		    continue;
		}
		if (type.name === 'Whale' && whalesSpawnedThisFloor >= 10) {
		    console.log(`Whale spawn skipped: reached cap of 10 Whales on floor ${floor}`);
		    continue;
		}
                const newEnemy = { x, y, type, hp: type.hp, address, sats: Math.round(btc * 1e8) };
                enemies.push(newEnemy);
		if (type.name === 'Whale') {
		    whalesSpawnedThisFloor++; // Increment Whale counter
		}
                const [amount, unit] = btc < 1 ? [Math.round(btc * 1e8), 'sats'] : [btc.toFixed(2), 'BTC'];
                logBattleEvent(`Floor ${floor} - ${type.name} Spawn: ${amount} ${unit}`);
                console.log(`[WHALE SPAWNED] Tx: ${tx.txid}, BTC: ${btc.toFixed(2)}, Floor: ${floor}, Position: (${x}, ${y})`);
                logWhaleHashId(tx.txid);
                document.getElementById('floor-indicator').textContent = `Floor ${floor} - Whale Alert! ${btc.toFixed(2)} BTC`;
                setTimeout(() => document.getElementById('floor-indicator').textContent = `Floor ${floor}`, 5000);
                enemyCount++;
            }
        }
        // Apply RIP blast to all on-screen enemies if active
        if (p.ripBlast && enemies.length > 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast annihilates all enemies!`);
            playWebAudioSound(sounds.hit);
            ripBlastActive = true; // Set flag for firestorm effect
            ripBlastStartTime = Date.now();
            enemies.forEach(enemy => {
                enemy.hp = 0; // Instant kill
                kills[enemy.type.name]++;
                logBattleEvent(`Floor ${floor} - ${enemy.type.name} destroyed!`);
                let dropPlaced = false;
                if (map[enemy.y][enemy.x] === 0) {
                    map[enemy.y][enemy.x] = 3;
                    satoshiDrops.push({x: enemy.x, y: enemy.y, sats: enemy.sats, type: enemy.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: enemy.x, y: enemy.y - 1},
                        {x: enemy.x, y: enemy.y + 1},
                        {x: enemy.x - 1, y: enemy.y},
                        {x: enemy.x + 1, y: enemy.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: enemy.sats, type: enemy.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }
                // Rune drop logic (20% for Hell Shrimp, 10% for others)
                if (Math.random() < (enemy.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (enemy.type.name === 'Shrimp' && currentTheme === 'hell') {
                        const hellShrimpRunes = ['b', 't', 'c', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[enemy.y][enemy.x] === 0) {
                        map[enemy.y][enemy.x] = 8;
                        runeDrops.push({ x: enemy.x, y: enemy.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: enemy.x, y: enemy.y - 1 },
                            { x: enemy.x, y: enemy.y + 1 },
                            { x: enemy.x - 1, y: enemy.y },
                            { x: enemy.x + 1, y: enemy.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8;
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${enemy.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
            });
            enemies = enemies.filter(e => e.hp > 0); // Remove dead enemies
            // Delay stairs placement until fire wave animation completes
            if (enemies.length === 0 && !exit && waveActive) {
                // Stairs will be placed in draw() after animation completes
            }
            p.ripBlast = false; // Disable blast after use
            needsRedraw = true;
        } else if (p.ripBlast && enemies.length === 0) {
            logBattleEvent(`Floor ${floor} - RIP Blast activated but no enemies to destroy!`);
            // Delay stairs placement until fire wave animation completes
            p.ripBlast = false; // Consume RIP even if no enemies
            needsRedraw = true;
        }
        if (enemiesSpawnedThisFloor > 0 && enemiesSpawnedThisFloor < 10 && !initialSpawnDoneThisFloor) {
            console.warn(`Only spawned ${enemiesSpawnedThisFloor} enemies due to insufficient valid blockchain data`);
        }
if (enemyCount > 0 && enemies.length > 0 && !exit) {
    if (!waveActive) {
        initialWaveSpawned = true;
        waveActive = true;
        document.getElementById('wave').textContent = wave;
        logBattleEvent(`Floor ${floor} - Wave ${wave} Started!`);
        console.log(`New wave started: wave=${wave}, enemies=${enemies.length}, waveActive=${waveActive}, initialWaveSpawned=${initialWaveSpawned}, exit=${exit ? `(${exit.x}, ${exit.y})` : 'null'}`);
    } else {
        console.log(`Additional enemies added to wave ${wave}, enemies=${enemies.length}, waveActive=${waveActive}`);
    }
    needsRedraw = true;
} else {
            console.log(`No enemies spawned, wave=${wave}, scheduling retry in ${API_INTERVAL / 1000}s`);
        }
    } catch (e) {
        console.error('fetchTxs Error:', e, e.stack);
    } finally {
        nextApiCallTime = now + API_INTERVAL;
        apiTimeoutId = setTimeout(fetchTxs, API_INTERVAL);
    }
}

function move(dir) {
    if (gameOver || splashActive) return;
    swordDir = dir;
    let nx = p.x, ny = p.y;
    let newDirection = p.anim.direction; // Default to current direction
    if (dir === 'up') {
        ny--;
        newDirection = 'back';
    }
    if (dir === 'down') {
        ny++;
        newDirection = 'front';
    }
    if (dir === 'left') {
        nx--;
        newDirection = 'left';
    }
    if (dir === 'right') {
        nx++;
        newDirection = 'right';
    }
    // Update direction even if move is blocked
    p.anim.direction = newDirection;
    if (!map[ny] || map[ny][nx] === undefined) {
        console.error('Invalid map access: nx=', nx, 'ny=', ny);
        initMap();
        needsRedraw = true;
        return;
    }
    if (enemies.some(e => e.x === nx && e.y === ny)) {
        return;
    }
    if (nx >= 0 && nx < W && ny >= 0 && ny < H && map[ny][nx] !== 1) {
        p.x = nx;
        p.y = ny;
        p.anim.frameIndex = (p.anim.frameIndex + 1) % 2; // Cycle frames
        p.anim.lastFrameTime = performance.now(); // Update frame time
        if (map[ny][nx] === 2) { 
            p.potions++; 
            map[ny][nx] = 0; 
            playWebAudioSound(sounds.pickup);
        }
        if (map[ny][nx] === 6) {
            if (currentTheme === 'paradise') {
                if (p.hp <= 36) {
                    const oldHP = p.hp;
                    p.hp = 24 + (p.hasArmor ? 12 : 0); // Full health (24 or 36 with armor)
                    logBattleEvent(`Floor ${floor} - Pond: HP restored to ${p.hp}`);
                    playWebAudioSound(sounds.pickup);
                }
                // If p.hp > 36, do nothing and continue
} else if (currentTheme === 'desert') {
    p.hp = Math.max(0, p.hp - 2);
    logBattleEvent(`Floor ${floor} - Sludge Pit: -2 HP (now ${p.hp})`);
    playWebAudioSound(sounds.hit);
    if (p.hp <= 0 && p.immortal) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
            } else if (p.hp <= 0) {
        p.hp = 0;
        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
        gameOver = true;
            }
} else if (currentTheme === 'hell') {
    p.hp = Math.max(0, p.hp - 8);
    logBattleEvent(`Floor ${floor} - Lava: -8 HP (now ${p.hp})`);
    playWebAudioSound(sounds.hit);
    if (p.hp <= 0 && p.immortal) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
            } else if (p.hp <= 0) {
        p.hp = 0;
        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
        gameOver = true;
            }
}
            updatePlayerState();
        }
        if (map[ny][nx] === 7) {
            const coinToss = Math.random() < 0.5; // 50/50 chance
            if (coinToss) {
                // Grant max health (original behavior)
                const healthGain = p.potions * 12;
                p.maxHP += healthGain;
                p.hp += healthGain;
                logBattleEvent(`Floor ${floor} - Gnome flips a coin... Heads! Traded ${p.potions} potions for +${healthGain} max HP (new max HP: ${p.hp})`);
                playWebAudioSound(sounds.heads); // Play heads.wav
            } else {
                // Remove excess health
                const currentMaxHP = p.hasArmor ? 36 : 24;
                if (p.hp > currentMaxHP) {
                    const healthLost = p.hp - currentMaxHP;
                    p.hp = currentMaxHP;
                    logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! A mischievous cackle echoes as ${healthLost} excess HP is whisked away! (HP now: ${p.hp})`);
                } else {
                    logBattleEvent(`Floor ${floor} - Gnome flips a coin... Tails! The gnome giggles but finds no excess HP to take! (HP: ${p.hp})`);
                }
                playWebAudioSound(sounds.tails); // Play tails.wav
            }
            p.potions = 0;
            map[ny][nx] = 0;
            updatePlayerState();
        }
        if (map[ny][nx] === 3) {
            const drop = satoshiDrops.find(d => d.x === nx && d.y === ny);
            if (drop) {
                satsEarned[drop.type] += drop.sats;
                map[ny][nx] = 0;
                satoshiDrops = satoshiDrops.filter(d => d !== drop);
                playWebAudioSound(sounds.pickup);
                updateSatsDisplay();
            }
        }
        if (map[ny][nx] === 4) {
            p.pickaxes++;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Pickaxe Found!`);
        }
        if (map[ny][nx] === 5) {
            if (p.hp >= 24) {
                p.hp += 12;
            } else {
                p.hp = 24 + 12;
            }
            p.hasArmor = true;
            map[ny][nx] = 0;
            playWebAudioSound(sounds.pickup);
            logBattleEvent(`Floor ${floor} - Armor Found: HP set to ${p.hp}`);
            updatePlayerState();
        }
        // Check for adjacent special tiles (type 6) and play ambient sound with cooldown
// Check for adjacent special tiles (type 6) and play ambient sound once per floor
if (currentTheme !== 'dungeon') {
    const adjacent = [
        {x: p.x, y: p.y - 1}, // Up
        {x: p.x, y: p.y + 1}, // Down
        {x: p.x - 1, y: p.y}, // Left
        {x: p.x + 1, y: p.y}  // Right
    ].filter(pos => pos.x >= 0 && pos.x < W && pos.y >= 0 && pos.y < H && map[pos.y][pos.x] === 6);
    if (adjacent.length > 0) {
        let soundKey;
        switch (currentTheme) {
            case 'hell':
                soundKey = 'lava';
                break;
            case 'desert':
                soundKey = 'quicksand';
                break;
            case 'paradise':
                soundKey = 'pond';
                break;
        }
        if (soundKey && !specialSoundsPlayedThisFloor[soundKey]) {
            playWebAudioSound(sounds[soundKey]);
            specialSoundsPlayedThisFloor[soundKey] = true;
            logBattleEvent(`Floor ${floor} - Heard ${soundKey === 'quicksand' ? 'sludge pit' : soundKey} nearby!`); // Updated to show Sludge Pit
                    }
    }
}
if (exit && p.x === exit.x && p.y === exit.y) {
    sounds.stairs.play().catch(e => console.error('Stairs sound error:', e));
    if (p.immortal) {
        p.immortal = false;
        logBattleEvent(`Floor ${floor} - HODL immortality has worn off!`);
            }
    enemiesSpawnedThisFloor = 0;
    initialSpawnDoneThisFloor = false;
    enemies = [];
    floor++;
    initialWaveSpawned = false;
    waveActive = false;
    exit = null;
    killsLog = [];
    
// Reset special sound tracking for the new floor
specialSoundsPlayedThisFloor.lava = false;
specialSoundsPlayedThisFloor.quicksand = false;
specialSoundsPlayedThisFloor.pond = false;
specialSoundsPlayedThisFloor.rune = false;

// Reset runewords to allow reactivation on new floor
p.runewords = [];

    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
        initMap();
    nextApiCallTime = null;
    const battleEvents = document.getElementById('battle-events');
    battleEvents.value = '';
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
    setTimeout(() => {
        if (!gameOver && !splashActive && floor > 0) {
            fetchTxs();
            console.log(`Triggered fetchTxs for wave ${wave} on floor ${floor}`);
        }
    }, 1000);
}

	if (map[ny][nx] === 8) {
    const rune = runeDrops.find(r => r.x === nx && r.y === ny);
    if (rune) {
        p.runes.push(rune.letter);
        map[ny][nx] = 9; // Specific rune image
        runeDrops = runeDrops.filter(r => r !== rune);
        runeDrops.push({ x: nx, y: ny, letter: rune.letter, specific: true }); // Mark as specific rune for drawing
        playWebAudioSound(sounds.pickup);
        logBattleEvent(`Floor ${floor} - Picked up Rune ${rune.letter.toUpperCase()}!`);
        checkRunewords();
    }
}

        updateFogMap(p.x, p.y);
    }
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

function moveEnemies() {
    if (gameOver || splashActive) return;
    enemies.forEach(e => {
        let dx = p.x - e.x, dy = p.y - e.y, dist = Math.abs(dx) + Math.abs(dy);
        if (dist <= 5) {
            let moves = e.type.move, steps = 0;
            while (steps < moves) {
                let nx = e.x, ny = e.y;
                if (e.type.name === 'Crab') {
                    nx += dx > 0 ? 1 : -1;
                } else if (e.type.name === 'Shrimp' || e.type.name === 'Dolphin' || e.type.name === 'Shark') {
                    if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                    else ny += dy > 0 ? 1 : -1;
                } else {
                    if (Math.abs(dx) > Math.abs(dy)) nx += dx > 0 ? 1 : -1;
                    else ny += dy > 0 ? 1 : -1;
                }
                if (
                    nx >= 0 && nx < W && ny >= 0 && ny < H && 
                    map[ny][nx] !== 1 && !(nx === p.x && ny === p.y) && 
                    !enemies.some(en => en.x === nx && en.y === ny && en !== e)
                ) {
                    e.x = nx; e.y = ny;
                } else break;
                steps++;
                dx = p.x - e.x; dy = p.y - e.y;
            }
            if (
                (e.type.name === 'Shrimp' || e.type.name === 'Crab' || e.type.name === 'Dolphin' || e.type.name === 'Shark') ?
                (Math.abs(e.x - p.x) === 1 && e.y === p.y) || (Math.abs(e.y - p.y) === 1 && e.x === p.x) :
                Math.abs(e.x - p.x) <= 1 && Math.abs(e.y - p.y) <= 1
            ) {
const damage = e.type.name === 'Whale' ? Math.ceil(p.hp / 10) : e.type.atk;
p.hp -= damage;
logBattleEvent(`Floor ${floor} - ${e.type.name} Attacks! ${damage} DMG`);
playWebAudioSound(sounds.hit);
if (p.hp <= 0 && p.immortal) {
    p.hp = 1;
    logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
    } else if (p.hp <= 0) {
    p.hp = 0;
    logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
    gameOver = true;
    }
updatePlayerState(); // Check HP and armor state after damage
            }
        }
    });
if (enemies.length === 0 && !exit && waveActive && !p.ripBlast && !ripBlastActive) {
    if (placeStairs()) {
        wave++;
        waveActive = false;
        document.getElementById('wave').textContent = wave;
        logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);
    } else {
        logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
    }
}
}

// Modified updateProjectiles function with Hell Shrimp rune drop rate changed to 20%
function updateProjectiles() {
    if (gameOver || splashActive) return;
    projectiles = projectiles.filter(proj => {
        // Only move every 50ms
        if (Date.now() - proj.lastMoveTime < 50) return true;
        
        // Calculate next position
        let nx = proj.x, ny = proj.y;
        if (proj.dir === 'up') ny--;
        if (proj.dir === 'down') ny++;
        if (proj.dir === 'left') nx--;
        if (proj.dir === 'right') nx++;
        
        // Check bounds
        if (nx < 0 || nx >= W || ny < 0 || ny >= H) {
            needsRedraw = true;
            return false;
        }
        
        // Check for wall hit before moving
        if (map[ny][nx] === 1) {
            needsRedraw = true;
            return false;
        }
        
        // Check for first enemy hit and deal damage
        let hit = enemies.find(e => e.x === nx && e.y === ny);
        if (hit) {
            const damage = Math.floor(p.atk * 0.5); // Half the damage output for shooting sword
            hit.hp -= damage;
            logBattleEvent(`Floor ${floor} - Shooting Sword hits ${hit.type.name}! ${damage} DMG (HP: ${hit.hp})`);
            playWebAudioSound(sounds.hit);
            if (hit.hp <= 0) {
                kills[hit.type.name]++;
                let dropPlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 3;
                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }
                if (!dropPlaced) {
                    // No space for satoshi drop
                }
                
                // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
                if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                        // Hell Shrimp: Use specific rune letters
                        const hellShrimpRunes = ['b', 't', 'c', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        // Regular rune drop
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[hit.y][hit.x] === 0) {
                        map[hit.y][hit.x] = 8; // Generic rune on floor
                        runeDrops.push({ x: hit.x, y: hit.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: hit.x, y: hit.y - 1 },
                            { x: hit.x, y: hit.y + 1 },
                            { x: hit.x - 1, y: hit.y },
                            { x: hit.x + 1, y: hit.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8; // Generic rune on floor
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
                
                enemies = enemies.filter(e => e !== hit);
                if (exit && enemies.length === 0) {
                    updateSatsDisplay();
                }
            }
            needsRedraw = true;
            return false; // Destroy projectile on enemy hit
        }
        
        // Update projectile position and move time
        proj.x = nx;
        proj.y = ny;
        proj.lastMoveTime = Date.now();
        needsRedraw = true;
        return true;
    });
}

let usePickaxeSword = false; // Global flag for draw
let ripBlastActive = false; // Flag for RIP blast gradient overlay effect
let ripBlastStartTime = 0; // Timestamp for RIP blast start
let columnProgress = 0; // Progress of gradient columns (0 to 1)

// Initialize gradient column overlay for RIP blast effect
function initGradientOverlay() {
    columnProgress = 0; // Start at beginning of animation
}

// Modified checkRunewords function to display 5x5 rune grid with counts
function checkRunewords() {
    // Define all possible runes
    const allRunes = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
    
    // Count occurrences of each rune, capped at 9
    const runeCounts = {};
    allRunes.forEach(rune => runeCounts[rune] = 0);
    p.runes.forEach(rune => {
        if (runeCounts[rune] < 9) {
            runeCounts[rune]++;
        }
    });
    
// Build 5x5 grid display
let displayText = '<br>'; // Start with a <br> for the first row
for (let i = 0; i < 5; i++) {
    const row = allRunes.slice(i * 5, (i + 1) * 5).map(rune => {
        const count = runeCounts[rune];
        const letter = rune.toUpperCase();
        const display = `${letter}<sup style="font-size: 0.6em;">${count}</sup>`;
        if (count > 0) {
            return display;
        }
        return `<span style="opacity: 0;">${display}</span>`;
    }).join('  '); // Two spaces for separation
    displayText += row + (i < 4 ? '<br>' : ''); // Newline except for last row
}
    
    // Wrap displayText in a span with Safari-compatible nbsp styling
    const wrappedDisplayText = `<span style="-webkit-nbsp-mode: normal;">${displayText}</span>`;
    
    // Update inventory display
    document.getElementById('runes').innerHTML = wrappedDisplayText; // Apply wrapped text to runes element
}

// Modified checkRunewordsAtFloorStart function to check for BTC, HODL, and RIP runes in any order
function checkRunewordsAtFloorStart() {
    const btcRunes = ['b', 't', 'c'];
    const hodlRunes = ['h', 'o', 'd', 'l'];
    const ripRunes = ['r', 'i', 'p'];
    let usedIndices = []; // Track indices of used runes
    let activatedRunewords = []; // Track activated runewords for display

    // Helper function to check if all required runes exist in p.runes, excluding used indices
    function hasRunes(requiredRunes, excludedIndices) {
        const runeCount = {};
        p.runes.forEach((r, i) => {
            if (!excludedIndices.includes(i)) {
                runeCount[r] = (runeCount[r] || 0) + 1;
            }
        });
        const indices = [];
        for (const rune of requiredRunes) {
            if (!runeCount[rune] || runeCount[rune] === 0) return { found: false };
            // Find the index of the first occurrence of this rune
            const index = p.runes.findIndex((r, i) => r === rune && !excludedIndices.includes(i) && !indices.includes(i));
            if (index === -1) return { found: false };
            indices.push(index);
            runeCount[rune]--;
        }
        return { found: true, indices };
    }

    // Define runewords
    const runewords = [
        { name: 'btc', runes: btcRunes, effect: () => {
            p.hp += 444;
            p.maxHP = Math.max(p.maxHP, p.hp);
            p.runewords.push('btc');
            logBattleEvent(`Floor ${floor} - Runeword BTC activated! +444 HP (now ${p.hp})`);
            updatePlayerState();
        }},
        { name: 'hodl', runes: hodlRunes, effect: () => {
            p.immortal = true;
            p.runewords.push('hodl');
            logBattleEvent(`Floor ${floor} - Runeword HODL activated! You are immortal!`);
            updatePlayerState();
        }},
        { name: 'rip', runes: ripRunes, effect: () => {
            p.ripBlast = true;
            p.runewords.push('rip');
            logBattleEvent(`Floor ${floor} - Runeword RIP activated! Incoming blast...`);
        }}
    ];

    // Check all runewords
    for (const runeword of runewords) {
        if (!p.runewords.includes(runeword.name)) {
            const result = hasRunes(runeword.runes, usedIndices);
            if (result.found) {
                runeword.effect();
                usedIndices.push(...result.indices);
                activatedRunewords.push(runeword.name.toUpperCase());
            }
        }
    }

    // Display activated runewords and play sound if any were found
    if (activatedRunewords.length > 0) {
        document.getElementById('floor-indicator').textContent = `Runeword${activatedRunewords.length > 1 ? 's' : ''} ${activatedRunewords.join(', ')} found!`;
        if (!specialSoundsPlayedThisFloor.rune) {
            playWebAudioSound(sounds.rune);
            specialSoundsPlayedThisFloor.rune = true;
        }
        setTimeout(() => {
            document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
        }, 5000);

        // Remove used runes
        usedIndices.sort((a, b) => b - a); // Sort descending to avoid index issues
        for (const index of usedIndices) {
            p.runes.splice(index, 1);
        }

        // Clear specific rune drops
        runeDrops = runeDrops.filter(r => !r.specific);
        for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
                if (map[y][x] === 9) {
                    map[y][x] = 0; // Clear specific rune tiles
                }
            }
        }
        checkRunewords(); // Update inventory display
        needsRedraw = true;
    }
}

/*
// DEBUG: Runeword testing function - comment out when not needed
function debugRuneword(runewordKey) {
    const runewordMap = {
        '1': { name: 'btc', runes: ['b', 't', 'c'] },
        '2': { name: 'hodl', runes: ['h', 'o', 'd', 'l'] },
        '3': { name: 'rip', runes: ['r', 'i', 'p'] },
        '4': { name: 'placeholder1', runes: [] },
        '5': { name: 'placeholder2', runes: [] },
        '6': { name: 'placeholder3', runes: [] },
        '7': { name: 'placeholder4', runes: [] },
        '8': { name: 'placeholder5', runes: [] },
        '9': { name: 'placeholder6', runes: [] }
    };

    const runeword = runewordMap[runewordKey];
    if (!runeword) {
        console.log(`No runeword mapped to key ${runewordKey}`);
        return;
    }

    if (runeword.runes.length === 0) {
        console.log(`Runeword ${runeword.name} is a placeholder and has no effect`);
        logBattleEvent(`Debug: Runeword ${runeword.name} is a placeholder and has no effect`);
        return;
    }

    // Add required runes to player's inventory
    p.runes = p.runes.concat(runeword.runes);
    console.log(`Debug: Added runes ${runeword.runes} for ${runeword.name}. Current runes: ${p.runes}`);
    logBattleEvent(`Debug: Added runes ${runeword.runes.join('')} for ${runeword.name}`);

    // Update inventory display
    checkRunewords();

    // Trigger runeword activation
    checkRunewordsAtFloorStart();
}
*/


// Modified attack function with Hell Shrimp rune drop rate changed to 20%
function attack() {
    if (gameOver || splashActive) return;
    swordActive = true;
    swordStart = Date.now();
    sounds.attack.play().catch(e => console.error('Attack sound error:', e));
    // Update player direction
    let newDirection = p.anim.direction;
    if (swordDir === 'up') newDirection = 'back';
    if (swordDir === 'down') newDirection = 'front';
    if (swordDir === 'left') newDirection = 'left';
    if (swordDir === 'right') newDirection = 'right';
    p.anim.direction = newDirection;
    const initialPickaxes = p.pickaxes;
    
    // Check for enemy or wall one tile away in swordDir
    let sx = p.x, sy = p.y;
    if (swordDir === 'up') sy--;
    if (swordDir === 'down') sy++;
    if (swordDir === 'left') sx--;
    if (swordDir === 'right') sx++;
    const isEnemyNearby = enemies.some(e => e.x === sx && e.y === sy);
    const isWallNearby = sx >= 0 && sx < W && sy >= 0 && sy < H && map[sy][sx] === 1;
    
    if (initialPickaxes > 0 || isEnemyNearby || isWallNearby) {
        usePickaxeSword = initialPickaxes > 0;
        let hit = enemies.find(e => e.x === sx && e.y === sy);
        if (hit) {
            const damage = p.atk; // Remove armor bonus
            hit.hp -= damage;
            logBattleEvent(`Floor ${floor} - ${hit.type.name} hit for ${damage} DMG (HP: ${hit.hp})`);
            playWebAudioSound(sounds.hit);
            if (hit.hp <= 0) {
                kills[hit.type.name]++;
                let dropPlaced = false;
                if (map[hit.y][hit.x] === 0) {
                    map[hit.y][hit.x] = 3;
                    satoshiDrops.push({x: hit.x, y: hit.y, sats: hit.sats, type: hit.type.name});
                    dropPlaced = true;
                } else {
                    const adjacent = [
                        {x: hit.x, y: hit.y - 1},
                        {x: hit.x, y: hit.y + 1},
                        {x: hit.x - 1, y: hit.y},
                        {x: hit.x + 1, y: hit.y}
                    ];
                    for (const pos of adjacent) {
                        const nx = pos.x, ny = pos.y;
                        if (
                            nx >= 0 && nx < W && ny >= 0 && ny < H &&
                            map[ny][nx] === 0 &&
                            !enemies.some(e => e.x === nx && e.y === ny)
                        ) {
                            map[ny][nx] = 3;
                            satoshiDrops.push({x: nx, y: ny, sats: hit.sats, type: hit.type.name});
                            dropPlaced = true;
                            break;
                        }
                    }
                }
                if (!dropPlaced) {
                    // No space for satoshi drop
                }
                
                // Rune drop logic (20% chance for Hell Shrimp, 10% for others)
                if (Math.random() < (hit.type.name === 'Shrimp' && currentTheme === 'hell' ? 0.2 : 0.1)) {
                    let runeLetter;
                    if (hit.type.name === 'Shrimp' && currentTheme === 'hell') {
                        // Hell Shrimp: Use specific rune letters
                        const hellShrimpRunes = ['b', 't', 'c', 'h', 'o', 'd', 'l'];
                        runeLetter = hellShrimpRunes[Math.floor(Math.random() * hellShrimpRunes.length)];
                    } else {
                        // Regular rune drop
                        const runeLetters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'y', 'z', 'æ', 'ø'];
                        runeLetter = runeLetters[Math.floor(Math.random() * runeLetters.length)];
                    }
                    let runePlaced = false;
                    if (map[hit.y][hit.x] === 0) {
                        map[hit.y][hit.x] = 8; // Generic rune on floor
                        runeDrops.push({ x: hit.x, y: hit.y, letter: runeLetter });
                        runePlaced = true;
                    } else {
                        const adjacent = [
                            { x: hit.x, y: hit.y - 1 },
                            { x: hit.x, y: hit.y + 1 },
                            { x: hit.x - 1, y: hit.y },
                            { x: hit.x + 1, y: hit.y }
                        ];
                        for (const pos of adjacent) {
                            const nx = pos.x, ny = pos.y;
                            if (
                                nx >= 0 && nx < W && ny >= 0 && ny < H &&
                                map[ny][nx] === 0 &&
                                !enemies.some(e => e.x === nx && e.y === ny)
                            ) {
                                map[ny][nx] = 8; // Generic rune on floor
                                runeDrops.push({ x: nx, y: ny, letter: runeLetter });
                                runePlaced = true;
                                break;
                            }
                        }
                    }
                    if (runePlaced) {
                        logBattleEvent(`Floor ${floor} - ${hit.type.name} dropped a mysterious rune!`);
                        playWebAudioSound(sounds.rune_drop);
                    }
                }
                
                enemies = enemies.filter(en => en !== hit);
                if (exit && enemies.length === 0) {
                    updateSatsDisplay();
                }
            }
        } else if (initialPickaxes > 0 && isWallNearby) {
            p.pickaxes--;
            sounds.secret.play().catch(e => console.error('Secret sound error:', e));
            logBattleEvent(`Floor ${floor} - Wall Broken!`);
            createSecretRoom(sx, sy, p.x, p.y, swordDir);
        }
    } else if (p.hp >= 24 && projectiles.length === 0) {
        let sx = p.x, sy = p.y; // Start at player's position
        if (sx >= 0 && sx < W && sy >= 0 && sy < H) {
            projectiles.push({ x: sx, y: sy, dir: swordDir, startTime: Date.now(), lastMoveTime: Date.now() });
            sounds.shoot_sword.pause();
            sounds.shoot_sword.currentTime = 0;
            sounds.shoot_sword.play().catch(e => console.error('Shoot sword sound error:', e));
        }
    }
    moveEnemies();
    needsRedraw = true;
    setTimeout(() => {
        swordActive = false;
        usePickaxeSword = false;
        needsRedraw = true;
    }, 200);
}

function usePotion() {
    if (gameOver || splashActive || p.potions <= 0) return;
    if (p.hp >= 24) {
        logBattleEvent(`Floor ${floor} - Potion Returned: HP already at ${p.hp}!`);
        sounds.potion.play().catch(e => console.error('Potion sound error:', e));
        return; // Refund potion by not decrementing p.potions
    }
    p.potions--;
    const oldHP = p.hp;
    p.hp = Math.min(24, p.hp + 12);
    logBattleEvent(`Floor ${floor} - Potion Used: +${p.hp - oldHP} HP (now ${p.hp})`);
    sounds.potion.play().catch(e => console.error('Potion sound error:', e));
    moveEnemies();
    updatePlayerState();
    needsRedraw = true;
}

function restart() {
    floor = 1;
    currentTheme = 'dungeon'; // Reset to default theme
    p.maxHP = 24; // Reset max HP to default
    document.documentElement.style.setProperty('--text-color', '#ff8c00'); // Reset to orange
    document.documentElement.style.setProperty('--text-shadow', '-1px -1px 0 #000000, 1px -1px 0 #000000, -1px 1px 0 #000000, 1px 1px 0 #000000'); // Reset outlined font
    // Force re-render of text color
    document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator').forEach(el => {
        el.style.color = '#ff8c00';
    });
    wave = 1;
    document.getElementById('wave').textContent = wave;
    p.hp = 24;
    p.potions = 0;
    p.pickaxes = 0;
    p.hasArmor = false;
    p.x = 2;
    p.y = 2;
    p.atk = 2;
    enemies = [];
    map = [];
    rooms = [];
    exit = null;
    gameOver = false;
    gameOverSoundPlayed = false;
    autoSubmitTriggered = false;
    enemiesSpawnedThisFloor = 0;
    initialSpawnDoneThisFloor = false;
    initialWaveSpawned = false;
    waveActive = false;
    nextApiCallTime = null;
    whaleHashIds = ['Whale Transactions:'];
    battleLog = [];
    killsLog = [];
    satsEarned = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    kills = {Shrimp: 0, Crab: 0, Squid: 0, Dolphin: 0, Shark: 0, Whale: 0};
    satoshiDrops = [];
    swordDir = 'right';
    swordActive = false;
    swordStart = 0;
    fogMap = [];
    scoreSubmitted = false;
    hasPlayedOnce = true; // Ensure Enter key is enabled for splash screen after restart
    populateNameList();
    projectiles = []; // Reset projectiles
    runeDrops = [];
    p.runes = [];
    p.runewords = [];
    p.immortal = false;
    p.ripBlast = false; // Reset RIP blast flag
    document.getElementById('runes').textContent = 'None';

    document.getElementById('whale-hash-ids').innerHTML = whaleHashIds.join('<br>');
    document.getElementById('battle-events').value = '';
    document.getElementById('floor-indicator').textContent = `Floor ${floor}`;
    document.getElementById('wave').textContent = wave;
    document.getElementById('health').textContent = p.hp;
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('pickaxes').textContent = p.pickaxes;
    document.getElementById('sats').textContent = '0';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('submit-score').style.display = 'none';
    document.getElementById('view-leaderboard').style.display = 'none';
    document.getElementById('restart-game').style.display = 'none';
    document.getElementById('username-input').value = '';
    document.getElementById('leaderboard-output').textContent = '';
    document.getElementById('leaderboard-output').style.display = 'none';
    document.getElementById('submit-score').disabled = false;
    document.getElementById('submit-score').style.background = '#ff8c00';
    document.getElementById('splash-screen').style.display = 'block';
    const battleEvents = document.getElementById('battle-events');
    battleEvents.style.transform = 'translateX(-100%)';
    battleEvents.style.opacity = '0';
    splashActive = true;

    sounds.music.pause();
    sounds.music.currentTime = 0;

    if (apiTimeoutId) {
        clearTimeout(apiTimeoutId);
        apiTimeoutId = null;
    }

    resetSplashScreen();
    initMap();
    updateSatsDisplay();
    needsRedraw = true;
    }

function draw() {
    if (!map?.[0] || !p || !enemies || !rooms?.length || !fogMap?.[0]) {
        console.error('Invalid state: map=', map, 'p=', p, 'enemies=', enemies, 'rooms=', rooms, 'fogMap=', fogMap);
        initMap();
        return;
    }
    c.fillStyle = splashActive ? '#F7931A' : '#000';
    c.fillRect(0, 0, W * S, H * S);
    if (gameOver) {
        const gameOverCanvas = document.getElementById('game-over-canvas').getContext('2d');
        gameOverCanvas.clearRect(0, 0, 320, 320);
        gameOverCanvas.fillStyle = '#000';
        gameOverCanvas.fillRect(0, 0, 320, 320);
        const scale = window.innerWidth <= 700 ? 1.5 : 2;
        const gw = 128 * scale, gh = 32 * scale;
        const offsetY = (Math.sin(Date.now() / 500) * 10);
        gameOverCanvas.drawImage(assets.gameOver, (320 - gw) / 2, (320 - gh) / 2 + offsetY, gw, gh);
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('submit-score').style.display = 'block';
        document.getElementById('view-leaderboard').style.display = 'block';
        document.getElementById('restart-game').style.display = 'block';
        return;
    }
    if (splashActive) { needsRedraw = false; return; }

    const radius = 4;
    // Draw walls first
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] === 1) c.drawImage(assets.themes[currentTheme].wall, x * S, y * S, S, S);
    }
    // Draw floors, items, stairs, and runes
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
        const isVisible = fogMap[y][x] === 1 || dist <= radius || map[y][x] === 1;
        if (isVisible && map[y][x] !== 1) {
            c.drawImage(assets.themes[currentTheme].floor, x * S, y * S, S, S);
            if (map[y][x] === 2) c.drawImage(assets.potion, x * S, y * S, S, S);
            if (map[y][x] === 3) c.drawImage(assets.bitcoin, x * S, y * S, S, S);
            if (map[y][x] === 4) c.drawImage(assets.pickaxe, x * S, y * S, S, S);
            if (map[y][x] === 5) c.drawImage(assets.armor, x * S, y * S, S, S);
            if (map[y][x] === 6 && currentTheme !== 'dungeon') c.drawImage(assets.themes[currentTheme].special, x * S, y * S, S, S);
            if (map[y][x] === 7) c.drawImage(assets.gnome, x * S, y * S, S, S);
            if (map[y][x] === 8) c.drawImage(assets.runes.on_floor, x * S, y * S, S, S);
            if (map[y][x] === 9) {
                const rune = runeDrops.find(r => r.x === x && r.y === y && r.specific);
                if (rune && assets.runes[rune.letter]) {
                    c.globalAlpha = 0.9; // Apply 10% transparency
                    c.drawImage(assets.runes[rune.letter], x * S, y * S, S, S);
                    c.globalAlpha = 1; // Restore full opacity
                }
            }
            if (exit && exit.x === x && exit.y === y) c.drawImage(assets.stairs, x * S, y * S, S, S);
        }
    }
    // Draw projectiles, skipping player's position
    projectiles.forEach(proj => {
        if (proj.x >= 0 && proj.x < W && proj.y >= 0 && proj.y < H && 
            (proj.x !== p.x || proj.y !== p.y)) {
            c.save();
            c.translate(proj.x * S + S / 2, proj.y * S + S / 2);
            if (proj.dir === 'up') c.rotate(-Math.PI / 2);
            if (proj.dir === 'down') c.rotate(Math.PI / 2);
            if (proj.dir === 'left') c.rotate(Math.PI);
            c.drawImage(assets.shoot_sword, -S / 2, -S / 2, S, S);
            c.restore();
        }
    });
    // Draw player
    if (p.x >= 0 && p.x < W && p.y >= 0 && p.y < H && map[p.y][p.x] !== 1) {
        const now = performance.now();
        if (now - p.anim.lastFrameTime >= p.anim.frameDuration) {
            p.anim.frameIndex = (p.anim.frameIndex + 1) % 2;
            p.anim.lastFrameTime = now;
        }
        const direction = p.anim.direction;
        const baseDirection = direction === 'left' ? 'right' : direction;
        const frameKey = p.hasArmor ? `armor_${baseDirection}` : baseDirection;
        const frame = p.anim.frames[frameKey][p.anim.frameIndex];
        c.save();
        if (direction === 'left') {
            c.translate((p.x + 1) * S, p.y * S);
            c.scale(-1, 1);
            c.drawImage(frame, 0, 0, S, S);
        } else {
            c.drawImage(frame, p.x * S, p.y * S, S, S);
        }
        c.restore();
    }
    // Draw sword or pickaxe-sword
    if (swordActive && Date.now() - swordStart < 200) {
        let sx = p.x, sy = p.y;
        if (swordDir === 'up') sy--;
        if (swordDir === 'down') sy++;
        if (swordDir === 'left') sx--;
        if (swordDir === 'right') sx++;
        if (sx >= 0 && sx < W && sy >= 0 && sy < H && Math.sqrt((sx - p.x) ** 2 + (sy - p.y) ** 2) <= radius) {
            c.save();
            c.translate(sx * S + S / 2, sy * S + S / 2);
            if (swordDir === 'up') c.rotate(-Math.PI / 2);
            if (swordDir === 'down') c.rotate(Math.PI / 2);
            if (swordDir === 'left') c.rotate(Math.PI);
            c.drawImage(usePickaxeSword ? assets.pickaxe_sword : assets.sword, -S / 2, -S / 2, S, S);
            c.restore();
        }
    }
    
// Draw gradient column overlay for RIP blast
if (ripBlastActive && Date.now() - ripBlastStartTime < 3000) {
    if (columnProgress === 0) {
        initGradientOverlay(); // Initialize overlay on first draw
    }
    c.save();
    c.globalCompositeOperation = 'screen'; // Subtle glow for visibility
    const elapsed = Date.now() - ripBlastStartTime;
    columnProgress = elapsed / 2000; // 0 to 1 over 2 seconds
    const columnWidth = 20; // Width of each column in pixels
    const numColumns = Math.ceil(W * S / columnWidth) + 1; // Cover entire width
    for (let i = 0; i < numColumns; i++) {
        const x = i * columnWidth + columnProgress * W * S; // Sweep left to right
        if (x > W * S) continue; // Skip columns off-screen
        const gradient = c.createLinearGradient(x, 0, x + columnWidth, 0);
        gradient.addColorStop(0, 'rgba(255, 100, 0, 0)'); // Transparent edge
        gradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.4)'); // Smudged orange center
        gradient.addColorStop(1, 'rgba(255, 100, 0, 0)'); // Transparent edge
        c.fillStyle = gradient;
        c.fillRect(x, 0, columnWidth, H * S); // Draw full-height column
    }
    c.restore();
    needsRedraw = true; // Ensure continuous redraw during effect
} else if (ripBlastActive) {
    ripBlastActive = false; // End effect after 3 seconds
    columnProgress = 0;
    if (enemies.length === 0 && !exit) {
        if (placeStairs()) {
            wave++;
            waveActive = false;
            document.getElementById('wave').textContent = wave;
            logBattleEvent(`Floor ${floor} - Wave ${wave - 1} cleared! Stairs appeared!`);
        } else {
            logBattleEvent(`Floor ${floor} - Wave ${wave} cleared, but stairs placement failed!`);
        }
    }
    needsRedraw = true;
}

    // Draw fog overlay
    for (let y = 0; y < H; y++) for (let x = 0; x < W; x++) {
        if (map[y][x] !== 1 && !fogMap[y][x]) {
            c.fillStyle = 'rgba(0, 0, 0, 0.7)';
            c.fillRect(x * S, y * S, S, S);
        }
    }
// Draw enemies with theme-based color overlays, preserving transparent backgrounds
enemies.forEach(e => {
    if (e.x >= 0 && e.x < W && e.y >= 0 && e.y < H) {
        const dist = Math.sqrt((e.x - p.x) ** 2 + (e.y - p.y) ** 2);
        const isVisible = fogMap[e.y][e.x] === 1 || dist <= radius;
        c.save();
        // Create a temporary canvas for rendering
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = S;
        tempCanvas.height = S;
        const tempCtx = tempCanvas.getContext('2d');
        
        // Handle animation for enemies with anim property (e.g., Shrimp)
        let img;
        if (e.type.anim) {
            const now = performance.now();
            if (now - e.type.anim.lastFrameTime >= e.type.anim.frameDuration) {
                e.type.anim.frameIndex = (e.type.anim.frameIndex + 1) % e.type.anim.frames.length;
                e.type.anim.lastFrameTime = now;
            }
            // Use Hell Shrimp frames if theme is hell, enemy is Shrimp, and visible
            if (e.type.name === 'Shrimp' && currentTheme === 'hell' && isVisible && e.type.anim.hellFrames) {
                img = e.type.anim.hellFrames[e.type.anim.frameIndex];
            } else {
                img = e.type.anim.frames[e.type.anim.frameIndex];
            }
        } else {
            img = e.type.img;
        }
        
        // Draw the sprite on the temporary canvas
        tempCtx.drawImage(img, 0, 0, S, S);
        
        // Apply theme-based effects
        if (isVisible) {
            if (currentTheme === 'desert') {
                // Create a white-ish silhouette with slight transparency for desert theme
                const imageData = tempCtx.getImageData(0, 0, S, S);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) { // Non-transparent pixel
                        data[i] = 255;     // Red
                        data[i + 1] = 242; // Green
                        data[i + 2] = 230; // Blue
                        data[i + 3] = Math.round(0.95 * 255); // 95% opacity
                    }
                }
                tempCtx.putImageData(imageData, 0, 0);
            } else if (currentTheme === 'hell') {
                // Apply red tint for hell theme
                tempCtx.globalCompositeOperation = 'source-atop';
                tempCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                tempCtx.fillRect(0, 0, S, S);
            } else if (currentTheme === 'paradise') {
                // Apply purple tint for paradise theme
                tempCtx.globalCompositeOperation = 'source-atop';
                tempCtx.fillStyle = 'rgba(153, 102, 255, 0.4)';
                tempCtx.fillRect(0, 0, S, S);
            }
        } else {
            // Outside fog of war, draw original sprite to show red eyes
            tempCtx.clearRect(0, 0, S, S);
            tempCtx.drawImage(img, 0, 0, S, S);
        }
        
        // Draw the processed sprite to the main canvas
        c.drawImage(tempCanvas, e.x * S, e.y * S, S, S);
        c.restore();
    }
});
    // Draw low-health warning border
    if (p.hp <= 4 && !gameOver && !splashActive) {
        const alpha = Math.min(0.9, Math.pow(Math.sin(Date.now() / 500) + 1, 0.5) - 0.5); // Smoother pulse
        c.strokeStyle = `rgba(255, 0, 0, ${alpha})`; // Red border for hp <= 4
        c.lineWidth = Math.max(5, window.innerWidth > 700 ? 10 : 5); // Responsive thickness
        c.beginPath();
        // Top border
        c.moveTo(0, 0);
        c.lineTo(W * S, 0);
        // Right border
        c.moveTo(W * S, 0);
        c.lineTo(W * S, H * S);
        // Bottom border
        c.moveTo(W * S, H * S);
        c.lineTo(0, H * S);
        // Left border
        c.moveTo(0, H * S);
        c.lineTo(0, 0);
        c.stroke();
    } else if (p.hp > 4 && p.hp < 9 && !gameOver && !splashActive) {
        const alpha = Math.min(0.9, Math.pow(Math.sin(Date.now() / 500) + 1, 0.5) - 0.5); // Same pulsing effect
        c.strokeStyle = `rgba(255, 165, 0, ${alpha})`; // Bitcoin orange border for 4 < hp < 13
        c.lineWidth = Math.max(5, window.innerWidth > 700 ? 10 : 5);
        c.beginPath();
        // Draw the same border as above
        c.moveTo(0, 0);
        c.lineTo(W * S, 0);
        c.moveTo(W * S, 0);
        c.lineTo(W * S, H * S);
        c.moveTo(W * S, H * S);
        c.lineTo(0, H * S);
        c.moveTo(0, H * S);
        c.lineTo(0, 0);
        c.stroke();
    }
    document.getElementById('potions').textContent = p.potions;
    document.getElementById('health').textContent = Math.max(0, p.hp);
    document.getElementById('pickaxes').textContent = p.pickaxes;
    needsRedraw = false;
}

function gameLoop(timestamp) {
    if (!map?.[0] || !p || !enemies || !rooms?.length) {
        console.error('Invalid state');
        initMap();
        needsRedraw = true;
    }
    if (gameOver) {
        sounds.music.pause();
        sounds.music.currentTime = 0;
        if (!gameOverSoundPlayed) {
            sounds.gameover.play().catch(e => console.error('Gameover sound error:', e));
            gameOverSoundPlayed = true;
        }
        document.getElementById('health').textContent = 0;
        // Reset text color to Bitcoin orange for game-over screen
        document.documentElement.style.setProperty('--text-color', '#ff8c00');
        document.querySelectorAll('#whale-log, #whale-hash-ids a, #battle-log, #battle-log textarea, #inventory, #floor-indicator, #leaderboard-output, #username-input').forEach(el => {
            el.style.color = '#ff8c00';
        });
        // Auto-submit score with random name from names array only if gamepad is connected
        if (!scoreSubmitted && gamepadIndex !== null && !autoSubmitTriggered) {
            autoSubmitTriggered = true;
            setTimeout(() => {
                document.getElementById('username-input').value = names[Math.floor(Math.random() * names.length)];
                                submitScore();
            }, 1000); // delay to ensure UI is rendered
        }
        needsRedraw = true;
    }
    updateProjectiles();
    if ((needsRedraw || p.hp <= 8) && !splashActive) draw();
if (p.hp <= 0 && !gameOver) {
    if (p.immortal) {
        p.hp = 1;
        logBattleEvent(`Floor ${floor} - HODL immortality prevents death! HP set to 1`);
                updatePlayerState();
    } else {
        p.hp = 0;
        logBattleEvent(`Floor ${floor} - Hero Fell! Reached Floor ${floor}`);
        gameOver = true;
    }
}
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
        if (splashActive && !hasPlayedOnce) {
                        return; // Block Enter on initial splash screen
        }
        if (splashActive && hasPlayedOnce) {
                        const startButton = document.getElementById('start-button');
            startButton.style.background = '#00b7ef'; // Mimic :hover color
            setTimeout(() => {
                startButton.style.background = '#00e8d8'; // Revert to original color
            }, 200); // Short duration to simulate tap
            preloadSounds(); // Initialize all sounds except music
            if (!musicMuted) {
                sounds.music.pause(); // Ensure clean state
                sounds.music.currentTime = 0;
                sounds.music.play().then(() => {
                                    }).catch(e => console.error('Music play failed on Enter:', e));
            }
            fadeSplash();
            setTimeout(() => {
                if (!gameOver && !splashActive) {
                    fetchTxs();
                    lastUpdate = Date.now();
                    console.log('Initial fetchTxs triggered after splash via Enter, wave=', wave);
                }
            }, 2000); // Match delay in start-button and startGame
            return;
        }
        if (gameOver && hasPlayedOnce) {
                        restart();
            return;
        }
    }
    if (gameOver || splashActive) return;

     /*
    // DEBUG: Runeword testing with keys 1-9 - comment out when not needed
    if (['1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(e.key)) {
        debugRuneword(e.key);
        needsRedraw = true;
        return;
    }
    */

    // Handle movement and actions
    let moveDir = null;
    if (e.key === 'ArrowUp') {
        e.preventDefault();
        moveDir = 'up';
        pendingKeyDir = 'up';
    } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        moveDir = 'down';
        pendingKeyDir = 'down';
    } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        moveDir = 'left';
        pendingKeyDir = 'left';
    } else if (e.key === 'ArrowRight') {
        e.preventDefault();
        moveDir = 'right';
        pendingKeyDir = 'right';
    } else if (e.key === 'a') {
        attack();
    } else if (e.key === 'd') {
        usePotion();
    }

    // Process movement: instant on first press, 50ms cap for all subsequent moves
    if (moveDir) {
        const now = Date.now();
        if (!isKeyHeld || now - lastKeyMoveTime >= 50) {
            move(moveDir);
            lastKeyMoveTime = now;
            isKeyHeld = true;
        }
    }
});

// Clear pending direction and key held state on release
document.addEventListener('keyup', e => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        pendingKeyDir = null;
        isKeyHeld = false;
    }
});

document.getElementById('game-over').addEventListener('click', (event) => {
    if (
        gameOver &&
        !document.getElementById('username-input').contains(event.target) &&
        !document.getElementById('submit-score').contains(event.target) &&
        !document.getElementById('view-leaderboard').contains(event.target) &&
        !document.getElementById('restart-game').contains(event.target) &&
        !document.getElementById('leaderboard-output').contains(event.target)
    ) {
        // No action on canvas click; restart only via button
    }
});

        initMap();
        updateSatsDisplay();
        populateNameList();
        requestAnimationFrame(gameLoop);
        
document.querySelectorAll('#dpad button').forEach(button => {
    let touchMovementTimer = null;
    let lastTouchMoveTime = 0;
    let isMoving = false;

    button.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.add('pressed'); // Add visual feedback
        if (!isMoving && !splashActive && !gameOver) {
            isMoving = true;
            const dir = button.id; // 'up', 'left', 'right', 'down'
            // Immediate move if 200ms have passed since last move
            if (Date.now() - lastTouchMoveTime >= 200) {
                move(dir);
                lastTouchMoveTime = Date.now();
            }
            // Start continuous movement
            touchMovementTimer = setInterval(() => {
                if (!splashActive && !gameOver && isMoving) {
                    const now = Date.now();
                    if (now - lastTouchMoveTime >= 200) {
                        move(dir);
                        lastTouchMoveTime = now;
                    }
                }
            }, 200); // Move every 200ms
        }
    }, { passive: false });

    button.addEventListener('touchend', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.remove('pressed'); // Remove visual feedback
        if (touchMovementTimer) {
            clearInterval(touchMovementTimer);
            touchMovementTimer = null;
        }
        isMoving = false;
        lastTouchMoveTime = 0;
    }, { passive: false });

    button.addEventListener('touchcancel', (e) => {
        e.preventDefault(); // Prevent scrolling
        e.stopPropagation(); // Stop event bubbling
        button.classList.remove('pressed'); // Remove visual feedback
        if (touchMovementTimer) {
            clearInterval(touchMovementTimer);
            touchMovementTimer = null;
        }
        isMoving = false;
        lastTouchMoveTime = 0;
    }, { passive: false });
});

//////////////////////
// Gamepad support //
////////////////////
let gamepadIndex = null; // Track connected gamepad
let lastButtonsState = []; // Track previous button states
let lastAxesState = { axis0: 0, axis1: 0 }; // Track previous D-pad axis states
let lastStartPressTime = 0; // Debounce Start button
const DEBOUNCE_MS = 200; // Debounce interval
const GAMEPAD_POLL_INTERVAL = 16; // Poll at ~60fps
let lastGamepadPollTime = 0; // Throttle polling
let movementTimer = null; // Timer for continuous movement
let currentMoveDir = null; // Track current movement direction
let lastMoveTime = 0; // Track last move to enforce 200ms interval
let pendingMove = false; // Flag to prevent overlapping moves
let gamepadPollingActive = false; // Track if gamepad polling is enabled
let hasPlayedOnce = false; // Track if player has played at least one game

// Handle gamepad connection
window.addEventListener("gamepadconnected", (e) => {
    gamepadIndex = e.gamepad.index;
        lastButtonsState = new Array(e.gamepad.buttons.length).fill(false);
    lastGamepadPollTime = performance.now();
    // Only start polling after user interaction (start button)
    if (!splashActive) {
        gamepadPollingActive = true;
        updateGamepad(); // Start polling
    } else {
            }
});

// Handle gamepad disconnection
window.addEventListener("gamepaddisconnected", (e) => {
        gamepadIndex = null;
    lastButtonsState = [];
    gamepadPollingActive = false;
    if (movementTimer) {
        clearInterval(movementTimer);
        movementTimer = null;
        currentMoveDir = null;
        lastMoveTime = 0;
        pendingMove = false;
            }
});

// Start game function for splash screen
function startGame() {
    if (!splashActive) {
                return;
    }
        const startButton = document.getElementById('start-button');
    startButton.style.background = '#00b7ef'; // Mimic hover
    setTimeout(() => {
        startButton.style.background = '#00e8d8'; // Revert
    }, 200);
    // Resume AudioContext
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
                    }).catch(e => console.error('Failed to resume AudioContext:', e));
    }
    preloadSounds(); // Preload sounds after user interaction
    if (!musicMuted) {
        sounds.music.pause();
        sounds.music.currentTime = 0;
        sounds.music.play().catch(e => console.error('Music play failed on gamepad START:', e));
    }
    fadeSplash();
    // Start gamepad polling if gamepad is connected
    if (gamepadIndex !== null) {
        gamepadPollingActive = true;
        updateGamepad();
            }
    hasPlayedOnce = true; // Mark that the player has started a game
    // Ensure fetchTxs is triggered after splash fade
    setTimeout(() => {
        if (!gameOver && !splashActive && floor > 0) {
            console.log('Post-splash fetchTxs triggered: floor=', floor, 'wave=', wave);
            fetchTxs();
        } else {
            console.log('Post-splash fetchTxs skipped: gameOver=', gameOver, 'splashActive=', splashActive, 'floor=', floor);
        }
    }, 2000); // Match original start-button delay
}

// Modify start-button click handler to enable gamepad polling
document.getElementById('start-button').addEventListener('click', () => {
    if (splashActive) {
                // Resume AudioContext
        if (audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
                            }).catch(e => console.error('Failed to resume AudioContext:', e));
        }
        preloadSounds();
        // Preload player animation frames
        const imagesToLoad = [
            p.anim.frames.front[0], p.anim.frames.front[1],
            p.anim.frames.back[0], p.anim.frames.back[1],
            p.anim.frames.right[0], p.anim.frames.right[1],
            p.anim.frames.armor_front[0], p.anim.frames.armor_front[1],
            p.anim.frames.armor_back[0], p.anim.frames.armor_back[1],
            p.anim.frames.armor_right[0], p.anim.frames.armor_right[1]
        ];
        let loadedCount = 0;
        imagesToLoad.forEach(img => {
            if (img.complete) {
                loadedCount++;
                if (loadedCount === imagesToLoad.length) {
                                    }
            } else {
                img.onload = () => {
                    loadedCount++;
                    if (loadedCount === imagesToLoad.length) {
                                            }
                };
                img.onerror = () => console.error(`Failed to load image: ${img.src}`);
            }
        });
        if (!musicMuted) {
            sounds.music.pause();
            sounds.music.currentTime = 0;
            sounds.music.play().then(() => {
                            }).catch(e => console.error('Music play failed on START:', e));
        }
        fadeSplash();
        // Start gamepad polling if gamepad is connected
        if (gamepadIndex !== null) {
            gamepadPollingActive = true;
            updateGamepad();
                    }
        hasPlayedOnce = true; // Mark that the player has started a game
        setTimeout(() => {
            if (!gameOver && !splashActive) {
                fetchTxs();
                lastUpdate = Date.now();
                console.log('Initial fetchTxs triggered after splash, wave=', wave);
            }
        }, 2000);
    }
});

// Poll gamepad state
function updateGamepad(timestamp) {
    if (gamepadIndex === null || !gamepadPollingActive) {
        return; // Stop polling if no gamepad or not active
    }
    const now = performance.now();
    if (now - lastGamepadPollTime < GAMEPAD_POLL_INTERVAL) {
        requestAnimationFrame(updateGamepad);
        return;
    }
    lastGamepadPollTime = now;
    const gamepad = navigator.getGamepads()[gamepadIndex];
    if (!gamepad) {
                gamepadIndex = null;
        gamepadPollingActive = false;
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
            currentMoveDir = null;
            lastMoveTime = 0;
            pendingMove = false;
                    }
        return;
    }

    // Handle buttons (A=0, B=1, Select=2, Start=3)
    const buttons = gamepad.buttons;
    const nowTime = Date.now();

    // A Button (0) - usePotion
    if (buttons[0].pressed && !lastButtonsState[0] && !splashActive && !gameOver) {
        usePotion();
            }

    // B Button (1) - attack
    if (buttons[1].pressed && !lastButtonsState[1] && !splashActive && !gameOver) {
        attack();
            }

    // Select Button (2) - toggleMute
    if (buttons[2].pressed && !lastButtonsState[2]) {
        toggleMute();
            }

    // Start Button (3) - startGame or restart
    if (buttons[3].pressed && !lastButtonsState[3] && nowTime - lastStartPressTime > DEBOUNCE_MS) {
        if (splashActive) {
            startGame();
        } else if (gameOver) {
            restart();
                    }
        lastStartPressTime = nowTime;
    }

    // Update button states
    lastButtonsState = buttons.map(b => b.pressed);

    // Handle D-pad (Axes 0 and 1)
    const axis0 = gamepad.axes[0]; // Left/Right
    const axis1 = gamepad.axes[1]; // Up/Down
    const deadZone = 0.2; // Ignore small axis movements

    // Determine current direction
    let newMoveDir = null;
    if (!splashActive && !gameOver) {
        if (currentMoveDir && !pendingMove) {
            // Continue in current direction if still held
            if (
                (currentMoveDir === 'left' && axis0 < -deadZone) ||
                (currentMoveDir === 'right' && axis0 > deadZone) ||
                (currentMoveDir === 'up' && axis1 < -deadZone) ||
                (currentMoveDir === 'down' && axis1 > deadZone)
            ) {
                newMoveDir = currentMoveDir;
            }
        } else if (!pendingMove) {
            // Select new direction: prioritize axis0 (left/right) if both active
            if (Math.abs(axis0) > deadZone) {
                newMoveDir = axis0 > 0 ? 'right' : 'left';
            } else if (Math.abs(axis1) > deadZone) {
                newMoveDir = axis1 > 0 ? 'down' : 'up';
            }
        }
    }

    // Handle continuous movement
    if (newMoveDir && newMoveDir !== currentMoveDir && !pendingMove) {
        // New direction: clear old timer and start new one
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
                    }
        // Only move if 200ms have passed since last move
        if (nowTime - lastMoveTime >= 200) {
            pendingMove = true;
            move(newMoveDir);
            lastMoveTime = nowTime;
                        pendingMove = false;
        }
        movementTimer = setInterval(() => {
            if (!splashActive && !gameOver && !pendingMove) {
                const intervalTime = Date.now();
                if (intervalTime - lastMoveTime >= 200) {
                    pendingMove = true;
                    move(newMoveDir);
                    lastMoveTime = intervalTime;
                                        pendingMove = false;
                }
            }
        }, 200); // Move every 200ms
        currentMoveDir = newMoveDir;
    } else if (!newMoveDir && currentMoveDir) {
        // D-pad released: clear timer
        if (movementTimer) {
            clearInterval(movementTimer);
            movementTimer = null;
                    }
        currentMoveDir = null;
        lastMoveTime = 0;
        pendingMove = false;
    }

    // Update axis states
    lastAxesState.axis0 = Math.abs(axis0) > deadZone ? axis0 : 0;
    lastAxesState.axis1 = Math.abs(axis1) > deadZone ? axis1 : 0;

    // Continue polling
    requestAnimationFrame(updateGamepad);
}
    </script>
</body>
</html>

